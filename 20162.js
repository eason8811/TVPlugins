(self.webpackChunktradingview = self.webpackChunktradingview || []).push([[20162, 35844, 9404], {
    715216: e=>{
        e.exports = {
            "tv-spinner__container-rotate": "tv-spinner__container-rotate-aLqboHuu"
        }
    }
    ,
    220350: e=>{
        e.exports = {
            screen: "screen-otjoFNF2",
            fade: "fade-otjoFNF2",
            screenfade: "screenfade-otjoFNF2"
        }
    }
    ,
    126572: e=>{
        e.exports = {}
    }
    ,
    98714: e=>{
        e.exports = {
            css_value_currency_label_radius: "4",
            css_wrapper_margin: "4",
            css_row_left_right_padding: "3",
            css_fade_height: "10",
            "price-axis-currency-label-wrapper": "price-axis-currency-label-wrapper-y5H41VPj",
            hidden: "hidden-y5H41VPj",
            "price-axis-currency-label": "price-axis-currency-label-y5H41VPj",
            row: "row-y5H41VPj",
            expanded: "expanded-y5H41VPj",
            "price-axis-currency-label-arrow-down": "price-axis-currency-label-arrow-down-y5H41VPj",
            "price-axis-currency-label-text": "price-axis-currency-label-text-y5H41VPj"
        }
    }
    ,
    82815: e=>{
        e.exports = {}
    }
    ,
    660070: e=>{
        e.exports = {}
    }
    ,
    99647: e=>{
        e.exports = {
            "css-value-chart-controls-bar-height-with-border": "39px",
            "css-value-chart-controls-bar-border": "1px"
        }
    }
    ,
    443882: e=>{
        e.exports = {}
    }
    ,
    685023: (e,t,i)=>{
        "use strict";
        i.d(t, {
            DEFAULT_SIZE: ()=>s,
            spinnerSizeMap: ()=>o
        });
        const s = "large"
          , o = {
            mini: "xsmall",
            xxsmall: "xxsmall",
            xsmall: "xsmall",
            small: "small",
            medium: "medium",
            large: "large"
        }
    }
    ,
    796416: (e,t,i)=>{
        "use strict";
        i.d(t, {
            TOAST_ANIMATION_DURATION: ()=>s
        });
        const s = 500
    }
    ,
    30931: (e,t,i)=>{
        "use strict";
        i.d(t, {
            ActivityStatus: ()=>o
        });
        var s = i(978296);
        class o {
            constructor(e) {
                this._unsetActive = ()=>{
                    this._isUserActive.setValue(!1)
                }
                ,
                this._resetActivity = ()=>{
                    this._setActive(),
                    clearTimeout(this._timeout),
                    this._timeout = setTimeout(this._unsetActive, this._timeoutDuration)
                }
                ,
                this._updateActivityFromVisibilityStatus = ()=>{
                    "hidden" === document.visibilityState ? this._unsetActive() : this._resetActivity()
                }
                ,
                this._isUserActive = new s.WatchedValue("hidden" !== document.visibilityState),
                this._timeoutDuration = e,
                this._timeout = setTimeout(this._unsetActive, e),
                document.addEventListener("click", this._resetActivity, {
                    passive: !0
                }),
                document.addEventListener("mousemove", this._resetActivity, {
                    passive: !0
                }),
                document.addEventListener("keydown", this._resetActivity, {
                    passive: !0
                }),
                document.addEventListener("touchstart", this._resetActivity, {
                    passive: !0
                }),
                document.addEventListener("wheel", this._resetActivity, {
                    passive: !0
                }),
                document.addEventListener("visibilitychange", this._updateActivityFromVisibilityStatus, {
                    passive: !0
                })
            }
            value() {
                return this._isUserActive.value()
            }
            subscribe(e) {
                this._isUserActive.subscribe(e)
            }
            unsubscribe(e) {
                this._isUserActive.unsubscribe(e)
            }
            destroy() {
                document.removeEventListener("click", this._resetActivity),
                document.removeEventListener("mousemove", this._resetActivity),
                document.removeEventListener("keydown", this._resetActivity),
                document.removeEventListener("touchstart", this._resetActivity),
                document.removeEventListener("wheel", this._resetActivity),
                document.removeEventListener("visibilitychange", this._updateActivityFromVisibilityStatus),
                clearTimeout(this._timeout)
            }
            _setActive() {
                this._isUserActive.setValue(!0)
            }
        }
    }
    ,
    351440: (e,t,i)=>{
        "use strict";
        async function s() {
            return Promise.all([i.e(33334), i.e(93703), i.e(75816), i.e(44524), i.e(21356), i.e(62093), i.e(77476), i.e(40702), i.e(32227), i.e(62526), i.e(97486)]).then(i.bind(i, 826618))
        }
        i.d(t, {
            importPopupRender: ()=>s
        })
    }
    ,
    613122: (e,t,i)=>{
        "use strict";
        i.r(t),
        i.d(t, {
            PublicationType: ()=>s,
            closeCurrentPublicationViewPopup: ()=>u,
            getPublicationType: ()=>a,
            importEntryComponent: ()=>l,
            openPublicationViewPopup: ()=>p,
            preloadPublicationViewPopup: ()=>h
        });
        var s, o = i(783359), n = i(351440);
        !function(e) {
            e.Idea = "idea",
            e.Script = "script",
            e.Video = "video"
        }(s || (s = {}));
        const r = new Set([o.ScriptType.Indicator, o.ScriptType.Library, o.ScriptType.Strategy, "indicator", "library", "strategy"]);
        function a({isVideo: e, isScript: t, scriptType: i}) {
            switch (!0) {
            case e:
                return s.Video;
            case t:
            case r.has(i || ""):
                return s.Script;
            default:
                return s.Idea
            }
        }
        async function l(e) {
            switch (e) {
            case s.Video:
                return Promise.all([i.e(9222), i.e(46445), i.e(93703), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(65857), i.e(53953), i.e(73399), i.e(2520), i.e(49742), i.e(22164), i.e(62564), i.e(29800), i.e(46489), i.e(29296), i.e(58985), i.e(77476), i.e(23141), i.e(62234), i.e(95083), i.e(88488), i.e(13055), i.e(77280), i.e(3062), i.e(16356), i.e(29258), i.e(21251), i.e(30358), i.e(55057), i.e(26773), i.e(52017), i.e(87393), i.e(30449), i.e(13502), i.e(90698), i.e(74566), i.e(99693), i.e(56261), i.e(90972), i.e(80774), i.e(49180), i.e(43602), i.e(95427), i.e(31234), i.e(7647), i.e(610), i.e(78724), i.e(87035), i.e(65642), i.e(18973), i.e(73131), i.e(37743), i.e(83579), i.e(83108), i.e(61348), i.e(35260), i.e(2170), i.e(5843), i.e(80826), i.e(32227), i.e(24951), i.e(60337), i.e(1563), i.e(41282), i.e(91795), i.e(86050), i.e(49923), i.e(62316), i.e(56991), i.e(40391), i.e(65392), i.e(26244), i.e(97071)]).then(i.bind(i, 453501)).then((e=>e.PublicationViewVideo));
            case s.Script:
                return Promise.all([i.e(28493), i.e(46445), i.e(93703), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(65857), i.e(36010), i.e(53953), i.e(73399), i.e(2520), i.e(25480), i.e(49742), i.e(22164), i.e(62564), i.e(29800), i.e(46489), i.e(29296), i.e(58985), i.e(77476), i.e(23141), i.e(62234), i.e(95083), i.e(88488), i.e(13055), i.e(77280), i.e(20016), i.e(3062), i.e(16356), i.e(29258), i.e(60736), i.e(21251), i.e(16809), i.e(30358), i.e(55057), i.e(26773), i.e(52017), i.e(87393), i.e(30449), i.e(13502), i.e(90698), i.e(74566), i.e(99693), i.e(56261), i.e(90972), i.e(80774), i.e(49180), i.e(43602), i.e(95427), i.e(31234), i.e(7647), i.e(610), i.e(78724), i.e(87035), i.e(65642), i.e(18973), i.e(73131), i.e(37743), i.e(81354), i.e(83579), i.e(83108), i.e(61348), i.e(35260), i.e(2170), i.e(76425), i.e(69212), i.e(48120), i.e(32227), i.e(47793), i.e(24951), i.e(60337), i.e(1563), i.e(41282), i.e(91795), i.e(86050), i.e(49923), i.e(62316), i.e(98461), i.e(56991), i.e(40391), i.e(65392), i.e(26244), i.e(57716), i.e(14675)]).then(i.bind(i, 730034)).then((e=>e.PublicationViewScript));
            case s.Idea:
                return Promise.all([i.e(11487), i.e(46445), i.e(93703), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(65857), i.e(53953), i.e(73399), i.e(2520), i.e(49742), i.e(22164), i.e(62564), i.e(29800), i.e(46489), i.e(29296), i.e(58985), i.e(77476), i.e(23141), i.e(62234), i.e(95083), i.e(88488), i.e(13055), i.e(77280), i.e(20016), i.e(3062), i.e(16356), i.e(29258), i.e(60736), i.e(21251), i.e(16809), i.e(30358), i.e(55057), i.e(26773), i.e(52017), i.e(87393), i.e(30449), i.e(13502), i.e(90698), i.e(74566), i.e(99693), i.e(56261), i.e(90972), i.e(80774), i.e(49180), i.e(43602), i.e(95427), i.e(31234), i.e(7647), i.e(610), i.e(78724), i.e(87035), i.e(65642), i.e(18973), i.e(73131), i.e(37743), i.e(83579), i.e(83108), i.e(61348), i.e(35260), i.e(2170), i.e(76425), i.e(69212), i.e(32227), i.e(24951), i.e(60337), i.e(1563), i.e(41282), i.e(91795), i.e(86050), i.e(49923), i.e(62316), i.e(56991), i.e(40391), i.e(65392), i.e(26244), i.e(84822)]).then(i.bind(i, 564166)).then((e=>e.PublicationViewIdea))
            }
        }
        let c = !1;
        async function d() {
            return c = !0,
            Promise.all([i.e(45792), i.e(58214)]).then(i.bind(i, 661254))
        }
        async function u() {
            if (!c)
                return;
            (await d()).closeCurrentPublicationViewPopup()
        }
        async function h(e) {
            d(),
            (0,
            n.importPopupRender)(),
            l(e)
        }
        async function p(e) {
            (await d()).openPublicationViewPopup(e)
        }
    }
    ,
    783359: (e,t,i)=>{
        "use strict";
        var s, o, n;
        i.d(t, {
            CONTAINS_IO_SCRIPT_TAG: ()=>r,
            PublicationMethod: ()=>o,
            ScriptAccessType: ()=>s,
            ScriptType: ()=>n
        }),
        function(e) {
            e[e.Public = 1] = "Public",
            e[e.Protected = 2] = "Protected",
            e[e.InviteOnly = 3] = "InviteOnly"
        }(s || (s = {})),
        function(e) {
            e[e.New = 0] = "New",
            e[e.Edit = 1] = "Edit",
            e[e.Update = 2] = "Update"
        }(o || (o = {})),
        function(e) {
            e[e.Indicator = 1] = "Indicator",
            e[e.Strategy = 2] = "Strategy",
            e[e.Library = 3] = "Library"
        }(n || (n = {}));
        const r = "containsioscript"
    }
    ,
    607436: (e,t,i)=>{
        "use strict";
        i.d(t, {
            DEFAULT_SIZE: ()=>s.DEFAULT_SIZE,
            spinnerSizeMap: ()=>s.spinnerSizeMap
        });
        var s = i(685023)
    }
    ,
    941285: (e,t,i)=>{
        "use strict";
        i.r(t),
        i.d(t, {
            Spinner: ()=>a,
            renderSpinnerTemplate: ()=>n
        });
        i(715216);
        var s = i(715050)
          , o = i(607436);
        function n(e="") {
            return `<div class="tv-spinner ${e}" role="progressbar"></div>`
        }
        const r = (0,
        s.parseHtmlElement)(n());
        class a {
            constructor(e) {
                this._shown = !1,
                this._el = r.cloneNode(!0),
                this.setSize(o.spinnerSizeMap[e || o.DEFAULT_SIZE])
            }
            spin(e) {
                return this._el.classList.add("tv-spinner--shown"),
                void 0 === this._container && (this._container = e,
                void 0 !== e && e.appendChild(this._el)),
                this._shown = !0,
                this
            }
            stop(e) {
                return e && void 0 !== this._container && this._container.removeChild(this._el),
                this._el && this._el.classList.remove("tv-spinner--shown"),
                this._shown = !1,
                this
            }
            setStyle(e) {
                return Object.keys(e).forEach((t=>{
                    const i = e[t];
                    void 0 !== i && this._el.style.setProperty(t, i)
                }
                )),
                this
            }
            style() {
                return this._el.style
            }
            setSize(e) {
                const t = void 0 !== e ? `tv-spinner--size_${e}` : "";
                return this._el.className = `tv-spinner ${t} ${this._shown ? "tv-spinner--shown" : ""}`,
                this
            }
            getEl() {
                return this._el
            }
            destroy() {
                this.stop(),
                delete this._el,
                delete this._container
            }
        }
    }
    ,
    936442: (e,t,i)=>{
        "use strict";
        i.d(t, {
            CHART_WARNINIG_GROUP_ID: ()=>r,
            showChartWarningNotification: ()=>a
        });
        var s = i(148255)
          , o = i(779672)
          , n = i(252979);
        const r = "chart_warning";
        function a(e, t) {
            return new Promise((i=>{
                o.toastManager.addToast(e, r, t),
                (0,
                n.setToastUserActivityBasedRemovalTimeout)(e, 1e4);
                const a = (0,
                s.subscribeOnToast)(e, (e=>{
                    "Remove" !== e.type && e.details !== n.CLOSE_DUE_TO_INACTIVITY_EVENT_DETAILS || (i(),
                    a())
                }
                ))
            }
            ))
        }
    }
    ,
    148255: (e,t,i)=>{
        "use strict";
        i.d(t, {
            subscribeOnToast: ()=>s
        });
        const s = i(779672).toastManager.subscribeOnToast
    }
    ,
    252979: (e,t,i)=>{
        "use strict";
        i.d(t, {
            CLOSE_DUE_TO_INACTIVITY_EVENT_DETAILS: ()=>n,
            setToastUserActivityBasedRemovalTimeout: ()=>r
        });
        var s = i(779672)
          , o = i(30931);
        const n = "userActivityTimeout"
          , r = function(e, t, i, s) {
            let n = null;
            const r = new Set;
            return function(a, l=2e4) {
                const {start: c, reset: d} = function(e, t) {
                    let i;
                    return {
                        start: ()=>{
                            i = setTimeout(e, t)
                        }
                        ,
                        reset: ()=>{
                            clearTimeout(i),
                            i = void 0
                        }
                    }
                }((()=>{
                    e.removeToast(a, s)
                }
                ), l)
                  , u = ()=>{
                    const e = h.value()
                      , i = t.value;
                    e && !i ? c() : d()
                }
                  , h = (p = a,
                r.add(p),
                n || (n = new o.ActivityStatus(i)),
                n);
                var p;
                u(),
                h.subscribe(u);
                const m = t.subscribe(u)
                  , g = e.subscribeOnToast(a, (e=>{
                    "RemoveAnimationStart" === e.type && (d(),
                    g(),
                    h.unsubscribe(u),
                    function(e) {
                        r.delete(e),
                        0 === r.size && n && (n.destroy(),
                        n = null)
                    }(a),
                    m())
                }
                ))
            }
        }(s.toastManager, s.toastUserInteractionStatus, 15e3, n)
    }
    ,
    779672: (e,t,i)=>{
        "use strict";
        i.r(t),
        i.d(t, {
            toastManager: ()=>o,
            toastUserInteractionStatus: ()=>n
        });
        var s = i(796416);
        const o = function() {
            const e = new Set
              , t = new Map
              , i = {
                groups: new Map
            };
            function o(e) {
                const t = i.groups.get(e);
                if (t)
                    return t;
                const s = {
                    id: e,
                    list: new Map,
                    added: new Set,
                    removed: new Set
                };
                return i.groups.set(e, s),
                s
            }
            function n(e, s) {
                t.delete(e),
                s.list.delete(e),
                s.removed.delete(e),
                0 === s.list.size ? i.groups.delete(s.id) : i.groups.set(s.id, {
                    ...s
                }),
                r({
                    type: "Remove",
                    toastId: e,
                    groupId: s.id
                })
            }
            function r(t) {
                i.groups = new Map(i.groups),
                e.forEach((e=>{
                    e(t)
                }
                ));
                const s = a.get(t.toastId);
                s && s.forEach((e=>{
                    e(t)
                }
                ))
            }
            const a = new Map;
            return {
                addToast: function(e, s, n, a, l) {
                    if (t.get(e))
                        return;
                    const c = o(s);
                    c.added.add(e);
                    const d = {
                        id: e,
                        ...n,
                        manualAnimationStart: l
                    };
                    c.list.set(e, d),
                    t.set(e, s),
                    i.groups.set(s, {
                        ...c
                    }),
                    r({
                        type: "Add",
                        toastId: e,
                        groupId: s,
                        data: n,
                        details: a
                    })
                },
                removeToast: function(e, o) {
                    const a = t.get(e);
                    if (!a)
                        return;
                    const l = i.groups.get(a);
                    l && (l.removed.has(e) || (l.removed.add(e),
                    i.groups.set(a, {
                        ...l
                    }),
                    r({
                        type: "RemoveAnimationStart",
                        toastId: e,
                        groupId: a,
                        details: o
                    }),
                    setTimeout((()=>{
                        n(e, l)
                    }
                    ), s.TOAST_ANIMATION_DURATION)))
                },
                removeGroup: function(e, t) {
                    const o = i.groups.get(e);
                    if (!o)
                        return;
                    const a = [];
                    o.list.forEach((i=>{
                        const s = i.id;
                        o.removed.has(s) || (a.push(s),
                        o.removed.add(s),
                        r({
                            type: "RemoveAnimationStart",
                            toastId: s,
                            groupId: e,
                            details: t
                        }))
                    }
                    )),
                    i.groups.set(e, {
                        ...o
                    }),
                    setTimeout((()=>{
                        a.forEach((e=>{
                            n(e, o)
                        }
                        ))
                    }
                    ), s.TOAST_ANIMATION_DURATION)
                },
                startAddAnimation: function(e) {
                    const s = t.get(e);
                    if (!s)
                        return;
                    const o = i.groups.get(s);
                    o && o.added.delete(e) && (i.groups.set(s, {
                        ...o
                    }),
                    r({
                        type: "AddAnimationStart",
                        toastId: e,
                        groupId: s
                    }))
                },
                subscribeOnToast: function(e, t) {
                    const i = function(e) {
                        const t = a.get(e);
                        if (t)
                            return t;
                        const i = new Set;
                        return a.set(e, i),
                        i
                    }(e);
                    return i.add(t),
                    ()=>{
                        i.delete(t),
                        0 === i.size && a.delete(e)
                    }
                },
                state: i,
                subscribe: function(t) {
                    return e.add(t),
                    ()=>{
                        e.delete(t)
                    }
                }
            }
        }()
          , n = function() {
            const e = new Set
              , t = new Set
              , i = {
                update: function(s, o) {
                    s ? t.add(o) : t.delete(o);
                    const n = t.size > 0;
                    i.value !== n && (i.value = n,
                    e.forEach((e=>{
                        e(s)
                    }
                    )))
                },
                value: !1,
                subscribe: function(t) {
                    return e.add(t),
                    ()=>{
                        e.delete(t)
                    }
                }
            };
            return i
        }()
    }
    ,
    100366: (e,t,i)=>{
        "use strict";
        async function s() {
            return (await Promise.all([i.e(27741), i.e(62564), i.e(58666), i.e(32227), i.e(20139)]).then(i.bind(i, 254543))).ErrorCardRenderer
        }
        i.d(t, {
            getErrorCardRenderer: ()=>s
        })
    }
    ,
    113610: (e,t,i)=>{
        "use strict";
        i.d(t, {
            getChartStorage: ()=>g
        });
        var s = i(702598)
          , o = i(895370)
          , n = i(175203)
          , r = i(652171)
          , a = i(198303)
          , l = i(622864)
          , c = i(474759);
        function d() {
            const e = document.querySelector('link[rel~="chart-storage"]')
              , t = new URL((null == e ? void 0 : e.href) || "/charts-storage/",location.href);
            return t.pathname.endsWith("/") || (t.pathname += "/"),
            t
        }
        function u(e) {
            const {charts: t={}, countSourcesTotal: i=0, limitBytesTotal: s=0, sizeBytesTotal: o=0} = e
              , n = new Map;
            for (const e in t) {
                const i = t[e].symbols
                  , s = new Map;
                for (const e in i || {}) {
                    const t = i[e];
                    s.set(e, {
                        countSources: t.countSources,
                        sizeBytes: t.sizeBytes,
                        ids: t.ids
                    })
                }
                n.set(e, s)
            }
            return {
                charts: n,
                countSourcesTotal: i,
                limitBytesTotal: s,
                sizeBytesTotal: o
            }
        }
        const h = {
            sources: new Map,
            groups: new Map
        };
        class p {
            constructor() {
                this._lastSaveRequest = Promise.resolve(),
                this._requestsCounter = 0,
                this._lastSharedToolsLoadingRequest = Promise.resolve(h)
            }
            async saveLineToolsAndGroups(e, t, i, u, h) {
                if ("" === e || void 0 === e)
                    return Promise.reject("Unnamed chart cannot be saved");
                const p = `${e}.${t}.${this._requestsCounter++}`
                  , m = `ChartStorage.Save.TotallyProcessing.${p}`
                  , g = (0,
                o.perfMeasureOperation)(m, (()=>this._lastSaveRequest.then((async()=>{
                    if (null == h ? void 0 : h.aborted)
                        throw (0,
                        l.createAbortError)();
                    const m = `ChartStorage.Save.GettingToken.${p}`
                      , g = await (0,
                    o.perfMeasureOperation)(m, (()=>(0,
                    r.getStorageTarget)(e, t, u, h)))
                      , _ = new URL(g.path,d());
                    g.chartId && _.searchParams.append("chart_id", g.chartId),
                    _.searchParams.append("jwt", g.token);
                    const v = (0,
                    c.stringifyLineToolsAndGroupsDTO)(i)
                      , S = `ChartStorage.Save.GettingResponse.${p}`;
                    return (0,
                    o.perfMeasureOperation)(S, (()=>(0,
                    s.fetch)(_.toString(), {
                        signal: h,
                        method: "PUT",
                        headers: {
                            "Content-Type": "application/json",
                            "X-BUILD-TIME": window.BUILD_TIME
                        },
                        credentials: "include",
                        body: v
                    }).then((e=>{
                        if (!e.ok) {
                            const t = 429 === e.status;
                            throw new a.SavingLineToolsError(t,`Response status is not success: ${e.status}`)
                        }
                        const t = e.json();
                        return n.telemetry.sendLineToolsStorageReport("line_tools_save_success"),
                        t
                    }
                    )).then((s=>({
                        content: s,
                        savedDto: i,
                        layoutId: e,
                        chartId: t,
                        sharingMode: u
                    })))))
                }
                ))));
                return this._lastSaveRequest = g.catch((e=>{
                    n.telemetry.sendLineToolsStorageReport("line_tools_save_error")
                }
                )),
                g
            }
            async loadLineToolsAndGroups(e, t, i) {
                if ("" === e || void 0 === e)
                    return h;
                const a = `${e}.${t}.${i.requestType}.${this._requestsCounter++}`
                  , l = `ChartStorage.Load.GettingToken.${a}`
                  , u = await (0,
                o.perfMeasureOperation)(l, (()=>(0,
                r.getStorageTarget)(e, t, i.sharingMode)))
                  , p = `get/${u.path}`
                  , m = new URL(p,d());
                switch (u.chartId && m.searchParams.append("chart_id", u.chartId),
                window.user.is_superuser && 2 === i.sharingMode && m.searchParams.append("layout_id", e),
                m.searchParams.append("jwt", u.token),
                i.requestType) {
                case "mainSeriesLineTools":
                    m.searchParams.append("symbol", i.symbol),
                    0 === i.sharingMode && m.searchParams.append("includeOwnerSource", i.seriesSourceId),
                    m.searchParams.append("brokerName", i.brokerName);
                    break;
                case "studiesLineTools":
                    m.searchParams.append("excludeOwnerSource", i.seriesSourceId);
                    break;
                case "lineToolsWithoutSymbol":
                    m.searchParams.append("symbol", ""),
                    0 === i.sharingMode && m.searchParams.append("includeOwnerSource", i.seriesSourceId)
                }
                const g = `ChartStorage.Load.GettingResponse.${a}`
                  , _ = ()=>(0,
                s.fetch)(m.toString(), {
                    method: "GET",
                    credentials: "include"
                }).then((e=>{
                    if (!e.ok)
                        throw new Error("Response status is not success");
                    const t = e.headers.get("X-Request-Id");
                    return e.json().then((e=>{
                        if (null === e)
                            throw new Error("Body is null");
                        if (!e.success)
                            throw new Error("Response is not success");
                        const i = (0,
                        c.parseLineToolsAndGroupsDTO)(e.payload || {}, t);
                        return n.telemetry.sendLineToolsStorageReport("line_tools_load_success"),
                        i
                    }
                    ))
                }
                ))
                  , v = 0 === i.sharingMode ? _ : ()=>this._lastSharedToolsLoadingRequest.then(_)
                  , S = (0,
                o.perfMeasureOperation)(g, v).catch((e=>{
                    throw n.telemetry.sendLineToolsStorageReport("line_tools_load_error"),
                    e
                }
                ));
                return 0 !== i.sharingMode && (this._lastSharedToolsLoadingRequest = S.catch((()=>h))),
                S
            }
            async removeLineTools(e, t, i, a) {
                if ("" === e || void 0 === e)
                    return !1;
                const l = `${e}.${t}.${this._requestsCounter++}`
                  , c = `ChartStorage.Remove.GettingToken.${l}`
                  , u = await (0,
                o.perfMeasureOperation)(c, (()=>(0,
                r.getStorageTarget)(e, t, i)))
                  , h = new URL(u.path,d());
                u.chartId && h.searchParams.append("chart_id", u.chartId),
                h.searchParams.append("jwt", u.token),
                h.searchParams.append("symbol", a);
                const p = `ChartStorage.Remove.GettingResponse.${l}`;
                return (0,
                o.perfMeasureOperation)(p, (()=>(0,
                s.fetch)(h.toString(), {
                    method: "DELETE",
                    credentials: "include"
                }).then((e=>{
                    if (!e.ok)
                        throw new Error("Response status is not success");
                    return e.json().then((e=>{
                        if (null === e)
                            throw new Error("Body is null");
                        if (!e.success)
                            throw new Error("Response is not success");
                        return n.telemetry.sendLineToolsStorageReport("line_tools_remove_by_symbol_success"),
                        !0
                    }
                    ))
                }
                )))).catch((e=>{
                    throw n.telemetry.sendLineToolsStorageReport("line_tools_remove_by_symbol_error"),
                    e
                }
                ))
            }
            async getLayoutDrawingsSizeInfo(e, t) {
                if ("" === e || void 0 === e)
                    return {
                        charts: new Map,
                        countSourcesTotal: 0,
                        limitBytesTotal: 0,
                        sizeBytesTotal: 0
                    };
                const i = `${e}.${t}.${this._requestsCounter++}`
                  , s = `ChartStorage.GetSizes.GettingToken.${i}`
                  , a = await (0,
                o.perfMeasureOperation)(s, (()=>(0,
                r.getStorageTarget)(e, t, 0)))
                  , l = new URL(`layout/${e}/sizes`,d());
                return l.searchParams.append("jwt", a.token),
                this._fetchData(`ChartStorage.GetSizes.GettingResponse.${i}`, l, {
                    method: "GET",
                    credentials: "include"
                }).then((e=>(n.telemetry.sendLineToolsStorageReport("line_tools_size_info_success"),
                u(e || {})))).catch((e=>{
                    throw n.telemetry.sendLineToolsStorageReport("line_tools_size_info_error"),
                    e
                }
                ))
            }
            async getUserGlobalDrawingsSizeInfo(e) {
                if ("" === e || void 0 === e)
                    return {
                        charts: new Map,
                        countSourcesTotal: 0,
                        limitBytesTotal: 0,
                        sizeBytesTotal: 0
                    };
                const t = this._requestsCounter++
                  , i = await (0,
                o.perfMeasureOperation)(`ChartStorage.GetGlobalSizes.GettingToken.${t}`, (()=>(0,
                r.getStorageTarget)(e, "", 2)))
                  , s = new URL("user/sizes",d());
                return s.searchParams.append("jwt", i.token),
                this._fetchData(`ChartStorage.GetGlobalSizes.GettingResponse.${t}`, s, {
                    credentials: "include"
                }).then((e=>(n.telemetry.sendLineToolsStorageReport("global_line_tools_size_info_success"),
                u(e || {})))).catch((e=>{
                    throw n.telemetry.sendLineToolsStorageReport("global_line_tools_size_info_error"),
                    e
                }
                ))
            }
            async _fetchData(e, t, i) {
                const n = await (0,
                o.perfMeasureOperation)(e, (()=>(0,
                s.fetch)(t.toString(), i)));
                if (!n.ok)
                    throw new Error("Response status is not success");
                const r = await n.json();
                if (null === r)
                    throw new Error("Body is null");
                if (!r.success)
                    throw new Error("Response is not success");
                return r.payload
            }
        }
        let m = null;
        async function g() {
            return null === m && (m = new p),
            m
        }
    }
    ,
    474759: (e,t,i)=>{
        "use strict";
        function s(e) {
            const t = {};
            return e.sources && (t.sources = {},
            e.sources.forEach(((e,i)=>{
                t.sources[i] = e
            }
            ))),
            t.drawing_groups = {},
            e.groups.forEach(((e,i)=>{
                t.drawing_groups[i] = e
            }
            )),
            t.clientId = e.clientId,
            JSON.stringify(t)
        }
        function o(e, t) {
            const i = {
                sources: null,
                groups: new Map
            };
            if (null !== e.sources) {
                i.sources = new Map;
                for (const t in e.sources || {}) {
                    const s = e.sources[t];
                    i.sources.set(t, s)
                }
            }
            for (const t in e.drawing_groups || {}) {
                const s = e.drawing_groups[t];
                i.groups.set(t, s)
            }
            return null !== t && (i.serverRequestId = t),
            i.clientId = e.clientId,
            i.symbol = e.symbol,
            i
        }
        i.d(t, {
            parseLineToolsAndGroupsDTO: ()=>o,
            stringifyLineToolsAndGroupsDTO: ()=>s
        })
    }
    ,
    198303: (e,t,i)=>{
        "use strict";
        i.r(t),
        i.d(t, {
            SavingLineToolsError: ()=>s,
            SavingLineToolsLibraryError: ()=>o
        });
        class s extends Error {
            constructor(e, t) {
                super(t),
                this.shouldBeCooled = e
            }
        }
        class o extends Error {
            constructor(e, t=!1) {
                super(e),
                this.safe = t,
                this.name = "SavingLineToolsLibraryError"
            }
        }
    }
    ,
    652171: (e,t,i)=>{
        "use strict";
        i.d(t, {
            getStorageTarget: ()=>a,
            globallySharedChartId: ()=>r,
            sharedChartId: ()=>n
        });
        var s = i(175203)
          , o = i(622864);
        const n = "_shared"
          , r = "UserSync";
        async function a(e, t, i, r) {
            try {
                const a = new URL("/chart-token/",location.href);
                a.searchParams.append("image_url", e);
                const l = window.user.id || -1;
                a.searchParams.append("user_id", "" + l);
                const c = await fetch(a.toString(), {
                    signal: r
                });
                if (!c.ok)
                    throw new Error(`Http response is not ok: ${c.status}}`);
                const d = await c.json();
                if (s.telemetry.sendLineToolsStorageReport("line_tools_token_request_success"),
                null == r ? void 0 : r.aborted)
                    throw (0,
                    o.createAbortError)();
                let u = t;
                return 2 === i ? u = void 0 : 1 === i && (u = n),
                {
                    token: d.token,
                    chartId: u,
                    path: 2 === i ? "user/sources" : `layout/${e}/sources`
                }
            } catch (e) {
                throw (0,
                o.isAbortError)(e) || s.telemetry.sendLineToolsStorageReport("line_tools_token_request_error"),
                e
            }
        }
    }
    ,
    709404: (e,t,i)=>{
        "use strict";
        i.r(t),
        i.d(t, {
            getExchanges: ()=>o
        });
        var s = i(294740);
        function o() {
            return s
        }
    }
    ,
    515312: (e,t,i)=>{
        "use strict";
        i.d(t, {
            isNativeUIInteraction: ()=>s.isNativeUIInteraction,
            isTextEditingField: ()=>s.isTextEditingField
        });
        var s = i(607423)
    }
    ,
    542682: (e,t,i)=>{
        "use strict";
        i.d(t, {
            isTouchEvent: ()=>o
        });
        var s = i(778785);
        function o(e) {
            const t = e.sourceCapabilities;
            let i = t && t.firesTouchEvents;
            return void 0 === i && (i = s.touch),
            i
        }
    }
    ,
    207678: (e,t,i)=>{
        "use strict";
        i.d(t, {
            breakpoints: ()=>s,
            mobileFirstBreakpoints: ()=>o,
            mobileFirstLegacyBreakpoints: ()=>n
        });
        const s = {
            desktop: 1 / 0,
            desktopHd: 1919,
            phone: 767,
            "phone-vertical": 479,
            tablet: 1019
        }
          , o = {
            base: 0,
            "media-mf-phone-vertical": 320,
            "media-mf-phone-landscape": 568,
            "media-mf-tablet-vertical": 768,
            "media-mf-tablet-landscape": 1024,
            "media-mf-laptop": 1280,
            "media-mf-desktop-medium": 1440,
            "media-mf-desktop-large": 1920,
            "media-mf-desktop-extra-large": 2560
        }
          , n = {
            "media-mf-legacy-phone-vertical": 330,
            "media-mf-legacy-phone": 480,
            "media-mf-legacy-notebook": 1020,
            "media-mf-legacy-desktop-medium": 1480,
            "media-mf-legacy-desktop": 1531
        }
    }
    ,
    850775: (e,t,i)=>{
        "use strict";
        i.d(t, {
            mediaState: ()=>c
        });
        var s = i(685459)
          , o = i.n(s)
          , n = i(411963)
          , r = i(207678)
          , a = i(76107);
        class l extends (o()) {
            constructor() {
                super(),
                this.width = 0,
                this.height = 0,
                this.device = null,
                this.breakpoints = r.breakpoints,
                this._checkDevice(),
                window.addEventListener("resize", this._checkDevice),
                Object.entries(r.breakpoints).sort((([e,t],[i,s])=>t - s)).forEach((([e,t],i,s)=>{
                    let o;
                    if (0 !== i) {
                        const [,e] = s[i - 1];
                        o = e + 1
                    } else
                        o = 0;
                    const n = (0,
                    a.matchMediaMinMax)(o, t);
                    n.matches && this._setNewDevice(e),
                    n.addEventListener("change", (t=>{
                        t.matches && (this._checkDevice(),
                        this._setNewDevice(e))
                    }
                    ))
                }
                )),
                (0,
                n.whenDocumentReady)(this._checkDevice.bind(this)),
                this.isPhoneSizeDevice.bind(this)
            }
            isPhoneSizeDevice() {
                return "phone" === this.device || "phone-vertical" === this.device
            }
            _checkDevice() {
                this.width = window.innerWidth,
                this.height = window.innerHeight
            }
            _setNewDevice(e) {
                const t = this.device;
                this.device = e,
                this.trigger("changeDevice", [e, t])
            }
        }
        const c = new l
    }
    ,
    895370: (e,t,i)=>{
        "use strict";
        i.d(t, {
            addPerfMark: ()=>c,
            perfMeasureOperation: ()=>d
        });
        var s = i(79342);
        function o() {}
        const n = console.timeStamp ? console.timeStamp.bind(console) : o
          , r = window.performance && performance.mark ? performance.mark.bind(performance) : o
          , a = window.performance && performance.measure ? performance.measure.bind(performance) : o
          , l = window.performance && performance.clearMarks ? performance.clearMarks.bind(performance) : o;
        function c(e) {
            n(e),
            r(e)
        }
        async function d(e, t) {
            const i = `measure-${e}-${(0,
            s.randomHash)()}`;
            r(i);
            try {
                return await t()
            } finally {
                a(e, i),
                l(i)
            }
        }
    }
    ,
    887357: (e,t,i)=>{
        "use strict";
        var s;
        i.d(t, {
            NewsWidgetPlacement: ()=>s
        }),
        function(e) {
            e.WidgetBar = "widgetbar",
            e.Main = "main",
            e.Chart = "chart",
            e.Screener = "screener"
        }(s || (s = {}))
    }
    ,
    67302: (e,t,i)=>{
        "use strict";
        i.d(t, {
            showThemeAction: ()=>r,
            showThemeSwitcher: ()=>n
        });
        var s = i(638456)
          , o = i(347402);
        function n() {
            return !(0,
            s.isDesktopApp)() || (0,
            o.desktopVersionIsLess)("1.0.10")
        }
        function r() {
            return (0,
            s.isDesktopApp)() && !(0,
            o.desktopVersionIsLess)("1.0.11")
        }
    }
    ,
    247001: (e,t,i)=>{
        "use strict";
        i.d(t, {
            trackStudies: ()=>n
        });
        var s = i(776734)
          , o = i(637761);
        function n(e, t) {
            const i = e.metaInfo()
              , n = !e.isPine() || e.isStandardPine() ? i.description : i.scriptIdPart
              , r = i.productId
              , a = o.StudyMetaInfo.isScriptStrategy(i)
              , l = window.user && window.user.pro_plan || "";
            (0,
            s.getTracker)().then((e=>{
                e && e.trackStudiesAnalytics(n, r, t, a, l)
            }
            ))
        }
    }
    ,
    526225: (e,t,i)=>{
        "use strict";
        i.r(t),
        i.d(t, {
            syncUserConversionData: ()=>u,
            syncUserData: ()=>d
        });
        var s = i(338619)
          , o = i(345848)
          , n = i(702598)
          , r = i(875385);
        const a = (0,
        s.getLogger)("User.Sync");
        function l(e) {
            return `${e}_${window.user && window.user.username || ""}`
        }
        function c(e, t, i, s=!0) {
            i !== window.user.pro_plan && (window.user.pro_plan = i,
            window.user.is_pro = Boolean(i),
            (0,
            o.trackEvent)("Sync User Data", "Different Pro Plan", l(e))),
            t !== window.is_authenticated && (window.is_authenticated = t,
            s && window.loginStateChange.fire(),
            (0,
            o.trackEvent)("Sync User Data", "Different Auth", l(e)))
        }
        async function d(e) {
            try {
                c(e, !0, (await (0,
                r.getProPlanDetailsForUser)()).pro_plan)
            } catch (t) {
                !function(e, t) {
                    403 === t.status && ["not_authenticated", "login_required"].includes(t.type || "") ? c(e, !1, void 0) : a.logError(t.message)
                }(e, t)
            }
        }
        async function u(e, t=!0) {
            var i;
            const s = new URL("/pricing/",window.location.origin)
              , o = new URLSearchParams(window.location.search);
            o.has("_test_country") && s.searchParams.append("_test_country", null !== (i = o.get("_test_country")) && void 0 !== i ? i : "");
            const r = await (0,
            n.fetch)(s.href)
              , a = await r.json();
            return c(e, a.is_authenticated, a.user.pro_plan, t),
            a
        }
    }
    ,
    902981: (e,t,i)=>{
        "use strict";
        i.d(t, {
            getThemeFromUserSettings: ()=>n,
            saveThemeInUserSettings: ()=>r
        });
        var s = i(62802);
        function o(e) {
            const t = function() {
                const e = location.hostname.split(".").filter(Boolean);
                return e.every(isFinite) ? location.host : e.slice(-2).join(".")
            }()
              , i = void 0 === e ? -1 : 3e8;
            document.cookie = `theme=${e};path=/;domain=${t};max-age=${i}`
        }
        function n() {
            return /(?:^|;)\s*theme=(dark|light)(?:;|$)|$/.exec(document.cookie)[1] || (0,
            s.getValue)("current_theme.name") || null
        }
        function r(e) {
            o(e),
            (0,
            s.setValue)("current_theme.name", e, {
                forceFlush: !0
            })
        }
    }
    ,
    308721: (e,t,i)=>{
        "use strict";
        i.r(t),
        i.d(t, {
            DEFAULT_THEME: ()=>S.DEFAULT_THEME,
            getCurrentTheme: ()=>y,
            getStdTheme: ()=>E,
            getStdThemeNames: ()=>A,
            getStdThemedValue: ()=>k,
            getTheme: ()=>M,
            getThemeNames: ()=>I,
            getThemedColor: ()=>C,
            isPublicTheme: ()=>b,
            isStdThemeName: ()=>L,
            isStdThemedDefaultValue: ()=>D,
            isThemeExist: ()=>R,
            loadTheme: ()=>w,
            removeTheme: ()=>B,
            restoreTheme: ()=>T,
            saveTheme: ()=>N,
            savedThemeName: ()=>P,
            syncTheme: ()=>x,
            themes: ()=>f.themes,
            translateStdThemeName: ()=>O
        });
        var s = {};
        i.r(s),
        i.d(s, {
            isThemeExist: ()=>m,
            loadTheme: ()=>d,
            loadThemes: ()=>u,
            removeTheme: ()=>p,
            saveTheme: ()=>h
        });
        var o = i(724377)
          , n = i(211183)
          , r = i(902981)
          , a = i(702598);
        const l = (0,
        i(338619).getLogger)("Themes.Provider");
        let c = null;
        function d(e) {
            return (0,
            a.fetch)("/theme/?themeName=" + encodeURIComponent(e), {
                credentials: "include",
                method: "GET"
            }).then((e=>e.json())).then((e=>{
                const t = {};
                return e.content && (t.content = JSON.parse(e.content)),
                t
            }
            ))
        }
        function u() {
            return c || (0,
            a.fetch)("/themes/", {
                credentials: "include",
                method: "GET"
            }).then((e=>(c = e.json(),
            c)))
        }
        function h(e, t) {
            const i = new FormData;
            return i.append("content", JSON.stringify(t)),
            i.append("name", e),
            c = null,
            (0,
            a.fetch)("/save-theme/", {
                credentials: "include",
                method: "POST",
                body: i
            }).then((e=>e.json()), (e=>l.logError(e)))
        }
        function p(e) {
            const t = new FormData;
            return t.append("name", e),
            c = null,
            (0,
            a.fetch)("/remove-theme/", {
                credentials: "include",
                method: "POST",
                body: t
            }).then((e=>e.json()), (e=>l.logError(e)))
        }
        function m(e) {
            return d(e).then((e=>Boolean(e.content)))
        }
        const g = s;
        var _ = i(668846)
          , v = i(909740)
          , S = i(484400)
          , f = i(994123);
        function b(e) {
            return !e.isPrivate
        }
        function y() {
            return f.themes[v.watchedTheme.value()] || f.themes[S.DEFAULT_THEME]
        }
        function C(e) {
            return y().getThemedColor(e)
        }
        async function w(e, t) {
            const {themeName: i, standardTheme: s, syncState: o=!0, noUndo: r=!1, applyOverrides: a=!1, onlyActiveChart: l=!1} = t
              , c = await (s ? Promise.resolve(E(i)) : M(i))
              , d = !s;
            if (void 0 !== c.content) {
                const t = !s || l;
                a && (void 0 !== (u = c.content).chartProperties && (0,
                n.applyDefaultsOverrides)(u.chartProperties),
                void 0 !== u.mainSourceProperties && (0,
                n.applyDefaultsOverrides)(u.mainSourceProperties, void 0, !0, "mainSeriesProperties")),
                await e.applyTheme({
                    theme: c.content,
                    onlyActiveChart: t,
                    restoreNonThemeDefaults: d,
                    themeName: i,
                    standardTheme: s,
                    syncState: o,
                    noUndo: r
                })
            }
            var u;
            return c
        }
        function T() {
            (0,
            v.setTheme)((0,
            r.getThemeFromUserSettings)() || S.DEFAULT_THEME)
        }
        function P() {
            return (0,
            r.getThemeFromUserSettings)()
        }
        function x() {
            (0,
            r.saveThemeInUserSettings)(y().name)
        }
        function M(e) {
            return g.loadTheme(e)
        }
        function I() {
            return g.loadThemes()
        }
        function A() {
            return _.getStdThemeNames()
        }
        function L(e) {
            return A().includes(e)
        }
        function E(e) {
            return _.getStdChartTheme(e) || {
                content: void 0
            }
        }
        function k(e, t) {
            const i = t || y().name
              , s = _.getStdChartTheme(i)
              , o = 0 !== e.length && e.split(".");
            return s && s.content && o ? o.reduce(((e,t)=>e[t]), s.content) : null
        }
        function D(e, t, i) {
            const s = k(e, i);
            return null !== s && (0,
            o.areEqualRgba)((0,
            o.parseRgba)(s), (0,
            o.parseRgba)(String(t)))
        }
        function N(e, t) {
            return g.saveTheme(e, t)
        }
        function B(e) {
            return g.removeTheme(e)
        }
        function R(e) {
            return g.isThemeExist(e)
        }
        function O(e) {
            return _.translateThemeName(e)
        }
    }
    ,
    721211: (e,t,i)=>{
        "use strict";
        i.d(t, {
            showChartObjectsWidget: ()=>o
        });
        var s = i(650151);
        function o() {
            const e = window.widgetbar;
            if (e) {
                const t = (0,
                s.ensureNotNull)(e.setPage("object_tree"))
                  , i = (0,
                s.ensureNotNull)(t.widget("object_tree"));
                (0,
                s.ensureDefined)(i.properties).setValue({
                    selectedPage: "data-window"
                })
            } else
                ;
        }
    }
    ,
    72368: (e,t,i)=>{
        "use strict";
        i.d(t, {
            canShowNewSymbolSearch: ()=>l,
            getCurrentLocaleInfoCountry: ()=>c,
            isMobile: ()=>r,
            isPlatformMobile: ()=>a
        });
        var s = i(314802)
          , o = i(953297)
          , n = i(638456);
        function r() {
            const e = window.matchMedia("(min-width: 602px) and (min-height: 445px)").matches;
            return n.CheckMobile.any() && !e
        }
        function a() {
            return !(0,
            s.isOnMobileAppPage)("any") && r()
        }
        function l() {
            return !o.enabled("widget") && !(0,
            s.isOnMobileAppPage)("any")
        }
        function c() {
            var e, t;
            return null === (t = null === (e = window.initData) || void 0 === e ? void 0 : e.currentLocaleInfo) || void 0 === t ? void 0 : t.flag.toUpperCase()
        }
    }
    ,
    560420: (e,t,i)=>{
        "use strict";
        i.d(t, {
            activateKeyPressHandler: ()=>h,
            showDialog: ()=>p
        });
        var s = i(576119)
          , o = i(826312)
          , n = i(953297)
          , r = i(214372)
          , a = i(533679)
          , l = i(506672)
          , c = i(345848);
        let d = null;
        function u(e) {
            if (!(0,
            o.globalKeypressMatches)(e))
                return !1;
            e.preventDefault();
            const t = String.fromCharCode(e.charCode);
            return n.enabled("show_interval_dialog_on_key_press") && function(e) {
                return /[1-9]/.test(e)
            }(t) ? (0,
            r.showChangeIntervalDialogAsync)({
                initVal: t
            }) : n.enabled("symbol_search_hot_key") && (p({
                defaultValue: t,
                selectSearchOnInit: !1,
                source: "keyboard",
                trackResultsOptions: {
                    trackResults: !n.enabled("widget"),
                    emptySearchType: "empty_result__supercharts"
                }
            }),
            (0,
            c.trackEvent)("GUI", "SS", "hotkey")),
            !0
        }
        function h() {
            (0,
            a.loadChangeIntervalDialog)(),
            s.pushBackListener("symbolEdit", u)
        }
        function p(e) {
            const t = d = (0,
            l.loadNewSymbolSearch)().then((i=>{
                t === d && i.showDefaultSearchDialog(e)
            }
            ));
            return t
        }
    }
    ,
    711496: (e,t,i)=>{
        "use strict";
        i.d(t, {
            hasFinancialsByAvailabilityFlags: ()=>d,
            hasFinancialsByTypespecs: ()=>c
        });
        var s = i(519073);
        const o = new Set(["stock", "dr", "right", "warrant", "structured", "bond"])
          , n = new Set(["mutual", "unit", "trust", "reit", "closedend", "etn"])
          , r = new Set(["etn"])
          , a = new Set(["convertible", "corporate"])
          , l = new Set(["cfd"]);
        function c(e, t) {
            return !(e && t && (0,
            s.isEtf)(e, t)) && ("structured" === e && (null == t ? void 0 : t.length) ? t.filter((e=>r.has(e))).length > 0 : "fund" === e && (null == t ? void 0 : t.length) ? t.filter((e=>n.has(e))).length > 0 : "bond" === e && (null == t ? void 0 : t.length) ? t.filter((e=>a.has(e))).length > 0 : "stock" === e && (null == t ? void 0 : t.length) ? 0 === t.filter((e=>l.has(e))).length : Boolean(e && o.has(e)))
        }
        function d(e, t, i) {
            if (t && i && (0,
            s.isEtf)(t, i))
                return !1;
            const {dividendsAvailability: o, earningsAvailability: n, financialsAvailability: r} = e;
            return 1 === r || 1 === o || 1 === n
        }
    }
    ,
    2606: (e,t,i)=>{
        "use strict";
        i.d(t, {
            isDetailsReady: ()=>s
        });
        const s = new (i(978296).WatchedValue)(!1)
    }
    ,
    137674: (e,t,i)=>{
        "use strict";
        i.d(t, {
            createSymbolNote: ()=>g,
            showMindsPage: ()=>m,
            showSymbolDetails: ()=>_,
            showSymbolIdeas: ()=>p,
            showSymbolNews: ()=>h,
            showSymbolNotes: ()=>u,
            showSymbolNotesGroups: ()=>v
        });
        var s = i(2606)
          , o = i(421219)
          , n = i(777453);
        async function r(e) {
            Promise.all([i.e(79706), i.e(46445), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(2520), i.e(29296), i.e(58985), i.e(77476), i.e(75826), i.e(59258), i.e(82421), i.e(67158), i.e(16356), i.e(71938), i.e(97384), i.e(3782), i.e(30358), i.e(49162), i.e(17175), i.e(39967), i.e(81354), i.e(27272), i.e(71553), i.e(44500), i.e(32227), i.e(50030), i.e(22113), i.e(86195), i.e(98461), i.e(84165), i.e(6889), i.e(50996)]).then(i.bind(i, 768175)).then((t=>{
                t.renderNotesDialog(e)
            }
            ))
        }
        var a = i(881607);
        var l = i(515828);
        let c = null;
        function d(e, t) {
            if (c && s.isDetailsReady.unsubscribe(c),
            c = ()=>{
                var i, s, o;
                (null === (o = null === (s = null === (i = null === window || void 0 === window ? void 0 : window.widgetbar) || void 0 === i ? void 0 : i.layout) || void 0 === s ? void 0 : s.getWidgetByType("detail")) || void 0 === o ? void 0 : o.widgetObject).navigate(e, t)
            }
            ,
            s.isDetailsReady.value())
                return c(),
                void (c = null);
            s.isDetailsReady.subscribe(c, {
                once: !0
            })
        }
        function u(e=null, t) {
            const i = (0,
            o.pathToGroup)(null != e ? e : "");
            t ? r(i) : d(i)
        }
        function h(e, t) {
            const s = (0,
            n.newsPathToGroup)(null != e ? e : "");
            t ? async function(e) {
                (await Promise.all([i.e(4212), i.e(93703), i.e(75816), i.e(49481), i.e(44524), i.e(21356), i.e(62093), i.e(53953), i.e(2520), i.e(49742), i.e(22164), i.e(58985), i.e(77476), i.e(75826), i.e(59258), i.e(82421), i.e(67158), i.e(74600), i.e(70125), i.e(16190), i.e(85758), i.e(97384), i.e(3782), i.e(7462), i.e(49162), i.e(52753), i.e(46879), i.e(18488), i.e(49325), i.e(53791), i.e(17175), i.e(4673), i.e(81029), i.e(32227), i.e(60384), i.e(82705), i.e(62065), i.e(84482)]).then(i.bind(i, 23154))).renderNewsDialog(e)
            }(s) : d(s)
        }
        function p(e, t) {
            const s = (0,
            a.ideasPathToGroup)(null != e ? e : "");
            t ? async function(e) {
                (await Promise.all([i.e(23304), i.e(46445), i.e(93703), i.e(75816), i.e(44524), i.e(21356), i.e(62093), i.e(2520), i.e(22164), i.e(62564), i.e(58985), i.e(77476), i.e(59258), i.e(82421), i.e(67158), i.e(77280), i.e(16190), i.e(85758), i.e(97384), i.e(3782), i.e(7462), i.e(49162), i.e(52753), i.e(52017), i.e(17175), i.e(56261), i.e(49180), i.e(95645), i.e(82627), i.e(2008), i.e(27272), i.e(38791), i.e(32227), i.e(24951), i.e(2861), i.e(91955), i.e(94673)]).then(i.bind(i, 790348))).renderIdeasDialog(e)
            }(s) : d(s)
        }
        function m(e, t, i) {
            d((0,
            l.createMindsPath)(null != e ? e : "", t, i))
        }
        function g(e=null, t) {
            const i = (0,
            o.pathToGroup)(null != e ? e : "") + "?new=" + performance.now();
            t && r(i),
            d(i)
        }
        function _() {
            d("/")
        }
        function v() {
            d(o.NOTES_PATH_PATTERN)
        }
    }
    ,
    881607: (e,t,i)=>{
        "use strict";
        i.d(t, {
            IDEAS_GROUP_PATH_PATTERN: ()=>s,
            ideasPathToGroup: ()=>o
        });
        const s = "/ideas/groups/:symbol/";
        function o(e) {
            return s.replace(":symbol", encodeURIComponent(e))
        }
    }
    ,
    515828: (e,t,i)=>{
        "use strict";
        i.d(t, {
            MINDS_GROUP_PATH_PATTERN: ()=>s,
            createMindsPath: ()=>o
        });
        const s = "/minds/groups/:symbol/";
        function o(e, t, i) {
            let o = s.replace(":symbol", encodeURIComponent(e));
            if (!t)
                return o;
            const n = new URLSearchParams;
            return n.set("mind", t),
            i && n.set("editable", "true"),
            o += `?${n.toString()}`,
            o
        }
    }
    ,
    777453: (e,t,i)=>{
        "use strict";
        i.d(t, {
            NEWS_GROUP_PATH_PATTERN: ()=>s,
            newsPathToGroup: ()=>o
        });
        const s = "/news/groups/:symbol/";
        function o(e) {
            return s.replace(":symbol", encodeURIComponent(e))
        }
    }
    ,
    421219: (e,t,i)=>{
        "use strict";
        i.d(t, {
            GROUP_PATH_PATTERN: ()=>o,
            NOTES_PATH_PATTERN: ()=>s,
            UNATTENDED_PATH_PATTERN: ()=>n,
            pathToGroup: ()=>r
        });
        const s = "/notes/"
          , o = "/notes/groups/:symbol/"
          , n = "/notes/unattended/";
        function r(e) {
            return e ? o.replace(":symbol", encodeURIComponent(e)) : n
        }
    }
    ,
    834698: (e,t,i)=>{
        "use strict";
        i.d(t, {
            CompareDialogRenderer: ()=>n
        });
        var s = i(999138);
        var o = i(251954);
        class n extends s.DialogRenderer {
            constructor(e) {
                super(),
                this._dialog = null,
                this._subscribe = e=>{
                    this._setVisibility(e)
                }
                ,
                this._chartWidgetCollection = e
            }
            show(e) {
                this._load().then((t=>{
                    var i, s;
                    null === (i = this._dialog) || void 0 === i || i.hide(),
                    null === (s = this._dialog) || void 0 === s || s.visible().unsubscribe(this._subscribe),
                    this._dialog = t,
                    t.visible().subscribe(this._subscribe),
                    t.show(e),
                    o.emit("compare_add")
                }
                ))
            }
            hide() {
                var e;
                null === (e = this._dialog) || void 0 === e || e.hide()
            }
            _load() {
                return Promise.all([Promise.all([i.e(88312), i.e(57271)]).then(i.bind(i, 910261)), Promise.all([i.e(11567), i.e(46445), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(53953), i.e(2520), i.e(25480), i.e(62564), i.e(29800), i.e(46489), i.e(58985), i.e(23141), i.e(75826), i.e(59258), i.e(82421), i.e(67158), i.e(74600), i.e(72197), i.e(24125), i.e(88015), i.e(98734), i.e(97384), i.e(93523), i.e(3782), i.e(86605), i.e(49162), i.e(41243), i.e(7001), i.e(71329), i.e(51488), i.e(94106), i.e(59470), i.e(75364), i.e(79412), i.e(42513), i.e(78685), i.e(59434), i.e(55206), i.e(98858), i.e(2610), i.e(32227), i.e(50030), i.e(87473), i.e(18405), i.e(93498), i.e(65267), i.e(50186), i.e(78e3), i.e(30731)]).then(i.bind(i, 635647))]).then((([e,t])=>{
                    const i = new e.CompareModel(this._chartWidgetCollection);
                    return t.getCompareDialogRenderer(i)
                }
                ))
            }
        }
    }
    ,
    103669: (e,t,i)=>{
        "use strict";
        i.d(t, {
            DetailsDialogController: ()=>n
        });
        var s = i(999138);
        let o;
        class n extends s.DialogRenderer {
            constructor() {
                super(...arguments),
                this._dialog = null,
                this._promise = null,
                this._subscribe = e=>{
                    this._setVisibility(e)
                }
            }
            show(e) {
                const t = this._promise = Promise.all([i.e(32492), i.e(59822), i.e(56762), i.e(93703), i.e(75816), i.e(49481), i.e(44524), i.e(21356), i.e(62093), i.e(65857), i.e(36010), i.e(53953), i.e(2520), i.e(22164), i.e(58985), i.e(75826), i.e(59258), i.e(82421), i.e(67158), i.e(74600), i.e(70125), i.e(40528), i.e(16190), i.e(92115), i.e(71938), i.e(85758), i.e(97384), i.e(3782), i.e(7462), i.e(49162), i.e(52753), i.e(46879), i.e(18488), i.e(49325), i.e(53791), i.e(13427), i.e(29145), i.e(36770), i.e(87445), i.e(96589), i.e(96312), i.e(26341), i.e(42233), i.e(55773), i.e(74541), i.e(62064), i.e(4673), i.e(6752), i.e(59253), i.e(71045), i.e(71641), i.e(32227), i.e(60337), i.e(50030), i.e(31057), i.e(22113), i.e(60384), i.e(70045), i.e(31154), i.e(52383), i.e(90777), i.e(11032), i.e(6122), i.e(62065), i.e(35586), i.e(56856), i.e(26720)]).then(i.bind(i, 282555)).then((i=>{
                    this._promise === t && (this._dialog && (this._dialog.hide(),
                    this._dialog.visible().unsubscribe(this._subscribe)),
                    this._dialog = new i.DetailsDialogRenderer,
                    this._dialog.visible().subscribe(this._subscribe),
                    this._dialog.show(e))
                }
                ))
            }
            hide() {
                var e, t;
                null === (e = this._dialog) || void 0 === e || e.hide(),
                null === (t = this._dialog) || void 0 === t || t.visible().unsubscribe(this._subscribe)
            }
            static getInstance() {
                return o || (o = new n),
                o
            }
        }
    }
    ,
    715518: (e,t,i)=>{
        "use strict";
        i.d(t, {
            showDetailsDialog: ()=>o
        });
        var s = i(103669);
        function o(e) {
            s.DetailsDialogController.getInstance().show(e)
        }
    }
    ,
    597101: (e,t,i)=>{
        "use strict";
        i.d(t, {
            hideStateChange: ()=>s
        });
        const s = new (i(942634).Delegate)
    }
    ,
    951713: (e,t,i)=>{
        "use strict";
        i.d(t, {
            getHideModeStateValue: ()=>h,
            getHideOptions: ()=>d,
            getSavedHideMode: ()=>p,
            toggleHideMode: ()=>u
        });
        var s = i(650151)
          , o = i(444372)
          , n = i(62802)
          , r = i(84281)
          , a = i(419283)
          , l = i(597101);
        let c = null;
        function d() {
            if (null !== c)
                return c;
            const e = (0,
            r.tradingService)();
            return c = new Map([["drawings", {
                label: o.t(null, void 0, i(703217)),
                dataName: "hide-drawing-tools",
                tooltip: {
                    active: o.t(null, void 0, i(185891)),
                    inactive: o.t(null, void 0, i(752563))
                },
                getBoxedValue: ()=>(0,
                a.hideAllDrawings)(),
                trackLabel: "hide drawings"
            }], ["indicators", {
                label: o.t(null, void 0, i(72351)),
                dataName: "hide-indicators",
                tooltip: {
                    active: o.t(null, void 0, i(598753)),
                    inactive: o.t(null, void 0, i(178525))
                },
                getBoxedValue: ()=>(0,
                a.hideAllIndicators)(),
                trackLabel: "hide indicators"
            }], ["positions", {
                label: o.t(null, void 0, i(492226)),
                dataName: "hide-positions-and-orders",
                tooltip: {
                    active: o.t(null, void 0, i(420506)),
                    inactive: o.t(null, void 0, i(842164))
                },
                getBoxedValue: ()=>(0,
                s.ensureNotNull)(e).showTradedSources,
                inverted: !0,
                trackLabel: "hide positions"
            }], ["all", {
                label: o.t(null, void 0, i(47074)),
                dataName: "hide-all",
                tooltip: {
                    active: e ? o.t(null, void 0, i(686738)) : o.t(null, void 0, i(225881)),
                    inactive: e ? o.t(null, void 0, i(418216)) : o.t(null, void 0, i(90763))
                },
                trackLabel: "hide all"
            }]]),
            e || c.delete("positions"),
            c
        }
        function u(e) {
            e ? n.setValue("ChartToolsHideMode", e) : e = p();
            const t = m();
            let i = !t;
            return "all" === e ? (g(((e,t,s)=>{
                e.setValue(s ? !i : i)
            }
            )),
            l.hideStateChange.fire({
                hideMode: e,
                isActive: i
            }),
            i) : (g(((s,o,n)=>{
                if (o === e) {
                    const e = t ? !n : !s.value();
                    s.setValue(e),
                    i = n ? !e : e
                } else
                    s.setValue(Boolean(n))
            }
            )),
            l.hideStateChange.fire({
                hideMode: e,
                isActive: i
            }),
            i)
        }
        function h(e) {
            if ("all" === e)
                return m();
            const t = (0,
            s.ensureDefined)(d().get(e))
              , i = (0,
            s.ensureDefined)(t.getBoxedValue)().value();
            return t.inverted ? !i : i
        }
        function p() {
            const e = n.getValue("ChartToolsHideMode", "drawings");
            return d().has(e) ? e : "drawings"
        }
        function m() {
            let e = !0;
            return g(((t,i,s)=>{
                const o = t.value();
                e = e && (s ? !o : o)
            }
            )),
            e
        }
        function g(e) {
            d().forEach(((t,i)=>{
                var s;
                const o = null === (s = t.getBoxedValue) || void 0 === s ? void 0 : s.call(t);
                o && e(o, i, t.inverted)
            }
            ))
        }
    }
    ,
    333126: (e,t,i)=>{
        "use strict";
        i.d(t, {
            ObjectTreeDialogController: ()=>n
        });
        var s = i(999138);
        let o;
        class n extends s.DialogRenderer {
            constructor() {
                super(),
                this._dialog = null,
                this._subscribe = e=>{
                    this._setVisibility(e)
                }
            }
            show() {
                this._load().then((e=>e.show()))
            }
            hide() {
                var e;
                null === (e = this._dialog) || void 0 === e || e.hide()
            }
            static getInstance() {
                return o || (o = new n),
                o
            }
            _load() {
                return Promise.all([i.e(53796), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(53953), i.e(2520), i.e(25480), i.e(75826), i.e(59258), i.e(82421), i.e(67158), i.e(74600), i.e(72197), i.e(16190), i.e(24125), i.e(97384), i.e(49325), i.e(17175), i.e(44066), i.e(17762), i.e(84353), i.e(5463), i.e(74510), i.e(38692), i.e(69393), i.e(83693), i.e(82882), i.e(32227), i.e(87473), i.e(5483), i.e(60473), i.e(23872), i.e(50698), i.e(13505), i.e(69183), i.e(782), i.e(34862)]).then(i.bind(i, 110614)).then((e=>{
                    var t, i;
                    return null === (t = this._dialog) || void 0 === t || t.hide(),
                    null === (i = this._dialog) || void 0 === i || i.visible().unsubscribe(this._subscribe),
                    this._dialog = new e.ObjectTreeDialogRenderer,
                    this._dialog.visible().subscribe(this._subscribe),
                    this._dialog
                }
                ))
            }
        }
    }
    ,
    161590: (e,t,i)=>{
        "use strict";
        i.d(t, {
            GeneralChartPropertiesRenderer: ()=>o
        });
        var s = i(999138);
        class o extends s.DialogRenderer {
            constructor(e) {
                super(),
                this._dialog = null,
                this._subscribe = e=>{
                    this._setVisibility(e)
                }
                ,
                this._chartWidgetCollection = e
            }
            show(e) {
                const t = this._chartWidgetCollection
                  , s = t.activeChartWidget.value();
                return s.generalPropertiesDefinitions().then((o=>Promise.all([i.e(72481), i.e(46445), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(65857), i.e(36010), i.e(53953), i.e(2520), i.e(25480), i.e(62564), i.e(29800), i.e(46489), i.e(29296), i.e(58985), i.e(23141), i.e(62234), i.e(95083), i.e(75826), i.e(59258), i.e(82421), i.e(67158), i.e(22106), i.e(74600), i.e(30422), i.e(72197), i.e(16356), i.e(24125), i.e(88015), i.e(98734), i.e(97384), i.e(93523), i.e(3782), i.e(86605), i.e(43362), i.e(49162), i.e(41243), i.e(64797), i.e(22602), i.e(7001), i.e(71329), i.e(51488), i.e(94106), i.e(59470), i.e(75364), i.e(8222), i.e(80089), i.e(76750), i.e(13752), i.e(32277), i.e(44066), i.e(25983), i.e(84353), i.e(77414), i.e(79412), i.e(31085), i.e(42513), i.e(78685), i.e(59434), i.e(82440), i.e(24474), i.e(89255), i.e(89638), i.e(78687), i.e(7572), i.e(31600), i.e(48694), i.e(85775), i.e(45619), i.e(38790), i.e(63095), i.e(83410), i.e(601), i.e(62319), i.e(79184), i.e(779), i.e(88544), i.e(39782), i.e(35288), i.e(32227), i.e(50030), i.e(87473), i.e(40563), i.e(18405), i.e(90223), i.e(93498), i.e(65267), i.e(50186), i.e(71457), i.e(35432), i.e(85589), i.e(89178), i.e(13338), i.e(1077), i.e(92597), i.e(37078)]).then(i.bind(i, 824306)).then((i=>{
                    var n, r;
                    const a = new i.GeneralChartPropertiesDialogRenderer({
                        chartWidgetCollection: t,
                        propertyPages: o,
                        activePageId: this._activePageId,
                        model: s.model()
                    });
                    return null === (n = this._dialog) || void 0 === n || n.hide(),
                    null === (r = this._dialog) || void 0 === r || r.visible().unsubscribe(this._subscribe),
                    this._dialog = a,
                    a.visible().subscribe(this._subscribe),
                    a.show(e),
                    this._activePageId = void 0,
                    a
                }
                ))))
            }
            hide() {
                var e;
                null === (e = this._dialog) || void 0 === e || e.hide()
            }
            isVisible() {
                return this.visible().value()
            }
            focusOnText() {}
            setActivePage(e) {
                this._activePageId = e
            }
        }
    }
    ,
    83871: (e,t,i)=>{
        "use strict";
        i.d(t, {
            SYMBOL_LIST_SERVICE: ()=>s
        });
        const s = {
            id: "SymbolListService"
        }
    }
    ,
    440498: (e,t,i)=>{
        "use strict";
        i.d(t, {
            DELETED_SYMBOLS_LIST_ID: ()=>a,
            DeletedSymbolsList: ()=>d,
            isDeletedSymbolsList: ()=>c
        });
        var s = i(49437)
          , o = i(738600);
        const n = "deleted_symbols_list"
          , r = "is_deleted_symbols_list_active"
          , a = "deleted_symbols_list_id"
          , l = "There was an error during attempt to set local storage value"
          , c = e=>e === a;
        class d {
            constructor() {
                this._logError = (e,t)=>{
                    e instanceof Error ? o.logger.logError(e.message) : o.logger.logError(t)
                }
            }
            createList(e) {
                this._setList(e)
            }
            removeList() {
                try {
                    s.TVLocalStorage.removeItem(n)
                } catch (e) {
                    this._logError(e, "There was an error during local storage item removal")
                }
            }
            addSymbols(e) {
                const t = this.getList();
                if (!t)
                    return;
                const i = new Set(t.symbols);
                for (const t of e)
                    i.add(t);
                const s = Array.from(i);
                s.length > 100 ? t.symbols = s.reverse().slice(0, 100).reverse() : t.symbols = s,
                this._setList(t)
            }
            removeSymbols(e) {
                const t = this.getList();
                if (!t)
                    return;
                const i = new Set(t.symbols);
                for (const t of e)
                    i.delete(t);
                t.symbols = Array.from(i),
                this._setList(t)
            }
            replaceSymbols(e) {
                const t = this.getList();
                t && (t.symbols = e,
                this._setList(t))
            }
            getIsActive() {
                try {
                    return "true" === s.TVLocalStorage.getItem(r)
                } catch (e) {
                    return this._logError(e, l),
                    !1
                }
            }
            setIsActive(e) {
                try {
                    s.TVLocalStorage.setItem(r, String(e))
                } catch (e) {
                    this._logError(e, l)
                }
            }
            getList() {
                try {
                    const e = s.TVLocalStorage.getItem(n);
                    return e ? JSON.parse(e) : null
                } catch (e) {
                    return this._logError(e, "There was an error during attempt to get local storage value"),
                    null
                }
            }
            _setList(e) {
                try {
                    s.TVLocalStorage.setItem(n, JSON.stringify(e))
                } catch (e) {
                    this._logError(e, l)
                }
            }
        }
    }
    ,
    738600: (e,t,i)=>{
        "use strict";
        i.d(t, {
            logger: ()=>s
        });
        const s = (0,
        i(338619).getLogger)("Platform.Model.Watchlist")
    }
    ,
    306388: (e,t,i)=>{
        "use strict";
        i.d(t, {
            initSymbolListService: ()=>r
        });
        var s = i(564894)
          , o = i(83871)
          , n = i(953297);
        function r() {
            return Promise.all([Promise.all([i.e(23391), i.e(46445), i.e(93703), i.e(75816), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(25480), i.e(46489), i.e(74600), i.e(88015), i.e(86605), i.e(41243), i.e(32227), i.e(50030), i.e(5483), i.e(62526), i.e(18405), i.e(38506), i.e(51666), i.e(90050), i.e(1026)]).then(i.bind(i, 999614)), Promise.all([i.e(23391), i.e(46445), i.e(93703), i.e(75816), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(25480), i.e(46489), i.e(74600), i.e(88015), i.e(86605), i.e(41243), i.e(32227), i.e(50030), i.e(5483), i.e(62526), i.e(18405), i.e(38506), i.e(51666), i.e(90050), i.e(1026)]).then(i.bind(i, 38506)), Promise.all([i.e(23391), i.e(46445), i.e(93703), i.e(75816), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(25480), i.e(46489), i.e(74600), i.e(88015), i.e(86605), i.e(41243), i.e(32227), i.e(50030), i.e(5483), i.e(62526), i.e(18405), i.e(38506), i.e(51666), i.e(90050), i.e(1026)]).then(i.bind(i, 850935)), Promise.all([i.e(23391), i.e(46445), i.e(93703), i.e(75816), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(25480), i.e(46489), i.e(74600), i.e(88015), i.e(86605), i.e(41243), i.e(32227), i.e(50030), i.e(5483), i.e(62526), i.e(18405), i.e(38506), i.e(51666), i.e(90050), i.e(1026)]).then(i.bind(i, 244692)), n.enabled("widget") ? null : Promise.all([i.e(23391), i.e(46445), i.e(93703), i.e(75816), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(25480), i.e(46489), i.e(74600), i.e(88015), i.e(86605), i.e(41243), i.e(32227), i.e(50030), i.e(5483), i.e(62526), i.e(18405), i.e(38506), i.e(51666), i.e(90050), i.e(1026)]).then(i.bind(i, 216752))]).then((([e,t,i,n,r])=>{
                if ((0,
                s.hasService)(o.SYMBOL_LIST_SERVICE))
                    return (0,
                    s.service)(o.SYMBOL_LIST_SERVICE);
                const {store: a, runner: l} = e.configureStore()
                  , c = l.run(t.symbolListRepositorySaga);
                (0,
                s.registerService)(o.SYMBOL_LIST_SERVICE, {
                    store: a,
                    runner: l,
                    actions: {
                        addSymbols: n.addSymbolsThunk,
                        initWidget: i.initWidget,
                        saveListAs: n.saveListAsThunk,
                        createNewWatchList: n.userCreateWatchlistThunk
                    },
                    task: c
                });
                const d = (0,
                s.service)(o.SYMBOL_LIST_SERVICE);
                return null !== r && r.getCustomSymbolListSynchronizationServiceInstance(d),
                d
            }
            ))
        }
    }
    ,
    826939: (e,t,i)=>{
        "use strict";
        i.d(t, {
            WATCHLIST_WIDGET_ID: ()=>s
        });
        const s = "watchlist-widget"
    }
    ,
    979822: (e,t,i)=>{
        "use strict";
        i.d(t, {
            initWatchlistWidget: ()=>n
        });
        var s = i(650151);
        const o = {};
        function n(e) {
            if (!window.widgetbar)
                return;
            const t = (0,
            s.ensureNotNull)(window.widgetbar.setPage("base")).widget("watchlist");
            t && (t.widgetObject ? e(t.widgetObject) : (t.widgetStarted().unsubscribeAll(o),
            t.widgetStarted().subscribe(o, (t=>e(t.widgetObject)), !0)))
        }
    }
    ,
    305514: (e,t,i)=>{
        "use strict";
        i.d(t, {
            showWatchListsDialog: ()=>r
        });
        var s = i(999138);
        let o;
        class n extends s.DialogRenderer {
            constructor() {
                super(...arguments),
                this._dialog = null,
                this._subscribe = e=>{
                    this._setVisibility(e)
                }
            }
            show(e) {
                this._load(e).then((e=>e.show()))
            }
            hide() {
                var e, t;
                null === (e = this._dialog) || void 0 === e || e.hide(),
                null === (t = this._dialog) || void 0 === t || t.visible().unsubscribe(this._subscribe)
            }
            static getInstance() {
                return o || (o = new n),
                o
            }
            _load(e) {
                return Promise.all([i.e(41953), i.e(46445), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(53953), i.e(2520), i.e(25480), i.e(62564), i.e(29800), i.e(46489), i.e(77476), i.e(23141), i.e(95083), i.e(75826), i.e(59258), i.e(82421), i.e(67158), i.e(74600), i.e(72197), i.e(24125), i.e(21251), i.e(88015), i.e(32175), i.e(98734), i.e(39963), i.e(93523), i.e(86605), i.e(41243), i.e(49325), i.e(94106), i.e(59470), i.e(39967), i.e(44066), i.e(15440), i.e(5463), i.e(65891), i.e(7572), i.e(43386), i.e(83410), i.e(49279), i.e(11858), i.e(12366), i.e(32227), i.e(50030), i.e(87473), i.e(5483), i.e(56624), i.e(18405), i.e(38506), i.e(50698), i.e(38112), i.e(87954), i.e(64536), i.e(69719), i.e(57945)]).then(i.bind(i, 429964)).then((t=>{
                    var i, s;
                    return null === (i = this._dialog) || void 0 === i || i.hide(),
                    null === (s = this._dialog) || void 0 === s || s.visible().unsubscribe(this._subscribe),
                    this._dialog = new t.WatchListsDialogRenderer(e),
                    this._dialog.visible().subscribe(this._subscribe),
                    this._dialog
                }
                ))
            }
        }
        function r(e) {
            n.getInstance().show(e)
        }
    }
    ,
    104436: (e,t,i)=>{
        "use strict";
        var s;
        i.d(t, {
            ToolboxType: ()=>s
        }),
        function(e) {
            e[e.Delete = 0] = "Delete"
        }(s || (s = {}))
    }
    ,
    294740: (e,t,i)=>{
        e.exports = [{
            value: "",
            name: "All Exchanges",
            desc: i.i18next(null, void 0, i(349225)),
            flag: "",
            country: "",
            group: "AllExchanges",
            providerId: ""
        }, {
            value: "BISWAP",
            name: "Biswap v2 (BNB chain)",
            desc: i.i18next(null, void 0, i(799753)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "biswap"
        }, {
            value: "BITAZZA",
            name: "Bitazza",
            desc: i.i18next(null, void 0, i(279367)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "bitazza"
        }, {
            value: "BITHUMB",
            name: "Bithumb",
            desc: i.i18next(null, void 0, i(141432)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "bithumb"
        }, {
            value: "BITKUB",
            name: "Bitkub",
            desc: i.i18next(null, void 0, i(861302)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "bitkub"
        }, {
            value: "BITRUE",
            name: "Bitrue",
            desc: i.i18next(null, void 0, i(209041)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "bitrue"
        }, {
            value: "BITMART",
            name: "BitMart",
            desc: i.i18next(null, void 0, i(976901)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "bitmart"
        }, {
            value: "COINMETRICS",
            name: "Coin Metrics",
            desc: i.i18next(null, void 0, i(705304)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "coinmetrics"
        }, {
            value: "MEXC",
            name: "MEXC",
            desc: i.i18next(null, void 0, i(726324)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "mexc"
        }, {
            value: "GATEIO",
            name: "Gate.io",
            desc: i.i18next(null, void 0, i(528604)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "gateio"
        }, {
            value: "HTX",
            name: "HTX",
            desc: i.i18next(null, void 0, i(299799)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "htx"
        }, {
            value: "796",
            name: "796",
            desc: i.i18next(null, void 0, i(364972)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            hideInSymbolSearch: !0,
            country: "",
            providerId: ""
        }, {
            value: "DERIBIT",
            name: "Deribit",
            desc: i.i18next(null, void 0, i(385909)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "deribit"
        }, {
            value: "DEFILLAMA",
            name: "Defi Llama",
            desc: i.i18next(null, void 0, i(490394)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "defillama"
        }, {
            value: "GLASSNODE",
            name: "Glassnode",
            desc: i.i18next(null, void 0, i(589943)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "glassnode"
        }, {
            value: "OKX",
            name: "OKX",
            desc: i.i18next(null, void 0, i(784466)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "okx"
        }, {
            value: "ORCA",
            name: "Orca (Solana)",
            desc: i.i18next(null, void 0, i(281595)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "orca"
        }, {
            value: "OSMOSIS",
            name: "Osmosis",
            desc: i.i18next(null, void 0, i(572407)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "osmosis"
        }, {
            value: "PANGOLIN",
            name: "Pangolin v2 (Avalanche)",
            desc: i.i18next(null, void 0, i(954418)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "pangolin"
        }, {
            value: "PANCAKESWAP",
            name: "PancakeSwap v2 (BNB chain)",
            desc: i.i18next(null, void 0, i(134248)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "pancakeswap"
        }, {
            value: "PANCAKESWAP3BSC",
            name: "PancakeSwap v3 (BNB chain)",
            desc: i.i18next(null, void 0, i(100454)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "pancakeswap3"
        }, {
            value: "PANCAKESWAP3ETH",
            name: "PancakeSwap v3 (Ethereum)",
            desc: i.i18next(null, void 0, i(411586)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "pancakeswap3"
        }, {
            value: "CURVE",
            name: "Curve (Ethereum)",
            desc: i.i18next(null, void 0, i(121562)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "curve"
        }, {
            value: "PIONEX",
            name: "Pionex",
            desc: i.i18next(null, void 0, i(85261)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "pionex"
        }, {
            value: "PYTH",
            name: "Pyth",
            desc: i.i18next(null, void 0, i(340806)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "pyth"
        }, {
            value: "RAYDIUM",
            name: "Raydium (Solana)",
            desc: i.i18next(null, void 0, i(729766)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "raydium"
        }, {
            value: "SPOOKYSWAP",
            name: "SpookySwap v2 (Fantom)",
            desc: i.i18next(null, void 0, i(64568)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "spookyswap"
        }, {
            value: "WHITEBIT",
            name: "WhiteBIT",
            desc: i.i18next(null, void 0, i(63136)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "whitebit"
        }, {
            value: "WOONETWORK",
            name: "WOO X",
            desc: i.i18next(null, void 0, i(146755)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "woonetwork"
        }, {
            value: "DYDX",
            name: "dYdX",
            desc: i.i18next(null, void 0, i(279744)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "dydx"
        }, {
            value: "VOLMEX",
            name: "Volmex",
            desc: i.i18next(null, void 0, i(36018)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "volmex"
        }, {
            value: "ZOOMEX",
            name: "Zoomex",
            desc: i.i18next(null, void 0, i(827860)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "zoomex"
        }, {
            value: "ADX",
            name: "ADX",
            desc: i.i18next(null, void 0, i(216372)),
            flag: "ae",
            group: "Middle East / Africa",
            country: "ae",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(879479)), i.i18next(null, void 0, i(770695))]
        }, {
            value: "DFM",
            name: "DFM",
            desc: i.i18next(null, void 0, i(168496)),
            flag: "ae",
            group: "Middle East / Africa",
            country: "ae",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(879479)), i.i18next(null, void 0, i(770695))]
        }, {
            value: "NASDAQDUBAI",
            name: "NASDAQ",
            desc: i.i18next(null, void 0, i(670103)),
            flag: "ae",
            group: "Middle East / Africa",
            country: "ae",
            priorityInGroup: 1,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(879479)), i.i18next(null, void 0, i(770695))]
        }, {
            value: "LSE",
            name: "LSE",
            desc: i.i18next(null, void 0, i(506690)),
            flag: "uk",
            group: "Europe",
            country: "uk",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(564554)), i.i18next(null, void 0, i(460411))]
        }, {
            value: "LME",
            name: "LME",
            desc: i.i18next(null, void 0, i(391262)),
            flag: "uk",
            group: "Europe",
            country: "uk",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(564554)), i.i18next(null, void 0, i(460411))]
        }, {
            value: "LSIN",
            name: "LSIN",
            desc: i.i18next(null, void 0, i(203392)),
            flag: "uk",
            group: "Europe",
            country: "uk",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(564554)), i.i18next(null, void 0, i(460411))]
        }, {
            value: "TURQUOISE",
            name: "Turquoise",
            desc: i.i18next(null, void 0, i(922542)),
            flag: "uk",
            group: "Europe",
            country: "uk",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(564554)), i.i18next(null, void 0, i(460411))]
        }, {
            value: "FTSE",
            name: "FTSE",
            desc: i.i18next(null, void 0, i(56079)),
            flag: "uk",
            group: "Europe",
            country: "uk",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(564554)), i.i18next(null, void 0, i(460411))]
        }, {
            value: "EUREX",
            name: "EUREX",
            desc: i.i18next(null, void 0, i(28727)),
            flag: "europe",
            group: "Europe",
            country: "eu",
            providerId: ""
        }, {
            value: "MGEX",
            name: "MGEX",
            desc: i.i18next(null, void 0, i(27946)),
            flag: "usa",
            hideInSymbolSearch: !0,
            group: "North America",
            country: "us",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "NASDAQ",
            name: "NASDAQ",
            desc: i.i18next(null, void 0, i(217103)),
            flag: "usa",
            group: "North America",
            country: "us",
            priorityInGroup: 1,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "NYSE",
            name: "NYSE",
            desc: i.i18next(null, void 0, i(715727)),
            flag: "usa",
            group: "North America",
            country: "us",
            priorityInGroup: 2,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "AMEX",
            name: "Arca",
            desc: i.i18next(null, void 0, i(800828)),
            flag: "usa",
            group: "North America",
            country: "us",
            priorityInGroup: 3,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "OTC",
            name: "OTC",
            desc: i.i18next(null, void 0, i(846485)),
            flag: "usa",
            group: "North America",
            country: "us",
            priorityInGroup: 4,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "DJ",
            name: "DJ",
            desc: i.i18next(null, void 0, i(473367)),
            flag: "usa",
            group: "North America",
            country: "us",
            priorityInGroup: 5,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "SP",
            name: "SP",
            desc: i.i18next(null, void 0, i(320939)),
            flag: "usa",
            group: "North America",
            country: "us",
            priorityInGroup: 6,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "CBOE",
            name: "CBOE",
            desc: i.i18next(null, void 0, i(395213)),
            flag: "usa",
            group: "North America",
            country: "us",
            priorityInGroup: 7,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "FINRABTDS",
            name: "FINRA BTDS",
            desc: i.i18next(null, void 0, i(137716)),
            flag: "usa",
            group: "North America",
            country: "us",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "OPRA",
            name: "OPRA",
            desc: i.i18next(null, void 0, i(646426)),
            flag: "usa",
            group: "North America",
            country: "us",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "FINRAATDS",
            name: "FINRA ATDS",
            desc: i.i18next(null, void 0, i(922843)),
            flag: "usa",
            group: "North America",
            country: "us",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "CBOEEU",
            name: "CBOE EU",
            desc: i.i18next(null, void 0, i(680842)),
            flag: "europe",
            group: "Europe",
            country: "eu",
            providerId: ""
        }, {
            value: "CBOT",
            name: "CBOT",
            desc: i.i18next(null, void 0, i(797720)),
            flag: "usa",
            group: "North America",
            country: "us",
            priorityInGroup: 8,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "CME",
            name: "CME GLOBEX",
            desc: i.i18next(null, void 0, i(78085)),
            flag: "usa",
            group: "North America",
            country: "us",
            priorityInGroup: 9,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "COMEX",
            name: "COMEX",
            desc: i.i18next(null, void 0, i(107840)),
            flag: "usa",
            group: "North America",
            country: "us",
            priorityInGroup: 10,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "NYMEX",
            name: "NYMEX",
            desc: i.i18next(null, void 0, i(346926)),
            flag: "usa",
            group: "North America",
            country: "us",
            priorityInGroup: 11,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "ICEUS",
            name: "ICEUS",
            desc: i.i18next(null, void 0, i(766301)),
            flag: "usa",
            group: "North America",
            country: "us",
            priorityInGroup: 12,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "FAIRX",
            name: "FairX",
            desc: i.i18next(null, void 0, i(389609)),
            flag: "usa",
            group: "North America",
            country: "us",
            priorityInGroup: 13,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "CSE",
            name: "CSE",
            desc: i.i18next(null, void 0, i(19521)),
            flag: "canada",
            group: "North America",
            country: "ca",
            priorityInGroup: 13,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(588590))]
        }, {
            value: "NEO",
            name: "NEO",
            desc: i.i18next(null, void 0, i(692726)),
            flag: "canada",
            group: "North America",
            country: "ca",
            priorityInGroup: 14,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(588590))]
        }, {
            value: "TSX",
            name: "TSX",
            desc: i.i18next(null, void 0, i(713373)),
            flag: "canada",
            group: "North America",
            country: "ca",
            priorityInGroup: 15,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(588590))]
        }, {
            value: "TSXV",
            name: "TSXV",
            desc: i.i18next(null, void 0, i(151990)),
            flag: "canada",
            group: "North America",
            country: "ca",
            priorityInGroup: 16,
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(588590))]
        }, {
            value: "ALOR",
            name: "ALOR",
            desc: i.i18next(null, void 0, i(987872)),
            flag: "russia",
            group: "Europe",
            country: "ru",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(115446))]
        }, {
            value: "MYX",
            name: "MYX",
            desc: i.i18next(null, void 0, i(522503)),
            flag: "malaysia",
            group: "Asia / Pacific",
            country: "my",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(910613))]
        }, {
            value: "FTSEMYX",
            name: "FTSE",
            desc: i.i18next(null, void 0, i(729317)),
            flag: "malaysia",
            group: "Asia / Pacific",
            country: "my",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(910613))]
        }, {
            value: "HOSE",
            name: "HOSE",
            desc: i.i18next(null, void 0, i(587176)),
            flag: "vietnam",
            group: "Asia / Pacific",
            country: "vn",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(403944))]
        }, {
            value: "HNX",
            name: "HNX",
            desc: i.i18next(null, void 0, i(247683)),
            flag: "vietnam",
            group: "Asia / Pacific",
            country: "vn",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(403944))]
        }, {
            value: "UPCOM",
            name: "HNX UPCoM",
            desc: i.i18next(null, void 0, i(468677)),
            flag: "vietnam",
            group: "Asia / Pacific",
            country: "vn",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(403944))]
        }, {
            value: "CSELK",
            name: "CSE",
            desc: i.i18next(null, void 0, i(817932)),
            flag: "sri_lanka",
            group: "Asia / Pacific",
            country: "lk",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(308201))]
        }, {
            value: "BITSTAMP",
            name: "Bitstamp",
            desc: i.i18next(null, void 0, i(926085)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "bitstamp"
        }, {
            value: "ACTIVTRADES",
            name: "ActivTrades",
            desc: i.i18next(null, void 0, i(136792)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "activtrades"
        }, {
            value: "AFTERPRIME",
            name: "Afterprime",
            desc: i.i18next(null, void 0, i(218282)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "afterprime"
        }, {
            value: "BLACKBULL",
            name: "BlackBull Markets",
            desc: i.i18next(null, void 0, i(890862)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "blackbullmarkets"
        }, {
            value: "FPMARKETS",
            name: "FP Markets",
            desc: i.i18next(null, void 0, i(328729)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "fpmarkets"
        }, {
            value: "FUSIONMARKETS",
            name: "Fusion Markets",
            desc: i.i18next(null, void 0, i(795486)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "fusionmarkets"
        }, {
            value: "IG",
            name: "IG",
            desc: i.i18next(null, void 0, i(364294)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "ig"
        }, {
            value: "THINKMARKETS",
            name: "ThinkMarkets",
            desc: i.i18next(null, void 0, i(992944)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "thinkmarkets"
        }, {
            value: "TRADENATION",
            name: "Trade Nation",
            desc: i.i18next(null, void 0, i(424782)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "tradenation"
        }, {
            value: "VANTAGE",
            name: "Vantage",
            desc: i.i18next(null, void 0, i(430760)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "vantagefx"
        }, {
            value: "VELOCITY",
            name: "Velocity Trade",
            desc: i.i18next(null, void 0, i(370458)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "velocitytrade"
        }, {
            value: "FX",
            name: "FXCM",
            desc: i.i18next(null, void 0, i(72752)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "fxcm"
        }, {
            value: "FXOPEN",
            name: "FXOpen",
            desc: i.i18next(null, void 0, i(453285)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "fxopen"
        }, {
            value: "EIGHTCAP",
            name: "Eightcap",
            desc: i.i18next(null, void 0, i(817793)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "eightcap"
        }, {
            value: "BTCE",
            name: "BTC-e",
            desc: i.i18next(null, void 0, i(900801)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            hideInSymbolSearch: !0,
            country: "",
            providerId: ""
        }, {
            value: "HONEYSWAP",
            name: "Honeyswap v2 (Gnosis)",
            desc: i.i18next(null, void 0, i(445782)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "honeyswap"
        }, {
            value: "BSE",
            name: "BSE",
            desc: i.i18next(null, void 0, i(679286)),
            flag: "india",
            group: "Asia / Pacific",
            country: "in",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(719912))]
        }, {
            value: "MSEI",
            name: "MSE",
            desc: i.i18next(null, void 0, i(196615)),
            flag: "india",
            group: "Asia / Pacific",
            country: "in",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(719912))]
        }, {
            value: "NYMEX_MINI",
            name: "NYMEX",
            desc: i.i18next(null, void 0, i(346926)),
            flag: "usa",
            group: "North America",
            hideInSymbolSearch: !0,
            country: "us",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "COMEX_MINI",
            name: "COMEX",
            desc: i.i18next(null, void 0, i(107840)),
            flag: "usa",
            group: "North America",
            hideInSymbolSearch: !0,
            country: "us",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "ICEEURFIN",
            name: "ICEEUR",
            desc: i.i18next(null, void 0, i(283020)),
            flag: "europe",
            group: "Europe",
            country: "eu",
            providerId: ""
        }, {
            value: "ICEEURCOMM",
            name: "ICEEUR",
            desc: i.i18next(null, void 0, i(273008)),
            flag: "europe",
            group: "Europe",
            country: "eu",
            providerId: ""
        }, {
            value: "NSE",
            name: "NSE",
            desc: i.i18next(null, void 0, i(849391)),
            flag: "india",
            group: "Asia / Pacific",
            country: "in",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(719912))]
        }, {
            value: "MCX",
            name: "MCX",
            desc: i.i18next(null, void 0, i(738203)),
            flag: "india",
            group: "Asia / Pacific",
            country: "in",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(719912))]
        }, {
            value: "NCDEX",
            name: "NCDEX",
            desc: i.i18next(null, void 0, i(32132)),
            flag: "india",
            group: "Asia / Pacific",
            country: "in",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(719912))]
        }, {
            value: "KCBT",
            name: "KCBT",
            desc: i.i18next(null, void 0, i(528616)),
            flag: "usa",
            hideInSymbolSearch: !0,
            group: "North America",
            country: "us",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "OKCOIN",
            name: "Okcoin",
            desc: i.i18next(null, void 0, i(659957)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "okcoin"
        }, {
            value: "CBOT_MINI",
            name: "CBOT",
            desc: i.i18next(null, void 0, i(797720)),
            flag: "usa",
            group: "North America",
            hideInSymbolSearch: !0,
            country: "us",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "KRAKEN",
            name: "Kraken",
            desc: i.i18next(null, void 0, i(959795)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "kraken"
        }, {
            value: "KUCOIN",
            name: "KuCoin",
            desc: i.i18next(null, void 0, i(348700)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "kucoin"
        }, {
            value: "LUNARCRUSH",
            name: "LunarCrush",
            desc: i.i18next(null, void 0, i(476316)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "lunarcrush"
        }, {
            value: "XEXCHANGE",
            name: "xExchange",
            desc: i.i18next(null, void 0, i(149853)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "xexchange"
        }, {
            value: "CME_MINI",
            name: "CME",
            desc: i.i18next(null, void 0, i(78085)),
            flag: "usa",
            group: "North America",
            hideInSymbolSearch: !0,
            country: "us",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "DJ",
            name: "DJ",
            desc: i.i18next(null, void 0, i(53182)),
            flag: "usa",
            hideInSymbolSearch: !0,
            group: "North America",
            country: "us",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "SP",
            name: "SP",
            desc: i.i18next(null, void 0, i(359390)),
            flag: "usa",
            hideInSymbolSearch: !0,
            group: "North America",
            country: "us",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "BTCCHINA",
            name: "BTC China",
            desc: i.i18next(null, void 0, i(812763)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            hideInSymbolSearch: !0,
            country: "",
            providerId: ""
        }, {
            value: "THRUSTER3",
            name: "Thruster v3 (Blast)",
            desc: i.i18next(null, void 0, i(689626)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "thruster"
        }, {
            value: "TIMEX",
            name: "TimeX",
            desc: i.i18next(null, void 0, i(4782)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "timex"
        }, {
            value: "ANX",
            name: "ANX",
            desc: i.i18next(null, void 0, i(158363)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            hideInSymbolSearch: !0,
            country: "",
            providerId: ""
        }, {
            value: "MEXBT",
            name: "meXBT",
            desc: i.i18next(null, void 0, i(145894)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            hideInSymbolSearch: !0,
            country: "",
            providerId: ""
        }, {
            value: "GEMINI",
            name: "Gemini",
            desc: i.i18next(null, void 0, i(880309)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "gemini"
        }, {
            value: "BITVC",
            name: "BitVC",
            desc: i.i18next(null, void 0, i(784960)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            hideInSymbolSearch: !0,
            country: "",
            providerId: ""
        }, {
            value: "BITYES",
            name: "BitYes",
            desc: i.i18next(null, void 0, i(61174)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            hideInSymbolSearch: !0,
            country: "",
            providerId: ""
        }, {
            value: "BITFLYER",
            name: "bitFlyer",
            desc: i.i18next(null, void 0, i(719564)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "bitflyer"
        }, {
            value: "BYBIT",
            name: "Bybit",
            desc: i.i18next(null, void 0, i(562521)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "bybit"
        }, {
            value: "BITMEX",
            name: "BitMEX",
            desc: i.i18next(null, void 0, i(433593)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "bitmex"
        }, {
            value: "CAPITALCOM",
            name: "Capital.com",
            desc: i.i18next(null, void 0, i(43469)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "capitalcom"
        }, {
            value: "CFI",
            name: "CFI",
            desc: i.i18next(null, void 0, i(270727)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "cfifinancial"
        }, {
            value: "COINEX",
            name: "CoinEx",
            desc: i.i18next(null, void 0, i(346959)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "coinex"
        }, {
            value: "INTOTHEBLOCK",
            name: "IntoTheBlock",
            desc: i.i18next(null, void 0, i(642457)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "intotheblock"
        }, {
            value: "EASYMARKETS",
            name: "easyMarkets",
            desc: i.i18next(null, void 0, i(239891)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "easymarkets"
        }, {
            value: "FOREXCOM",
            name: "FOREX.com",
            desc: i.i18next(null, void 0, i(273774)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "gain"
        }, {
            value: "FX_IDC",
            name: "ICE",
            desc: i.i18next(null, void 0, i(712566)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "ice"
        }, {
            value: "IBKR",
            name: "Interactive Brokers",
            desc: i.i18next(null, void 0, i(341971)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "ibkr"
        }, {
            value: "IBROKER",
            name: "iBroker",
            desc: i.i18next(null, void 0, i(520915)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "ibroker"
        }, {
            value: "ICMARKETS",
            name: "IC Markets",
            desc: i.i18next(null, void 0, i(6506)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "icmarkets"
        }, {
            value: "BITFINEX",
            name: "Bitfinex",
            desc: i.i18next(null, void 0, i(732549)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "bitfinex"
        }, {
            value: "MTGOX",
            name: "Mt.Gox",
            desc: i.i18next(null, void 0, i(305241)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            hideInSymbolSearch: !0,
            country: "",
            providerId: "mtgox"
        }, {
            value: "PHEMEX",
            name: "Phemex",
            desc: i.i18next(null, void 0, i(3906)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "phemex"
        }, {
            value: "POLONIEX",
            name: "Poloniex",
            desc: i.i18next(null, void 0, i(418819)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "poloniex"
        }, {
            value: "PULSEX",
            name: "Pulsex (Pulsechain)",
            desc: i.i18next(null, void 0, i(31780)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "pulsex"
        }, {
            value: "QUICKSWAP",
            name: "QuickSwap v2 (Polygon)",
            desc: i.i18next(null, void 0, i(222051)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "quickswap"
        }, {
            value: "QUICKSWAP3POLYGONZKEVM",
            name: "QuickSwap v3 (Polygon zkEVM)",
            desc: i.i18next(null, void 0, i(329095)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "quickswap3"
        }, {
            value: "QUICKSWAP3POLYGON",
            name: "QuickSwap v3 (Polygon)",
            desc: i.i18next(null, void 0, i(565062)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "quickswap3"
        }, {
            value: "SUSHISWAP",
            name: "SushiSwap v2 (Ethereum)",
            desc: i.i18next(null, void 0, i(487896)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "sushiswap"
        }, {
            value: "SUSHISWAPPOLYGON",
            name: "SushiSwap v2 (Polygon)",
            desc: i.i18next(null, void 0, i(496143)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "sushiswap"
        }, {
            value: "TOKENIZE",
            name: "Tokenize",
            desc: i.i18next(null, void 0, i(783427)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "tokenize"
        }, {
            value: "TRADERJOE",
            name: "Trader Joe v2 (Avalanche)",
            desc: i.i18next(null, void 0, i(811847)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "traderjoe"
        }, {
            value: "UNISWAP",
            name: "Uniswap v2 (Ethereum)",
            desc: i.i18next(null, void 0, i(846768)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "uniswap"
        }, {
            value: "UNISWAP3ETH",
            name: "Uniswap v3 (Ethereum)",
            desc: i.i18next(null, void 0, i(976337)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "uniswap3"
        }, {
            value: "UNISWAP3POLYGON",
            name: "Uniswap v3 (Polygon)",
            desc: i.i18next(null, void 0, i(725829)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "uniswap3"
        }, {
            value: "UNISWAP3ARBITRUM",
            name: "Uniswap v3 (Arbitrum)",
            desc: i.i18next(null, void 0, i(439063)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "uniswap3"
        }, {
            value: "UNISWAP3OPTIMISM",
            name: "Uniswap v3 (Optimism)",
            desc: i.i18next(null, void 0, i(234811)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "uniswap3"
        }, {
            value: "UNISWAP3BSC",
            name: "Uniswap v3 (BNB chain)",
            desc: i.i18next(null, void 0, i(743891)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "uniswap3"
        }, {
            value: "UNISWAP3BASE",
            name: "Uniswap v3 (Base)",
            desc: i.i18next(null, void 0, i(590022)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "uniswap3"
        }, {
            value: "UNISWAP3AVALANCHE",
            name: "Uniswap v3 (Avalanche)",
            desc: i.i18next(null, void 0, i(936011)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "uniswap3"
        }, {
            value: "UPBIT",
            name: "UpBit",
            desc: i.i18next(null, void 0, i(977837)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "upbit"
        }, {
            value: "BINGX",
            name: "BingX",
            desc: i.i18next(null, void 0, i(190615)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "bingx"
        }, {
            value: "BTSE",
            name: "BTSE",
            desc: i.i18next(null, void 0, i(598713)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "btse"
        }, {
            value: "BITTREX",
            name: "Bittrex",
            desc: i.i18next(null, void 0, i(874414)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "bittrex"
        }, {
            value: "BINANCE",
            name: "Binance",
            desc: i.i18next(null, void 0, i(943962)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "binance"
        }, {
            value: "BITGET",
            name: "Bitget",
            desc: i.i18next(null, void 0, i(290121)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "bitget"
        }, {
            value: "BINANCEUS",
            name: "Binance.US",
            desc: i.i18next(null, void 0, i(776240)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "binance"
        }, {
            value: "DELTA",
            name: "Delta Exchange",
            desc: i.i18next(null, void 0, i(996886)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "delta"
        }, {
            value: "BLOFIN",
            name: "BloFin",
            desc: i.i18next(null, void 0, i(8013)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "blofin"
        }, {
            value: "BNC",
            name: "Brave New Coin",
            desc: i.i18next(null, void 0, i(334878)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "bnc"
        }, {
            value: "KATANA",
            name: "Katana (Ronin)",
            desc: i.i18next(null, void 0, i(635120)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "katana"
        }, {
            value: "CAMELOT",
            name: "Camelot v2 (Arbitrum)",
            desc: i.i18next(null, void 0, i(458981)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "camelot2"
        }, {
            value: "CAMELOT3ARBITRUM",
            name: "Camelot v3 (Arbitrum)",
            desc: i.i18next(null, void 0, i(788251)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "camelot3"
        }, {
            value: "CRYPTOCOM",
            name: "Crypto.com",
            desc: i.i18next(null, void 0, i(479308)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "cryptocom"
        }, {
            value: "VELODROME",
            name: "Velodrome (Optimism)",
            desc: i.i18next(null, void 0, i(151597)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "velodrome"
        }, {
            value: "VVSFINANCE",
            name: "VVS Finance (Cronos)",
            desc: i.i18next(null, void 0, i(384055)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "vvsfinance"
        }, {
            value: "MMFINANCE",
            name: "MM Finance (Cronos)",
            desc: i.i18next(null, void 0, i(192290)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "mmfinance"
        }, {
            value: "BASESWAP",
            name: "BaseSwap (Base)",
            desc: i.i18next(null, void 0, i(758571)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "baseswap"
        }, {
            value: "BCBA",
            name: "BYMA",
            desc: i.i18next(null, void 0, i(873679)),
            flag: "argentina",
            group: "Mexico and South America",
            country: "ar",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(106226))]
        }, {
            value: "MATBAROFEX",
            name: "ROFEX",
            desc: i.i18next(null, void 0, i(287198)),
            flag: "argentina",
            group: "Mexico and South America",
            country: "ar",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(106226))]
        }, {
            value: "BMFBOVESPA",
            name: "B3",
            desc: i.i18next(null, void 0, i(297117)),
            flag: "brasil",
            group: "Mexico and South America",
            country: "br",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(497100))]
        }, {
            value: "BMV",
            name: "BMV",
            desc: i.i18next(null, void 0, i(167429)),
            flag: "mexico",
            group: "Mexico and South America",
            country: "mx",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(774951))]
        }, {
            value: "BIVA",
            name: "BIVA",
            desc: i.i18next(null, void 0, i(545849)),
            flag: "mexico",
            group: "Mexico and South America",
            country: "mx",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(774951))]
        }, {
            value: "BVL",
            name: "BVL",
            desc: i.i18next(null, void 0, i(557266)),
            flag: "peru",
            group: "Mexico and South America",
            country: "pe",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(184677))]
        }, {
            value: "BCS",
            name: "SSE",
            desc: i.i18next(null, void 0, i(837838)),
            flag: "chile",
            group: "Mexico and South America",
            country: "cl",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(887583))]
        }, {
            value: "BVC",
            name: "BVC",
            desc: i.i18next(null, void 0, i(472364)),
            flag: "colombia",
            group: "Mexico and South America",
            country: "co",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(882104))]
        }, {
            value: "BVCV",
            name: "BVC",
            desc: i.i18next(null, void 0, i(368544)),
            flag: "venezuela",
            group: "Mexico and South America",
            country: "ve",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(250614))]
        }, {
            value: "NAG",
            name: "NSE",
            desc: i.i18next(null, void 0, i(835936)),
            flag: "japan",
            group: "Asia / Pacific",
            country: "jp",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(200186))]
        }, {
            value: "TSE",
            name: "TSE",
            desc: i.i18next(null, void 0, i(626004)),
            flag: "japan",
            group: "Asia / Pacific",
            country: "jp",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(200186))]
        }, {
            value: "TFEX",
            name: "TFEX",
            desc: i.i18next(null, void 0, i(477940)),
            flag: "thailand",
            group: "Asia / Pacific",
            country: "th",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(215786))]
        }, {
            value: "TFX",
            name: "TFX",
            desc: i.i18next(null, void 0, i(774401)),
            flag: "japan",
            group: "Asia / Pacific",
            country: "jp",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(200186))]
        }, {
            value: "TOCOM",
            name: "TOCOM",
            desc: i.i18next(null, void 0, i(686908)),
            flag: "japan",
            group: "Asia / Pacific",
            country: "jp",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(200186))]
        }, {
            value: "OSE",
            name: "OSE",
            desc: i.i18next(null, void 0, i(565991)),
            flag: "japan",
            group: "Asia / Pacific",
            country: "jp",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(200186))]
        }, {
            value: "SGX",
            name: "SGX",
            desc: i.i18next(null, void 0, i(726842)),
            flag: "singapore",
            group: "Asia / Pacific",
            country: "sg",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(977377))]
        }, {
            value: "ICESG",
            name: "ICE Futures Singapore",
            desc: i.i18next(null, void 0, i(123453)),
            flag: "singapore",
            group: "Asia / Pacific",
            country: "sg",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(977377))]
        }, {
            value: "FTSEST",
            name: "FTSE ST",
            desc: i.i18next(null, void 0, i(556743)),
            flag: "singapore",
            group: "Asia / Pacific",
            country: "sg",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(977377))]
        }, {
            value: "SAPSE",
            name: "SSE",
            desc: i.i18next(null, void 0, i(588484)),
            flag: "japan",
            group: "Asia / Pacific",
            country: "jp",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(200186))]
        }, {
            value: "FSE",
            name: "FSE",
            desc: i.i18next(null, void 0, i(424900)),
            flag: "japan",
            group: "Asia / Pacific",
            country: "jp",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(200186))]
        }, {
            value: "TPEX",
            name: "TPEx",
            desc: i.i18next(null, void 0, i(271124)),
            flag: "taiwan",
            group: "Asia / Pacific",
            country: "tw",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(59215))]
        }, {
            value: "TAIFEX",
            name: "TAIFEX",
            desc: i.i18next(null, void 0, i(343324)),
            flag: "taiwan",
            group: "Asia / Pacific",
            country: "tw",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(59215))]
        }, {
            value: "TWSE",
            name: "TWSE",
            desc: i.i18next(null, void 0, i(546623)),
            flag: "taiwan",
            group: "Asia / Pacific",
            country: "tw",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(59215))]
        }, {
            value: "SET",
            name: "SET",
            desc: i.i18next(null, void 0, i(4085)),
            flag: "thailand",
            group: "Asia / Pacific",
            country: "th",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(215786))]
        }, {
            value: "KRX",
            name: "KRX",
            desc: i.i18next(null, void 0, i(233866)),
            flag: "south_korea",
            group: "Asia / Pacific",
            country: "kr",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(617661))]
        }, {
            value: "BAHRAIN",
            name: "BHB",
            desc: i.i18next(null, void 0, i(198411)),
            flag: "bahrain",
            group: "Middle East / Africa",
            country: "bh",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(290594))]
        }, {
            value: "KSE",
            name: "KSE",
            desc: i.i18next(null, void 0, i(869885)),
            flag: "kuwait",
            group: "Middle East / Africa",
            country: "kw",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(76614))]
        }, {
            value: "CSECY",
            name: "CSE",
            desc: i.i18next(null, void 0, i(90904)),
            flag: "cyprus",
            group: "Europe",
            country: "cy",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(935415))]
        }, {
            value: "BVMT",
            name: "BVMT",
            desc: i.i18next(null, void 0, i(707302)),
            flag: "tunisia",
            group: "Middle East / Africa",
            country: "tn",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(420349))]
        }, {
            value: "ATHEX",
            name: "ATHEX",
            desc: i.i18next(null, void 0, i(672725)),
            flag: "greece",
            group: "Europe",
            country: "gr",
            providerId: ""
        }, {
            value: "BELEX",
            name: "BELEX",
            desc: i.i18next(null, void 0, i(43917)),
            flag: "serbia",
            group: "Europe",
            country: "rs",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(428819))]
        }, {
            value: "EGX",
            name: "EGX",
            desc: i.i18next(null, void 0, i(673924)),
            flag: "egypt",
            group: "Middle East / Africa",
            country: "eg",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(324432))]
        }, {
            value: "TADAWUL",
            name: "Tadawul",
            desc: i.i18next(null, void 0, i(294693)),
            flag: "saudi_arabia",
            group: "Middle East / Africa",
            country: "sa",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(605991))]
        }, {
            value: "CSEMA",
            name: "CSE",
            desc: i.i18next(null, void 0, i(825559)),
            flag: "morocco",
            group: "Middle East / Africa",
            country: "ma",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(224794))]
        }, {
            value: "IDX",
            name: "IDX",
            desc: i.i18next(null, void 0, i(108698)),
            flag: "indonesia",
            group: "Asia / Pacific",
            country: "id",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(532355))]
        }, {
            value: "HSI",
            name: "HSI",
            desc: i.i18next(null, void 0, i(711161)),
            flag: "hong_kong",
            group: "Asia / Pacific",
            country: "hk",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(248861))]
        }, {
            value: "QSE",
            name: "QSE",
            desc: i.i18next(null, void 0, i(265698)),
            flag: "qatar",
            group: "Middle East / Africa",
            country: "qa",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(328756))]
        }, {
            value: "OANDA",
            name: "OANDA",
            desc: i.i18next(null, void 0, i(373389)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "oanda"
        }, {
            value: "SAXO",
            name: "Saxo",
            desc: i.i18next(null, void 0, i(597961)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "saxobank"
        }, {
            value: "PEPPERSTONE",
            name: "Pepperstone",
            desc: i.i18next(null, void 0, i(82455)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "pepperstone"
        }, {
            value: "PHILLIPNOVA",
            name: "Phillip Nova",
            desc: i.i18next(null, void 0, i(714387)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "phillipnova"
        }, {
            value: "SKILLING",
            name: "SKILLING",
            desc: i.i18next(null, void 0, i(519061)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "skilling"
        }, {
            value: "SPREADEX",
            name: "Spreadex",
            desc: i.i18next(null, void 0, i(732187)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "spreadex"
        }, {
            value: "GBEBROKERS",
            name: "GBE brokers",
            desc: i.i18next(null, void 0, i(891454)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "gbebrokers"
        }, {
            value: "EURONEXT",
            name: "Euronext",
            desc: i.i18next(null, void 0, i(771342)),
            flag: "europe",
            group: "Europe",
            country: "eu",
            providerId: ""
        }, {
            value: "EURONEXTAMS",
            name: "EURONEXTAMS",
            desc: i.i18next(null, void 0, i(350877)),
            flag: "netherlands",
            group: "Europe",
            country: "nl",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(376970))]
        }, {
            value: "EURONEXTBRU",
            name: "EURONEXTBRU",
            desc: i.i18next(null, void 0, i(982141)),
            flag: "belgium",
            group: "Europe",
            country: "be",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(795521))]
        }, {
            value: "EURONEXTLIS",
            name: "EURONEXTLIS",
            desc: i.i18next(null, void 0, i(138631)),
            flag: "portugal",
            group: "Europe",
            country: "pt",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(958902))]
        }, {
            value: "EURONEXTPAR",
            name: "EURONEXTPAR",
            desc: i.i18next(null, void 0, i(596269)),
            flag: "france",
            group: "Europe",
            country: "fr",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(891160))]
        }, {
            value: "OSL",
            name: "EURONEXTOSE",
            desc: i.i18next(null, void 0, i(742391)),
            flag: "norway",
            group: "Europe",
            country: "no",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(723309))]
        }, {
            value: "EUROTLX",
            name: "EUROTLX",
            desc: i.i18next(null, void 0, i(522546)),
            flag: "italy",
            group: "Europe",
            country: "it",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(35146))]
        }, {
            value: "OMX",
            name: "OMX",
            desc: i.i18next(null, void 0, i(785340)),
            flag: "europe",
            group: "Europe",
            country: "eu",
            providerId: ""
        }, {
            value: "FWB",
            name: "FWB",
            desc: i.i18next(null, void 0, i(649952)),
            flag: "germany",
            group: "Europe",
            country: "de",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(403447))]
        }, {
            value: "FRA",
            name: "FRA",
            desc: i.i18next(null, void 0, i(99036)),
            flag: "germany",
            hideInSymbolSearch: !0,
            group: "Europe",
            country: "de",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(403447))]
        }, {
            value: "SWB",
            name: "SWB",
            desc: i.i18next(null, void 0, i(698575)),
            flag: "germany",
            group: "Europe",
            country: "de",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(403447))]
        }, {
            value: "XETR",
            name: "XETR",
            desc: i.i18next(null, void 0, i(120304)),
            flag: "germany",
            group: "Europe",
            country: "de",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(403447))]
        }, {
            value: "BME",
            name: "BME",
            desc: i.i18next(null, void 0, i(66074)),
            flag: "spain",
            group: "Europe",
            country: "es",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(174897))]
        }, {
            value: "BSSE",
            name: "BSSE",
            desc: i.i18next(null, void 0, i(312536)),
            flag: "slovakia",
            group: "Europe",
            country: "sk",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(742494))]
        }, {
            value: "BVB",
            name: "BVB",
            desc: i.i18next(null, void 0, i(339762)),
            flag: "romania",
            group: "Europe",
            country: "ro",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(700102))]
        }, {
            value: "BET",
            name: "BET",
            desc: i.i18next(null, void 0, i(192321)),
            flag: "hungary",
            group: "Europe",
            country: "hu",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(893317))]
        }, {
            value: "GPW",
            name: "GPW",
            desc: i.i18next(null, void 0, i(494151)),
            flag: "poland",
            group: "Europe",
            country: "pl",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(15112))]
        }, {
            value: "NEWCONNECT",
            name: "GPW — NewConnect",
            desc: i.i18next(null, void 0, i(339484)),
            flag: "poland",
            group: "Europe",
            country: "pl",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(15112))]
        }, {
            value: "LUXSE",
            name: "LUXSE",
            desc: i.i18next(null, void 0, i(981337)),
            flag: "luxembourg",
            group: "Europe",
            country: "lu",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(681038))]
        }, {
            value: "MIL",
            name: "MIL",
            desc: i.i18next(null, void 0, i(707917)),
            flag: "italy",
            group: "Europe",
            country: "it",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(35146))]
        }, {
            value: "NGM",
            name: "NGM",
            desc: i.i18next(null, void 0, i(242150)),
            flag: "sweden",
            group: "Europe",
            country: "se",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(73412))]
        }, {
            value: "BER",
            name: "BER",
            desc: i.i18next(null, void 0, i(404185)),
            flag: "germany",
            group: "Europe",
            country: "de",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(403447))]
        }, {
            value: "DUS",
            name: "DUS",
            desc: i.i18next(null, void 0, i(605654)),
            flag: "germany",
            group: "Europe",
            country: "de",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(403447))]
        }, {
            value: "HAM",
            name: "HAM",
            desc: i.i18next(null, void 0, i(10867)),
            flag: "germany",
            group: "Europe",
            country: "de",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(403447))]
        }, {
            value: "HAN",
            name: "HAN",
            desc: i.i18next(null, void 0, i(788921)),
            flag: "germany",
            group: "Europe",
            country: "de",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(403447))]
        }, {
            value: "MUN",
            name: "MUN",
            desc: i.i18next(null, void 0, i(491213)),
            flag: "germany",
            group: "Europe",
            country: "de",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(403447))]
        }, {
            value: "TRADEGATE",
            name: "TRADEGATE",
            desc: i.i18next(null, void 0, i(367542)),
            flag: "germany",
            group: "Europe",
            country: "de",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(403447))]
        }, {
            value: "GETTEX",
            name: "GETTEX",
            desc: i.i18next(null, void 0, i(410624)),
            flag: "germany",
            group: "Europe",
            country: "de",
            providerId: "finanzen",
            searchTerms: [i.i18next(null, void 0, i(403447))]
        }, {
            value: "MILSEDEX",
            name: "MILSEDEX",
            desc: i.i18next(null, void 0, i(533977)),
            flag: "italy",
            group: "Europe",
            hideInSymbolSearch: !0,
            country: "it",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(35146))]
        }, {
            value: "IST",
            name: "IST",
            desc: i.i18next(null, void 0, i(835045)),
            flag: "turkey",
            hideInSymbolSearch: !0,
            group: "Europe",
            country: "tr",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(929826))]
        }, {
            value: "BIST",
            name: "BIST",
            desc: i.i18next(null, void 0, i(399366)),
            flag: "turkey",
            group: "Europe",
            country: "tr",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(929826))]
        }, {
            value: "TASE",
            name: "TASE",
            desc: i.i18next(null, void 0, i(292877)),
            flag: "israel",
            group: "Middle East / Africa",
            country: "il",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(368291))]
        }, {
            value: "SIX",
            name: "SIX",
            desc: i.i18next(null, void 0, i(706275)),
            flag: "switzerland",
            group: "Europe",
            country: "ch",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(508058))]
        }, {
            value: "BX",
            name: "BX",
            desc: i.i18next(null, void 0, i(643856)),
            flag: "switzerland",
            group: "Europe",
            country: "ch",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(508058))]
        }, {
            value: "PSECZ",
            name: "PSE",
            desc: i.i18next(null, void 0, i(267449)),
            flag: "czech",
            group: "Europe",
            country: "cz",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(728962))]
        }, {
            value: "ASX",
            name: "ASX",
            desc: i.i18next(null, void 0, i(560392)),
            flag: "australia",
            group: "Asia / Pacific",
            country: "au",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(722157))]
        }, {
            value: "CHIXAU",
            name: "Cboe Australia",
            desc: i.i18next(null, void 0, i(896235)),
            flag: "australia",
            group: "Asia / Pacific",
            country: "au",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(722157))]
        }, {
            value: "VIE",
            name: "WB",
            desc: i.i18next(null, void 0, i(644040)),
            flag: "austria",
            group: "Europe",
            country: "at",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(696600))]
        }, {
            value: "DSEBD",
            name: "DSE",
            desc: i.i18next(null, void 0, i(402001)),
            flag: "bangladesh",
            group: "Asia / Pacific",
            country: "bd",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(225040))]
        }, {
            value: "NZX",
            name: "NZX",
            desc: i.i18next(null, void 0, i(157054)),
            flag: "new_zealand",
            group: "Asia / Pacific",
            country: "nz",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(866103))]
        }, {
            value: "SSE",
            name: "SSE",
            desc: i.i18next(null, void 0, i(66599)),
            flag: "china",
            group: "Asia / Pacific",
            country: "cn",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(133470))]
        }, {
            value: "SHFE",
            name: "SHFE",
            desc: i.i18next(null, void 0, i(562969)),
            flag: "china",
            group: "Asia / Pacific",
            country: "cn",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(133470))]
        }, {
            value: "SZSE",
            name: "SZSE",
            desc: i.i18next(null, void 0, i(50361)),
            flag: "china",
            group: "Asia / Pacific",
            country: "cn",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(133470))]
        }, {
            value: "ZCE",
            name: "ZCE",
            desc: i.i18next(null, void 0, i(36074)),
            flag: "china",
            group: "Asia / Pacific",
            country: "cn",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(133470))]
        }, {
            value: "HKEX",
            name: "HKEX",
            desc: i.i18next(null, void 0, i(111355)),
            flag: "hong_kong",
            group: "Asia / Pacific",
            country: "hk",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(248861))]
        }, {
            value: "PSE",
            name: "PSE",
            desc: i.i18next(null, void 0, i(842444)),
            flag: "philippines",
            group: "Asia / Pacific",
            country: "ph",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(728919))]
        }, {
            value: "PSX",
            name: "PSX",
            desc: i.i18next(null, void 0, i(225977)),
            flag: "pakistan",
            group: "Asia / Pacific",
            country: "pk",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(917892))]
        }, {
            value: "NSENG",
            name: "NSE",
            desc: i.i18next(null, void 0, i(929818)),
            flag: "nigeria",
            group: "Middle East / Africa",
            country: "ng",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(591520))]
        }, {
            value: "NSEKE",
            name: "NSE",
            desc: i.i18next(null, void 0, i(925499)),
            flag: "kenya",
            group: "Middle East / Africa",
            country: "ke",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(981233))]
        }, {
            value: "JSE",
            name: "JSE",
            desc: i.i18next(null, void 0, i(547946)),
            flag: "south_africa",
            group: "Middle East / Africa",
            country: "za",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(663647))]
        }, {
            value: "JFX",
            name: "JFX",
            desc: i.i18next(null, void 0, i(621448)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "jfx"
        }, {
            value: "COINBASE",
            name: "Coinbase",
            desc: i.i18next(null, void 0, i(171533)),
            flag: "bitcoin",
            group: "Cryptocurrency",
            country: "",
            providerId: "coinbase"
        }, {
            value: "CITYINDEX",
            name: "City Index",
            desc: i.i18next(null, void 0, i(900322)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "cityindex"
        }, {
            value: "USI",
            name: "USI",
            desc: i.i18next(null, void 0, i(913682)),
            flag: "usa",
            hideInSymbolSearch: !0,
            group: "North America",
            country: "us",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "OMXHEX",
            name: "HEX",
            desc: i.i18next(null, void 0, i(239593)),
            flag: "finland",
            group: "Europe",
            country: "fi",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(223442))]
        }, {
            value: "OMXICE",
            name: "ICEX",
            desc: i.i18next(null, void 0, i(45362)),
            flag: "iceland",
            group: "Europe",
            country: "is",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(217499))]
        }, {
            value: "OMXCOP",
            name: "CSE",
            desc: i.i18next(null, void 0, i(262384)),
            flag: "denmark",
            group: "Europe",
            country: "dk",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(877527))]
        }, {
            value: "OMXSTO",
            name: "STO",
            desc: i.i18next(null, void 0, i(161712)),
            flag: "sweden",
            group: "Europe",
            country: "se",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(73412))]
        }, {
            value: "OMXVSE",
            name: "VSE",
            desc: i.i18next(null, void 0, i(585254)),
            flag: "lithuania",
            group: "Europe",
            country: "lt",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(868380))]
        }, {
            value: "OMXTSE",
            name: "TALSE",
            desc: i.i18next(null, void 0, i(227465)),
            flag: "estonia",
            group: "Europe",
            country: "ee",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(714153))]
        }, {
            value: "OMXRSE",
            name: "OMXR",
            desc: i.i18next(null, void 0, i(280534)),
            flag: "latvia",
            group: "Europe",
            country: "lv",
            providerId: "",
            searchTerms: [i.i18next(null, void 0, i(262063))]
        }, {
            value: "OMXNORDIC",
            name: "OMXNORDIC",
            desc: i.i18next(null, void 0, i(736331)),
            flag: "europe",
            hideInSymbolSearch: !0,
            group: "Europe",
            country: "eu",
            providerId: ""
        }, {
            value: "OMXBALTIC",
            name: "OMXBALTIC",
            desc: i.i18next(null, void 0, i(284173)),
            flag: "europe",
            hideInSymbolSearch: !0,
            group: "Europe",
            country: "eu",
            providerId: ""
        }, {
            value: "FRED",
            name: "FRED",
            desc: i.i18next(null, void 0, i(533754)),
            flag: "usa",
            group: "Economy",
            country: "",
            providerId: "fred2",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "ISM",
            name: "ISM",
            desc: i.i18next(null, void 0, i(716678)),
            flag: "usa",
            group: "Economy",
            country: "",
            providerId: "quandl_ism",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "FRBNY",
            name: "FRBNY",
            desc: i.i18next(null, void 0, i(636850)),
            flag: "usa",
            group: "Economy",
            country: "",
            providerId: "quandl_frbny",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "FRBP",
            name: "FRBP",
            desc: i.i18next(null, void 0, i(936560)),
            flag: "usa",
            group: "Economy",
            country: "",
            providerId: "quandl_frbp",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "ECONOMICS",
            name: "Trading Economics",
            desc: i.i18next(null, void 0, i(863968)),
            flag: "usa",
            group: "Economy",
            country: "",
            providerId: "economics",
            searchTerms: [i.i18next(null, void 0, i(232240)), i.i18next(null, void 0, i(836986))]
        }, {
            value: "WHSELFINVEST",
            name: "WH SelfInvest",
            desc: i.i18next(null, void 0, i(24172)),
            flag: "forex",
            group: "Forex",
            country: "",
            providerId: "whselfinvest"
        }]
    }
    ,
    263844: e=>{
        e.exports = {
            chartsSplitter: "chartsSplitter-L0xapso5",
            hovered: "hovered-L0xapso5",
            "i-active": "i-active-L0xapso5"
        }
    }
    ,
    945982: e=>{
        e.exports = {
            "css-value-pane-controls-padding-left": "1px",
            "css-value-pane-controls-padding-right": "4px"
        }
    }
    ,
    656479: e=>{
        e.exports = {
            paneSeparator: "paneSeparator-uqBaC1Ki",
            handle: "handle-uqBaC1Ki",
            hovered: "hovered-uqBaC1Ki",
            active: "active-uqBaC1Ki"
        }
    }
    ,
    858994: e=>{
        e.exports = {
            "css-value-small-size": "18px",
            "css-value-medium-size": "22px",
            "css-value-large-size": "28px",
            "css-value-border-radius-small-size": "9px",
            "css-value-border-radius-medium-size": "11px",
            "css-value-border-radius-large-size": "8px",
            statuses: "statuses-Lgtz1OtS",
            statusItem: "statusItem-Lgtz1OtS",
            statuses_hidden: "statuses_hidden-Lgtz1OtS",
            small: "small-Lgtz1OtS",
            medium: "medium-Lgtz1OtS",
            large: "large-Lgtz1OtS",
            blinking: "blinking-Lgtz1OtS",
            "blinking-animation": "blinking-animation-Lgtz1OtS",
            marketStatusOpen: "marketStatusOpen-Lgtz1OtS",
            marketStatusClose: "marketStatusClose-Lgtz1OtS",
            marketStatusPre: "marketStatusPre-Lgtz1OtS",
            marketStatusPost: "marketStatusPost-Lgtz1OtS",
            marketStatusHoliday: "marketStatusHoliday-Lgtz1OtS",
            marketStatusDelisted: "marketStatusDelisted-Lgtz1OtS",
            marketStatusExpired: "marketStatusExpired-Lgtz1OtS",
            marketStatusCustom: "marketStatusCustom-Lgtz1OtS",
            invalidSymbol: "invalidSymbol-Lgtz1OtS",
            replayModeAutoPlay: "replayModeAutoPlay-Lgtz1OtS",
            replayModePause: "replayModePause-Lgtz1OtS",
            replayModePointSelect: "replayModePointSelect-Lgtz1OtS",
            "blinking-animation-custom": "blinking-animation-custom-Lgtz1OtS",
            notAccurate: "notAccurate-Lgtz1OtS",
            openedInPineEditor: "openedInPineEditor-Lgtz1OtS",
            openedInDetachedPineEditor: "openedInDetachedPineEditor-Lgtz1OtS",
            delay: "delay-Lgtz1OtS",
            eod: "eod-Lgtz1OtS",
            tvCalculatedPair: "tvCalculatedPair-Lgtz1OtS",
            dataProblemHigh: "dataProblemHigh-Lgtz1OtS",
            dataProblemLow: "dataProblemLow-Lgtz1OtS",
            updateAvailable: "updateAvailable-Lgtz1OtS"
        }
    }
    ,
    242238: (e,t,i)=>{
        "use strict";
        i.d(t, {
            ChartSession: ()=>n
        });
        var s = i(942634)
          , o = i(607016);
        class n extends o.Session {
            constructor(e, t=!1) {
                super(e, "cs", !1),
                this._sessionDisabled = !1,
                this._handler = null,
                this._criticalError = new s.Delegate,
                this._symbolResolveMap = new Map,
                this._lastSymbolResolveInfoMap = new Map,
                this._disableStatistics = t
            }
            destroy() {
                this._criticalError.destroy(),
                this._handler = null,
                this._symbolResolveMap.clear(),
                super.destroy()
            }
            switchTimezone(e) {
                return this._getChartApi().switchTimezone(this.sessionId(), e)
            }
            defaultResolutions() {
                return this._getChartApi().defaultResolutions()
            }
            availableCurrencies() {
                return this._getChartApi().availableCurrencies()
            }
            availableUnits() {
                return this._getChartApi().availableUnits()
            }
            availablePriceSources(e) {
                return this._getChartApi().availablePriceSources(e)
            }
            resolveSymbol(e, t, i) {
                if (this._symbolResolveMap.has(t)) {
                    const [e,s] = this._symbolResolveMap.get(t);
                    return Array.isArray(s) ? s.push(i) : s.then(i),
                    e
                }
                {
                    const s = [i];
                    return this._getChartApi().resolveSymbol(this.sessionId(), e, t, (i=>{
                        if ("symbol_error" === i.method)
                            this._symbolResolveMap.delete(t);
                        else {
                            this._symbolResolveMap.set(t, [e, Promise.resolve(i)]);
                            const [,s] = i.params
                              , o = {
                                pro_name: s.pro_name,
                                ticker: s.ticker
                            };
                            this._lastSymbolResolveInfoMap.set(t, o),
                            o.pro_name && this._lastSymbolResolveInfoMap.set(o.pro_name, o),
                            s.full_name && this._lastSymbolResolveInfoMap.set(s.full_name, o),
                            o.ticker && this._lastSymbolResolveInfoMap.set(o.ticker, o)
                        }
                        s.forEach((e=>e(i)))
                    }
                    )),
                    this._symbolResolveMap.set(t, [e, s]),
                    e
                }
            }
            requestFirstBarTime(e, t, i) {
                return this._getChartApi().requestFirstBarTime(this.sessionId(), e, t, i)
            }
            lastSymbolResolveInfo(e) {
                var t;
                return null !== (t = this._lastSymbolResolveInfoMap.get(e)) && void 0 !== t ? t : null
            }
            createSeries(e, t, i, s, o, n, r) {
                return this._getChartApi().createSeries(this.sessionId(), e, t, i, s, o, n, r)
            }
            modifySeries(e, t, i, s, o, n, r) {
                return this._getChartApi().modifySeries(this.sessionId(), e, t, i, s, o, n, r)
            }
            removeSeries(e) {
                return !!this.isConnected().value() && this._getChartApi().removeSeries(this.sessionId(), e)
            }
            requestMoreData(e, t, i) {
                return "number" == typeof e ? this._getChartApi().requestMoreData(this.sessionId(), e) : this._getChartApi().requestMoreData(this.sessionId(), e, t, i)
            }
            requestMoreTickmarks(e, t, i) {
                return this._getChartApi().requestMoreTickmarks(this.sessionId(), e, t, i)
            }
            setFutureTickmarksMode(e) {
                return this._getChartApi().setFutureTickmarksMode(this.sessionId(), e)
            }
            canCreateStudy(e, t) {
                return this._getChartApi().canCreateStudy(this.sessionId(), e, t)
            }
            getStudyCounter() {
                return this._getChartApi().getStudyCounter(this.sessionId())
            }
            getFundamentalCounter() {
                return this._getChartApi().getFundamentalCounter(this.sessionId())
            }
            createStudy(e, t, i, s, o, n, r) {
                return this._getChartApi().createStudy(this.sessionId(), e, t, i, s, o, n, r)
            }
            modifyStudy(e, t, i, s, o) {
                return this._getChartApi().modifyStudy(this.sessionId(), e, t, i, s, o)
            }
            notifyStudy(e, t, i) {
                return this._getChartApi().notifyStudy(this.sessionId(), e, t, i)
            }
            removeStudy(e) {
                return this._getChartApi().removeStudy(this.sessionId(), e)
            }
            createPointset(e, t, i, s, o, n) {
                return this._getChartApi().createPointset(this.sessionId(), e, t, i, s, o, n)
            }
            modifyPointset(e, t, i, s) {
                return this._getChartApi().modifyPointset(this.sessionId(), e, t, i, s)
            }
            removePointset(e) {
                return this._getChartApi().removePointset(this.sessionId(), e)
            }
            setVisibleTimeRange(e, t, i, s, o, n) {
                0
            }
            criticalError() {
                return this._criticalError
            }
            connect(e=null) {
                null !== e && (this._handler = e),
                this._symbolResolveMap.clear(),
                super.connect()
            }
            setHandler(e) {
                this._handler = e
            }
            connected() {
                return this.isConnected().value() && !this._sessionDisabled
            }
            disable() {
                this._sessionDisabled = !0
            }
            chartApi() {
                return this._getChartApi()
            }
            _sendCreateSession() {
                Object.keys(this).forEach((e=>{
                    /^(s|st|symbol_)\d+$/.test(e) && delete this[e]
                }
                )),
                this._getChartApi().chartCreateSession(this.sessionId(), this._disableStatistics)
            }
            _sendRemoveSession() {
                this._getChartApi().chartDeleteSession(this.sessionId())
            }
            _onMessage(e) {
                this._handler && this._handler(e)
            }
            _onCriticalError(e, t) {
                this._criticalError.fire(e, t),
                super._onCriticalError(e, t)
            }
        }
    }
    ,
    430777: (e,t,i)=>{
        "use strict";
        i.d(t, {
            availableTimezones: ()=>n,
            timezoneIsAvailable: ()=>l,
            timezoneTitle: ()=>c
        });
        var s = i(601526)
          , o = i(499625);
        const n = (0,
        o.getAvailableTimezones)()
          , r = new Map;
        n.forEach((e=>{
            r.set(e.id, !0)
        }
        ));
        const a = new Map;
        o.specialTimezones.concat(o.customTimezones).forEach((e=>{
            a.set(e.id, !0)
        }
        ));
        function l(e) {
            return r.has(e)
        }
        function c(e) {
            for (const {id: t, title: i} of o.customTimezones)
                if (t === e) {
                    return `${i} (${(0,
                    s.parseTzOffset)(e).string})`
                }
            for (const {id: t, title: i} of n)
                if (t === e)
                    return `${i}`;
            return e
        }
    }
    ,
    67326: (e,t,i)=>{
        "use strict";
        function s(e) {
            return "economic" === e
        }
        i.d(t, {
            isNonTradableSymbolType: ()=>s
        })
    }
    ,
    601526: (e,t,i)=>{
        "use strict";
        i.d(t, {
            parseTzOffset: ()=>o
        });
        var s = i(870045);
        function o(e, t=Date.now()) {
            const i = (0,
            s.get_timezone)(e).offset_utc(t);
            let o = "";
            const n = i / 1e3 / 60 / 60;
            n % 1 && (o = ":" + Math.round(Math.abs(n % 1 * 60)).toString().padStart(2, "0"));
            let r = "";
            return r = n > 0 ? "+" + (n - n % 1) + o : 0 === n ? "" : String(n - n % 1 + o),
            {
                offset: i,
                string: "UTC" + r
            }
        }
    }
    ,
    499625: (e,t,i)=>{
        "use strict";
        i.d(t, {
            customTimezones: ()=>r,
            getAvailableTimezones: ()=>l,
            specialTimezones: ()=>n
        });
        var s = i(444372)
          , o = i(601526);
        const n = [{
            id: "Etc/UTC",
            get title() {
                return s.t(null, void 0, i(901833))
            }
        }, {
            id: "exchange",
            get title() {
                return s.t(null, void 0, i(786905))
            }
        }]
          , r = [{
            id: "Africa/Cairo",
            get title() {
                return s.t(null, void 0, i(365736))
            },
            offset: 0
        }, {
            id: "Africa/Casablanca",
            get title() {
                return s.t(null, void 0, i(770409))
            },
            offset: 0
        }, {
            id: "Africa/Johannesburg",
            get title() {
                return s.t(null, void 0, i(239585))
            },
            offset: 0
        }, {
            id: "Africa/Lagos",
            get title() {
                return s.t(null, void 0, i(919931))
            },
            offset: 0
        }, {
            id: "Africa/Nairobi",
            get title() {
                return s.t(null, void 0, i(740977))
            },
            offset: 0
        }, {
            id: "Africa/Tunis",
            get title() {
                return s.t(null, void 0, i(21007))
            },
            offset: 0
        }, {
            id: "America/Anchorage",
            get title() {
                return s.t(null, void 0, i(942630))
            },
            offset: 0
        }, {
            id: "America/Argentina/Buenos_Aires",
            get title() {
                return s.t(null, void 0, i(325282))
            },
            offset: 0
        }, {
            id: "America/Bogota",
            get title() {
                return s.t(null, void 0, i(273905))
            },
            offset: 0
        }, {
            id: "America/Caracas",
            get title() {
                return s.t(null, void 0, i(930948))
            },
            offset: 0
        }, {
            id: "America/Chicago",
            get title() {
                return s.t(null, void 0, i(72452))
            },
            offset: 0
        }, {
            id: "America/El_Salvador",
            get title() {
                return s.t(null, void 0, i(255502))
            },
            offset: 0
        }, {
            id: "America/Juneau",
            get title() {
                return s.t(null, void 0, i(367560))
            },
            offset: 0
        }, {
            id: "America/Lima",
            get title() {
                return s.t(null, void 0, i(759444))
            },
            offset: 0
        }, {
            id: "America/Los_Angeles",
            get title() {
                return s.t(null, void 0, i(28733))
            },
            offset: 0
        }, {
            id: "America/Mexico_City",
            get title() {
                return s.t(null, void 0, i(773332))
            },
            offset: 0
        }, {
            id: "America/New_York",
            get title() {
                return s.t(null, void 0, i(940544))
            },
            offset: 0
        }, {
            id: "America/Phoenix",
            get title() {
                return s.t(null, void 0, i(114055))
            },
            offset: 0
        }, {
            id: "America/Santiago",
            get title() {
                return s.t(null, void 0, i(630231))
            },
            offset: 0
        }, {
            id: "America/Sao_Paulo",
            get title() {
                return s.t(null, void 0, i(991912))
            },
            offset: 0
        }, {
            id: "America/Toronto",
            get title() {
                return s.t(null, void 0, i(110095))
            },
            offset: 0
        }, {
            id: "America/Vancouver",
            get title() {
                return s.t(null, void 0, i(632838))
            },
            offset: 0
        }, {
            id: "US/Mountain",
            get title() {
                return s.t(null, void 0, i(327358))
            },
            offset: 0
        }, {
            id: "Asia/Almaty",
            get title() {
                return s.t(null, void 0, i(398128))
            },
            offset: 0
        }, {
            id: "Asia/Ashkhabad",
            get title() {
                return s.t(null, void 0, i(763627))
            },
            offset: 0
        }, {
            id: "Asia/Bahrain",
            get title() {
                return s.t(null, void 0, i(290594))
            },
            offset: 0
        }, {
            id: "Asia/Bangkok",
            get title() {
                return s.t(null, void 0, i(947045))
            },
            offset: 0
        }, {
            id: "Asia/Chongqing",
            get title() {
                return s.t(null, void 0, i(850349))
            },
            offset: 0
        }, {
            id: "Asia/Colombo",
            get title() {
                return s.t(null, void 0, i(10871))
            },
            offset: 0
        }, {
            id: "Asia/Dhaka",
            get title() {
                return s.t(null, void 0, i(724959))
            },
            offset: 0
        }, {
            id: "Asia/Dubai",
            get title() {
                return s.t(null, void 0, i(523650))
            },
            offset: 0
        }, {
            id: "Asia/Ho_Chi_Minh",
            get title() {
                return s.t(null, void 0, i(334491))
            },
            offset: 0
        }, {
            id: "Asia/Hong_Kong",
            get title() {
                return s.t(null, void 0, i(248861))
            },
            offset: 0
        }, {
            id: "Asia/Jakarta",
            get title() {
                return s.t(null, void 0, i(414995))
            },
            offset: 0
        }, {
            id: "Asia/Jerusalem",
            get title() {
                return s.t(null, void 0, i(436057))
            },
            offset: 0
        }, {
            id: "Asia/Karachi",
            get title() {
                return s.t(null, void 0, i(70913))
            },
            offset: 0
        }, {
            id: "Asia/Kathmandu",
            get title() {
                return s.t(null, void 0, i(454533))
            },
            offset: 0
        }, {
            id: "Asia/Kolkata",
            get title() {
                return s.t(null, void 0, i(31561))
            },
            offset: 0
        }, {
            id: "Asia/Kuala_Lumpur",
            get title() {
                return s.t(null, void 0, i(538561))
            },
            offset: 0
        }, {
            id: "Asia/Kuwait",
            get title() {
                return s.t(null, void 0, i(76614))
            },
            offset: 0
        }, {
            id: "Asia/Manila",
            get title() {
                return s.t(null, void 0, i(348991))
            },
            offset: 0
        }, {
            id: "Asia/Muscat",
            get title() {
                return s.t(null, void 0, i(909865))
            },
            offset: 0
        }, {
            id: "Asia/Nicosia",
            get title() {
                return s.t(null, void 0, i(94600))
            },
            offset: 0
        }, {
            id: "Asia/Qatar",
            get title() {
                return s.t(null, void 0, i(328756))
            },
            offset: 0
        }, {
            id: "Asia/Riyadh",
            get title() {
                return s.t(null, void 0, i(837974))
            },
            offset: 0
        }, {
            id: "Asia/Seoul",
            get title() {
                return s.t(null, void 0, i(326820))
            },
            offset: 0
        }, {
            id: "Asia/Shanghai",
            get title() {
                return s.t(null, void 0, i(601852))
            },
            offset: 0
        }, {
            id: "Asia/Singapore",
            get title() {
                return s.t(null, void 0, i(977377))
            },
            offset: 0
        }, {
            id: "Asia/Taipei",
            get title() {
                return s.t(null, void 0, i(511034))
            },
            offset: 0
        }, {
            id: "Asia/Tehran",
            get title() {
                return s.t(null, void 0, i(806686))
            },
            offset: 0
        }, {
            id: "Asia/Tokyo",
            get title() {
                return s.t(null, void 0, i(769122))
            },
            offset: 0
        }, {
            id: "Asia/Yangon",
            get title() {
                return s.t(null, void 0, i(553168))
            },
            offset: 0
        }, {
            id: "Atlantic/Reykjavik",
            get title() {
                return s.t(null, void 0, i(813386))
            },
            offset: 0
        }, {
            id: "Australia/Adelaide",
            get title() {
                return s.t(null, void 0, i(437265))
            },
            offset: 0
        }, {
            id: "Australia/Brisbane",
            get title() {
                return s.t(null, void 0, i(579336))
            },
            offset: 0
        }, {
            id: "Australia/Perth",
            get title() {
                return s.t(null, void 0, i(724436))
            },
            offset: 0
        }, {
            id: "Australia/Sydney",
            get title() {
                return s.t(null, void 0, i(531622))
            },
            offset: 0
        }, {
            id: "Europe/Amsterdam",
            get title() {
                return s.t(null, void 0, i(936485))
            },
            offset: 0
        }, {
            id: "Europe/Athens",
            get title() {
                return s.t(null, void 0, i(373702))
            },
            offset: 0
        }, {
            id: "Europe/Belgrade",
            get title() {
                return s.t(null, void 0, i(271797))
            },
            offset: 0
        }, {
            id: "Europe/Berlin",
            get title() {
                return s.t(null, void 0, i(764313))
            },
            offset: 0
        }, {
            id: "Europe/Bratislava",
            get title() {
                return s.t(null, void 0, i(270876))
            },
            offset: 0
        }, {
            id: "Europe/Brussels",
            get title() {
                return s.t(null, void 0, i(991499))
            },
            offset: 0
        }, {
            id: "Europe/Bucharest",
            get title() {
                return s.t(null, void 0, i(633672))
            },
            offset: 0
        }, {
            id: "Europe/Budapest",
            get title() {
                return s.t(null, void 0, i(20313))
            },
            offset: 0
        }, {
            id: "Europe/Copenhagen",
            get title() {
                return s.t(null, void 0, i(538917))
            },
            offset: 0
        }, {
            id: "Europe/Dublin",
            get title() {
                return s.t(null, void 0, i(479716))
            },
            offset: 0
        }, {
            id: "Europe/Helsinki",
            get title() {
                return s.t(null, void 0, i(348203))
            },
            offset: 0
        }, {
            id: "Europe/Istanbul",
            get title() {
                return s.t(null, void 0, i(478326))
            },
            offset: 0
        }, {
            id: "Europe/Lisbon",
            get title() {
                return s.t(null, void 0, i(53375))
            },
            offset: 0
        }, {
            id: "Europe/London",
            get title() {
                return s.t(null, void 0, i(119439))
            },
            offset: 0
        }, {
            id: "Europe/Luxembourg",
            get title() {
                return s.t(null, void 0, i(681038))
            },
            offset: 0
        }, {
            id: "Europe/Madrid",
            get title() {
                return s.t(null, void 0, i(52066))
            },
            offset: 0
        }, {
            id: "Europe/Malta",
            get title() {
                return s.t(null, void 0, i(638365))
            },
            offset: 0
        }, {
            id: "Europe/Moscow",
            get title() {
                return s.t(null, void 0, i(564039))
            },
            offset: 0
        }, {
            id: "Europe/Oslo",
            get title() {
                return s.t(null, void 0, i(375722))
            },
            offset: 0
        }, {
            id: "Europe/Paris",
            get title() {
                return s.t(null, void 0, i(161879))
            },
            offset: 0
        }, {
            id: "Europe/Prague",
            get title() {
                return s.t(null, void 0, i(81248))
            },
            offset: 0
        }, {
            id: "Europe/Riga",
            get title() {
                return s.t(null, void 0, i(594022))
            },
            offset: 0
        }, {
            id: "Europe/Rome",
            get title() {
                return s.t(null, void 0, i(152961))
            },
            offset: 0
        }, {
            id: "Europe/Stockholm",
            get title() {
                return s.t(null, void 0, i(86716))
            },
            offset: 0
        }, {
            id: "Europe/Tallinn",
            get title() {
                return s.t(null, void 0, i(779995))
            },
            offset: 0
        }, {
            id: "Europe/Vienna",
            get title() {
                return s.t(null, void 0, i(23160))
            },
            offset: 0
        }, {
            id: "Europe/Vilnius",
            get title() {
                return s.t(null, void 0, i(960534))
            },
            offset: 0
        }, {
            id: "Europe/Warsaw",
            get title() {
                return s.t(null, void 0, i(505959))
            },
            offset: 0
        }, {
            id: "Europe/Zurich",
            get title() {
                return s.t(null, void 0, i(362859))
            },
            offset: 0
        }, {
            id: "Pacific/Auckland",
            get title() {
                return s.t(null, void 0, i(866103))
            },
            offset: 0
        }, {
            id: "Pacific/Chatham",
            get title() {
                return s.t(null, void 0, i(36549))
            },
            offset: 0
        }, {
            id: "Pacific/Fakaofo",
            get title() {
                return s.t(null, void 0, i(298549))
            },
            offset: 0
        }, {
            id: "Pacific/Honolulu",
            get title() {
                return s.t(null, void 0, i(879668))
            },
            offset: 0
        }, {
            id: "Pacific/Norfolk",
            get title() {
                return s.t(null, void 0, i(467891))
            },
            offset: 0
        }];
        function a(e, t, i) {
            const s = function(e) {
                return e.map((e=>{
                    const {id: t} = e
                      , {string: i, offset: s} = (0,
                    o.parseTzOffset)(t);
                    return {
                        id: t,
                        offset: s,
                        get title() {
                            return `(${i}) ${e.title}`
                        }
                    }
                }
                ))
            }(e)
              , n = i.filter((({alias: e})=>Boolean(e))).map((e=>{
                const {alias: t, id: i} = e
                  , {string: s, offset: n} = (0,
                o.parseTzOffset)(t);
                return {
                    id: i,
                    offset: n,
                    get title() {
                        return `(${s}) ${e.title}`
                    },
                    alias: t
                }
            }
            ))
              , r = function(e) {
                return e.sort(((e,t)=>{
                    const i = e.offset - t.offset;
                    return 0 !== i ? i : e.title.localeCompare(t.title)
                }
                ))
            }(s.concat(n));
            return t.concat(r)
        }
        function l() {
            return a(r, n, [])
        }
    }
    ,
    314824: (e,t,i)=>{
        "use strict";
        i.d(t, {
            ActionWithStandardIcon: ()=>n
        });
        var s = i(691371)
          , o = i(18343);
        class n extends s.Action {
            constructor(e) {
                var t, i;
                const {options: s, customActionOptions: n} = e;
                s.iconId && (s.icon = null !== (t = s.icon) && void 0 !== t ? t : o.icons.get(s.iconId)),
                n && n.iconId && (n.icon = null !== (i = n.icon) && void 0 !== i ? i : o.icons.get(n.iconId)),
                super(e)
            }
        }
    }
    ,
    18343: (e,t,i)=>{
        "use strict";
        i.d(t, {
            icons: ()=>k
        });
        var s = i(539706)
          , o = i(472382)
          , n = i(198083)
          , r = i(80465)
          , a = i(748040)
          , l = i(324020)
          , c = i(845437)
          , d = i(428026)
          , u = i(625923)
          , h = i(270068)
          , p = i(789795)
          , m = i(439970)
          , g = i(808757)
          , _ = i(133736)
          , v = i(634369)
          , S = i(139267)
          , f = i(993544)
          , b = i(484959)
          , y = i(437924)
          , C = i(677067)
          , w = i(416911)
          , T = i(225191)
          , P = i(854190)
          , x = i(706862)
          , M = i(397874)
          , I = i(902872)
          , A = i(201457)
          , L = i(593379);
        let E = [["Chart.Reset", S], ["Chart.RemoveSelectedObject", f], ["Settings", v], ["Chart.Hide", b], ["Chart.SymbolInfo", y], ["Chart.VisualOrder", C], ["Chart.ShowObject", w], ["Chart.PriceScale", T], ["Chart.Move", P], ["Chart.ApplyIndicator", x], ["Chart.UnlockObject", M], ["Chart.LockObject", I], ["Chart.Clone", A], ["Chart.AddHorzLine", L]];
        E = E.concat([["TextNote.Add", l], ["Watchlist.AddSymbol", c], ["Watchlist.CreateNew", c], ["Chart.Financials", d], ["Alert.Add", u], ["Alert.Edit", h], ["Alert.Restart", p], ["Alert.Stop", m], ["Alert.EventsExport", g], ["Alert.Clear", _]]),
        E = E.concat([["Chart.ShowDataWindow", s], ["Trading.Sell", o], ["Trading.Buy", n], ["ObjectsTree.CreateGroup", r], ["ObjectsTree.RenameItem", a]]);
        const k = new Map(E)
    }
    ,
    706847: (e,t,i)=>{
        "use strict";
        i.d(t, {
            PropertyBoundAction: ()=>n
        });
        var s = i(691371);
        class o {
            constructor(e) {
                const {action: t, property: i, undoModel: s, undoText: o, callback: n=null} = e;
                this._property = i,
                this._undoModel = s,
                this._undoText = o,
                this._action = t,
                this.setValue(i.value()),
                i.subscribe(this, this._propertyChanged),
                null !== n ? t.update({
                    onExecute: n.bind(this)
                }) : t.update({
                    onExecute: this._onActionCallback.bind(this)
                })
            }
            destroy() {
                this._property.unsubscribe(this, this._propertyChanged)
            }
            value() {
                return this._action.isChecked()
            }
            setValue(e) {
                this._action.update({
                    checked: Boolean(e)
                })
            }
            _onActionCallback() {
                this._undoModel.setProperty(this._property, this.value(), this._undoText)
            }
            _propertyChanged(e) {
                this.setValue(e.value())
            }
        }
        class n extends s.Action {
            constructor(e, t) {
                super(e),
                this._binding = new o({
                    action: this,
                    ...t
                })
            }
            destroy() {
                this._binding.destroy(),
                super.destroy()
            }
        }
    }
    ,
    734469: (e,t,i)=>{
        "use strict";
        i.d(t, {
            ActionsProvider: ()=>fi,
            createActionCopyPrice: ()=>mi,
            createActionToggleVisibilityDataSources: ()=>vi,
            createActionTrade: ()=>di,
            createChangeIntervalsVisibilitiesAction: ()=>pi,
            createLinesAction: ()=>gi,
            createPasteAction: ()=>ui,
            createSyncDrawingActions: ()=>_i,
            createVisualOrderAction: ()=>hi,
            defaultContextMenuOptions: ()=>li
        });
        var s = i(650151)
          , o = i(338619)
          , n = i(960521)
          , r = i(124829)
          , a = i(444372)
          , l = i(953297)
          , c = i(691371)
          , d = i(109436)
          , u = i(287741)
          , h = i(434396)
          , p = i(33052)
          , m = i(716004)
          , g = i(345848)
          , _ = i(995152)
          , v = i(67326)
          , S = i(427047)
          , f = i(598631)
          , b = i(84281)
          , y = i(683833)
          , C = i(130841)
          , w = i(999872)
          , T = i(284682)
          , P = i(727534)
          , x = i(622429)
          , M = i(383557)
          , I = i(938614)
          , A = i(711496)
          , L = i(597655)
          , E = i(147117)
          , k = i(599344)
          , D = i(381350)
          , N = i(314802)
          , B = i(638456)
          , R = i(861814)
          , O = i(189436);
        class V extends c.Action {
            constructor(e, t) {
                const s = {
                    icon: R,
                    statName: "SetLayoutChartsSyncGroup",
                    label: a.t(null, void 0, i(104086))
                };
                super({
                    actionId: "Chart.LinkingGroupSync",
                    options: {
                        ...s,
                        subItems: O.icons.map((({icon: t},i)=>new c.Action({
                            actionId: "Chart.LinkingGroupSync.ChangeGroup",
                            options: {
                                label: t,
                                checkable: !0,
                                checked: e.value() === i,
                                onExecute: ()=>this._setLinkingGroupIndexImpl(i)
                            }
                        })))
                    },
                    customActionOptions: {
                        ...s,
                        subItems: [new c.Action({
                            actionId: "Chart.LinkingGroupSync.ChangeGroup",
                            options: {},
                            optionsLoader: async()=>{
                                const [e,{LayoutChartsSyncContextMenuItem: t}] = await Promise.all([Promise.resolve().then(i.t.bind(i, 50959, 19)), Promise.all([i.e(8800), i.e(65857), i.e(36010), i.e(78687), i.e(72610), i.e(10184)]).then(i.bind(i, 168880))]);
                                return {
                                    doNotCloseOnClick: !1,
                                    noInteractive: !0,
                                    jsxLabel: e.createElement(t, {
                                        active: this._linkingGroupIndex,
                                        icons: O.icons,
                                        onClick: e=>{
                                            this._setLinkingGroupIndexImpl(e)
                                        }
                                    })
                                }
                            }
                        })]
                    }
                }),
                this._setLinkingGroupIndexImpl = e=>{
                    this._setLinkingGroupIndex(this._linkingGroupIndex.value() === e ? null : e)
                }
                ,
                this._linkingGroupIndex = e.spawn(),
                this._setLinkingGroupIndex = t
            }
        }
        var W = i(354957)
          , F = i(956250)
          , H = i(845520)
          , z = i(470316)
          , U = i(104436)
          , G = i(622161)
          , j = i(519073)
          , q = i(440075)
          , X = i(898192)
          , K = i(465836)
          , Y = i(487945)
          , Z = i(547777)
          , $ = i(370407)
          , J = i(419283)
          , Q = i(378975)
          , ee = i(469805)
          , te = i(412788)
          , ie = i(793993)
          , se = i(218049)
          , oe = i(658843)
          , ne = i(508918)
          , re = i(418638)
          , ae = i(558634)
          , le = i(971417)
          , ce = i(306060)
          , de = i(375308)
          , ue = i(314824);
        const he = (0,
        o.getLogger)("Chart.ActionsProvider")
          , pe = new $.TranslatedString("change visibility",a.t(null, void 0, i(201924)))
          , me = new $.TranslatedString("pin to scale {label}",a.t(null, void 0, i(981566)))
          , ge = new $.TranslatedString("pin to right scale",a.t(null, void 0, i(607495)))
          , _e = new $.TranslatedString("pin to left scale",a.t(null, void 0, i(778690)))
          , ve = new $.TranslatedString("change earnings visibility",a.t(null, void 0, i(706819)))
          , Se = new $.TranslatedString("change dividends visibility",a.t(null, void 0, i(753929)))
          , fe = new $.TranslatedString("change splits visibility",a.t(null, void 0, i(347474)))
          , be = new $.TranslatedString("change continuous contract switch visibility",a.t(null, void 0, i(818867)))
          , ye = new $.TranslatedString("change futures contract expiration visibility",a.t(null, void 0, i(585532)))
          , Ce = new $.TranslatedString("change key facts today visibility",a.t(null, void 0, i(967077)))
          , we = new $.TranslatedString("change latest news and Minds visibility",a.t(null, void 0, i(350243)))
          , Te = new $.TranslatedString("show all ideas",a.t(null, void 0, i(13336)))
          , Pe = new $.TranslatedString("show ideas of followed users",a.t(null, void 0, i(791395)))
          , xe = new $.TranslatedString("show my ideas only",a.t(null, void 0, i(757460)))
          , Me = new $.TranslatedString("change events visibility on chart",a.t(null, void 0, i(906119)))
          , Ie = new $.TranslatedString("add this symbol to entire layout",a.t(null, void 0, i(679290)))
          , Ae = new $.TranslatedString("add this indicator to entire layout",a.t(null, void 0, i(96677)))
          , Le = new $.TranslatedString("add this strategy to entire layout",a.t(null, void 0, i(358156)))
          , Ee = new $.TranslatedString("add this financial metric to entire layout",a.t(null, void 0, i(267608)))
          , ke = new $.TranslatedString("apply drawing template",a.t(null, void 0, i(89720)))
          , De = new $.TranslatedString("lock objects",a.t(null, void 0, i(18942)))
          , Ne = new $.TranslatedString("unlock objects",a.t(null, void 0, i(823230)))
          , Be = new $.TranslatedString("change visibility at current interval and above",a.t(null, void 0, i(545800)))
          , Re = new $.TranslatedString("change visibility at current interval and below",a.t(null, void 0, i(175645)))
          , Oe = new $.TranslatedString("change visibility at current interval",a.t(null, void 0, i(584331)))
          , Ve = new $.TranslatedString("change visibility at all intervals",a.t(null, void 0, i(557916)))
          , We = a.t(null, void 0, i(366823))
          , Fe = (0,
        Z.appendEllipsis)(a.t(null, void 0, i(800264)))
          , He = a.t(null, void 0, i(698334))
          , ze = a.t(null, void 0, i(327298))
          , Ue = a.t(null, void 0, i(703564))
          , Ge = a.t(null, void 0, i(794559))
          , je = a.t(null, void 0, i(702165))
          , qe = a.t(null, void 0, i(16986))
          , Xe = a.t(null, void 0, i(312645))
          , Ke = a.t(null, void 0, i(544579))
          , Ye = a.t(null, void 0, i(429436))
          , Ze = a.t(null, void 0, i(81054))
          , $e = a.t(null, void 0, i(32538))
          , Je = a.t(null, void 0, i(172046))
          , Qe = a.t(null, void 0, i(590095))
          , et = a.t(null, void 0, i(14115))
          , tt = a.t(null, void 0, i(233110))
          , it = a.t(null, void 0, i(928280))
          , st = a.t(null, void 0, i(676150))
          , ot = a.t(null, void 0, i(694210))
          , nt = a.t(null, void 0, i(960035))
          , rt = a.t(null, void 0, i(210761))
          , at = a.t(null, void 0, i(411254))
          , lt = a.t(null, void 0, i(635049))
          , ct = a.t(null, void 0, i(319271))
          , dt = a.t(null, void 0, i(715512))
          , ut = a.t(null, void 0, i(546545))
          , ht = a.t(null, void 0, i(752160))
          , pt = a.t(null, void 0, i(417293))
          , mt = a.t(null, void 0, i(21973))
          , gt = a.t(null, void 0, i(55481))
          , _t = a.t(null, void 0, i(171179))
          , vt = a.t(null, void 0, i(804077))
          , St = a.t(null, void 0, i(754853))
          , ft = a.t(null, void 0, i(720177))
          , bt = a.t(null, void 0, i(700494))
          , yt = a.t(null, void 0, i(960668))
          , Ct = a.t(null, void 0, i(858026))
          , wt = a.t(null, void 0, i(156982))
          , Tt = (0,
        Z.appendEllipsis)(a.t(null, void 0, i(235088)))
          , Pt = (0,
        Z.appendEllipsis)(a.t(null, void 0, i(702439)))
          , xt = (0,
        Z.appendEllipsis)(a.t(null, void 0, i(232514)))
          , Mt = a.t(null, void 0, i(178358))
          , It = (0,
        Z.appendEllipsis)(a.t(null, void 0, i(276266)))
          , At = a.t(null, void 0, i(249680))
          , Lt = a.t(null, void 0, i(712537))
          , Et = a.t(null, void 0, i(93553))
          , kt = a.t(null, void 0, i(774975))
          , Dt = a.t(null, void 0, i(999894))
          , Nt = a.t(null, void 0, i(205837))
          , Bt = a.t(null, void 0, i(537113))
          , Rt = a.t(null, void 0, i(629449))
          , Ot = a.t(null, void 0, i(350849))
          , Vt = a.t(null, void 0, i(833158))
          , Wt = a.t(null, void 0, i(81465))
          , Ft = a.t(null, void 0, i(710428))
          , Ht = a.t(null, void 0, i(68112))
          , zt = a.t(null, void 0, i(555418))
          , Ut = a.t(null, void 0, i(510261))
          , Gt = a.t(null, void 0, i(644020))
          , jt = (0,
        Z.appendEllipsis)(a.t(null, void 0, i(232514)))
          , qt = a.t(null, void 0, i(897878))
          , Xt = a.t(null, void 0, i(239010))
          , Kt = a.t(null, void 0, i(326090))
          , Yt = a.t(null, void 0, i(995754))
          , Zt = a.t(null, void 0, i(535679))
          , $t = a.t(null, void 0, i(709140))
          , Jt = a.t(null, void 0, i(846607))
          , Qt = a.t(null, void 0, i(639079))
          , ei = (0,
        Z.appendEllipsis)(a.t(null, void 0, i(975594)))
          , ti = (0,
        Z.appendEllipsis)(a.t(null, void 0, i(288853)))
          , ii = a.t(null, void 0, i(735140))
          , si = a.t(null, void 0, i(163553))
          , oi = a.t(null, void 0, i(792957))
          , ni = a.t(null, void 0, i(858764))
          , ri = a.t(null, void 0, i(910996))
          , ai = a.t(null, void 0, i(903061))
          , li = {
            general: !0,
            mainSeries: !0,
            mainSeriesTrade: !1,
            esdStudies: !0,
            studies: !0,
            fundamentals: !0,
            lineTools: !0,
            publishedCharts: !0,
            ordersAndPositions: !0,
            alerts: !0,
            chartEvents: !0,
            objectTree: !0,
            gotoLineTool: !1
        };
        function ci(e) {
            return (0,
            Y.isActingAsSymbolSource)(e) ? e.symbolTitle(u.TitleDisplayTarget.StatusLine, !0, !0) : (0,
            m.clean)(e.title(u.TitleDisplayTarget.StatusLine, !0), !0)
        }
        async function di(e, t, i) {
            if (e.model().isInReplay().value())
                return null;
            const s = e.model().mainSeries()
              , o = s.symbolInfo();
            if (s.isConvertedToOtherCurrency() || s.isConvertedToOtherUnit() || (0,
            v.isNonTradableSymbolType)(null == o ? void 0 : o.type))
                return null;
            const n = await (async()=>{
                const t = (0,
                b.tradingService)();
                if (null === t || 0 === (await t.brokersMetainfo()).length)
                    return [];
                const s = e.model().mainSeries();
                let o;
                i && (o = i.localY);
                try {
                    const e = await (0,
                    y.createTradeContext)(s, o);
                    return await t.chartContextMenuActions(e, {
                        hideNotExecutableAction: !0
                    })
                } catch (e) {
                    return he.logError(e.message),
                    []
                }
            }
            )();
            if (n.length > 0) {
                const e = ()=>new Promise(((e,t)=>{
                    0 !== n.length ? e({
                        name: "trade",
                        label: We,
                        subItems: n,
                        statName: "Trading"
                    }) : e({
                        label: We,
                        disabled: !0
                    })
                }
                ));
                return new c.Action({
                    actionId: "Trading.TradeFromChart",
                    options: {},
                    optionsLoader: ()=>(0,
                    C.makeTimeLimited)(e(), 5e3, "Action trade not received")
                })
            }
            return null
        }
        function ui(e, t) {
            return !t.isEmpty() && l.enabled("datasource_copypaste") ? new ue.ActionWithStandardIcon({
                actionId: "Chart.Clipboard.PasteSource",
                options: {
                    label: ii.trim(),
                    shortcutHint: (0,
                    z.humanReadableHash)(z.Modifiers.Mod + 86),
                    statName: "Paste",
                    onExecute: ()=>e.chartWidgetCollection().clipboard.uiRequestPaste(t)
                }
            }) : null
        }
        function hi(e, t) {
            const i = e.model()
              , s = i.availableZOrderOperations(t)
              , o = [new ue.ActionWithStandardIcon({
                actionId: "Chart.Source.VisualOrder.BringToFront",
                options: {
                    label: pt,
                    statName: "BringToFront",
                    disabled: !s.bringToFrontEnabled,
                    onExecute: ()=>i.bringToFront(t)
                }
            }), new ue.ActionWithStandardIcon({
                actionId: "Chart.Source.VisualOrder.SendToBack",
                options: {
                    label: mt,
                    statName: "SendToBack",
                    disabled: !s.sendToBackEnabled,
                    onExecute: ()=>i.sendToBack(t)
                }
            }), new ue.ActionWithStandardIcon({
                actionId: "Chart.Source.VisualOrder.BringForward",
                options: {
                    label: gt,
                    statName: "BringForward",
                    disabled: !s.bringForwardEnabled,
                    onExecute: ()=>i.bringForward(t)
                }
            }), new ue.ActionWithStandardIcon({
                actionId: "Chart.Source.VisualOrder.SendBackward",
                options: {
                    label: _t,
                    statName: "SendBackward",
                    disabled: !s.sendBackwardEnabled,
                    onExecute: ()=>i.sendBackward(t)
                }
            })];
            return new ue.ActionWithStandardIcon({
                actionId: "Chart.Source.VisualOrder",
                options: {
                    label: vt,
                    iconId: "Chart.VisualOrder",
                    statName: "VisualOrder",
                    subItems: o
                }
            })
        }
        function pi(e, t) {
            const i = e.model()
              , s = (e,s)=>{
                const o = Q.Interval.parse(i.mainSeries().interval())
                  , n = (0,
                te.getIntervalsVisibilitiesForMode)(o, e)
                  , r = []
                  , a = [];
                t.forEach((e=>{
                    const t = e.properties().intervalsVisibilities.childs();
                    r.push(t.ticks),
                    a.push(n.ticks),
                    r.push(t.seconds),
                    a.push(n.seconds),
                    r.push(t.secondsFrom),
                    a.push(n.secondsFrom),
                    r.push(t.secondsTo),
                    a.push(n.secondsTo),
                    r.push(t.minutes),
                    a.push(n.minutes),
                    r.push(t.minutesFrom),
                    a.push(n.minutesFrom),
                    r.push(t.minutesTo),
                    a.push(n.minutesTo),
                    r.push(t.hours),
                    a.push(n.hours),
                    r.push(t.hoursFrom),
                    a.push(n.hoursFrom),
                    r.push(t.hoursTo),
                    a.push(n.hoursTo),
                    r.push(t.days),
                    a.push(n.days),
                    r.push(t.daysFrom),
                    a.push(n.daysFrom),
                    r.push(t.daysTo),
                    a.push(n.daysTo),
                    r.push(t.weeks),
                    a.push(n.weeks),
                    r.push(t.weeksFrom),
                    a.push(n.weeksFrom),
                    r.push(t.weeksTo),
                    a.push(n.weeksTo),
                    r.push(t.months),
                    a.push(n.months),
                    r.push(t.monthsFrom),
                    a.push(n.monthsFrom),
                    r.push(t.monthsTo),
                    a.push(n.monthsTo),
                    r.push(t.ranges),
                    a.push(n.ranges)
                }
                )),
                i.setProperties(r, a, s, (0,
                de.sourcesAffectState)(t))
            }
              , o = [new ue.ActionWithStandardIcon({
                actionId: "Chart.Source.IntervalsVisibility.CurrentAndAbove",
                options: {
                    label: ft,
                    statName: "currentAndAboveIntervals",
                    onExecute: ()=>s(3, Be)
                }
            }), new ue.ActionWithStandardIcon({
                actionId: "Chart.Source.IntervalsVisibility.CurrentAndBelow",
                options: {
                    label: bt,
                    statName: "currentAndBelowIntervals",
                    onExecute: ()=>s(2, Re)
                }
            }), new ue.ActionWithStandardIcon({
                actionId: "Chart.Source.IntervalsVisibility.Current",
                options: {
                    label: yt,
                    statName: "currentInterval",
                    onExecute: ()=>s(1, Oe)
                }
            }), new ue.ActionWithStandardIcon({
                actionId: "Chart.Source.IntervalsVisibility.All",
                options: {
                    label: Ct,
                    statName: "allIntervals",
                    onExecute: ()=>s(0, Ve)
                }
            })];
            return new ue.ActionWithStandardIcon({
                actionId: "Chart.Source.IntervalsVisibility",
                options: {
                    label: St,
                    statName: "IntervalsVisibility",
                    subItems: o
                }
            })
        }
        function mi(e, t) {
            var i, s, o;
            const n = e.defaultPriceScale()
              , r = void 0 !== t ? n.coordinateToPrice(t, null !== (s = null === (i = e.mainDataSource()) || void 0 === i ? void 0 : i.firstValue()) && void 0 !== s ? s : 0) : e.model().mainSeries().lastValueData(4, !0, !0).price
              , a = null === (o = e.mainDataSource()) || void 0 === o ? void 0 : o.formatter();
            if (void 0 === r || !a)
                return null;
            const l = a.format(r)
              , c = a.format(r, {
                ignoreLocaleNumberFormat: !0
            });
            return new ue.ActionWithStandardIcon({
                actionId: "Chart.Clipboard.CopyPrice",
                options: {
                    label: `${si} ${l}`,
                    statName: "CopyPrice",
                    onExecute: ()=>(0,
                    ie.getClipboard)().writeText(c)
                }
            })
        }
        function gi(e) {
            const t = e.actions()
              , i = [t.showPriceLine];
            return i.push(t.showSeriesPrevCloseLine),
            i.push(t.showPrePostMarketPriceLine),
            i.push(t.showHighLowPriceLines),
            e.model().model().hasCustomSource("bidask") && i.push(t.showBidAskLines),
            new ue.ActionWithStandardIcon({
                actionId: "Chart.Lines",
                options: {
                    label: wt,
                    statName: "Lines",
                    subItems: i
                }
            })
        }
        function _i(e, t) {
            const i = [];
            {
                if (J.isToolCreatingNow.value())
                    return i;
                const s = ()=>t.some((e=>e.isSynchronizable()));
                {
                    if (!window.user.is_pro)
                        return i;
                    if (!s())
                        return i;
                    let o = t[0].sharingMode().value();
                    o = t.every((e=>e.sharingMode().value() === o)) ? o : null;
                    const n = e.model();
                    i.push(new c.Action({
                        actionId: "Chart.LineTool.NoSync",
                        options: {
                            label: $t,
                            statName: "NoSyncDrawing",
                            checkable: !0,
                            checked: 0 === o,
                            onExecute: e=>{
                                e.isChecked() && n.shareLineTools(t, 0)
                            }
                        }
                    }), new c.Action({
                        actionId: "Chart.LineTool.SyncInLayout",
                        options: {
                            label: Jt,
                            statName: "SyncDrawingInLayout",
                            checkable: !0,
                            checked: 1 === o,
                            onExecute: e=>{
                                e.isChecked() && n.shareLineTools(t, 1)
                            }
                        }
                    }), new c.Action({
                        actionId: "Chart.LineTool.SyncGlobally",
                        options: {
                            label: Qt,
                            statName: "SyncDrawingGlobally",
                            checkable: !0,
                            checked: 2 === o,
                            onExecute: e=>{
                                e.isChecked() && n.shareLineTools(t, 2)
                            }
                        }
                    }))
                }
            }
            return i
        }
        function vi(e, t) {
            const i = t[0].properties().visible.value()
              , s = i ? ze : He
              , o = i ? "Chart.Hide" : "Chart.ShowObject"
              , n = i ? "Chart.SelectedObject.Hide" : "Chart.SelectedObject.Show";
            return new ue.ActionWithStandardIcon({
                actionId: n,
                options: {
                    checkable: !0,
                    statName: "ToggleVisibilitySelectedObject",
                    label: s,
                    iconId: o,
                    onExecute: ()=>{
                        const s = e.model();
                        s.withMacro(pe, (()=>{
                            t.forEach((e=>{
                                s.setProperty(e.properties().visible, !i, pe, ee.lineToolsDoNotAffectChartInvalidation && (0,
                                K.isLineTool)(e))
                            }
                            ))
                        }
                        ))
                    }
                }
            })
        }
        function Si() {
            var e, t;
            return !(0,
            B.onWidget)() && !(0,
            N.isOnMobileAppPage)("any") && !!(null === (t = null === (e = window.widgetbar) || void 0 === e ? void 0 : e.layout) || void 0 === t ? void 0 : t.canOpen())
        }
        class fi {
            constructor(e, t) {
                this._chartWidget = e,
                this._options = (0,
                r.merge)((0,
                r.clone)(li), t || {})
            }
            async contextMenuActionsForSources(e, t, i, s, o) {
                const n = e[0]
                  , r = this._options
                  , a = [];
                if (n === this._chartWidget.model().mainSeries() && r.mainSeries)
                    a.push(...await this._contextMenuActionsForSeries(n, i));
                else if ((0,
                h.isESDStudy)(n) && r.esdStudies)
                    a.push(...this._contextMenuActionsForESD());
                else if ((0,
                h.isRollDatesStudy)(n))
                    a.push(...this._contextMenuActionsForRollDates());
                else if ((0,
                E.isFuturesContractExpiration)(n))
                    a.push(...this._contextMenuActionsForFuturesContractExpiration());
                else if ((0,
                D.isKeyFactsTodaySource)(n))
                    a.push(...this._contextMenuActionsForKeyFactsToday());
                else if ((0,
                k.isLatestUpdatesSource)(n))
                    a.push(...this._contextMenuActionsForisLatestUpdates());
                else if ((0,
                h.isStudy)(n) && r.studies)
                    a.push(...await this._contextMenuActionsForStudy(n, t, i));
                else if (n instanceof x.PublishedChartsTimeline && r.publishedCharts)
                    a.push(...this._contextMenuActionsForPublishedTimeline(n));
                else if ((n instanceof w.LineToolOrder || n instanceof T.LineToolPosition) && r.ordersAndPositions)
                    a.push(...this._contextMenuActionsForTradingDrawings(n));
                else if ((0,
                I.isAlertLabel)(n) && n.alert().id().value() && !n.alert().isNew() && r.alerts)
                    a.push(...await this._contextMenuActionsForAlertLabel(n.alert(), s));
                else if ((0,
                K.isLineTool)(n) && r.lineTools) {
                    const t = e.filter(K.isLineTool);
                    a.push(...await this._contextMenuActionsForLineTool(t))
                } else
                    (function(e) {
                        return e.name() === ne.ChartEventsSourceId.Value
                    }
                    )(n) && r.chartEvents && a.push(...this._contextMenuActionsForChartEvents(n));
                return a.length && (null == o ? void 0 : o.length) && a.push(new c.Separator),
                a.push(...null != o ? o : []),
                a
            }
            _isReadOnly() {
                return this._chartWidget.readOnly()
            }
            _createActionScale(e) {
                const t = (0,
                s.ensureNotNull)(e.priceScale())
                  , i = this._chartWidget.model().model()
                  , o = (0,
                s.ensureNotNull)(i.paneForSource(e))
                  , n = o.priceScalePosition(t)
                  , r = ("left" === n ? o.leftPriceScales() : o.rightPriceScales()).indexOf(t)
                  , a = i.priceScaleSlotsCount().totallySlots < 2 ? "dontneedname" : "needname"
                  , l = "overlay" === n ? "" : (0,
                d.getPriceAxisNameInfo)(n, r).label
                  , c = st.format({
                    label: l
                })
                  , u = {
                    "left-needname": c,
                    "left-dontneedname": nt,
                    "right-needname": c,
                    "right-dontneedname": rt,
                    "overlay-needname": ot,
                    "overlay-dontneedname": ot
                }[n + "-" + a];
                return new ue.ActionWithStandardIcon({
                    actionId: "Chart.Source.ChangePriceScale",
                    options: {
                        label: u,
                        iconId: "Chart.PriceScale",
                        subItems: this._createActionScaleItems(e)
                    }
                })
            }
            _createActionResetInputPoints(e) {
                const t = e.metaInfo()
                  , s = t.inputs.filter(se.isTimeOrPriceNotHiddenInput);
                return 0 === s.length ? null : new ue.ActionWithStandardIcon({
                    actionId: "Chart.Source.ResetInputPoints",
                    options: {
                        label: ti,
                        onExecute: async()=>{
                            let o;
                            try {
                                const n = e.properties().childs().inputs.state();
                                for (const e of Object.keys(n))
                                    s.find((t=>t.id === e)) || delete n[e];
                                const r = new oe.Property({
                                    inputs: n
                                })
                                  , a = await Promise.all([i.e(55073), i.e(46445), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(65857), i.e(36010), i.e(53953), i.e(2520), i.e(25480), i.e(62564), i.e(29800), i.e(46489), i.e(29296), i.e(58985), i.e(23141), i.e(62234), i.e(95083), i.e(75826), i.e(59258), i.e(82421), i.e(67158), i.e(22106), i.e(74600), i.e(30422), i.e(72197), i.e(16356), i.e(24125), i.e(88015), i.e(98734), i.e(97384), i.e(93523), i.e(3782), i.e(86605), i.e(49162), i.e(41243), i.e(64797), i.e(22602), i.e(7001), i.e(71329), i.e(51488), i.e(94106), i.e(59470), i.e(75364), i.e(8222), i.e(80089), i.e(76750), i.e(13752), i.e(32277), i.e(25983), i.e(79412), i.e(31085), i.e(42513), i.e(78685), i.e(59434), i.e(82440), i.e(89255), i.e(89638), i.e(31600), i.e(85775), i.e(63095), i.e(79184), i.e(56316), i.e(32227), i.e(50030), i.e(87473), i.e(18405), i.e(90223), i.e(93498), i.e(65267), i.e(50186), i.e(71457), i.e(35432), i.e(89178), i.e(13338), i.e(53030)]).then(i.bind(i, 204564));
                                o = (await a.selectInputValuesOnChart(this._chartWidget, s, r, t.shortDescription, t.inputs)).customSourceId,
                                e.properties().mergeAndFire(r.state())
                            } finally {
                                void 0 !== o && this._chartWidget.model().model().removeCustomSource(o)
                            }
                        }
                    }
                })
            }
            _createActionLayoutChartsSync() {
                return new V(this._chartWidget.linkingGroupIndex().readonly(),(e=>this._chartWidget.model().setLinkingGroupIndex(e)))
            }
            _createActionScaleDetach(e, t, i, o) {
                const n = this._chartWidget.model().model()
                  , r = (0,
                s.ensureNotNull)(n.paneForSource(e));
                if (!r.canCreateNewPriceScale())
                    return null;
                const a = (0,
                s.ensureNotNull)(e.priceScale())
                  , l = a.canDetachSource(e)
                  , c = r.priceScalePosition(a)
                  , u = l || c !== t;
                if (!u)
                    return null;
                const h = n.priceScaleSlotsCount()
                  , p = {
                    left: {
                        labelled: Ye,
                        sided: tt
                    },
                    right: {
                        labelled: Ye,
                        sided: it
                    }
                }
                  , m = "left" === t ? r.leftPriceScales().length : r.rightPriceScales().length
                  , g = h[t] > m ? "labelled" : "sided"
                  , _ = (0,
                d.getPriceAxisNameInfo)(t, m).label
                  , v = p[t][g].format({
                    label: _
                });
                return new ue.ActionWithStandardIcon({
                    actionId: "Chart.Source.ChangePriceScale",
                    options: {
                        checkable: !1,
                        disabled: !u,
                        label: v,
                        statName: o,
                        payload: e,
                        onExecute: i
                    }
                })
            }
            _onDetachLeft(e) {
                const t = e.getPayload()
                  , i = this._chartWidget.model().model()
                  , o = (0,
                s.ensureNotNull)(i.paneForSource(t));
                this._chartWidget.model().detachToLeft(t, o)
            }
            _onDetachRight(e) {
                const t = e.getPayload()
                  , i = this._chartWidget.model().model()
                  , o = (0,
                s.ensureNotNull)(i.paneForSource(t));
                this._chartWidget.model().detachToRight(t, o)
            }
            _createActionScaleDetachLeft(e) {
                return this._createActionScaleDetach(e, "left", this._onDetachLeft.bind(this), "ToggleScaleLeft")
            }
            _createActionScaleDetachRight(e) {
                return this._createActionScaleDetach(e, "right", this._onDetachRight.bind(this), "ToggleScaleRight")
            }
            _onMoveToScale(e) {
                const t = e.getPayload();
                if (t.datasource.priceScale() === t.priceScale)
                    return;
                const i = this._chartWidget.model().model()
                  , o = (0,
                s.ensureNotNull)(i.paneForSource(t.datasource));
                this._chartWidget.model().moveToScale(t.datasource, o, t.priceScale, t.undoText)
            }
            _createMoveToScaleAction(e, t, i, s) {
                const o = e.priceScale() === t;
                return new ue.ActionWithStandardIcon({
                    actionId: "Chart.Source.MoveToOtherScale",
                    options: {
                        checkable: !0,
                        checked: o,
                        label: i,
                        statName: "ToggleScale",
                        payload: {
                            datasource: e,
                            priceScale: t,
                            undoText: s
                        },
                        onExecute: this._onMoveToScale.bind(this)
                    }
                })
            }
            _onNoScale(e) {
                const t = e.getPayload().datasource
                  , i = this._chartWidget.model().model()
                  , o = (0,
                s.ensureNotNull)(i.paneForSource(t));
                o.isOverlay(t) || this._chartWidget.model().detachNoScale(t, o)
            }
            _createActionNoScale(e) {
                const t = this._chartWidget.model().model()
                  , i = (0,
                s.ensureNotNull)(t.paneForSource(e))
                  , o = i.actionNoScaleIsEnabled(e);
                return new ue.ActionWithStandardIcon({
                    actionId: "Chart.Source.MoveToNoScale",
                    options: {
                        checkable: !0,
                        checked: i.isOverlay(e),
                        label: at,
                        disabled: !o,
                        statName: "ToggleNoScale",
                        payload: {
                            datasource: e
                        },
                        onExecute: this._onNoScale.bind(this)
                    }
                })
            }
            _createActionScaleItems(e) {
                const t = []
                  , i = this._chartWidget.model().model()
                  , o = (0,
                s.ensureNotNull)(i.paneForSource(e))
                  , n = i.priceScaleSlotsCount().totallySlots > 1
                  , r = o.rightPriceScales()
                  , a = o.leftPriceScales()
                  , l = this._createActionScaleDetachRight(e)
                  , u = this._createActionScaleDetachLeft(e)
                  , h = r.length + a.length + (null === l ? 0 : 1) + (null === u ? 0 : 1) > 2
                  , p = {
                    right: {
                        hidden: {
                            checked: {
                                labelled: Ue,
                                sided: Ge
                            },
                            unchecked: {
                                labelled: je,
                                sided: qe
                            }
                        },
                        visible: {
                            checked: {
                                labelled: Xe,
                                sided: Ke
                            },
                            unchecked: {
                                labelled: Ye,
                                sided: Ze
                            }
                        }
                    },
                    left: {
                        hidden: {
                            checked: {
                                labelled: Ue,
                                sided: $e
                            },
                            unchecked: {
                                labelled: je,
                                sided: Je
                            }
                        },
                        visible: {
                            checked: {
                                labelled: Xe,
                                sided: Qe
                            },
                            unchecked: {
                                labelled: Ye,
                                sided: et
                            }
                        }
                    }
                }
                  , m = {
                    right: ge,
                    left: _e
                }
                  , g = {
                    left: o.visibleLeftPriceScales(),
                    right: o.visibleRightPriceScales()
                }
                  , _ = (t,i)=>{
                    const s = ("right" === i ? r : a)[t]
                      , o = g[i].includes(s) ? "visible" : "hidden"
                      , l = e.priceScale() === s ? "checked" : "unchecked"
                      , c = n ? "labelled" : "sided"
                      , u = p[i]
                      , h = (0,
                    d.getPriceAxisNameInfo)(i, t).label;
                    return {
                        actionText: u[o][l][c].format({
                            label: h
                        }),
                        undoText: n ? me.format({
                            label: h
                        }) : m[i]
                    }
                }
                ;
                t.push(...r.map(((t,i)=>{
                    const s = _(i, "right");
                    return this._createMoveToScaleAction(e, t, s.actionText, s.undoText)
                }
                ))),
                null !== l && t.push(l);
                h && (r.length > 0 || null !== l) && t.push(new c.Separator);
                t.push(...a.map(((t,i)=>{
                    const s = _(i, "left");
                    return this._createMoveToScaleAction(e, t, s.actionText, s.undoText)
                }
                ))),
                null !== u && t.push(u);
                h && (a.length > 0 || null !== u) && t.push(new c.Separator);
                return t.push(this._createActionNoScale(e)),
                t
            }
            _createActionMergeUp(e) {
                const t = this._chartWidget.model();
                return t.model().isMergeUpAvailableForSource(e) ? new ue.ActionWithStandardIcon({
                    actionId: "Chart.Source.MergeUp",
                    options: {
                        label: ct,
                        statName: "MergeUp",
                        onExecute: ()=>t.mergeSourceUp(e)
                    }
                }) : null
            }
            _createActionUnmergeUp(e) {
                const t = this._chartWidget.model();
                return t.model().isUnmergeAvailableForSource(e) ? new ue.ActionWithStandardIcon({
                    actionId: "Chart.Source.UnmergeUp",
                    options: {
                        label: dt,
                        statName: "UnmergeUp",
                        onExecute: ()=>t.unmergeSourceUp(e)
                    }
                }) : null
            }
            _createActionMergeDown(e) {
                const t = this._chartWidget.model();
                return t.model().isMergeDownAvailableForSource(e) ? new ue.ActionWithStandardIcon({
                    actionId: "Chart.Source.MergeDown",
                    options: {
                        label: ut,
                        statName: "MergeDown",
                        onExecute: ()=>t.mergeSourceDown(e)
                    }
                }) : null
            }
            _createActionUnmergeDown(e) {
                const t = this._chartWidget.model();
                return t.model().isUnmergeAvailableForSource(e) ? new ue.ActionWithStandardIcon({
                    actionId: "Chart.Source.UnmergeDown",
                    options: {
                        label: ht,
                        statName: "UnmergeDown",
                        onExecute: ()=>t.unmergeSourceDown(e)
                    }
                }) : null
            }
            _mergeContentMenuItems(e) {
                return [this._createActionMergeUp(e), this._createActionUnmergeUp(e), this._createActionMergeDown(e), this._createActionUnmergeDown(e)].filter(r.notNull)
            }
            _createActionMove(e) {
                const t = this._mergeContentMenuItems(e);
                return t.length > 0 ? new ue.ActionWithStandardIcon({
                    actionId: "Chart.Source.MoveToPane",
                    options: {
                        label: lt,
                        iconId: "Chart.Move",
                        subItems: t
                    }
                }) : null
            }
            async _contextMenuActionsForSeries(e, t) {
                var i;
                const o = []
                  , n = this._chartWidget.model().model()
                  , r = (0,
                s.ensureNotNull)(n.paneForSource(e))
                  , a = this._chartWidget.actions()
                  , d = t && "localY"in t ? t.localY : void 0;
                if (this._isReadOnly())
                    o.push(vi(this._chartWidget, [e])),
                    o.push(new c.Separator),
                    o.push(this._createActionScale(e));
                else {
                    if (e.alertCreationAvailable().value()) {
                        const t = (await (0,
                        ae.getAlertsChartActionCreators)()).createAlert(this._chartWidget, {
                            series: e,
                            localY: d
                        });
                        null !== t && o.push(t)
                    }
                    if (o.push(this._createActionAddChildStudy(e)),
                    this._options.fundamentals) {
                        const t = this._createActionAddFundamentals(e);
                        null !== t && o.push(t)
                    }
                    if (this._options.mainSeriesTrade) {
                        const e = await di(this._chartWidget);
                        null !== e && o.push(e)
                    }
                    o.length > 0 && !(o[o.length - 1]instanceof c.Separator) && o.push(new c.Separator),
                    l.enabled("symbol_info") && o.push(a.showSymbolInfoDialog),
                    Si() && o.push(this._chartWidget.actions().showDataWindow);
                    const t = n.mainSeries().symbolInfo();
                    if (a.showFinancials && null !== t && (0,
                    A.hasFinancialsByTypespecs)(t.type, t.typespecs) && o.push(a.showFinancials),
                    o.length > 0 && !(o[o.length - 1]instanceof c.Separator) && o.push(new c.Separator),
                    !r.isEmpty() && l.enabled("datasource_copypaste")) {
                        const e = mi(r, d)
                          , t = ui(this._chartWidget, r);
                        (e || t) && (e && o.push(e),
                        t && o.push(t),
                        o.push(new c.Separator))
                    }
                    o.push(hi(this._chartWidget, [e]));
                    const s = this._createActionMove(e);
                    null !== s && o.push(s),
                    o.push(this._createActionScale(e)),
                    this._chartWidget.isMultipleLayout().value() && (this._chartWidget.chartWidgetCollection().lock.symbol.value() || this._chartWidget.chartWidgetCollection().lock.interval.value()) && o.push(this._createActionLayoutChartsSync()),
                    o.push(vi(this._chartWidget, [e])),
                    o.push(new c.Separator);
                    Boolean(null === (i = window.widgetbar) || void 0 === i ? void 0 : i.widget("watchlist")) && a.addToWatchlist && o.push(a.addToWatchlist),
                    l.enabled("text_notes") && o.push(a.addToTextNotes),
                    o[o.length - 1]instanceof c.Separator || o.push(new c.Separator),
                    l.enabled("show_chart_property_page") && !this._chartWidget.onWidget() && o.push(a.mainSeriesPropertiesAction),
                    o[o.length - 1]instanceof c.Separator && o.pop()
                }
                return o
            }
            _createActionAddChildStudy(e) {
                const t = this._chartWidget.model().model();
                return new ue.ActionWithStandardIcon({
                    actionId: "Chart.Indicator.ApplyChildIndicator",
                    options: {
                        label: Tt.format({
                            studyTitle: ci(e)
                        }),
                        iconId: "Chart.ApplyIndicator",
                        statName: "ApplyIndicator",
                        onExecute: ()=>{
                            const i = this._chartWidget.showIndicators((0,
                            h.isStudy)(e) ? [e] : []);
                            if (i && (0,
                            h.isStudy)(e)) {
                                const e = ()=>{
                                    (0,
                                    g.trackEvent)("SOS", "Apply SOS", "Apply by RC menu")
                                }
                                  , s = t.studyInserted();
                                s.subscribe(this, e),
                                i.visible().subscribe((t=>{
                                    t || s.unsubscribe(this, e)
                                }
                                ), {
                                    once: !0
                                })
                            }
                        }
                    }
                })
            }
            _createActionAddFundamentals(e) {
                {
                    const t = e.symbolInfo();
                    if (null !== t && "forex" !== t.type && !(0,
                    j.hasCryptoTypespec)(t.typespecs || []))
                        return new ue.ActionWithStandardIcon({
                            actionId: "Chart.Indicator.ApplyFinancials",
                            options: {
                                label: Pt.format({
                                    instrumentName: ci(e)
                                }),
                                iconId: "Chart.Financials",
                                statName: "ApplyFundamental",
                                onExecute: ()=>{
                                    this._chartWidget.showFundamentals(e !== this._chartWidget.model().mainSeries() ? e : void 0)
                                }
                            }
                        })
                }
                return null
            }
            _createActionShowSymbolInfoDialog(e, t) {
                const i = this._chartWidget.model().model();
                return new ue.ActionWithStandardIcon({
                    actionId: "Chart.Dialogs.ShowSymbolInfo",
                    options: {
                        label: ei,
                        iconId: "Chart.SymbolInfo",
                        checkable: !1,
                        statName: "SymbolInfo",
                        onExecute: ()=>{
                            const s = {
                                symbolInfo: e.symbolInfo(),
                                unitDescription: e=>e ? t.description(e) : "",
                                dateFormatter: i.dateFormatter()
                            };
                            (0,
                            q.showSymbolInfoDialog)(s)
                        }
                    }
                })
            }
            _createActionShowProperties(e) {
                return new ue.ActionWithStandardIcon({
                    actionId: "Chart.Indicator.ShowSettingsDialog",
                    options: {
                        label: xt,
                        iconId: "Settings",
                        statName: "EditSelectedObject",
                        onExecute: ()=>this._chartWidget.showSourceProperties(e)
                    }
                })
            }
            async _contextMenuActionsForStudy(e, t, s) {
                const o = this._chartWidget.model()
                  , n = t !== o.paneForSource(e)
                  , r = this._chartWidget.actions()
                  , d = s && "localY"in s ? s.localY : void 0
                  , u = [];
                if (!e.userEditEnabled())
                    return u;
                if (this._chartWidget.readOnly())
                    u.push(vi(this._chartWidget, [e])),
                    u.push(new c.Separator),
                    (0,
                    S.isNonSeriesStudy)(e) || u.push(this._createActionScale(e));
                else {
                    if (e.alertCreationAvailable().value()) {
                        const t = (await (0,
                        ae.getAlertsChartActionCreators)()).createAlert(this._chartWidget, {
                            series: e,
                            localY: d
                        });
                        null !== t && u.push(t)
                    }
                    if (l.enabled("study_on_study") && e.canHaveChildren() && u.push(this._createActionAddChildStudy(e)),
                    (0,
                    h.isCompareOrOverlayStudy)(e) && this._options.fundamentals) {
                        const t = this._createActionAddFundamentals(e);
                        null !== t && u.push(t)
                    }
                    const t = this._createApplyToEntireLayoutCommand(e);
                    null !== t && u.push(t);
                    const s = this._createAddIndicatorToFavoritesCommand(e);
                    if (s && u.push(s),
                    u.length > 0 && !(u[u.length - 1]instanceof c.Separator) && u.push(new c.Separator),
                    l.enabled("symbol_info") && (0,
                    h.isCompareOrOverlayStudy)(e) && null !== e.symbolInfo() && (u.push(this._createActionShowSymbolInfoDialog(e, this._chartWidget.model().model().availableUnits())),
                    u.push(new c.Separator)),
                    n || u.push(hi(this._chartWidget, [e])),
                    u.push(pi(this._chartWidget, [e])),
                    !(0,
                    S.isNonSeriesStudy)(e) && !n) {
                        const t = this._createActionMove(e);
                        null !== t && u.push(t),
                        u.push(this._createActionScale(e))
                    }
                    u.push(new c.Separator);
                    const p = e.metaInfo();
                    if (!(0,
                    B.onWidget)() && e.pineSourceCodeModel) {
                        const t = await e.pineSourceCodeModel();
                        if (t) {
                            const [s,n] = await Promise.all([(0,
                            re.showAboutTheStudyHandler)(t), t.requestUpdateInformation()]);
                            if (s) {
                                const t = (0,
                                h.isFundamentalStudy)(e) ? (0,
                                Z.appendEllipsis)(a.t(null, void 0, i(746135))) : p.pine ? (0,
                                Z.appendEllipsis)(a.t(null, void 0, i(657486))) : (0,
                                Z.appendEllipsis)(a.t(null, void 0, i(717274)));
                                u.push(new c.Action({
                                    actionId: "Chart.Indicator.About",
                                    options: {
                                        label: t,
                                        statName: "OpenSelectedObjectAbout",
                                        onExecute: s
                                    }
                                }))
                            }
                            if (n && n.lastVersion.isGreater(ce.Version.parse(n.currentVersion))) {
                                const s = (0,
                                h.isFundamentalStudy)(e) ? (0,
                                Z.appendEllipsis)(a.t(null, void 0, i(136339))) : p.pine ? (0,
                                Z.appendEllipsis)(a.t(null, void 0, i(342524))) : (0,
                                Z.appendEllipsis)(a.t(null, void 0, i(798451)));
                                u.push(new c.Action({
                                    actionId: "Chart.Indicator.About",
                                    options: {
                                        label: s,
                                        statName: "UpdateStudyVersion",
                                        onExecute: async()=>{
                                            t.updateToVersion(o, n.lastVersion)
                                        }
                                    }
                                }))
                            }
                        }
                    }
                    if (!(0,
                    h.isFundamentalStudy)(e) && p.pine && r.viewSourceCode) {
                        const {scriptIdPart: t, pine: {version: i}} = p;
                        u.push(r.viewSourceCode);
                        const s = this._createActionResetInputPoints(e);
                        s && u.push(s),
                        u.push(new c.Separator),
                        r.viewSourceCode.update({
                            disabled: !1
                        }),
                        (0,
                        P.isAuthToGetPineSourceCode)(t, i).then((e=>{
                            e || r.viewSourceCode.update({
                                disabled: !0
                            })
                        }
                        )).catch((e=>{
                            he.logError("Failed isAuthToGetPineSourceCode, reason: " + e)
                        }
                        ))
                    }
                    if (window.is_authenticated && (0,
                    F.isUserStudyWithLogs)(e) && (u.push(new c.Action({
                        actionId: "Chart.Indicator.PineLogs",
                        options: {
                            label: a.t(null, void 0, i(69056)),
                            statName: "PineLogs",
                            onExecute: ()=>{
                                (0,
                                H.openPineLogsInRightPanel)(e)
                            }
                        }
                    })),
                    u.push(new c.Separator)),
                    e.copiable()) {
                        const t = new ue.ActionWithStandardIcon({
                            actionId: "Chart.Clipboard.CopySource",
                            options: {
                                label: At,
                                shortcutHint: (0,
                                z.humanReadableHash)(z.Modifiers.Mod + 67),
                                statName: "Copy",
                                onExecute: ()=>{
                                    this._chartWidget.chartWidgetCollection().clipboard.uiRequestCopy([e])
                                }
                            }
                        });
                        u.push(t)
                    }
                    u.push(vi(this._chartWidget, [e])),
                    u.push(r.studyRemove);
                    const m = !this._chartWidget.onWidget() && this._options.objectTree && r.paneObjectTree
                      , g = Si();
                    (m || g) && (u.push(new c.Separator),
                    m && u.push(r.paneObjectTree),
                    g && u.push(this._chartWidget.actions().showDataWindow)),
                    u.push(new c.Separator),
                    l.enabled("property_pages") && new f.MetaInfoHelper(p).hasUserEditableOptions() && u.push(this._createActionShowProperties(e)),
                    u[u.length - 1]instanceof c.Separator && u.pop()
                }
                return u
            }
            _createLineToolTemplateAction(e) {
                {
                    const t = this._chartWidget.model()
                      , s = i=>{
                        t.applyLineToolTemplate(e, i, ke)
                    }
                    ;
                    return new c.Action({
                        actionId: "Chart.LineTool.Templates",
                        options: {},
                        optionsLoader: async()=>{
                            const {LinetoolTemplatesList: o} = await Promise.all([i.e(68541), i.e(5483), i.e(90728), i.e(3177)]).then(i.bind(i, 670019))
                              , n = new o(e.toolname,s)
                              , r = [];
                            if (l.enabled("drawing_templates")) {
                                const t = new ue.ActionWithStandardIcon({
                                    actionId: "Chart.LineTool.Templates.SaveAs",
                                    options: {
                                        label: It,
                                        statName: "SaveAs",
                                        onExecute: ()=>{
                                            n.showSaveDialog((t=>{
                                                const i = JSON.stringify(e.template());
                                                n.saveTemplate(t, i)
                                            }
                                            ))
                                        }
                                    }
                                });
                                r.push(t)
                            }
                            const a = new ue.ActionWithStandardIcon({
                                actionId: "Chart.LineTool.Templates.ApplyDefaults",
                                options: {
                                    label: Mt,
                                    statName: "ApplyDefault",
                                    onExecute: ()=>{
                                        t.restorePropertiesForSource(e),
                                        window.lineToolPropertiesToolbar.refresh()
                                    }
                                }
                            });
                            return r.push(a),
                            new Promise((e=>{
                                n.templatesLoaded().then((()=>{
                                    var e;
                                    const t = null !== (e = n.getData()) && void 0 !== e ? e : [];
                                    t.length > 0 && r.push(new c.Separator),
                                    t.forEach(((e,t)=>{
                                        const i = new ue.ActionWithStandardIcon({
                                            actionId: "Chart.LineTool.Templates.Apply",
                                            options: {
                                                label: e,
                                                statName: "ApplyTemplate",
                                                onExecute: ()=>n.loadTemplate(e),
                                                toolbox: {
                                                    type: U.ToolboxType.Delete,
                                                    action: ()=>{
                                                        n.deleteAction(e)
                                                    }
                                                },
                                                showToolboxOnHover: !0
                                            }
                                        });
                                        r.push(i)
                                    }
                                    ))
                                }
                                ), (e=>{
                                    he.logWarn(e)
                                }
                                )).then((()=>{
                                    e({
                                        label: Et,
                                        statName: "Template",
                                        subItems: r
                                    })
                                }
                                ))
                            }
                            ))
                        }
                    })
                }
            }
            _createActionToggleLockLineTools(e) {
                const t = e[0].properties().frozen.value()
                  , i = t ? Dt : Nt;
                return new ue.ActionWithStandardIcon({
                    actionId: "Chart.SelectedObject.ToggleLocked",
                    options: {
                        label: i,
                        statName: "ToggleLockSelectedObject",
                        checkable: !0,
                        iconId: t ? "Chart.UnlockObject" : "Chart.LockObject",
                        onExecute: ()=>{
                            if (1 === e.length)
                                this._chartWidget.toggleLockSelectedObject();
                            else {
                                const i = t ? Ne : De
                                  , s = this._chartWidget.model();
                                s.withMacro(i, (()=>{
                                    e.forEach((e=>{
                                        s.setProperty(e.properties().frozen, !t, i, ee.lineToolsDoNotAffectChartInvalidation)
                                    }
                                    ))
                                }
                                ))
                            }
                        }
                    }
                })
            }
            async _contextMenuActionsForLineTool(e) {
                const t = []
                  , i = this._chartWidget.actions()
                  , o = this._chartWidget.model().model()
                  , r = ()=>{
                    t.push(hi(this._chartWidget, e))
                }
                  , a = ()=>{
                    t.push(pi(this._chartWidget, e))
                }
                  , d = ()=>{
                    const i = e.filter((e=>e.cloneable()));
                    if (i.length > 0) {
                        const e = new ue.ActionWithStandardIcon({
                            actionId: "Chart.LineTool.Clone",
                            options: {
                                label: Lt,
                                iconId: "Chart.Clone",
                                shortcutHint: (0,
                                z.humanReadableModifiers)(z.Modifiers.Mod) + "Drag",
                                statName: "Clone",
                                onExecute: ()=>this._chartWidget.model().cloneLineTools(i, !1)
                            },
                            id: "Clone"
                        });
                        t.push(e)
                    }
                    return !!i.length
                }
                  , h = ()=>{
                    const i = e.filter((e=>e.copiable()));
                    if (i.length > 0) {
                        const e = new c.Action({
                            actionId: "Chart.Clipboard.CopyLineTools",
                            options: {
                                label: At,
                                shortcutHint: (0,
                                z.humanReadableHash)(z.Modifiers.Mod + 67),
                                statName: "Copy",
                                onExecute: ()=>this._chartWidget.chartWidgetCollection().clipboard.uiRequestCopy(i)
                            },
                            id: "Copy"
                        });
                        t.push(e)
                    }
                    return !!i.length
                }
                  , p = ()=>{
                    const i = _i(this._chartWidget, e);
                    return t.push(...i),
                    i.length > 0
                }
                  , m = async e=>{
                    if (this._chartWidget.model().isInReplay().value())
                        return;
                    const i = e.getOrderTemplate();
                    if (null === i)
                        return;
                    const r = (0,
                    b.tradingService)();
                    if (null !== r) {
                        const e = r.activeBroker();
                        if (e && 1 === e.connectionStatus() && e.metainfo().configFlags.supportLimitOrders) {
                            const a = o.mainSeries()
                              , {symbol: l} = await r.getActualSymbol(a.proSymbol())
                              , {tradable: d} = await e.isTradable(l);
                            if (d) {
                                const {qty: {step: o}} = await e.symbolInfo(l);
                                i.symbol = l,
                                i.qty = function(e, t) {
                                    return (0,
                                    n.Big)(e).div(t).round(void 0, 0).mul(t).toNumber()
                                }(i.qty, o),
                                t.push(new c.Separator),
                                t.push(function(e) {
                                    const t = (0,
                                    s.ensureNotNull)((0,
                                    b.tradingService)());
                                    return new ue.ActionWithStandardIcon({
                                        actionId: "Chart.LineTool.CreateLimitOrderFromState",
                                        options: {
                                            label: Fe,
                                            statName: "CreateLimitOrder",
                                            onExecute: ()=>{
                                                t.trackEvent("Chart Context Menu", "RiskRewardCreateLimitOrder"),
                                                (0,
                                                s.ensureNotNull)(t.brokerCommandsUI()).placeOrder(e)
                                            }
                                        }
                                    })
                                }(i))
                            }
                        } else
                            null === e && (t.push(new c.Separator),
                            t.push((0,
                            s.ensureNotNull)(function() {
                                const e = (0,
                                s.ensureNotNull)((0,
                                b.tradingService)());
                                return new c.Action({
                                    actionId: "Trading.ShowSelectBrokerPanel",
                                    options: {
                                        label: Fe,
                                        statName: "ShowSelectBrokerNotification",
                                        onExecute: ()=>{
                                            var t;
                                            (0,
                                            L.isMobileTradingAvailable)() && !(null === (t = window.TradingView.bottomWidgetBar) || void 0 === t ? void 0 : t.isVisible().value()) ? e.toggleTradingPanelPopup() : e.toggleTradingWidget(),
                                            e.onNeedSelectBroker.fire()
                                        }
                                    }
                                })
                            }())))
                    }
                }
                  , g = e=>{
                    const i = new ue.ActionWithStandardIcon({
                        actionId: "Chart.ScrollToLineTool",
                        options: {
                            label: kt.format({
                                lineToolName: e.title(u.TitleDisplayTarget.StatusLine)
                            }),
                            statName: "GoToLineTool",
                            checkable: !1,
                            onExecute: async()=>this._chartWidget.model().scrollToLineTool(e)
                        }
                    });
                    t.push(i)
                }
                  , _ = e=>{
                    const t = this._chartWidget.model().model().lineToolsGroupModel()
                      , i = e.map((e=>t.groupForLineTool(e)));
                    return new Set(i).size <= 1
                }
                ;
                if (1 === e.length) {
                    const s = e[0];
                    if (this._chartWidget.readOnly())
                        t.push(vi(this._chartWidget, [s]));
                    else if (s.userEditEnabled()) {
                        if (W.alertsAvailable && !this._chartWidget.onWidget()) {
                            const e = await (0,
                            ae.getAlertsChartActionCreators)();
                            if (s.hasAlert && s.hasAlert().value())
                                t.push(e.editAlertOnLineDataSource(s)),
                                t.push(new c.Separator);
                            else if (s.canHasAlert() && s.alertCreationAvailable().value()) {
                                const i = e.createAlert(this._chartWidget, {
                                    drawing: s
                                });
                                null !== i && (t.push(i),
                                t.push(new c.Separator))
                            }
                        }
                        {
                            const e = this._createLineToolTemplateAction(s);
                            null !== e && t.push(e)
                        }
                        r(),
                        a(),
                        this._options.objectTree && i.paneObjectTree && t.push(i.paneObjectTree),
                        await m(s),
                        t.push(new c.Separator);
                        let e = d();
                        e = h() || e,
                        e && t.push(new c.Separator),
                        e = p(),
                        e && t.push(new c.Separator),
                        t.push(this._createActionToggleLockLineTools([s])),
                        t.push(vi(this._chartWidget, [s])),
                        t.push(i.lineRemove),
                        s.points().length > 0 && this._options.gotoLineTool && (t.push(new c.Separator),
                        g(s));
                        const o = await this._chartWidget.propertiesDefinitionsForSource(s);
                        if (l.enabled("property_pages") && null !== o && (t.push(new c.Separator),
                        t.push(i.format)),
                        s.additionalActions) {
                            t.push(new c.Separator);
                            const e = s.additionalActions(this._chartWidget.model());
                            t.push(...e)
                        }
                    }
                } else
                    this._options.objectTree && i.paneObjectTree && t.push(i.paneObjectTree),
                    _(e) && r(),
                    a(),
                    t.length > 0 && t.push(new c.Separator),
                    d(),
                    h(),
                    p(),
                    t.push(new c.Separator),
                    t.push(this._createActionToggleLockLineTools(e)),
                    t.push(vi(this._chartWidget, e)),
                    t.push(i.lineRemove),
                    l.enabled("property_pages") && (t.push(new c.Separator),
                    t.push(i.format));
                return t
            }
            _createEarningsShow() {
                const e = this._chartWidget.model().mainSeries().properties().childs().esdShowEarnings;
                return new c.Action({
                    actionId: "Chart.ToggleVisibility.Earnings",
                    options: {
                        label: Bt,
                        checkable: !0,
                        checked: e.value(),
                        name: "ToggleShowEarnings",
                        statName: "ToggleShowEarnings",
                        onExecute: t=>this._chartWidget.model().setProperty(e, t.isChecked(), ve)
                    }
                })
            }
            _createDividendsShow() {
                const e = this._chartWidget.model().mainSeries().properties().childs().esdShowDividends;
                return new c.Action({
                    actionId: "Chart.ToggleVisibility.Dividends",
                    options: {
                        label: Rt,
                        checkable: !0,
                        checked: e.value(),
                        name: "ToggleShowDividends",
                        statName: "ToggleShowDividends",
                        onExecute: t=>this._chartWidget.model().setProperty(e, t.isChecked(), Se)
                    }
                })
            }
            _createSplitsShow() {
                const e = this._chartWidget.model().mainSeries().properties().childs().esdShowSplits;
                return new c.Action({
                    actionId: "Chart.ToggleVisibility.Splits",
                    options: {
                        checkable: !0,
                        label: Ot,
                        checked: e.value(),
                        name: "ToggleShowSplits",
                        statName: "ToggleShowSplits",
                        onExecute: t=>this._chartWidget.model().setProperty(e, t.isChecked(), fe)
                    }
                })
            }
            _contextMenuActionsForESD() {
                const e = [];
                return this._chartWidget.readOnly() || e.push((0,
                s.ensureNotNull)(this._createDividendsShow()), (0,
                s.ensureNotNull)(this._createSplitsShow()), (0,
                s.ensureNotNull)(this._createEarningsShow())),
                e
            }
            _contextMenuActionsForRollDates() {
                const e = [];
                if (!this._chartWidget.readOnly()) {
                    const t = this._chartWidget.model().mainSeries().properties().childs().showContinuousContractSwitches;
                    e.push(new c.Action({
                        actionId: "Chart.ToggleVisibility.ContinuousContractSwitch",
                        options: {
                            label: Vt,
                            checkable: !0,
                            checked: t.value(),
                            name: "ToggleShowContractSwitches",
                            statName: "ToggleShowContractSwitches",
                            onExecute: e=>this._chartWidget.model().setProperty(t, e.isChecked(), be)
                        }
                    }))
                }
                return e
            }
            _contextMenuActionsForFuturesContractExpiration() {
                const e = [];
                if (!this._chartWidget.readOnly()) {
                    const t = this._chartWidget.model().mainSeries().properties().childs().showFuturesContractExpiration;
                    e.push(new c.Action({
                        actionId: "Chart.ToggleVisibility.ContractExpiration",
                        options: {
                            label: Wt,
                            checkable: !0,
                            checked: t.value(),
                            name: "ToggleShowFuturesContractExpirations",
                            statName: "ToggleShowFuturesContractExpirations",
                            onExecute: e=>this._chartWidget.model().setProperty(t, e.isChecked(), ye)
                        }
                    }))
                }
                return e
            }
            _contextMenuActionsForisLatestUpdates() {
                const e = [];
                if (!this._chartWidget.readOnly()) {
                    const t = this._chartWidget.model().mainSeries().properties().childs().showLastNews;
                    e.push(new c.Action({
                        actionId: "Chart.ToggleVisibility.LatestNewsAndMinds",
                        options: {
                            label: Ht,
                            checkable: !0,
                            checked: t.value(),
                            name: "ToggleShowLatestUpdates",
                            statName: "ToggleShowLatestUpdates",
                            onExecute: e=>this._chartWidget.model().setProperty(t, e.isChecked(), we)
                        }
                    }))
                }
                return e
            }
            _contextMenuActionsForKeyFactsToday() {
                const e = [];
                if (!this._chartWidget.readOnly()) {
                    const t = this._chartWidget.model().mainSeries().properties().childs().showKeyFactsToday;
                    e.push(new c.Action({
                        actionId: "Chart.ToggleVisibility.KeyFactsToday",
                        options: {
                            label: Ft,
                            checkable: !0,
                            checked: t.value(),
                            name: "ToggleShowKeyFactsToday",
                            statName: "ToggleShowKeyFactsToday",
                            onExecute: e=>this._chartWidget.model().setProperty(t, e.isChecked(), Ce)
                        }
                    }))
                }
                return e
            }
            _contextMenuActionsForPublishedTimeline(e) {
                const t = this._chartWidget.actions()
                  , i = [];
                if (i.push(t.lineHide),
                window.is_authenticated) {
                    const t = e.properties().childs().filter
                      , s = new c.Action({
                        actionId: "Chart.ShowAllIdeas",
                        options: {
                            checked: t.value() === M.PublishedChartsFilter.None,
                            checkable: !0,
                            label: zt,
                            name: "ToggleAllIdeas",
                            statName: "ToggleAllIdeas",
                            onExecute: ()=>this._chartWidget.model().setProperty(t, M.PublishedChartsFilter.None, Te)
                        }
                    })
                      , o = new c.Action({
                        actionId: "Chart.ShowIdeasOfFollowedUsers",
                        options: {
                            checked: t.value() === M.PublishedChartsFilter.Following,
                            checkable: !0,
                            label: Ut,
                            name: "ToggleIdeasOfPeopleAndUser",
                            statName: "ToggleIdeasOfPeopleAndUser",
                            onExecute: ()=>this._chartWidget.model().setProperty(t, M.PublishedChartsFilter.Following, Pe)
                        }
                    })
                      , n = new c.Action({
                        actionId: "Chart.ShowMyIdeasOnly",
                        options: {
                            checked: t.value() === M.PublishedChartsFilter.Private,
                            checkable: !0,
                            label: Gt,
                            name: "ToggleUserIdeas",
                            statName: "ToggleUserIdeas",
                            onExecute: ()=>this._chartWidget.model().setProperty(t, M.PublishedChartsFilter.Private, xe)
                        }
                    });
                    i.push(new c.Separator, s, o, n)
                }
                return i
            }
            _contextMenuActionsForTradingDrawings(e) {
                return e.contextMenuItems()
            }
            async _contextMenuActionsForAlertLabel(e, t) {
                if (W.alertsAvailable && !this._chartWidget.onWidget()) {
                    const {getAlertLabelContextMenuActions: s} = await i.e(46745).then(i.bind(i, 697395))
                      , o = (0,
                    _.getSettingsProperty)().childs().line.childs().visible
                      , n = `chart_alert_context_menu_${null != t ? t : "line"}`
                      , r = "chart_alert";
                    return s({
                        alert: e,
                        chartWidget: this._chartWidget,
                        labelExtendProperty: o,
                        analytics: {
                            actionLabel: n,
                            actionSource: r
                        }
                    })
                }
                return []
            }
            _contextMenuActionsForChartEvents(e) {
                const t = [];
                if (l.enabled("property_pages")) {
                    const e = new c.Action({
                        actionId: "Chart.Dialogs.ShowGeneralSettings.EventsAndAlertsTab",
                        options: {
                            label: jt,
                            statName: "Format",
                            onExecute: ()=>this._chartWidget.showGeneralChartProperties(p.TabNames.eventsAndAlerts)
                        }
                    });
                    t.push(e)
                }
                const i = new c.Action({
                    actionId: "Chart.ToggleVisibility.EconomicEvents",
                    options: {
                        label: qt,
                        name: "HideEvents",
                        statName: "HideEvents",
                        onExecute: ()=>this._chartWidget.model().setProperty(e.properties().childs().visible, !1, Me)
                    }
                });
                return t.push(i),
                t
            }
            _createApplyToEntireLayoutCommand(e) {
                if (!this._chartWidget.chartWidgetCollection().applyIndicatorsToAllChartsAvailable())
                    return null;
                const t = this._chartWidget.model().model();
                if (e.parentSources().length > 0)
                    return null;
                const i = (0,
                s.ensureNotNull)(t.paneForSource(e))
                  , o = t.paneForSource(t.mainSeries()) === i
                  , n = e instanceof G.StudyCompare && e.priceScale() === t.mainSeries().priceScale() && (0,
                s.ensureNotNull)(e.priceScale()).isPercentage()
                  , r = o ? void 0 : t.panes().indexOf(i);
                let a = Kt
                  , l = Ae
                  , d = "AddStudyToEntireLayout";
                return (0,
                Y.isActingAsSymbolSource)(e) && (a = Xt,
                l = Ie,
                d = "AddSymbolToEntireLayout"),
                (0,
                h.isStudyStrategy)(e) && (a = Yt,
                l = Le,
                d = "AddStrategyToEntireLayout"),
                (0,
                h.isFundamentalStudy)(e) && (a = Zt,
                l = Ee,
                d = "AddFundamentalToEntireLayout"),
                new c.Action({
                    actionId: "Chart.AddIndicatorToAllCharts",
                    options: {
                        label: a,
                        statName: d,
                        onExecute: ()=>{
                            const i = (0,
                            s.ensureNotNull)((0,
                            X.clipboardDataForSources)(t.id(), [e]))
                              , a = this._chartWidget.chartWidgetCollection()
                              , c = {
                                isOnMainPane: o,
                                asCompare: n,
                                paneIndex: r
                            };
                            a.applyIndicatorToAllCharts(this._chartWidget, i, c, l)
                        }
                    },
                    id: "applyStudyToEntireLayout"
                })
            }
            _createAddIndicatorToFavoritesCommand(e) {
                const t = e.metaInfo();
                let s;
                if ((0,
                B.onWidget)() || (0,
                h.isCompareOrOverlayStudy)(e))
                    return null;
                if ((0,
                h.isFundamentalStudy)(e)) {
                    const e = (0,
                    le.extractPineId)(t.fullId);
                    if (!e)
                        return null;
                    s = ()=>i.e(69790).then(i.bind(i, 257015)).then((({FavoriteFundamentals: t})=>{
                        const i = t.getInstance();
                        return {
                            label: i.isFav(e) ? ai : ri,
                            onExecute: ()=>i.toggleFavorite(e)
                        }
                    }
                    ))
                } else {
                    const e = t.scriptIdPart || t.id;
                    if (!e)
                        return null;
                    s = ()=>i.e(69790).then(i.bind(i, 725897)).then((({FavoriteScriptsModel: t})=>{
                        const i = t.getInstance();
                        return {
                            label: i.isFav(e) ? ni : oi,
                            onExecute: ()=>i.toggleFavorite(e)
                        }
                    }
                    ))
                }
                return new c.Action({
                    actionId: "Chart.Indicator.AddFavorites",
                    id: "addIndicatorToFavorites",
                    optionsLoader: s,
                    options: {
                        statName: "AddIndicatorToFavorites"
                    }
                })
            }
        }
    }
    ,
    100716: (e,t,i)=>{
        "use strict";
        var s;
        i.d(t, {
            AlertEditorAbortReason: ()=>s
        }),
        function(e) {
            e.AlertIsInvalid = "alert-is-invalid",
            e.AlertsMaintenance = "alerts-maintenance",
            e.ChartModelNotFound = "chart-model-not-found",
            e.IsAlreadyPresent = "is-already-present",
            e.MainSeriesIsATR = "main-series-is-atr",
            e.MainSeriesIsPercentageLTP = "main-series-is-percentage-ltp",
            e.MainSeriesIsInReplay = "main-series-is-in-replay",
            e.MainSeriesIsOffline = "main-series-is-offline",
            e.SourceIsDangerous = "source-is-dangerous",
            e.SymbolInfoTimeout = "symbol-info-timeout",
            e.SymbolIsInvalid = "symbol-is-invalid",
            e.SymbolCurrencyConverted = "symbol-currency-converted",
            e.SymbolUnitConverted = "symbol-unit-converted",
            e.SymbolCurrencyAndUnitConverted = "symbol-currency-and-unit-converted",
            e.SymbolIsEconomics = "symbol-is-economics",
            e.UnsupportedResolution = "unsupported-resolution",
            e.ManualAbort = "manual-abort",
            e.MisleadingPriceScale = "misleading-price-scale",
            e.ResolutionIsTicks = "resolution-is-ticks"
        }(s || (s = {}))
    }
    ,
    848891: (e,t,i)=>{
        "use strict";
        i.d(t, {
            Animation: ()=>r
        });
        var s = i(930203)
          , o = i(939656);
        const n = {
            duration: 250,
            easing: s.easingFunc.easeOutCubic
        };
        class r {
            constructor(e) {
                this._onFinishCalled = !1,
                this._options = {
                    ...n,
                    ...e
                },
                this._startTime = performance.now()
            }
            getStartPosition() {
                return this._options.from
            }
            getPosition(e) {
                const t = this._calculateProgress(e);
                return 1 === t ? (this._options.onFinish && !this._onFinishCalled && (this._options.onFinish(!0),
                this._onFinishCalled = !0),
                this._options.to) : (0,
                o.lerp)(this._options.from, this._options.to, this._options.easing(t))
            }
            finished(e) {
                return 1 === this._calculateProgress(e)
            }
            onFinish(e) {
                var t, i;
                this._onFinishCalled || (null === (i = (t = this._options).onFinish) || void 0 === i || i.call(t, e),
                this._onFinishCalled = !0)
            }
            _calculateProgress(e) {
                const t = e - this._startTime;
                return t >= this._options.duration ? 1 : t / this._options.duration
            }
        }
    }
    ,
    898192: (e,t,i)=>{
        "use strict";
        i.d(t, {
            clipboardDataForSources: ()=>l,
            isLineToolClipboardData: ()=>a
        });
        var s = i(650151)
          , o = i(287741)
          , n = i(434396)
          , r = i(465836);
        function a(e) {
            return "drawing" === e.type
        }
        function l(e, t) {
            if (1 === t.length && (0,
            n.isStudy)(t[0])) {
                const e = t[0];
                return {
                    title: e.title(o.TitleDisplayTarget.StatusLine),
                    sources: [{
                        source: (0,
                        s.ensureNotNull)(e.state()),
                        type: "study"
                    }]
                }
            }
            const i = {
                sources: [],
                title: ""
            };
            return i.sources = t.filter((e=>e.copiable() && (0,
            r.isLineTool)(e))).map((t=>{
                const i = {
                    type: "drawing",
                    geometry: t.geometry(),
                    source: {
                        ...t.state(!1),
                        points: t.normalizedPoints()
                    },
                    modelId: e
                };
                return delete i.source.alertId,
                i
            }
            )),
            i.sources.length > 0 ? (1 === i.sources.length ? i.title = t[0].title(o.TitleDisplayTarget.StatusLine) : i.title = "Drawings",
            i) : null
        }
    }
    ,
    895366: (e,t,i)=>{
        "use strict";
        i.d(t, {
            ChartHotkeysListener: ()=>S,
            globalEnvironmentState: ()=>v,
            modifierPressed: ()=>_,
            shiftPressed: ()=>g
        });
        var s, o, n, r = i(799786), a = i(470316), l = i(515312), c = i(978296), d = i(970427);
        const u = new c.WatchedValue(Boolean((null !== (s = r.pressedKeys.value()) && void 0 !== s ? s : 0) & a.Modifiers.Shift))
          , h = new c.WatchedValue(Boolean((null !== (o = r.pressedKeys.value()) && void 0 !== o ? o : 0) & a.Modifiers.Mod))
          , p = new c.WatchedValue(Boolean((null !== (n = r.pressedKeys.value()) && void 0 !== n ? n : 0) & a.Modifiers.Alt))
          , m = [a.Modifiers.None, a.Modifiers.Alt, a.Modifiers.Mod, a.Modifiers.Alt + a.Modifiers.Shift];
        function g() {
            return u
        }
        function _() {
            return h
        }
        function v() {
            return new d.EnvironmentState({
                altKey: p.value(),
                ctrlKey: _().value(),
                metaKey: _().value(),
                shiftKey: g().value()
            })
        }
        r.pressedKeys.subscribe(((e=0)=>{
            u.setValue(Boolean(e & a.Modifiers.Shift)),
            h.setValue(Boolean(e & a.Modifiers.Mod)),
            p.setValue(Boolean(e & a.Modifiers.Alt))
        }
        ));
        class S {
            constructor(e, t) {
                this._pressedKeyCode = null,
                this._boundKeydownHandler = null,
                this._boundKeyupHandler = null,
                this._chartWidget = e,
                this._parent = t,
                this._boundKeydownHandler = this._keydownHandler.bind(this),
                this._boundKeyupHandler = this._keyupHandler.bind(this),
                this._parent.ownerDocument.addEventListener("keydown", this._boundKeydownHandler),
                this._parent.ownerDocument.addEventListener("keyup", this._boundKeyupHandler)
            }
            destroy() {
                null !== this._boundKeydownHandler && (this._parent.ownerDocument.removeEventListener("keydown", this._boundKeydownHandler),
                this._boundKeydownHandler = null),
                null !== this._boundKeyupHandler && (this._parent.ownerDocument.removeEventListener("keyup", this._boundKeyupHandler),
                this._boundKeyupHandler = null)
            }
            _keydownHandler(e) {
                this._chartWidget.hasModel() && window.document.activeElement === window.document.body && this._chartWidget.isActive().value() && (e.defaultPrevented || (this._handleMoveDrawingsKeyDown(e) || this._handleScrollKeyDown(e) || this._handleZoomKeyDown(e)) && e.preventDefault())
            }
            _keyupHandler(e) {
                this._chartWidget.hasModel() && this._handleScrollKeyUp(e)
            }
            _handleMoveDrawingsKeyDown(e) {
                const t = 255 & (0,
                a.hashFromEvent)(e)
                  , i = this._chartWidget.model();
                switch (t) {
                case 37:
                    return i.moveSelectedToolsLeft();
                case 39:
                    return i.moveSelectedToolsRight();
                case 38:
                    return i.moveSelectedToolsUp();
                case 40:
                    return i.moveSelectedToolsDown()
                }
                return !1
            }
            _handleScrollKeyDown(e) {
                if (null !== this._pressedKeyCode)
                    return !1;
                const t = (0,
                a.hashFromEvent)(e)
                  , i = 255 & t
                  , s = (0,
                a.modifiersFromEvent)(e);
                let o;
                if (37 === i)
                    o = 1;
                else {
                    if (39 !== i)
                        return !1;
                    o = -1
                }
                return !(a.isMacKeyboard && s === a.Modifiers.Mod || !m.includes(s)) && (!(0,
                l.isNativeUIInteraction)(t, e.target) && (this._pressedKeyCode = i,
                s === a.Modifiers.None ? this._chartWidget.scrollHelper().moveByBar(o) : s === a.Modifiers.Alt || s === a.Modifiers.Mod ? this._chartWidget.scrollHelper().move(o) : -1 === o ? this._chartWidget.model().timeScale().scrollToRealtime(!0) : this._chartWidget.model().timeScale().scrollToFirstBar(),
                !0))
            }
            _handleScrollKeyUp(e) {
                if (null === this._pressedKeyCode)
                    return !1;
                const t = (0,
                a.hashFromEvent)(e);
                if ((0,
                l.isNativeUIInteraction)(t, e.target))
                    return !1;
                return (255 & t) === this._pressedKeyCode && (this._pressedKeyCode = null,
                this._chartWidget.scrollHelper().stopMove(),
                !0)
            }
            _handleZoomKeyDown(e) {
                const t = (0,
                a.hashFromEvent)(e)
                  , i = 255 & t;
                if ((0,
                a.modifiersFromEvent)(e) !== a.Modifiers.Mod || (0,
                l.isNativeUIInteraction)(t, e.target))
                    return !1;
                const s = this._chartWidget.model();
                if (38 === i)
                    s.zoomIn();
                else {
                    if (40 !== i)
                        return !1;
                    s.zoomOut()
                }
                return !0
            }
        }
    }
    ,
    238874: (e,t,i)=>{
        "use strict";
        i.r(t),
        i.d(t, {
            activeLinkingGroupWV: ()=>Du,
            allInitialModelsCreated: ()=>mu,
            allInitialSymbolsResolved: ()=>pu,
            allLinkingGroupsWV: ()=>Bu,
            applyIndicatorToAllChartsImpl: ()=>bd,
            applyIndicatorsToAllChartsImpl: ()=>fd,
            applyLineToolUpdateNotificationImpl: ()=>xd,
            applyStudiesOverrides: ()=>$u,
            applyThemeImpl: ()=>vu,
            chartsSymbolsImpl: ()=>Ld,
            checkProFeatureImpl: ()=>gu,
            combinedTrackTimeLock: ()=>Fu,
            computeContentBoxImpl: ()=>Hd,
            copyScreenshotToClipboard: ()=>Rd,
            createBroadcastChannel: ()=>du,
            createChartStorageSubscriptionsIfRequired: ()=>Ed,
            createChartWidgetCollectionNewsNotifier: ()=>kd,
            createClipboardHandler: ()=>Id,
            createLeftBottomChartWidgetWV: ()=>Vd,
            deserializedChartIds: ()=>Td,
            destroyBroadcastChannel: ()=>uu,
            downloadScreenshot: ()=>Bd,
            generateNewChartId: ()=>Zd,
            getAllLinkingGroups: ()=>Nu,
            getChartWidgetsForIntervalLock: ()=>Lu,
            getClientSnapshot: ()=>Fd,
            getLinkingGroupCharts: ()=>Ru,
            getSnapshot: ()=>Wd,
            getStateForChartImpl: ()=>wd,
            getVisuallyAdjacentDefImpl: ()=>Kd,
            handleConnectionLimitReachedChanged: ()=>Vu,
            handleDateRangeLockChange: ()=>wu,
            handleInternalDateRangeLockChange: ()=>Cu,
            handleInternalIntervalLockChange: ()=>bu,
            handleInternalSymbolLockChange: ()=>Su,
            handleInternalTrackTimeLockChange: ()=>Tu,
            handleIntervalLockChange: ()=>yu,
            handleSymbolLockChange: ()=>fu,
            handleTrackTimeLockChange: ()=>Pu,
            hideChartImpl: ()=>eu,
            lineToolsAndGroupsDTOsImpl: ()=>Cd,
            removeChartWidgetSubscriptionsImpl: ()=>iu,
            resetLayoutSizesImpl: ()=>Gd,
            resetLineToolsInvalidatedImpl: ()=>Pd,
            setBrokerImpl: ()=>Ad,
            setChartLayoutWithUndoImpl: ()=>_u,
            setChartStyleToWidget: ()=>Iu,
            setLayoutImpl: ()=>au,
            setResolution: ()=>Eu,
            setSymbol: ()=>Mu,
            setSymbolAll: ()=>xu,
            someOfWidgetsAreInSelectingReplayPointMode: ()=>Wu,
            stateImpl: ()=>Yu,
            subscribeToCompletedEventForDateRangeUpdate: ()=>Hu,
            subscribeToEventsForDateRangeSync: ()=>ju,
            syncChartsDateRangesWithActiveChartRange: ()=>Ku,
            syncCrosshairImpl: ()=>cu,
            syncScrollImpl: ()=>hu,
            takeScreenshot: ()=>Dd,
            takeServerScreenshot: ()=>Nd,
            unloadUnusedChartsImpl: ()=>su,
            unsubscribeFromEventsForDateRangeSync: ()=>qu,
            updateLayoutImpl: ()=>Xd,
            updateLayoutPartialImpl: ()=>qd,
            updateLinkingGroupCharts: ()=>Ou
        });
        var s = i(650151)
          , o = i(86441)
          , n = i(338619)
          , r = i(444372)
          , a = i(912445)
          , l = i(638456)
          , c = i(370407)
          , d = i(953297);
        function u(e) {
            const t = {};
            return {
                promise: new Promise(((i,s)=>{
                    e.subscribe(t, i, !0)
                }
                )),
                destroy: ()=>{
                    e.unsubscribeAll(t)
                }
            }
        }
        var h = i(978296)
          , p = i(26829)
          , m = i(669763);
        class g extends m.UndoCommand {
            constructor(e, t) {
                super(null),
                this._chartModel = e,
                this._targetIndex = t
            }
            redo() {
                const e = this._chartModel.createPane(this._targetIndex, void 0, this._paneId);
                this._paneId = e.id()
            }
            undo() {
                const e = (0,
                s.ensureDefined)(this._paneId)
                  , t = this._chartModel.panes().find((t=>t.id() === e));
                void 0 !== t && this._chartModel.removePane(t)
            }
            createdPaneId() {
                return this._paneId
            }
        }
        class _ extends m.UndoCommand {
            constructor(e, t, i, s) {
                super(s),
                this._setter = e,
                this._oldValue = t,
                this._newValue = i
            }
            redo() {
                this._setter(this._newValue)
            }
            undo() {
                this._setter(this._oldValue)
            }
        }
        class v extends _ {
            constructor(e, t, i, s) {
                super((e=>this._vwState.setValue(e)), t, i, s),
                this._vwState = e
            }
        }
        var S = i(433524)
          , f = i(963239)
          , b = i(793993);
        const y = (0,
        n.getLogger)("Clipboard");
        class C {
            constructor(e) {
                this._e = e
            }
            write(e) {
                return (0,
                f.writeImpl)(this._toRaw(e), this._e)
            }
            _toRaw(e) {
                const t = {
                    files: []
                };
                t.text = e.text,
                void 0 !== e.app ? t.html = this._serializeAppData(e.app, e.text) : e.html && (t.html = e.html);
                for (const i of e.files || [])
                    t.files.push(i);
                return t
            }
            _serializeAppData(e, t) {
                return `<meta charset="utf-8"><span data-tradingview-clip="${(0,
                S.htmlEscape)(e)}">${t ? (0,
                S.htmlEscape)(t.slice(0, 256)) : "&#128200;"}</span>`
            }
        }
        class w {
            constructor(e) {
                this._e = e
            }
            async read() {
                this._e && 0 === this._e.eventPhase && (y.logWarn("Cannot use an already dispatched ClipboardEvent for reading"),
                this._e = null);
                const e = this._e ? this._readUsingEvent(this._e) : await this._readUsingApi();
                return this._fromRaw(e)
            }
            _readUsingEvent(e) {
                const t = (0,
                s.ensure)(e.clipboardData);
                e.preventDefault();
                const i = {
                    files: []
                };
                for (let e = 0; e < t.files.length; e++)
                    i.files.push(t.files[e]);
                for (let e = 0; e < t.items.length; e++) {
                    const s = t.items[e];
                    "string" === s.kind && ("text/plain" === s.type ? i.text = t.getData(s.type) : "text/html" === s.type ? i.html = t.getData(s.type) : i.files.push(new Blob([t.getData(s.type)],{
                        type: s.type
                    })))
                }
                return i
            }
            async _readUsingApi() {
                const e = (0,
                b.getClipboard)();
                if (!e || !e.read)
                    throw new DOMException("ClipboardApi is not supported","NotSupportedError");
                let t, i;
                const s = []
                  , o = await e.read();
                for (const e of o)
                    for (const o of e.types)
                        "text/html" === o ? t = e.getType(o).then(this._readBlobAsText) : "text/plain" === o ? i = e.getType(o).then(this._readBlobAsText) : s.push(e.getType(o));
                return {
                    text: await i,
                    html: await t,
                    files: await Promise.all(s)
                }
            }
            _fromRaw(e) {
                const t = {};
                if (void 0 !== e.text && (t.text = e.text),
                void 0 !== e.html) {
                    const i = this._parseAppData(e.html);
                    i ? t.app = i : t.html = e.html
                }
                return e.files.length > 0 && (t.files = e.files),
                t
            }
            _parseAppData(e) {
                if (-1 === e.slice(0, 1024).indexOf("data-tradingview-clip"))
                    return;
                const t = (new DOMParser).parseFromString(e, "text/html").querySelector("[data-tradingview-clip]");
                return t ? t.getAttribute("data-tradingview-clip") || "" : void 0
            }
            _readBlobAsText(e) {
                return new Promise(((t,i)=>{
                    const s = new FileReader;
                    s.onloadend = ()=>{
                        t(s.result)
                    }
                    ,
                    s.onerror = ()=>{
                        i(s.error)
                    }
                    ,
                    s.readAsText(e)
                }
                ))
            }
        }
        var T = i(515312);
        function P(e) {
            const t = e.target;
            return null !== t && 1 === t.nodeType && (0,
            T.isTextEditingField)(t)
        }
        function x(e) {
            const t = e.target;
            if (null === t)
                return !1;
            const i = (t.ownerDocument || t).getSelection();
            return null !== i && !i.isCollapsed
        }
        class M extends class {
            constructor(e) {
                this._callbacks = Object.assign({}, e),
                this._boundOnCopy = this._onCopyEv.bind(this),
                this._boundOnCut = this._onCutEv.bind(this),
                this._boundOnPaste = this._onPasteEv.bind(this)
            }
            listen() {
                document.addEventListener("copy", this._boundOnCopy),
                document.addEventListener("cut", this._boundOnCut),
                document.addEventListener("paste", this._boundOnPaste)
            }
            async peek() {
                if ("granted" !== (await navigator.permissions.query({
                    name: "clipboard-read"
                })).state)
                    throw new Error("clipboard-read is not granted");
                return new w(null).read()
            }
            uiRequestCopy(e) {
                this._callbacks.copyRequested && this._callbacks.copyRequested(new C(null), e)
            }
            uiRequestCut(e) {
                this._callbacks.cutRequested && this._callbacks.cutRequested(new C(null), e)
            }
            uiRequestPaste(e) {
                this._callbacks.pasteRequested && this._callbacks.pasteRequested(new w(null), e)
            }
            destroy() {
                document.removeEventListener("copy", this._boundOnCopy),
                document.removeEventListener("cut", this._boundOnCut),
                document.removeEventListener("paste", this._boundOnPaste)
            }
            _onCopyEv(e) {
                e.defaultPrevented || this._callbacks.copyRequested && this._callbacks.copyRequested(new C(e))
            }
            _onCutEv(e) {
                e.defaultPrevented || this._callbacks.cutRequested && this._callbacks.cutRequested(new C(e))
            }
            _onPasteEv(e) {
                e.defaultPrevented || this._callbacks.pasteRequested && this._callbacks.pasteRequested(new w(e))
            }
        }
        {
            _onCopyEv(e) {
                if (!P(e) && !x(e))
                    return super._onCopyEv(e)
            }
            _onCutEv(e) {
                if (!P(e) && !x(e))
                    return super._onCutEv(e)
            }
            _onPasteEv(e) {
                if (!P(e))
                    return super._onPasteEv(e)
            }
        }
        const I = ()=>Promise.all([i.e(21630), i.e(54389)]).then(i.bind(i, 29425));
        function A(e, t={}) {
            return I().then((i=>i.copyToClipboardImageOfChart(e, t)))
        }
        function L(e, t={}) {
            return I().then((i=>i.getImageOfChartSilently(e, t)))
        }
        var E = i(936442)
          , k = i(470316)
          , D = i(588948)
          , N = i(472512);
        const B = (0,
        n.getLogger)("TimingsMeter.Service")
          , R = (0,
        n.getLogger)("TimingsMeter.Stats", {
            maxCount: 160
        });
        function O() {
            return {
                [N.InvalidationLevel.None]: {
                    count: 0,
                    lastTime: 0,
                    maxTime: 0,
                    totalTime: 0
                },
                [N.InvalidationLevel.Cursor]: {
                    count: 0,
                    lastTime: 0,
                    maxTime: 0,
                    totalTime: 0
                },
                [N.InvalidationLevel.Light]: {
                    count: 0,
                    lastTime: 0,
                    maxTime: 0,
                    totalTime: 0
                },
                [N.InvalidationLevel.Full]: {
                    count: 0,
                    lastTime: 0,
                    maxTime: 0,
                    totalTime: 0
                }
            }
        }
        function V(e, t) {
            e.lastTime = t,
            e.totalTime += t,
            ++e.count,
            t > e.maxTime && (e.maxTime = t)
        }
        function W(e) {
            return e.toFixed(2)
        }
        function F(e) {
            const t = e.count;
            if (0 === t)
                return "no events";
            const i = e.totalTime / t
              , s = W(e.maxTime);
            return `count=${t}, last=${W(e.lastTime)}, max=${s}, avg=${W(i)}`
        }
        class H {
            constructor(e) {
                this._waitDrawStartTime = -1,
                this._startDrawTime = -1,
                this._currentDrawLevel = N.InvalidationLevel.Full,
                this._currentDrawItems = O(),
                this._currentWaitingItem = {
                    count: 0,
                    lastTime: 0,
                    maxTime: 0,
                    totalTime: 0
                },
                this._dumpTimingsStatsInterval = 0,
                this._logPrefix = `[${e}]`
            }
            destroy() {
                this.stopCollect()
            }
            startCollect() {
                0 !== this._dumpTimingsStatsInterval && (B.logWarn(`${this._logPrefix} Multiple start detected`),
                this.stopCollect()),
                this._clearCurrentState(),
                this._dumpTimingsStatsInterval = setInterval(this._dumpTimingsStats.bind(this), 15e3),
                B.logNormal(`${this._logPrefix} Collecting started`)
            }
            stopCollect() {
                0 !== this._dumpTimingsStatsInterval && (clearInterval(this._dumpTimingsStatsInterval),
                this._dumpTimingsStatsInterval = 0,
                B.logNormal(`${this._logPrefix} Collecting stopped. Dumping last state...`),
                this._dumpTimingsStats())
            }
            startWaitingDraw() {
                this._waitDrawStartTime = window.performance.now()
            }
            startDraw(e) {
                this._startDrawTime = window.performance.now(),
                this._currentDrawLevel = e
            }
            stopDraw() {
                const e = window.performance.now();
                if (-1 === this._startDrawTime || -1 === this._waitDrawStartTime)
                    return;
                const t = this._startDrawTime - this._waitDrawStartTime;
                V(this._currentWaitingItem, t),
                this._waitDrawStartTime = -1;
                const i = e - this._startDrawTime;
                V(this._currentDrawItems[this._currentDrawLevel], i),
                this._startDrawTime = -1
            }
            _dumpTimingsStats() {
                const e = [this._logPrefix, " awaiting:", F(this._currentWaitingItem), "; cursor:", F(this._currentDrawItems[N.InvalidationLevel.Cursor]), "; light:", F(this._currentDrawItems[N.InvalidationLevel.Light]), "; full:", F(this._currentDrawItems[N.InvalidationLevel.Full])].join("");
                R.logNormal(e),
                this._clearCurrentState()
            }
            _clearCurrentState() {
                this._currentDrawItems = O(),
                this._currentWaitingItem = {
                    count: 0,
                    lastTime: 0,
                    maxTime: 0,
                    totalTime: 0
                }
            }
        }
        var z = i(622429)
          , U = i(627620);
        function G(e) {
            return {
                ...e,
                panes: (t = e.panes,
                t.map((e=>{
                    return {
                        ...e,
                        sources: (t = e.sources,
                        t.filter((e=>!(0,
                        U.isLineToolName)(e.type))))
                    };
                    var t
                }
                )))
            };
            var t
        }
        function j(e, t) {
            var i;
            const s = e.find((e=>e.tools.includes(t)));
            return null !== (i = null == s ? void 0 : s.id) && void 0 !== i ? i : null
        }
        function q(e) {
            var t, i;
            const o = e.panes.map((e=>e.sources.filter((e=>(0,
            U.isLineToolName)(e.type))))).reduce(((e,t)=>t.concat(e)), [])
              , n = null !== (i = null === (t = e.lineToolsGroups) || void 0 === t ? void 0 : t.groups) && void 0 !== i ? i : []
              , r = new Map;
            o.forEach((e=>{
                const t = e.id;
                r.set(t, function(e, t) {
                    var i;
                    return {
                        id: e.id,
                        symbol: e.state.symbol,
                        ownerSource: (0,
                        s.ensureDefined)(e.ownerSource),
                        state: e,
                        groupId: null !== (i = j(t, e.id)) && void 0 !== i ? i : void 0
                    }
                }(e, n))
            }
            ));
            const a = new Map;
            return n.forEach((e=>{
                const t = function(e, t) {
                    var i, s;
                    if (0 === e.tools.length)
                        return null;
                    const o = e.tools[0];
                    return null !== (s = null === (i = t.get(o)) || void 0 === i ? void 0 : i.symbol) && void 0 !== s ? s : null
                }(e, r);
                null !== t && a.set(e.id, {
                    id: e.id,
                    name: e.name,
                    symbol: t
                })
            }
            )),
            {
                sources: r,
                groups: a
            }
        }
        var X = i(271868)
          , K = i(405117)
          , Y = i(795688)
          , Z = i(590508)
          , $ = i(640146)
          , J = i(907256)
          , Q = i(585627)
          , ee = i(613122)
          , te = i(175203)
          , ie = i(314802)
          , se = i(5553)
          , oe = i(652171)
          , ne = i(474759)
          , re = i(454576)
          , ae = i(160285)
          , le = i(942634)
          , ce = i(125226);
        const de = new Set(["chart_storage_hibernation_delay_60min", "chart_storage_hibernation_delay_10min", "chart_storage_hibernation_delay_5min"]);
        const ue = new h.WatchedValue(he());
        function he() {
            return (0,
            ce.isFeatureEnabled)("chart_storage_hibernation_delay_60min") ? 36e5 : (0,
            ce.isFeatureEnabled)("chart_storage_hibernation_delay_10min") ? 6e5 : (0,
            ce.isFeatureEnabled)("chart_storage_hibernation_delay_5min") ? 3e5 : 6e4
        }
        (0,
        ce.onFeaturesStateChanged)().subscribe(null, (e=>{
            if (!function(e) {
                return de.has(e)
            }(e))
                return;
            const t = he();
            ue.setValue(t, !1)
        }
        ));
        const pe = ue.readonly();
        function me(e) {
            const t = document.querySelector('link[rel~="chart-storage-notifications"]');
            return (null == t ? void 0 : t.href) ? e ? new URL(e,t.href) : new URL(t.href) : null
        }
        function ge(e, t) {
            return Boolean(e.metaInfo.uid.value()) && !t.containsData && !t.onWidget && function() {
                if (!(0,
                ie.isOnMobileAppPage)("new"))
                    return !0;
                const e = /TradingView\/(\d+)\.(\d+)\.(\d+)\.?/.exec(navigator.userAgent);
                if (null === e)
                    return !0;
                const t = Number(e[1]) - 1
                  , i = Number(e[2]) - 15
                  , s = Number(e[3]) - 0;
                if (t > 0 || 0 === t && i > 0 || 0 === t && 0 === i && s > 0)
                    return !0;
                return !1
            }() && null !== me()
        }
        const _e = (0,
        n.getLogger)("ChartStorageChangesSubscription");
        class ve extends se.PersistentEventSourceTransport {
            constructor(e, t) {
                super((e=>this._onMessage(e))),
                this._destroyed = !1,
                this._onChangeVisibilityBound = this._onChangeVisibility.bind(this),
                this._hibernateTimerId = null,
                this._hibernateDelay = pe.spawn(),
                this._beforeUnhibernating = new le.Delegate,
                this._haveEverBeenHibernated = !1,
                this._chartWidgetsCollection = e,
                this._layoutVisibility = e.resizerBridge().visible.spawn(),
                this._layoutVisibility.subscribe(this._onChangeVisibilityBound, {
                    callWithLast: !0
                }),
                te.telemetry.sendLineToolsStorageReport("line_tools_subscription_initial_connect"),
                this._connectionStatus.subscribe((e=>{
                    e === re.ConnectionStatus.Closed && te.telemetry.sendLineToolsStorageReport("line_tools_subscription_disconnected")
                }
                )),
                this._subscribeForSharingLayout = t,
                this.connect(),
                this._hibernateDelay.subscribe((e=>{
                    null !== this._hibernateTimerId && this._scheduleHibernation(e)
                }
                ))
            }
            destroy() {
                this._layoutVisibility.destroy(),
                this._hibernateDelay.destroy(),
                this.disconnect(),
                this._destroyed = !0
            }
            beforeUnhibernating() {
                return this._beforeUnhibernating
            }
            async _prepareParamsForConnection(e) {
                const t = this._chartWidgetsCollection.metaInfo.uid.value();
                if (this._destroyed)
                    return Promise.reject("Subscription is being destroyed");
                const i = await (0,
                oe.getStorageTarget)(t, "", 0)
                  , s = me(`/charts-storage/layout/${t}/subscribe`);
                null !== s ? (s.searchParams.delete("jwt"),
                s.searchParams.append("jwt", i.token),
                this._subscribeForSharingLayout && window.user.id && window.user.is_pro && s.searchParams.append("id", "" + window.user.id),
                this._url = s.toString()) : this._url = ""
            }
            _tryReconnectImpl() {
                super._tryReconnectImpl(),
                te.telemetry.sendLineToolsStorageReport("line_tools_subscription_reconnecting")
            }
            _onMessage(e) {
                if ("string" != typeof e)
                    throw new Error("Wrong message type, expected string");
                const t = JSON.parse(e);
                Object.entries(t).forEach((e=>{
                    const t = (0,
                    ne.parseLineToolsAndGroupsDTO)(e[1], "")
                      , i = e[0];
                    let s = 0;
                    i === oe.sharedChartId ? s = 1 : i === oe.globallySharedChartId && (s = 2),
                    this._chartWidgetsCollection.applyLineToolUpdateNotification(i, t, s)
                }
                ))
            }
            _onChangeVisibility() {
                const e = this._layoutVisibility.value();
                e && this.connectionStatus().value() === re.ConnectionStatus.Closed ? (this.connect(),
                this._beforeUnhibernating.fire(),
                this._haveEverBeenHibernated && (_e.logNormal("Connect due to becoming visible"),
                te.telemetry.sendLineToolsStorageReport("line_tools_unhibenate_subscription"))) : e || this._scheduleHibernation(pe.value())
            }
            _scheduleHibernation(e) {
                null !== this._hibernateTimerId && ae.workerBasedTimers.clearTimeout(this._hibernateTimerId),
                this._hibernateTimerId = ae.workerBasedTimers.setTimeout((()=>this._disconnectIfInvisible()), e)
            }
            _disconnectIfInvisible() {
                this._hibernateTimerId = null,
                this._layoutVisibility.value() || (_e.logNormal("Disconnect due to becoming invisible"),
                this.disconnect(),
                te.telemetry.sendLineToolsStorageReport("line_tools_hibenate_subscription"),
                this._haveEverBeenHibernated = !0)
            }
        }
        var Se = i(850775)
          , fe = i(430719)
          , be = i(870045)
          , ye = i(975179)
          , Ce = i(308721)
          , we = i(558150)
          , Te = i(828473)
          , Pe = i(79342)
          , xe = i(442657)
          , Me = i(251954)
          , Ie = i(581996)
          , Ae = i(327714)
          , Le = i(481251)
          , Ee = i(591800)
          , ke = i(62802)
          , De = i(668846)
          , Ne = i(345848)
          , Be = i(799786)
          , Re = i(432059)
          , Oe = i(956248)
          , Ve = i(955273)
          , We = i(125388)
          , Fe = i(560420)
          , He = i(951713)
          , ze = i(333126)
          , Ue = i(124829)
          , Ge = i(218049)
          , je = i(658843);
        async function qe(e, t, s, o, n, a="default") {
            let l, c = [];
            const d = e.model().model()
              , u = (0,
            Ue.clone)(t)
              , h = new je.Property({
                inputs: u
            })
              , p = function(e, t) {
                return "symbol" === t ? e.inputs.filter((t=>t.id === e.symbolInputId())) : e.inputs.filter((e=>e.confirm))
            }(s, a)
              , m = ()=>{
                l && d.removeCustomSource(l)
            }
              , g = ()=>{
                m(),
                n()
            }
              , _ = e=>{
                o({
                    inputs: e,
                    parentSources: c
                }),
                m()
            }
              , v = p.filter(Ge.isTimeOrPriceNotHiddenInput);
            if (v.length > 0)
                try {
                    const t = await Promise.all([i.e(55073), i.e(46445), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(65857), i.e(36010), i.e(53953), i.e(2520), i.e(25480), i.e(62564), i.e(29800), i.e(46489), i.e(29296), i.e(58985), i.e(23141), i.e(62234), i.e(95083), i.e(75826), i.e(59258), i.e(82421), i.e(67158), i.e(22106), i.e(74600), i.e(30422), i.e(72197), i.e(16356), i.e(24125), i.e(88015), i.e(98734), i.e(97384), i.e(93523), i.e(3782), i.e(86605), i.e(49162), i.e(41243), i.e(64797), i.e(22602), i.e(7001), i.e(71329), i.e(51488), i.e(94106), i.e(59470), i.e(75364), i.e(8222), i.e(80089), i.e(76750), i.e(13752), i.e(32277), i.e(25983), i.e(79412), i.e(31085), i.e(42513), i.e(78685), i.e(59434), i.e(82440), i.e(89255), i.e(89638), i.e(31600), i.e(85775), i.e(63095), i.e(79184), i.e(56316), i.e(32227), i.e(50030), i.e(87473), i.e(18405), i.e(90223), i.e(93498), i.e(65267), i.e(50186), i.e(71457), i.e(35432), i.e(89178), i.e(13338), i.e(53030)]).then(i.bind(i, 204564))
                      , o = await t.selectInputValuesOnChart(e, v, h, s.shortDescription, s.inputs);
                    if (l = o.customSourceId,
                    o.destPane) {
                        const e = o.destPane.mainDataSource();
                        c = e === d.mainSeries() ? [] : [e]
                    } else
                        c = []
                } catch (e) {
                    return void g()
                }
            v.length !== p.length ? Promise.all([i.e(55073), i.e(46445), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(65857), i.e(36010), i.e(53953), i.e(2520), i.e(25480), i.e(62564), i.e(29800), i.e(46489), i.e(29296), i.e(58985), i.e(23141), i.e(62234), i.e(95083), i.e(75826), i.e(59258), i.e(82421), i.e(67158), i.e(22106), i.e(74600), i.e(30422), i.e(72197), i.e(16356), i.e(24125), i.e(88015), i.e(98734), i.e(97384), i.e(93523), i.e(3782), i.e(86605), i.e(49162), i.e(41243), i.e(64797), i.e(22602), i.e(7001), i.e(71329), i.e(51488), i.e(94106), i.e(59470), i.e(75364), i.e(8222), i.e(80089), i.e(76750), i.e(13752), i.e(32277), i.e(25983), i.e(79412), i.e(31085), i.e(42513), i.e(78685), i.e(59434), i.e(82440), i.e(89255), i.e(89638), i.e(31600), i.e(85775), i.e(63095), i.e(79184), i.e(56316), i.e(32227), i.e(50030), i.e(87473), i.e(18405), i.e(90223), i.e(93498), i.e(65267), i.e(50186), i.e(71457), i.e(35432), i.e(89178), i.e(13338), i.e(53030)]).then(i.bind(i, 49294)).then((t=>{
                const o = new t.ConfirmInputsDialogRenderer(function(e) {
                    if ("symbol" === e)
                        return r.t(null, void 0, i(346501));
                    return r.t(null, void 0, i(648141))
                }(a),p,h,a,s,e.model(),_,g);
                return o.show(),
                o
            }
            )) : _(h.state().inputs || {})
        }
        let Xe = null;
        var Ke = i(941285)
          , Ye = i(643322)
          , Ze = i(430777);
        function $e(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }
        function Je(e) {
            return e.reduce(((e,t)=>{
                for (const i in t)
                    if ($e(t, i)) {
                        const s = t[i]
                          , o = e[i];
                        o ? o.push(s) : e[i] = [s]
                    }
                return e
            }
            ), {})
        }
        var Qe = i(631088)
          , et = i(895366);
        const tt = new c.TranslatedString("move left",r.t(null, void 0, i(179209)))
          , it = new c.TranslatedString("move right",r.t(null, void 0, i(360114)));
        class st {
            constructor(e) {
                this._chartModel = null,
                this._animation = null,
                this._chart = e,
                this._chart.withModel(this, (()=>{
                    this._chartModel = this._chart.model()
                }
                ))
            }
            destroy() {
                var e;
                null === (e = this._animation) || void 0 === e || e.stop()
            }
            move(e) {
                if (null !== this._chartModel) {
                    if (this._chartModel.timeScale().isEmpty())
                        return;
                    const t = .003
                      , i = 1.1
                      , s = Math.round(i / t);
                    this._moveImpl(e, ((o,n,r)=>{
                        const a = Math.min(n, s)
                          , l = e * t * Math.pow(a, 2) / 2;
                        if (n <= s)
                            return o + l;
                        const c = Number.isFinite(r) ? Math.max(0, s - r) : 0;
                        return o + l + e * (n - a - c) * i + e * (i * c - t * Math.pow(c, 2) / 2)
                    }
                    ), (e=>Math.max(0, s - e) + s))
                }
            }
            moveByBar(e) {
                if (null !== this._chartModel) {
                    const t = this._chartModel.timeScale()
                      , i = t.visibleBarsStrictRange();
                    if (t.isEmpty() || null === i)
                        return;
                    const s = 300
                      , o = i.lastBar();
                    this._moveImpl(e, ((i,n)=>{
                        const r = Math.floor(Math.max(0, n - s) / 100) + 1
                          , a = o + e * r
                          , l = t.indexToCoordinate(o);
                        return i + (t.indexToCoordinate(a) - l)
                    }
                    ), (()=>0), !0)
                }
            }
            stopMove() {
                var e;
                null === (e = this._animation) || void 0 === e || e.stop(),
                this._animation = null
            }
            scrollToRealtime(e) {
                null !== this._chartModel && this._chartModel.timeScale().scrollToRealtime(e)
            }
            _moveImpl(e, t, i, s) {
                if (null === this._chartModel)
                    return;
                const o = this._chartModel.timeScale();
                if (o.isEmpty())
                    return;
                if (this._chartModel.changeTimeScale(1 === e ? tt : it, !1),
                s && null !== o.visibleBarsStrictRange()) {
                    const e = o.indexToCoordinate(o.visibleBarsStrictRange().lastBar()) + o.barSpacing() / 2;
                    Math.abs(o.width() - e) > o.barSpacing() / 6 && o.setRightOffset(Math.round(o.rightOffset()))
                }
                const n = performance.now();
                let r = 1 / 0;
                this._animation = {
                    getStartPosition: ()=>0,
                    getPosition: e=>(e = Math.min(r, e),
                    t(0, e - n, r - e)),
                    finished: e=>e >= r,
                    stop: ()=>{
                        const e = performance.now() - n;
                        r = performance.now() + i(e)
                    }
                },
                this._chartModel.model().stopTimeScaleAnimation(),
                this._chartModel.model().setTimeScaleAnimation(this._animation)
            }
        }
        var ot = i(33052);
        function nt(e, t, s, o, n) {
            return Promise.all([i.e(31856), i.e(46445), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(65857), i.e(36010), i.e(53953), i.e(2520), i.e(25480), i.e(62564), i.e(29800), i.e(46489), i.e(29296), i.e(58985), i.e(23141), i.e(62234), i.e(95083), i.e(75826), i.e(59258), i.e(82421), i.e(67158), i.e(22106), i.e(74600), i.e(30422), i.e(72197), i.e(16356), i.e(24125), i.e(88015), i.e(32175), i.e(98734), i.e(97384), i.e(39963), i.e(93523), i.e(3782), i.e(86605), i.e(43362), i.e(49162), i.e(41243), i.e(64797), i.e(22602), i.e(7001), i.e(71329), i.e(51488), i.e(94106), i.e(59470), i.e(75364), i.e(8222), i.e(33828), i.e(80089), i.e(76750), i.e(13752), i.e(32277), i.e(44066), i.e(25983), i.e(77414), i.e(79412), i.e(31085), i.e(42513), i.e(65891), i.e(78685), i.e(59434), i.e(82440), i.e(24474), i.e(89255), i.e(89638), i.e(78687), i.e(31600), i.e(48694), i.e(85775), i.e(45619), i.e(38790), i.e(63095), i.e(601), i.e(62319), i.e(79184), i.e(88544), i.e(39782), i.e(71813), i.e(94448), i.e(54786), i.e(32864), i.e(32227), i.e(50030), i.e(87473), i.e(5483), i.e(40563), i.e(53722), i.e(18405), i.e(90223), i.e(93498), i.e(65267), i.e(50186), i.e(71457), i.e(35432), i.e(85589), i.e(89178), i.e(13338), i.e(1077), i.e(92597), i.e(46796), i.e(46265)]).then(i.bind(i, 441347)).then((i=>{
                const r = new (0,
                i.EditObjectDialogRenderer)(e,t,o,n);
                return r.show(s),
                r
            }
            ))
        }
        var rt = i(434396);
        let at = null;
        var lt = i(862954)
          , ct = i(465836);
        const dt = {
            [ot.TabNames.symbol]: "symbol",
            [ot.TabNames.legend]: "legend",
            [ot.TabNames.scales]: "scales",
            [ot.TabNames.trading]: "trading",
            [ot.TabNames.events]: "events",
            [ot.TabNames.eventsAndAlerts]: "events",
            [ot.TabNames.timezoneSessions]: "canvas",
            [ot.TabNames.text]: "text",
            [ot.TabNames.style]: "style",
            [ot.TabNames.visibility]: "visibility"
        }
          , ut = {
            [ot.TabNames.style]: "style",
            [ot.TabNames.visibility]: "visibilities"
        };
        async function ht(e, t, s={}, o, n) {
            const r = o.activeChartWidget.value()
              , {initialTab: a, tabName: l} = s;
            if (l && !a && (s.initialTab = ut[l]),
            (0,
            ct.isStudyLineTool)(e) && function(e) {
                if (!(0,
                ct.isStudyLineTool)(e))
                    return !1;
                return ["LineToolFixedRangeVolumeProfile", "LineToolVbPFixed", "LineToolAnchoredVolumeProfile"].filter(Ue.notNull).some((t=>e.toolname === t))
            }(e))
                return r.propertiesDefinitionsForSource(e).then((i=>null !== i ? nt(e, t, s, n, i) : null));
            if ((0,
            rt.isStudy)(e) && function(e) {
                const {shortId: t} = e.metaInfo();
                return "Overlay" === t
            }(e) || (0,
            ct.isLineTool)(e))
                return r.propertiesDefinitionsForSource(e).then((o=>{
                    if (null !== o) {
                        return function(e) {
                            return Promise.all([i.e(3618), i.e(46445), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(65857), i.e(36010), i.e(53953), i.e(2520), i.e(25480), i.e(62564), i.e(29800), i.e(46489), i.e(29296), i.e(58985), i.e(23141), i.e(62234), i.e(95083), i.e(75826), i.e(59258), i.e(82421), i.e(67158), i.e(22106), i.e(74600), i.e(30422), i.e(72197), i.e(16356), i.e(24125), i.e(88015), i.e(98734), i.e(97384), i.e(93523), i.e(3782), i.e(86605), i.e(43362), i.e(49162), i.e(41243), i.e(64797), i.e(22602), i.e(7001), i.e(71329), i.e(51488), i.e(94106), i.e(59470), i.e(75364), i.e(8222), i.e(33828), i.e(80089), i.e(76750), i.e(13752), i.e(32277), i.e(44066), i.e(25983), i.e(77414), i.e(79412), i.e(31085), i.e(42513), i.e(78685), i.e(59434), i.e(82440), i.e(24474), i.e(89255), i.e(89638), i.e(78687), i.e(31600), i.e(48694), i.e(85775), i.e(45619), i.e(38790), i.e(63095), i.e(601), i.e(62319), i.e(79184), i.e(88544), i.e(39782), i.e(71813), i.e(54786), i.e(1833), i.e(32227), i.e(50030), i.e(87473), i.e(5483), i.e(40563), i.e(53722), i.e(18405), i.e(90223), i.e(93498), i.e(65267), i.e(50186), i.e(71457), i.e(35432), i.e(85589), i.e(89178), i.e(13338), i.e(1077), i.e(92597), i.e(46796), i.e(46780)]).then(i.bind(i, 757381)).then((t=>{
                                const i = new (0,
                                t.SourcePropertiesEditorRenderer)(e);
                                return null !== at && at.hide(),
                                i.show({
                                    shouldReturnFocus: e.shouldReturnFocus
                                }),
                                at = i,
                                i
                            }
                            ))
                        }({
                            propertyPages: o,
                            model: t,
                            source: e,
                            activePageId: l && dt[l],
                            shouldReturnFocus: s.shouldReturnFocus
                        })
                    }
                    return null
                }
                ));
            if ((0,
            rt.isStudy)(e) && !(0,
            lt.isLollipopDataSource)(e))
                return nt(e, t, s, n);
            {
                const t = (0,
                lt.isLollipopDataSource)(e) ? "events" : l && dt[l]
                  , i = o.getChartPropertiesDialogRenderer();
                return i.setActivePage(t),
                i.show(s)
            }
        }
        var pt = i(166770)
          , mt = i(909740)
          , gt = i(61499)
          , _t = i(100366)
          , vt = i(342707)
          , St = i(468302);
        const ft = (0,
        pt.getHexColorByName)("color-cold-gray-700")
          , bt = (0,
        pt.getHexColorByName)("color-cold-gray-400")
          , yt = (0,
        pt.getHexColorByName)("color-cold-gray-900")
          , Ct = (0,
        pt.getHexColorByName)("color-white")
          , wt = r.t(null, void 0, i(518905));
        function Tt(e) {
            return e ? {
                ...e,
                message: (0,
                vt.formatStudyError)(e.message),
                rawHtml: !0
            } : null
        }
        class Pt {
            constructor(e) {
                this._container = null,
                this._errorCardRenderer = null,
                this._mainSeriesErrorMessage = null,
                this._banErrorMessage = new h.WatchedValue(null).spawn(),
                this._errorMessageHandler = e=>{
                    e = Tt(e),
                    this._chartWidget.hasModel() ? this._updatePaneWidgets(e) : this._renderErrorWithoutModel(e)
                }
                ,
                this._chartWidget = e,
                this._subscribeToMainSeriesErrors()
            }
            destroy() {
                var e, t;
                null === (e = this._mainSeriesErrorMessage) || void 0 === e || e.destroy(),
                this._banErrorMessage.destroy(),
                null === (t = this._errorCardRenderer) || void 0 === t || t.then((e=>{
                    e.container.remove(),
                    e.destroy()
                }
                ))
            }
            updatePaneWidgets() {
                this._updatePaneWidgets()
            }
            setContainer(e) {
                var t;
                if (this._container !== e) {
                    this._container = e,
                    null === (t = this._errorCardRenderer) || void 0 === t || t.then((e=>e.container.remove()));
                    const i = this._getErrorMessage();
                    i && this._errorMessageHandler(i)
                }
            }
            _updatePaneWidgets(e=this._getErrorMessage()) {
                this._chartWidget.paneWidgets().forEach((t=>t.setErrorMessage(e)))
            }
            async _renderErrorWithoutModel(e) {
                if (null === this._container || null === e && null === this._errorCardRenderer)
                    return;
                const t = await this._getErrorCardRenderer();
                this._container.contains(t.container) || this._container.appendChild(t.container),
                t.update(this._createErrorCardRendererState(e))
            }
            async _getErrorCardRenderer() {
                return this._errorCardRenderer || (this._errorCardRenderer = this._createErrorCardRenderer())
            }
            async _createErrorCardRenderer() {
                return new (await (0,
                _t.getErrorCardRenderer)())
            }
            _createErrorCardRendererState(e) {
                return e ? {
                    message: e.message,
                    icon: e.icon,
                    textColor: mt.watchedTheme.value() === gt.StdTheme.Dark ? bt : ft,
                    backgroundColor: mt.watchedTheme.value() === gt.StdTheme.Dark ? yt : Ct,
                    solutionId: e.solutionId,
                    rawHtml: e.rawHtml,
                    buttons: e.buttons
                } : {
                    message: null
                }
            }
            _subscribeToMainSeriesErrors() {
                const e = this._chartWidget;
                this._banErrorMessage = (0,
                Ye.combine)((e=>{
                    if (!e)
                        return null;
                    let t;
                    if ("banned by ip" === e.reason)
                        t = r.t(null, void 0, i(743954));
                    else
                        t = r.t(null, void 0, i(39931));
                    return {
                        message: t,
                        solutionId: Q.solutionIds.WHY_IS_MY_ACCOUNT_BANNED,
                        icon: "stop-hand"
                    }
                }
                ), window.ChartApiInstance.connectionBanInfo().weakReference()),
                this._banErrorMessage.subscribe(this._errorMessageHandler, {
                    callWithLast: !0
                }),
                e.withModel(this, (()=>{
                    const t = e.model().model().mainSeries();
                    this._mainSeriesErrorMessage = (0,
                    Ye.combine)(((t,s)=>{
                        if (t)
                            return t;
                        if (null === s)
                            return null;
                        switch (s.type) {
                        case "invalid_symbol":
                            return {
                                message: r.t(null, void 0, i(652969)),
                                icon: "ghost"
                            };
                        case "calculations_error":
                            return {
                                message: s.errorMessage,
                                icon: "attention"
                            };
                        case "no_data":
                            return {
                                message: r.t(null, void 0, i(836252)),
                                icon: "ghost"
                            };
                        case "unsupported_resolution":
                            return this._createErrorParamsForUnsupportedResolution(e)
                        }
                    }
                    ), this._banErrorMessage.weakReference(), (0,
                    ye.getSeriesDisplayErrorWV)(t).ownership()),
                    this._mainSeriesErrorMessage.subscribe(this._errorMessageHandler, {
                        callWithLast: !0
                    })
                }
                ))
            }
            _createErrorParamsForUnsupportedResolution(e) {
                const t = e.model()
                  , i = t.mainSeries().unsupportedResolutionState().value();
                return null === i ? null : {
                    message: (0,
                    St.getErrorFromUnsupportedResolutionState)(i, !0),
                    icon: "unsupported-resolution",
                    rawHtml: !0,
                    maxHeight: 400,
                    zeroHeight: 200,
                    buttons: [{
                        name: wt.format({
                            resolution: i.applicableResolution
                        }),
                        onClick: ()=>{
                            t.setResolution(t.model().mainSeries(), i.applicableResolution)
                        }
                    }]
                }
            }
            _getErrorMessage() {
                var e;
                return Tt(this._banErrorMessage.value() || (null === (e = this._mainSeriesErrorMessage) || void 0 === e ? void 0 : e.value()) || null)
            }
        }
        var xt = i(18900)
          , Mt = i(937713)
          , It = i(201871)
          , At = i(124066)
          , Lt = i(540519)
          , Et = i(220350);
        class kt {
            constructor(e, t) {
                this._showed = !1,
                this._cw = e,
                this._element = document.createElement("div"),
                this._element.classList.add(Et.screen),
                t.appendChild(this._element),
                this._cw.withModel(this, this._connectToModel)
            }
            show(e) {
                if (e) {
                    const e = this._cw.model().mainSeries().status();
                    if (1 !== e && 2 !== e)
                        return
                }
                this._cw.setInLoadingState(!0),
                this._showed || (this._showed = !0,
                this._show())
            }
            hide() {
                this._cw.setInLoadingState(!1),
                this._showed && this._hide()
            }
            isShown() {
                return this._showed
            }
            _connectToModel() {
                const e = this._cw.model().mainSeries()
                  , t = e.dataEvents();
                t.symbolError().subscribe(this, (e=>{
                    e !== At.permissionDenied && this.hide()
                }
                )),
                t.seriesError().subscribe(this, (()=>{
                    (0,
                    d.enabled)("hide_loading_screen_on_series_error") && this.hide()
                }
                )),
                e.statusWV().subscribe((e=>{
                    (Lt.seriesReadyStatuses.has(e) || 4 === e || 12 === e || 13 === e || 14 === e) && this.hide()
                }
                ))
            }
            _show() {
                const e = this._cw.properties().childs().paneProperties.childs();
                let t;
                if (e.backgroundType.value() === It.ColorType.Solid)
                    t = e.background.value();
                else {
                    t = `linear-gradient(${e.backgroundGradientStartColor.value()},${e.backgroundGradientEndColor.value()})`
                }
                this._element.style.background = t,
                this._element.classList.add(Et.fade)
            }
            _hide() {
                this._showed = !1,
                this._element.classList.remove(Et.fade)
            }
        }
        function Dt(e, t) {
            let {deltaX: i, deltaY: s} = e;
            switch (i /= 100,
            s /= 100,
            t.deltaMode) {
            case t.DOM_DELTA_PAGE:
                i *= 120,
                s *= 120;
                break;
            case t.DOM_DELTA_LINE:
                i *= 32,
                s *= 32
            }
            return {
                deltaX: i,
                deltaY: s
            }
        }
        class Nt {
            constructor() {
                this._totalDeltaX = 0,
                this._totalDeltaY = 0,
                this._prevWheelTime = 0
            }
            processWheel(e) {
                e.timeStamp - this._prevWheelTime > 100 && this._reset();
                const t = !(0,
                l.isMac)() && e.shiftKey
                  , i = t ? -e.deltaY : e.deltaX
                  , s = t ? e.deltaX : e.deltaY;
                this._totalDeltaX += i,
                this._totalDeltaY += s,
                this._prevWheelTime = e.timeStamp;
                const o = {
                    deltaX: i,
                    deltaY: s
                };
                return 0 === this._totalDeltaX || 0 === this._totalDeltaY || (Math.abs(this._totalDeltaX) >= Math.abs(3 * this._totalDeltaY) && (o.deltaY = 0),
                Math.abs(this._totalDeltaY) >= Math.abs(3 * this._totalDeltaX) && (o.deltaX = 0)),
                Dt(o, e)
            }
            _reset() {
                this._totalDeltaX = 0,
                this._totalDeltaY = 0
            }
        }
        var Bt = i(724377)
          , Rt = i(750139)
          , Ot = i(188035)
          , Vt = i(656479);
        class Wt {
            constructor(e, t, i) {
                this._handleEl = null,
                this._resizeInfo = null,
                this._colorCache = {
                    lineColor: "",
                    backgroundColor: "",
                    color: ""
                },
                this._chart = e,
                this._topPaneIndex = t,
                this._bottomPaneIndex = i,
                this._element = document.createElement("div"),
                this._element.classList.add(Vt.paneSeparator),
                this._element.style.background = this._color(),
                this.adjustSize(),
                this._element.addEventListener("click", (()=>{}
                ));
                const s = document.createElement("div");
                s.classList.add(Vt.handle),
                this._element.appendChild(s),
                this._mouseEventHandler = new Ot.MouseEventHandler(s,this,{
                    treatVertTouchDragAsPageScroll: !1,
                    treatHorzTouchDragAsPageScroll: !0
                }),
                this._handleEl = s,
                this._element.setAttribute("aria-hidden", "true")
            }
            destroy() {
                this._mouseEventHandler.destroy(),
                this._element.parentElement && this._element.parentElement.removeChild(this._element)
            }
            getElement() {
                return this._element
            }
            hide() {
                this._element.classList.add("js-hidden")
            }
            show() {
                this._element.classList.remove("js-hidden")
            }
            adjustSize() {
                this._element.style.height = Wt.height() + "px"
            }
            mouseEnterEvent(e) {
                const {topPane: t, bottomPane: i} = this._topBottomPane(!0);
                null !== t && null !== i && (0,
                s.ensureNotNull)(this._handleEl).classList.add(Vt.hovered)
            }
            mouseLeaveEvent(e) {
                (0,
                s.ensureNotNull)(this._handleEl).classList.remove(Vt.hovered)
            }
            mouseDownEvent(e) {
                this._mouseDownOrTouchStartEvent(e)
            }
            touchStartEvent(e) {
                this._mouseDownOrTouchStartEvent(e)
            }
            pressedMouseMoveEvent(e) {
                this._pressedMouseOrTouchMoveEvent(e)
            }
            touchMoveEvent(e) {
                this._pressedMouseOrTouchMoveEvent(e)
            }
            mouseUpEvent(e) {
                this._mouseUpOrTouchEndEvent(e)
            }
            touchEndEvent(e) {
                this._mouseUpOrTouchEndEvent(e)
            }
            update() {
                this._element.style.background = this._color().toString()
            }
            paint() {}
            image() {
                const {topPane: e} = this._topBottomPane(!1)
                  , t = e.leftPriceAxisesContainer().getWidth()
                  , i = e.width()
                  , s = e.rightPriceAxisesContainer().getWidth()
                  , o = this._color()
                  , n = (0,
                Qe.createDisconnectedCanvas)(document, (0,
                Ae.size)({
                    width: t,
                    height: 1
                }))
                  , r = (0,
                Qe.getPrescaledContext2D)(n);
                r.fillStyle = o,
                r.fillRect(0, 0, t, 1);
                const a = (0,
                Qe.createDisconnectedCanvas)(document, (0,
                Ae.size)({
                    width: i,
                    height: 1
                }))
                  , l = (0,
                Qe.getPrescaledContext2D)(a);
                l.fillStyle = o,
                l.fillRect(0, 0, i, 1);
                const c = (0,
                Qe.createDisconnectedCanvas)(document, (0,
                Ae.size)({
                    width: s,
                    height: 1
                }))
                  , d = (0,
                Qe.getPrescaledContext2D)(c);
                return d.fillStyle = o,
                d.fillRect(0, 0, s, 1),
                {
                    type: "separator",
                    leftAxis: {
                        content: n.toDataURL(),
                        canvas: n,
                        contentWidth: t,
                        contentHeight: 1
                    },
                    rightAxis: {
                        content: c.toDataURL(),
                        canvas: c,
                        contentWidth: s,
                        contentHeight: 1
                    },
                    content: a.toDataURL(),
                    canvas: a,
                    contentWidth: i,
                    contentHeight: 1
                }
            }
            static height() {
                const e = window.devicePixelRatio || 1;
                return e >= 1 ? 1 : 1 / e
            }
            _mouseDownOrTouchStartEvent(e) {
                const {topPane: t, bottomPane: i} = this._topBottomPane(!0);
                if (null === t || null === i)
                    return;
                const o = t.state().stretchFactor() + i.state().stretchFactor()
                  , n = o / (t.height() + i.height())
                  , r = 30 * n;
                o <= 2 * r || (this._resizeInfo = {
                    startY: e.pageY,
                    prevStretchTopPane: t.state().stretchFactor(),
                    maxPaneStretch: o - r,
                    totalStretch: o,
                    pixelStretchFactor: n,
                    minPaneStretch: r
                },
                (0,
                s.ensureNotNull)(this._handleEl).classList.add(Vt.active))
            }
            _pressedMouseOrTouchMoveEvent(e) {
                const {topPane: t, bottomPane: i} = this._topBottomPane(!0)
                  , s = this._resizeInfo;
                if (null === s || null === t || null === i)
                    return;
                const o = (e.pageY - s.startY) * s.pixelStretchFactor
                  , n = (0,
                Rt.clamp)(s.prevStretchTopPane + o, s.minPaneStretch, s.maxPaneStretch);
                t.state().setStretchFactor(n),
                i.state().setStretchFactor(s.totalStretch - n),
                this._chart.model().model().fullUpdate()
            }
            _mouseUpOrTouchEndEvent(e) {
                const {topPane: t, bottomPane: i} = this._topBottomPane(!0)
                  , o = this._resizeInfo;
                null !== o && null !== t && null !== i && (this._chart.model().addPaneStretchFactorUndoCommand(t.state(), i.state(), o.prevStretchTopPane, t.state().stretchFactor()),
                this._resizeInfo = null,
                (0,
                s.ensureNotNull)(this._handleEl).classList.remove(Vt.active))
            }
            _color() {
                const e = this._chart.properties().childs().paneProperties.childs().separatorColor.value()
                  , t = this._chart.model().model().backgroundColor().value();
                if (this._colorCache.lineColor !== e || this._colorCache.backgroundColor !== t) {
                    const i = (0,
                    Bt.parseRgba)(t)
                      , s = (0,
                    Bt.parseRgba)(e)
                      , o = 0 === i[3] && 0 === s[3] ? "rgba(0,0,0,0)" : (0,
                    Bt.rgbaToString)((0,
                    Bt.blendRgba)(i, s));
                    this._colorCache = {
                        lineColor: e,
                        backgroundColor: t,
                        color: o
                    }
                }
                return this._colorCache.color
            }
            _topBottomPane(e) {
                const t = this._chart.paneWidgets();
                let i = null
                  , s = null;
                for (let s = this._topPaneIndex; s >= 0; --s) {
                    const o = t[s];
                    if (!e || !o.state().collapsed().value()) {
                        i = o;
                        break
                    }
                }
                for (let i = this._bottomPaneIndex; i < t.length; ++i) {
                    const o = t[i];
                    if (!e || !o.state().collapsed().value()) {
                        s = o;
                        break
                    }
                }
                return {
                    topPane: i,
                    bottomPane: s
                }
            }
        }
        var Ft = i(650279)
          , Ht = i(45003)
          , zt = i(509078)
          , Ut = i(779732)
          , Gt = i(970427)
          , jt = i(803279)
          , qt = i(419283)
          , Xt = i(571491)
          , Kt = i(665798)
          , Yt = i(694852)
          , Zt = i(965251)
          , $t = i(5486)
          , Jt = i(621452)
          , Qt = i(499994)
          , ei = i(511275)
          , ti = i(507983);
        const ii = (0,
        Yt.makeFont)(11, ei.CHART_FONT_FAMILY)
          , si = {
            enableTooltip: !0,
            showLabels: !0,
            enableMenu: !0,
            enableHighlight: !0
        };
        function oi(e, t) {
            return Math.max(1, Math.floor(e.borderSize * t))
        }
        class ni {
            constructor(e, t, i, s, o, n=null) {
                this._invalidated = !0,
                this._size = (0,
                Ae.size)({
                    width: 0,
                    height: 0
                }),
                this._offset = 0,
                this._axisInfo = null,
                this._onLabelHovered = new le.Delegate,
                this._highlighted = !1,
                this._labelMode = 2,
                this._fixedLabelMode = null,
                this._textWidthCache = new $t.TextWidthCache(5),
                this._gearRenderer = (0,
                Zt.svgRenderer)(ti),
                this._canvasConfiguredHandler = ()=>{
                    this.update(),
                    this._textWidthCache.reset()
                }
                ,
                this._timeAxisWidget = n,
                this._isLeft = "left" === e;
                const {rendererOptionsProvider: r, sourcesTitlesProvider: a, contextMenuItemsProvider: l, backgroundBasedTheme: c, onActiveOrHoveredChart: d=new h.WatchedValue(!1).ownership(), requestRepaint: u, getBackgroundTopColor: p, getBackgroundBottomColor: m, showHorizontalBorder: g} = s;
                this._rendererOptionsProvider = r,
                this._sourcesTitlesProvider = a,
                this._contextMenuItemsProvider = l,
                this._backgroundBasedTheme = c,
                this._onActiveOrHoveredChart = d,
                this._requestRepaint = u,
                this._getBackgroundTopColor = p,
                this._getBackgroundBottomColor = m,
                this._showHorizontalBorder = Boolean(g),
                this._properties = t,
                this._axisInfo = i,
                this._labelOptions = {
                    ...si,
                    ...o
                },
                this._properties.lineColor.subscribe(this, this._onPropertyChanged),
                this._cell = document.createElement("div"),
                this._labelOptions.enableTooltip && this._cell.classList.add("apply-common-tooltip"),
                this._cell.style.width = "25px",
                this._cell.style.height = "100%",
                this._cell.style.position = "absolute",
                this._cell.style.left = "0",
                this._cell.style.overflow = "hidden",
                this._labelOptions.showLabels && (this._labelOptions.enableTooltip && (0,
                Qt.setTooltipData)(this._cell, "text", (e=>this._tooltipContent())),
                this._onActiveOrHoveredChart.subscribe(u)),
                this._mouseEventHandler = new Ot.MouseEventHandler(this._cell,this,{
                    treatHorzTouchDragAsPageScroll: !0,
                    treatVertTouchDragAsPageScroll: !0
                }),
                this._canvasBinding = (0,
                Qe.createBoundCanvas)(this._cell, (0,
                Ae.size)({
                    width: 16,
                    height: 16
                })),
                this._canvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
                const _ = this._canvasBinding.canvasElement;
                _.style.position = "absolute",
                _.style.left = "0",
                _.style.top = "0",
                this._cell.setAttribute("aria-hidden", "true")
            }
            destroy() {
                this._canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler),
                this._canvasBinding.dispose(),
                this._properties.lineColor.unsubscribe(this, this._onPropertyChanged),
                this._mouseEventHandler.destroy(),
                this._backgroundBasedTheme.release(),
                this._onActiveOrHoveredChart.unsubscribe(this._requestRepaint),
                this._onActiveOrHoveredChart.release()
            }
            mouseEnterEvent(e) {
                this._mouseOrTouchEnterEvent(e)
            }
            touchStartEvent(e) {
                this._mouseOrTouchEnterEvent(e)
            }
            mouseLeaveEvent(e) {
                this._mouseOrTouchLeaveEvent(e)
            }
            touchEndEvent(e) {
                this._mouseOrTouchLeaveEvent(e)
            }
            mouseClickEvent(e) {
                this._mouseClickOrTapEvent(e)
            }
            tapEvent(e) {
                this._mouseClickOrTapEvent(e)
            }
            update() {}
            getElement() {
                return this._cell
            }
            onLabelHovered() {
                return this._onLabelHovered
            }
            setSizeAndOffset(e, t) {
                (0,
                Ae.equalSizes)(this._size, e) || (this._size = e,
                this._canvasBinding.resizeCanvasElement(e),
                this._cell.style.width = `${e.width}px`,
                this._cell.style.minWidth = `${e.width}px`,
                this._cell.style.height = `${e.height}px`,
                this._invalidated = !0),
                this._offset !== t && (this._offset = t,
                this._cell.style.left = `${t}px`)
            }
            paint(e) {
                e < N.InvalidationLevel.Light && !this._invalidated || 0 !== this._size.width && 0 !== this._size.height && (this._invalidated = !1,
                (0,
                Qe.tryApplySuggestedCanvasBitmapSize)(this._canvasBinding),
                this._paintImpl((0,
                Qe.getContext2D)(this._canvasBinding.canvasElement), (0,
                Qe.getBindingRenderingInfo)(this._canvasBinding)))
            }
            getWidth() {
                return this._size.width
            }
            getImage() {
                const e = (0,
                Qe.getBindingRenderingInfo)(this._canvasBinding)
                  , t = (0,
                Qe.createDisconnectedCanvasByRenderingInfo)(document, e);
                return this._paintImpl((0,
                Qe.getContext2D)(t), e, !0),
                t
            }
            setLabelMode(e) {
                e !== this._labelMode && (this._labelMode = e,
                this._cell.classList.toggle("apply-common-tooltip", 1 !== e && this._labelOptions.enableTooltip))
            }
            _paintImpl(e, t, i) {
                this._drawBackground(e, t),
                this._drawVerticalBorder(e, t),
                this._showHorizontalBorder && this._drawHorizontalBorder(e, t),
                this._labelOptions.showLabels && this._drawLabel(e, t, i)
            }
            _setHighlighted(e) {
                this._labelOptions.enableHighlight && (this._onLabelHovered.fire("stubButton", e),
                this._highlighted !== e && (this._highlighted = e,
                this._invalidated = !0))
            }
            _onPropertyChanged() {
                this._invalidated = !0
            }
            _drawVerticalBorder(e, t) {
                e.save(),
                e.fillStyle = this._vertBorderColor();
                const i = oi(this._rendererOptionsProvider.options(), t.horizontalPixelRatio)
                  , s = this._isLeft ? t.bitmapSize.width - i : 0;
                e.fillRect(s, 0, i, t.bitmapSize.height),
                e.restore()
            }
            _drawHorizontalBorder(e, t) {
                e.save(),
                e.fillStyle = this._horzBorderColor();
                const i = oi(this._rendererOptionsProvider.options(), t.verticalPixelRatio)
                  , s = this._isLeft ? 0 : i;
                e.fillRect(s, 0, t.bitmapSize.width - i, i),
                e.restore()
            }
            _drawBackground(e, t) {
                const i = this._getBackgroundTopColor()
                  , s = this._getBackgroundBottomColor()
                  , {bitmapSize: o} = t;
                if (i === s ? (0,
                Qe.clearRect)(e, 0, 0, o.width, o.height, i) : (0,
                Kt.clearRectWithGradient)(e, 0, 0, o.width, o.height, i, s),
                this._highlighted) {
                    const t = Ce.themes[this._backgroundBasedTheme.value()].getThemedColor("color-price-axis-highlight");
                    (0,
                    Qe.fillRect)(e, 0, 0, o.width, o.height, t),
                    e.globalAlpha = 1
                }
            }
            _drawLabel(e, t, i) {
                const s = this._backgroundBasedTheme.value()
                  , n = this._axisInfo;
                if (null === n || !i && !this._onActiveOrHoveredChart.value())
                    return;
                const {bitmapSize: r, horizontalPixelRatio: a, verticalPixelRatio: l} = t
                  , c = oi(this._rendererOptionsProvider.options(), a)
                  , d = Math.round(r.width) - c
                  , u = oi(this._rendererOptionsProvider.options(), l)
                  , h = Math.round(r.height) - u
                  , p = (0,
                o.point)(c + d / 2, u + h / 2);
                if (1 === this._labelMode || 2 === this._labelMode && (!this._highlighted || i)) {
                    e.fillStyle = Ce.themes[s].getThemedColor("color-price-axis-label-back"),
                    e.globalAlpha = .5,
                    e.beginPath(),
                    e.arc(p.x, p.y, 9.5 * a, 0, 2 * Math.PI, !0),
                    e.fill(),
                    e.globalAlpha = 1,
                    e.fillStyle = Ce.themes[s].getThemedColor("color-price-axis-label-text"),
                    e.font = ii,
                    e.textAlign = "center",
                    e.textBaseline = "middle";
                    const t = this._textWidthCache.yMidCorrection(e, n.label);
                    (0,
                    Qe.drawScaled)(e, a, l, (()=>{
                        e.fillText(n.label, p.x / a, p.y / l + t)
                    }
                    ))
                } else if (!i && this._onActiveOrHoveredChart.value()) {
                    const t = this._gearRenderer.viewBox()
                      , i = Math.round(p.x - t.width * a / 2)
                      , o = Math.round(p.y - t.height * l / 2);
                    e.fillStyle = Ce.themes[s].getThemedColor("color-text-primary"),
                    e.imageSmoothingQuality = "high",
                    this._gearRenderer.render(e, {
                        targetViewBox: {
                            x: i,
                            y: o,
                            width: t.width * a,
                            height: t.height * l
                        },
                        doNotApplyColors: !0
                    })
                }
            }
            _vertBorderColor() {
                return this._properties.lineColor.value()
            }
            _horzBorderColor() {
                var e, t;
                return null !== (t = null === (e = this._timeAxisWidget) || void 0 === e ? void 0 : e.lineColor()) && void 0 !== t ? t : this._vertBorderColor()
            }
            _tooltipContent() {
                return this._sourcesTitlesProvider().join("\n")
            }
            _mouseOrTouchEnterEvent(e) {
                this._labelOptions.showLabels && this._labelOptions.enableHighlight && this._setHighlighted(!0)
            }
            _mouseOrTouchLeaveEvent(e) {
                this._labelOptions.showLabels && this._labelOptions.enableHighlight && this._setHighlighted(!1)
            }
            _mouseClickOrTapEvent(e) {
                if (e.preventDefault(),
                null !== this._fixedLabelMode || 1 === this._labelMode || !this._labelOptions.enableMenu || !this._labelOptions.showLabels)
                    return void Jt.ContextMenuManager.hideAll();
                this._fixedLabelMode = this._labelMode,
                this.setLabelMode(0);
                const t = this._cell.getBoundingClientRect();
                Jt.ContextMenuManager.showMenu(this._contextMenuItemsProvider(), {
                    clientX: this._isLeft ? t.left : t.right,
                    clientY: t.top,
                    attachToXBy: this._isLeft ? "left" : "right",
                    attachToYBy: "bottom"
                }, {
                    statName: "PriceScaleLabelContextMenu",
                    doNotCloseOn: this.getElement()
                }, {
                    menuName: "PriceScaleLabelContextMenu"
                }, (()=>{
                    this.setLabelMode((0,
                    s.ensureNotNull)(this._fixedLabelMode)),
                    this._fixedLabelMode = null
                }
                ))
            }
        }
        var ri = i(109436);
        class ai {
            constructor(e, t, i, s, o, n=null) {
                this._axises = [],
                this._stubs = [],
                this._size = (0,
                Ae.size)({
                    width: 0,
                    height: 0
                }),
                this._onLabelHovered = new le.Delegate,
                this._scalesProperties = e,
                this._priceAxisWidgetFactory = i,
                this._timeAxisWidget = n,
                this._rendererOptionsProvider = s.rendererOptionsProvider,
                this._titlesProvider = s.titlesProvider,
                this._stubContextMenuProvider = s.stubContextMenuProvider,
                this._backgroundBasedTheme = s.backgroundBasedTheme,
                this._onActiveOrHoveredChart = s.onActiveOrHoveredChart,
                this._getBackgroundTopColor = s.getBackgroundTopColor,
                this._getBackgroundBottomColor = s.getBackgroundBottomColor,
                this._requestRepaint = s.requestRepaint,
                this._showHorisontalBorder = Boolean(s.showHorizontalBorder),
                this._labelsOptions = {
                    ...si,
                    ...o
                };
                const r = this._scalesProperties.childs();
                this._stubProperties = {
                    lineColor: r.lineColor,
                    fontSize: r.fontSize
                },
                this._side = t,
                this._cell = document.createElement("div"),
                this._cell.classList.add("chart-markup-table", "price-axis-container"),
                this._cell.style.width = "25px",
                this._cell.style.position = "relative"
            }
            destroy() {
                var e;
                this.setScales([], 0, 0, 0),
                this._backgroundBasedTheme.release(),
                null === (e = this._onActiveOrHoveredChart) || void 0 === e || e.release()
            }
            onLabelHovered() {
                return this._onLabelHovered
            }
            setScales(e, t, i, o) {
                for (; e.length > this._axises.length && this._axises.length < t; ) {
                    const e = (0,
                    ri.getPriceAxisNameInfo)(this._side, this._axises.length)
                      , t = this._priceAxisWidgetFactory(this._side, this._rendererOptionsProvider, this._scalesProperties, e, this._backgroundBasedTheme);
                    this._axises.push(t),
                    this._cell.appendChild(t.getElement())
                }
                for (; e.length < this._axises.length; ) {
                    const e = (0,
                    s.ensureDefined)(this._axises.pop());
                    this._cell.removeChild(e.getElement()),
                    e.destroy()
                }
                for (let t = 0; t < this._axises.length; ++t)
                    this._axises[t].setPriceScale(e[t]);
                const n = t - e.length
                  , r = Math.max(0, n);
                for (; this._stubs.length > r; ) {
                    const e = (0,
                    s.ensureDefined)(this._stubs.pop());
                    e.onLabelHovered().unsubscribeAll(this),
                    this._cell.removeChild(e.getElement()),
                    e.destroy()
                }
                for (; this._stubs.length < n; ) {
                    const e = this._labelsOptions.showLabels ? (0,
                    ri.getPriceAxisNameInfo)(this._side, this._stubs.length) : null
                      , t = new ni(this._side,this._stubProperties,e,this._stubParams(this._stubs.length),this._labelsOptions,this._timeAxisWidget);
                    t.onLabelHovered().subscribe(this, ((t,i)=>{
                        this._labelsOptions.showLabels && this._labelsOptions.enableHighlight && this._onLabelHovered.fire({
                            owner: t,
                            axis: (0,
                            s.ensureNotNull)(e)
                        }, i)
                    }
                    )),
                    this._stubs.push(t),
                    this._cell.appendChild(t.getElement())
                }
                const a = this._labelsOptions.enableMenu;
                1 === o ? this._stubs.forEach(((e,t)=>e.setLabelMode(a ? 0 : 1))) : this._stubs.forEach(((e,t)=>e.setLabelMode(t < i && a ? 2 : 1)))
            }
            getElement() {
                return this._cell
            }
            updateCurrencyLabels() {
                return this._axises.forEach((e=>e.updateCurrencyLabel()))
            }
            optimalWidths() {
                return this._axises.map((e=>e.optimalWidth()))
            }
            setSizes(e, t) {
                this._size = (0,
                Ae.size)({
                    width: t.reduce(((e,t)=>e + t), 0),
                    height: e
                }),
                this._cell.style.width = this._size.width + "px",
                this._cell.style.minWidth = this._size.width + "px",
                this._cell.style.height = this._size.height + "px",
                t.length !== this._axises.length + this._stubs.length && (0,
                s.assert)(t.length === this._axises.length + this._stubs.length, "Widgets count should be the same as widths one");
                let i = 0;
                this._forEachWidgetFromLeft(((s,o)=>{
                    const n = t[o];
                    s.setSizeAndOffset((0,
                    Ae.size)({
                        width: n,
                        height: e
                    }), i),
                    i += n
                }
                ))
            }
            update() {
                this._axises.forEach((e=>e.update())),
                this._stubs.forEach((e=>e.update()))
            }
            paint(e) {
                this._axises.forEach(((t,i)=>t.paint(e(i)))),
                this._stubs.forEach(((t,i)=>t.paint(e(i))))
            }
            paintStubs(e) {
                this._stubs.forEach((t=>t.paint(e)))
            }
            restoreDefaultCursor() {
                this._axises.forEach((e=>e.restoreDefaultCursor()))
            }
            getWidth() {
                return this._size.width
            }
            findAxisWidgetForScale(e) {
                const t = this._axises.find((t=>t.priceScale() === e));
                return void 0 === t ? null : t
            }
            getScreenshotData() {
                const e = this._getImage();
                return {
                    canvas: e,
                    content: e.toDataURL(),
                    contentHeight: this._size.height,
                    contentWidth: this._size.width
                }
            }
            getImage() {
                return this._getImage()
            }
            slotsCount() {
                return this._axises.length + this._stubs.length
            }
            highlightPriceAxisByLabel(e) {
                this._axises.forEach((t=>{
                    const i = t.axisInfo();
                    t.setHighlighted(null !== i && i.equals(e))
                }
                ))
            }
            axes() {
                return this._axises
            }
            _stubParams(e) {
                var t;
                return {
                    rendererOptionsProvider: this._rendererOptionsProvider,
                    backgroundBasedTheme: this._backgroundBasedTheme.spawnOwnership(),
                    onActiveOrHoveredChart: null === (t = this._onActiveOrHoveredChart) || void 0 === t ? void 0 : t.spawnOwnership(),
                    sourcesTitlesProvider: ()=>this._titlesProvider(this._side, e),
                    contextMenuItemsProvider: ()=>this._stubContextMenuProvider(this._side, e),
                    getBackgroundTopColor: this._getBackgroundTopColor,
                    getBackgroundBottomColor: this._getBackgroundBottomColor,
                    requestRepaint: this._requestRepaint,
                    showHorizontalBorder: this._showHorisontalBorder
                }
            }
            _getImage() {
                const e = (0,
                Qe.createDisconnectedCanvas)(document, this._size)
                  , t = (0,
                Qe.getPrescaledContext2D)(e);
                let i = 0;
                return this._forEachWidgetFromLeft(((e,s)=>{
                    const o = e.getWidth();
                    0 !== o && 0 !== this._size.height && (t.drawImage(e.getImage(), i, 0, o, this._size.height),
                    i += o)
                }
                )),
                e
            }
            _forEachWidgetFromLeft(e) {
                const t = [...this._axises, ...this._stubs]
                  , i = "left" === this._side
                  , s = i ? -1 : t.length
                  , o = i ? -1 : 1;
                for (let n = i ? t.length - 1 : 0; n !== s; n += o)
                    e(t[n], n, t)
            }
        }
        var li = i(938614)
          , ci = i(855824)
          , di = i(98714);
        class ui {
            constructor() {
                this._width = null,
                this._labelBottom = null,
                this._currencyInfo = null,
                this._unitInfo = null,
                this._measureUnitIdInfo = null,
                this._fontSize = 0,
                this._currencyAndUnitLabelsWrapper = document.createElement("div"),
                this._currencyAndUnitLabelsWrapper.className = di["price-axis-currency-label-wrapper"],
                this._currencyAndUnitLabelsWrapper.setAttribute("data-name", "currency-unit-label-wrapper"),
                this._controlsContainer = document.createElement("div"),
                this._controlsContainer.className = di["price-axis-currency-label"],
                this._currencyAndUnitLabelsWrapper.appendChild(this._controlsContainer),
                this._currencyLabelDiv = document.createElement("div"),
                this._currencyLabelDiv.classList.add(di.row, "apply-common-tooltip"),
                this._currencyLabelDiv.dataset.name = "currency-label-selector",
                (0,
                Qt.setTooltipData)(this._currencyLabelDiv, "text", (e=>this._currencyTooltipContent())),
                this._currencyText = document.createElement("div"),
                this._currencyText.className = di["price-axis-currency-label-text"],
                this._currencyLabelDiv.appendChild(this._currencyText),
                this._currencyArrowDown = document.createElement("div"),
                this._currencyArrowDown.className = di["price-axis-currency-label-arrow-down"],
                this._currencyArrowDown.innerHTML = ci,
                this._currencyLabelDiv.appendChild(this._currencyArrowDown),
                this._measureUnitIdLabelDiv = document.createElement("div"),
                this._measureUnitIdLabelDiv.className = di.row,
                this._measureUnitIdLabelDiv.classList.add("apply-common-tooltip"),
                this._measureUnitIdLabelDiv.classList.add("readonly"),
                (0,
                Qt.setTooltipData)(this._measureUnitIdLabelDiv, "text", (e=>this._measureUnitIdTooltipContent())),
                this._measureUnitIdText = document.createElement("div"),
                this._measureUnitIdText.className = di["price-axis-currency-label-text"],
                this._measureUnitIdLabelDiv.appendChild(this._measureUnitIdText),
                this._unitLabelDiv = document.createElement("div"),
                this._unitLabelDiv.classList.add(di.row, "apply-common-tooltip"),
                this._unitLabelDiv.dataset.name = "unit-label-selector",
                (0,
                Qt.setTooltipData)(this._unitLabelDiv, "text", (e=>this._unitTooltipContent())),
                this._unitText = document.createElement("div"),
                this._unitText.className = di["price-axis-currency-label-text"],
                this._unitLabelDiv.appendChild(this._unitText),
                this._unitArrowDown = document.createElement("div"),
                this._unitArrowDown.className = di["price-axis-currency-label-arrow-down"],
                this._unitArrowDown.innerHTML = ci,
                this._unitLabelDiv.appendChild(this._unitArrowDown),
                this._controlsContainer.appendChild(this._currencyLabelDiv),
                this._controlsContainer.appendChild(this._measureUnitIdLabelDiv),
                this._controlsContainer.appendChild(this._unitLabelDiv),
                this.disableCurrency(),
                this.disableUnit()
            }
            element() {
                return this._currencyAndUnitLabelsWrapper
            }
            currencyLabelElement() {
                return this._currencyLabelDiv
            }
            unitLabelElement() {
                return this._unitLabelDiv
            }
            isEnabled() {
                return this.currencyLabelEnabled() || this.unitLabelEnabled() || this.measureUnitIdLableEnabled()
            }
            isHidden() {
                return this._currencyAndUnitLabelsWrapper.classList.contains(di.hidden)
            }
            setCurrencyExpanded(e) {
                this._currencyLabelDiv.classList.toggle(di.expanded, e)
            }
            setUnitExpanded(e) {
                this._unitLabelDiv.classList.toggle(di.expanded, e)
            }
            width() {
                if (null !== this._width)
                    return this._width;
                let e = 0;
                if (this.currencyLabelEnabled()) {
                    const t = this._currencyText.getBoundingClientRect()
                      , i = this._currencyArrowDown.getBoundingClientRect();
                    e = Math.max(e, t.width + i.width + 2 * this._textMarginAndPadding())
                }
                if (this.measureUnitIdLableEnabled()) {
                    const t = this._measureUnitIdText.getBoundingClientRect();
                    e = Math.max(e, t.width + 2 * this._textMarginAndPadding())
                }
                if (this.unitLabelEnabled()) {
                    const t = this._unitText.getBoundingClientRect()
                      , i = this._unitArrowDown.getBoundingClientRect();
                    e = Math.max(e, t.width + i.width + 2 * this._textMarginAndPadding())
                }
                return this._width = e
            }
            drawLabel(e, t, i) {
                var s, o, n;
                if (!this.isEnabled())
                    return;
                const r = Math.round(Number(di.css_wrapper_margin) * i)
                  , a = (0,
                Rt.ceiledEven)(t * i) - 2 * r
                  , l = Math.round(this.labelBottom() * i)
                  , c = l - 2 * r
                  , d = Math.round(Number(di.css_value_currency_label_radius) * i);
                e.fillStyle = getComputedStyle(this._currencyAndUnitLabelsWrapper).backgroundColor,
                e.fillRect(0, 0, Math.ceil(t * i), l);
                const u = [];
                u.push(this.currencyLabelEnabled() && null !== (s = this._currencyText.textContent) && void 0 !== s ? s : ""),
                u.push(this.measureUnitIdLableEnabled() && null !== (o = this._measureUnitIdText.textContent) && void 0 !== o ? o : ""),
                u.push(this.unitLabelEnabled() && null !== (n = this._unitText.textContent) && void 0 !== n ? n : ""),
                e.font = (0,
                Yt.makeFont)(this._fontSize, ei.CHART_FONT_FAMILY);
                const h = new $t.TextWidthCache;
                let p = 0;
                const m = [];
                u.forEach((t=>{
                    let i = 0;
                    "" !== t && (i = h.yMidCorrection(e, t),
                    p++),
                    m.push(i)
                }
                ));
                const g = c / p;
                e.beginPath();
                const _ = getComputedStyle(this._controlsContainer);
                e.fillStyle = _.backgroundColor,
                e.strokeStyle = _.borderColor,
                (0,
                Kt.drawRoundRect)(e, r, r, a, c, d),
                e.fill(),
                e.stroke(),
                e.fillStyle = getComputedStyle(this._currencyLabelDiv).color,
                e.textBaseline = "middle",
                e.textAlign = "left";
                const v = Math.round(this._textMarginAndPadding() * i) + r
                  , S = g / 2;
                let f = r + S;
                u.forEach(((t,s)=>{
                    "" !== t && ((0,
                    Qe.drawScaled)(e, i, i, (()=>{
                        e.fillText(t, v / i, (f + m[s]) / i)
                    }
                    )),
                    f = Math.ceil(f + 2 * S))
                }
                ))
            }
            setHidden(e) {
                this._currencyAndUnitLabelsWrapper.classList.toggle(di.hidden, e)
            }
            enableCurrency() {
                this._currencyLabelDiv.classList.remove("js-hidden"),
                this._resetSizesAndVisibility()
            }
            disableCurrency() {
                this._currencyLabelDiv.classList.add("js-hidden"),
                this._resetSizesAndVisibility()
            }
            enableUnit() {
                this._unitLabelDiv.classList.remove("js-hidden"),
                this._resetSizesAndVisibility()
            }
            disableUnit() {
                this._unitLabelDiv.classList.add("js-hidden"),
                this._resetSizesAndVisibility()
            }
            enableMeasureUnitId() {
                this._measureUnitIdLabelDiv.classList.remove("js-hidden"),
                this._resetSizesAndVisibility()
            }
            disableMeasureUnitId() {
                this._measureUnitIdLabelDiv.classList.add("js-hidden"),
                this._resetSizesAndVisibility()
            }
            currencyLabelEnabled() {
                return !this._currencyLabelDiv.classList.contains("js-hidden")
            }
            unitLabelEnabled() {
                return !this._unitLabelDiv.classList.contains("js-hidden")
            }
            measureUnitIdLableEnabled() {
                return !this._measureUnitIdLabelDiv.classList.contains("js-hidden")
            }
            currencyConversionAvailable() {
                return !this._currencyLabelDiv.classList.contains("readonly")
            }
            unitConversionAvailable() {
                return !this._unitLabelDiv.classList.contains("readonly")
            }
            setCurrencyInfo(e) {
                if (this._currencyInfo === e)
                    return !1;
                this._currencyInfo = e;
                const t = null === e.selectedCurrency ? r.t(null, void 0, i(454215)) : (0,
                s.ensureDefined)(e.displayedValues.get(e.selectedCurrency));
                return this._currencyText.textContent !== t && (this._currencyText.textContent = t,
                this._width = null),
                this._currencyArrowDown.classList.contains("js-hidden") !== e.readOnly && (this._currencyArrowDown.classList.toggle("js-hidden", e.readOnly),
                this._currencyLabelDiv.classList.toggle("readonly", e.readOnly),
                this._width = null),
                !0
            }
            setUnitInfo(e) {
                if (null !== this._unitInfo && this._unitInfo.selectedUnit === e.selectedUnit && 0 === this._unitInfo.availableGroups.size == (0 === e.availableGroups.size) && this._unitInfo.originalUnits.size === e.originalUnits.size)
                    return this._unitInfo = e,
                    !1;
                this._unitInfo = e;
                const t = null === e.selectedUnit ? r.t(null, void 0, i(454215)) : (0,
                s.ensureDefined)(e.names.get(e.selectedUnit));
                return this._unitText.textContent !== t && (this._unitText.textContent = t,
                this._width = null),
                this._unitArrowDown.classList.contains("js-hidden") !== (0 === e.availableGroups.size) && (this._unitArrowDown.classList.toggle("js-hidden", 0 === e.availableGroups.size),
                this._unitLabelDiv.classList.toggle("readonly", 0 === e.availableGroups.size),
                this._width = null),
                !0
            }
            setMeasureUnitIdInfo(e) {
                if (this._measureUnitIdInfo === e)
                    return !1;
                this._measureUnitIdInfo = e;
                const t = null === e.selectedMeasureUnitId ? r.t(null, void 0, i(454215)) : (0,
                s.ensureDefined)(e.names.get(e.selectedMeasureUnitId));
                return this._measureUnitIdText.textContent !== t && (this._measureUnitIdText.textContent = t,
                this._width = null),
                this._measureUnitIdLabelDiv.classList.contains("js-hidden") !== (0 === e.names.size) && (this._measureUnitIdLabelDiv.classList.toggle("js-hidden", 0 === e.names.size),
                this._width = null),
                !0
            }
            currencyInfo() {
                return this._currencyInfo
            }
            unitInfo() {
                return this._unitInfo
            }
            measureUnitIdInfo() {
                return this._measureUnitIdInfo
            }
            setFontSize(e) {
                this._fontSize !== e && (this._fontSize = e,
                this._currencyLabelDiv.style.fontSize = e + "px",
                this._measureUnitIdLabelDiv.style.fontSize = e + "px",
                this._unitLabelDiv.style.fontSize = e + "px",
                this._width = null,
                this._labelBottom = null)
            }
            labelBottom() {
                if (null !== this._labelBottom)
                    return this._labelBottom;
                const e = this._controlsContainer.getBoundingClientRect()
                  , t = this._currencyAndUnitLabelsWrapper.getBoundingClientRect()
                  , i = e.y - t.y;
                return this._labelBottom = e.height + 2 * i
            }
            _resetSizesAndVisibility() {
                this._width = null,
                this._labelBottom = null,
                this._updateVisibility()
            }
            _textMarginAndPadding() {
                return Number(di.css_wrapper_margin) + Number(di.css_row_left_right_padding) + 2
            }
            _currencyTooltipContent() {
                const e = this._currencyInfo;
                return null === e ? "" : null === e.selectedCurrency ? Array.from(e.currencies).map((t=>(0,
                s.ensureDefined)(e.displayedValues.get(t)))).join(", ") : e.readOnly ? r.t(null, void 0, i(243931)) : r.t(null, void 0, i(548566))
            }
            _unitTooltipContent() {
                const e = this._unitInfo;
                return null === e ? "" : null === e.selectedUnit ? Array.from(e.units).map((t=>(0,
                s.ensureDefined)(e.names.get(t)))).join(", ") : 0 === e.availableGroups.size ? r.t(null, void 0, i(540012)) : r.t(null, void 0, i(185110))
            }
            _measureUnitIdTooltipContent() {
                const e = this._measureUnitIdInfo;
                return null === e ? "" : null === e.selectedMeasureUnitId ? Array.from(e.measureUnitIds).map((t=>(0,
                s.ensureDefined)(e.names.get(t)))).join(", ") : e.descriptions.get(e.selectedMeasureUnitId) || ""
            }
            _updateVisibility() {
                const e = this.isEnabled();
                this._currencyAndUnitLabelsWrapper.classList.toggle("js-hidden", !e)
            }
        }
        async function hi(e, t, s, o, n, r) {
            const {UnitConversionRenderer: a} = await Promise.all([i.e(69093), i.e(93703), i.e(75816), i.e(44524), i.e(21356), i.e(62093), i.e(53953), i.e(2520), i.e(59258), i.e(82421), i.e(67158), i.e(74600), i.e(98734), i.e(93523), i.e(43362), i.e(5463), i.e(16164), i.e(38985), i.e(32227), i.e(62526), i.e(32704)]).then(i.bind(i, 300203));
            return new a(e,s,t,o,n,r)
        }
        var pi = i(706847)
          , mi = i(832312)
          , gi = i(734469)
          , _i = i(691371)
          , vi = i(546821)
          , Si = i(883188)
          , fi = i(314824);
        i(82815);
        const bi = new c.TranslatedString("change no overlapping labels",r.t(null, void 0, i(561557)))
          , yi = new c.TranslatedString("toggle auto scale",r.t(null, void 0, i(642240)))
          , Ci = new c.TranslatedString("toggle log scale",r.t(null, void 0, i(149403)))
          , wi = r.t(null, void 0, i(488314))
          , Ti = r.t(null, void 0, i(5119))
          , Pi = r.t(null, void 0, i(259396))
          , xi = r.t(null, void 0, i(715432))
          , Mi = r.t(null, void 0, i(115332))
          , Ii = r.t(null, void 0, i(224157))
          , Ai = r.t(null, {
            context: "scale_menu"
        }, i(34954))
          , Li = r.t(null, {
            context: "scale_menu"
        }, i(235210))
          , Ei = r.t(null, {
            context: "scale_menu"
        }, i(131340))
          , ki = r.t(null, {
            context: "scale_menu"
        }, i(655300))
          , Di = r.t(null, {
            context: "scale_menu"
        }, i(19405))
          , Ni = r.t(null, {
            context: "scale_menu"
        }, i(775163));
        const Bi = function(e) {
            const t = new mi.LimitedPrecisionNumericFormatter(e);
            return (e,i)=>(0,
            Ue.isNumber)(i) && !e.isLog() ? t.format(i) : ""
        }(4)
          , Ri = d.enabled("currency_menu_disabled")
          , Oi = d.enabled("unit_menu_disabled")
          , Vi = {
            contextMenuEnabled: !0,
            currencyConversionEnabled: !1,
            unitConversionEnabled: !1,
            countdownEnabled: !0,
            contextMenu: {
                general: !0,
                source: !0
            },
            pressedMouseMoveScale: !0,
            mouseWheelScale: !0,
            pinchScale: !0,
            croppedTickMarks: !0
        };
        class Wi {
            constructor(e, t, i, s, o, n, r, a, l) {
                this._actions = null,
                this._priceScale = null,
                this._scaleModeButtons = null,
                this._widthCache = new $t.TextWidthCache(1e3),
                this._color = null,
                this._fontSize = null,
                this._currencyFontSize = 0,
                this._currencyLabelWidth = null,
                this._isVisible = !0,
                this._currencyMenu = null,
                this._unitMenu = null,
                this._size = (0,
                Ae.size)({
                    width: 0,
                    height: 0
                }),
                this._currentCursorClassName = "",
                this._destroyed = !1,
                this._highlighted = !1,
                this._highlightColorCache = null,
                this._mouseWheelHelper = null,
                this._dragScaleActive = !1,
                this._offset = NaN,
                this._pinching = !1,
                this._lastHittestResult = null,
                this._isHovered = new h.WatchedValue(!1),
                this._selectedViaTap = new h.WatchedValue(!1),
                this._recalcCurrencyAndUnitVisibility = ()=>{
                    if (null === this._currencyLabel)
                        return;
                    let e = !0;
                    switch ((0,
                    vi.actualCurrencyUnitVisibility)().value()) {
                    case "alwaysOff":
                        e = !1;
                        break;
                    case "visibleOnMouseOver":
                        const t = this._chart.anyPriceAxisHovered().value()
                          , i = null !== this._currencyMenu && this._currencyMenu.isOpened()
                          , s = null !== this._unitMenu && this._unitMenu.isOpened();
                        e = t || i || s;
                        break;
                    case "visibleOnTapSelection":
                        e = this._selectedViaTap.value()
                    }
                    this._currencyLabel.setHidden(!e)
                }
                ,
                this._handleActualAutoLogButtonsVisibility = async e=>{
                    const t = e.value();
                    "alwaysOff" === t ? this._scaleModeButtons && this._destroyScaleModeButtons() : (this._scaleModeButtons || (this._scaleModeButtons = await this._createScaleModeButtons()),
                    "alwaysOn" === t ? (this._isHovered.unsubscribe(this._updatePriceScaleModeButtonsVisibility),
                    this._updatePriceScaleModeButtonsVisibility()) : this._isHovered.subscribe(this._updatePriceScaleModeButtonsVisibility, {
                        callWithLast: !0
                    })),
                    this.onOptimalWidthNeedToBeRecalculated()
                }
                ,
                this._updatePriceScaleModeButtonsVisibility = ()=>{
                    var e;
                    const t = this._isHovered.value()
                      , i = this._selectedViaTap.value();
                    let s = !1;
                    switch ((0,
                    Si.actualAutoLogButtonsVisibility)().value()) {
                    case "visibleOnMouseOver":
                        s = t;
                        break;
                    case "visibleOnTapSelection":
                        s = i;
                        break;
                    case "alwaysOn":
                        s = !0
                    }
                    null === (e = this._scaleModeButtons) || void 0 === e || e.element().classList.toggle("price-axis__modeButtons_hidden", !s)
                }
                ,
                this._updateScaleModeButtons = ()=>{
                    var e;
                    null === (e = this._scaleModeButtons) || void 0 === e || e.update()
                }
                ,
                this._chart = e,
                this._pane = t,
                this._undoModel = i,
                this._properties = s,
                this._isLeft = "left" === n,
                this._options = (0,
                Ue.merge)((0,
                Ue.clone)(Vi), r),
                this._rendererOptionsProvider = o,
                this._backgroundBasedTheme = l,
                this._cell = document.createElement("div"),
                this._cell.className = "price-axis",
                this._cell.style.width = "25px",
                this._cell.style.left = "0",
                this._canvasConfiguredHandler = ()=>{
                    this._undoModel.model().lightUpdate()
                }
                ,
                this._canvasBinding = (0,
                Qe.createBoundCanvas)(this._cell, (0,
                Ae.size)({
                    width: 16,
                    height: 16
                })),
                this._canvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
                const c = this._canvasBinding.canvasElement;
                c.style.position = "absolute",
                c.style.zIndex = "1",
                c.style.left = "0",
                c.style.top = "0",
                this._topCanvasBinding = (0,
                Qe.createBoundCanvas)(this._cell, (0,
                Ae.size)({
                    width: 16,
                    height: 16
                })),
                this._topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
                const d = this._topCanvasBinding.canvasElement;
                d.style.position = "absolute",
                d.style.zIndex = "2",
                d.style.left = "0",
                d.style.top = "0",
                this._cell.setAttribute("aria-hidden", "true"),
                this._mouseEventHandler = new Ot.MouseEventHandler(this._cell,this,{
                    treatVertTouchDragAsPageScroll: !1,
                    treatHorzTouchDragAsPageScroll: !0
                }),
                this._options.currencyConversionEnabled || this._options.unitConversionEnabled ? (this._currencyLabel = new ui,
                this._cell.appendChild(this._currencyLabel.element())) : this._currencyLabel = null,
                this._properties.childs().fontSize.subscribe(this, this._onFontSizeChanged),
                this._options.mouseWheelScale && (this._mouseWheelHelper = new Nt,
                this._cell.addEventListener("wheel", this._onMousewheel.bind(this), {
                    passive: !1
                })),
                this._axisInfo = a,
                this._offset = 0,
                this.restoreDefaultCursor(),
                (0,
                vi.actualCurrencyUnitVisibility)().subscribe(this, this._recalcCurrencyAndUnitVisibility),
                this._selectedViaTap.subscribe(this._recalcCurrencyAndUnitVisibility.bind(this)),
                (0,
                Si.actualAutoLogButtonsVisibility)().subscribe(this, this._handleActualAutoLogButtonsVisibility),
                this._selectedViaTap.subscribe(this._updatePriceScaleModeButtonsVisibility.bind(this)),
                this._handleActualAutoLogButtonsVisibility((0,
                Si.actualAutoLogButtonsVisibility)()).catch((()=>{}
                )),
                this._chart.anyPriceAxisHovered().subscribe(this._recalcCurrencyAndUnitVisibility, {
                    callWithLast: !0
                }),
                this.update()
            }
            getContextMenuActions(e) {
                var t;
                this._initActions();
                const i = (0,
                s.ensureNotNull)(this._actions)
                  , o = this._chart.actions()
                  , n = [];
                return (null === (t = this._priceScale) || void 0 === t ? void 0 : t.resetScaleAvailable().value()) && n.push(i.reset, new _i.Separator),
                n.push(this._autoScaleAction()),
                this._isMainSeriesAxis() && n.push(this._lockScaleAction()),
                n.push(o.scaleSeriesOnly, this._invertAction(), new _i.Separator, this._regularScaleAction(), this._percentageAction(), this._indexedTo100Action(), this._logAction(), new _i.Separator),
                l.CheckMobile.any() || (n.push(this._createMergeScalesAction()),
                n.push(new _i.Separator)),
                d.enabled("fundamental_widget") || n.push(new _i.Action({
                    actionId: "Chart.PriceScale.Labels",
                    options: {
                        label: Ti,
                        subItems: [o.showSymbolLabelsAction, o.showSeriesLastValue, o.showSeriesPrevCloseValue, o.showPrePostMarketPriceLabel, o.showHighLowPriceLabels, d.enabled("show_average_close_price_line_and_label") ? o.showAverageClosePriceLabel : null, this._undoModel.model().hasCustomSource("bidask") && o.showBidAskLabels, o.showStudyPlotNamesAction, o.showStudyLastValue, i.alignLabels].filter(Boolean)
                    }
                })),
                n.push((0,
                gi.createLinesAction)(this._chart)),
                this._options.countdownEnabled && n.push(o.showCountdown),
                this._undoModel.crossHairSource().isMenuEnabled() && n.push(o.addPlusButton),
                e && !this._chart.onWidget() && d.enabled("show_chart_property_page") && d.enabled("chart_property_page_scales") && o.scalesProperties && n.push(new _i.Separator, o.scalesProperties),
                n
            }
            getElement() {
                return this._cell
            }
            onOptimalWidthNeedToBeRecalculated(e) {
                (this._size.width < this.optimalWidth() || e) && this._undoModel.model().fullUpdate()
            }
            optimalWidth() {
                var e, t, i;
                if (!this.isVisible())
                    return 0;
                let o = 0;
                const n = this.rendererOptions();
                if (this._pane.hasState()) {
                    const t = (0,
                    Qe.getContext2D)(this._canvasBinding.canvasElement);
                    t.font = this.baseFont();
                    const i = this._views(2, this._groupedSources());
                    for (let e = i.length; e--; ) {
                        if (!i[e].isAxisLabelVisible())
                            continue;
                        const s = this._widthCache.measureText(t, i[e].text());
                        o = Math.max(o, s);
                        const n = i[e].secondLineText();
                        n && (o = Math.max(o, this._widthCache.measureText(t, n)));
                        const r = i[e].thirdLineText();
                        r && (o = Math.max(o, this._widthCache.measureText(t, r)))
                    }
                    const s = this.priceScale();
                    for (const e of s.marks())
                        o = Math.max(o, this._widthCache.measureText(t, e.label));
                    const n = (null === (e = s.mainSource()) || void 0 === e ? void 0 : e.firstValue()) || null;
                    if (null !== n) {
                        const e = s.coordinateToPrice(1, n)
                          , i = s.coordinateToPrice(this._size.height - 2, n);
                        if (Math.abs(e - i) > 1e-14) {
                            const r = s.formatPrice(Math.floor(Math.min(e, i)) + .11111111111111, n)
                              , a = s.formatPrice(Math.ceil(Math.max(e, i)) - .11111111111111, n);
                            o = Math.max(o, this._widthCache.measureText(t, r), this._widthCache.measureText(t, a))
                        }
                    }
                }
                let r = 0;
                this._isCurrencyLabelEnabled() && (null === this._currencyLabelWidth && (this._currencyLabelWidth = (0,
                s.ensureNotNull)(this._currencyLabel).width()),
                r = Math.round(this._currencyLabelWidth));
                const a = o || 34;
                let l = Math.max(r, null !== (i = null === (t = this._scaleModeButtons) || void 0 === t ? void 0 : t.width()) && void 0 !== i ? i : 0, Math.ceil(n.borderSize + n.additionalPaddingInner + n.paddingInner + n.paddingOuter + a + 4));
                return l += l % 2,
                l
            }
            setSizeAndOffset(e, t) {
                (0,
                Ae.equalSizes)(this._size, e) || (this._size = e,
                this._canvasBinding.resizeCanvasElement(e),
                this._topCanvasBinding.resizeCanvasElement(e),
                this._cell.style.width = e.width + "px",
                this._cell.style.height = e.height + "px",
                this._cell.style.minWidth = e.width + "px"),
                this._offset !== t && (this._offset = t,
                this._cell.style.left = t + "px")
            }
            getWidth() {
                return this._size.width
            }
            getImage() {
                const e = this._size
                  , t = (0,
                Qe.createDisconnectedCanvas)(document, e);
                return (0,
                Qe.getPrescaledContext2D)(t).drawImage(this._canvasBinding.canvasElement, 0, 0, e.width, e.height),
                null === this._currencyLabel || this._currencyLabel.isHidden() || this._currencyLabel.drawLabel((0,
                Qe.getContext2D)(t), e.width, (0,
                xt.getCanvasDevicePixelRatio)(t)),
                t
            }
            update() {
                null !== this._priceScale && (this._priceScale.marks(),
                this._updateCurrencyLabelFont(),
                this.rendererOptions())
            }
            paint(e) {
                if (!this._isVisible || 0 === this._size.width || 0 === this._size.height)
                    return;
                if (e === N.InvalidationLevel.None)
                    return;
                const t = this._pane.state()
                  , i = !t.maximized().value() && t.collapsed().value()
                  , o = this._pane.hasState();
                (0,
                Qe.tryApplySuggestedCanvasBitmapSize)(this._canvasBinding),
                (0,
                Qe.tryApplySuggestedCanvasBitmapSize)(this._topCanvasBinding);
                const n = this._groupedSources()
                  , r = null !== this._currencyLabel && !this._currencyLabel.isHidden()
                  , a = (e,t,i)=>{
                    if (r) {
                        e.save(),
                        e.beginPath();
                        const i = (0,
                        s.ensureNotNull)(this._currencyLabel).labelBottom();
                        e.rect(0, i * t.verticalPixelRatio, t.bitmapSize.width, t.bitmapSize.height),
                        e.clip()
                    }
                    i(),
                    r && e.restore()
                }
                ;
                if (e > N.InvalidationLevel.Cursor) {
                    const e = (0,
                    Qe.getContext2D)(this._canvasBinding.canvasElement)
                      , t = (0,
                    Qe.getBindingRenderingInfo)(this._canvasBinding);
                    i || this._alignLabels(),
                    o && this.updateCurrencyLabel(),
                    this._drawBackground(e, t),
                    a(e, t, (()=>{
                        this._drawDrawingsHighlight(e, t)
                    }
                    )),
                    this._drawBorder(e, t),
                    o && (this._scaleModeButtons && (this._scaleModeButtons.element().style.background = this._highlighted ? this._highlightColor() : this.backgroundColor()),
                    i || a(e, t, (()=>{
                        this._drawTickMarks(e, t),
                        this._drawLabels(this._views(0, n), e, t)
                    }
                    )))
                }
                if (o && !i) {
                    const e = (0,
                    Qe.getContext2D)(this._topCanvasBinding.canvasElement)
                      , t = (0,
                    Qe.getBindingRenderingInfo)(this._topCanvasBinding);
                    e.clearRect(0, 0, t.bitmapSize.width, t.bitmapSize.height),
                    a(e, t, (()=>{
                        this._drawLabels(this._views(1, n), e, t),
                        this._drawCrossHairLabel(e, t)
                    }
                    ))
                }
            }
            restoreDefaultCursor() {
                this._setCursor("")
            }
            priceScale() {
                return (0,
                s.ensureNotNull)(this._priceScale)
            }
            setPriceScale(e) {
                this._priceScale !== e && (null !== this._priceScale && (this._priceScale.onMarksChanged().unsubscribe(this, this.onOptimalWidthNeedToBeRecalculated),
                this._priceScale.modeChanged().unsubscribeAll(this)),
                this._priceScale = e,
                null !== e && (e.onMarksChanged().subscribe(this, this.onOptimalWidthNeedToBeRecalculated),
                e.modeChanged().subscribe(this, (()=>this.onOptimalWidthNeedToBeRecalculated(!0))),
                this.onOptimalWidthNeedToBeRecalculated(),
                this._scaleModeButtons && (e.modeChanged().subscribe(this, this._updateScaleModeButtons),
                this._updateScaleModeButtons())))
            }
            isVisible() {
                return this._isVisible
            }
            setVisible(e) {
                (e = !!e) !== this._isVisible && (this._cell.style.display = e ? "table-cell" : "none",
                this._isVisible = e)
            }
            destroy() {
                null !== this._currencyMenu && (this._currencyMenu.close(),
                this._currencyMenu = null),
                null !== this._unitMenu && (this._unitMenu.close(),
                this._unitMenu = null),
                this._topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler),
                this._topCanvasBinding.dispose(),
                this._canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler),
                this._canvasBinding.dispose(),
                null !== this._priceScale && (this._priceScale.onMarksChanged().unsubscribe(this, this.onOptimalWidthNeedToBeRecalculated),
                this._priceScale.modeChanged().unsubscribeAll(this)),
                this._priceScale = null,
                this._mouseEventHandler.destroy(),
                this._properties.childs().fontSize.unsubscribe(this, this._onFontSizeChanged),
                null !== this._actions && (Object.values(this._actions).forEach((e=>{
                    e.destroy()
                }
                )),
                this._actions = null),
                (0,
                vi.actualCurrencyUnitVisibility)().unsubscribeAll(this),
                this._chart.anyPriceAxisHovered().unsubscribe(this._recalcCurrencyAndUnitVisibility),
                (0,
                Si.actualAutoLogButtonsVisibility)().unsubscribeAll(this),
                this._chart.setPriceAxisHovered(this, !1),
                this._destroyScaleModeButtons(),
                this._destroyed = !0
            }
            axisInfo() {
                return this._axisInfo
            }
            setHighlighted(e) {
                this._highlighted = e
            }
            backgroundColor() {
                return this._pane.state().model().backgroundColor().value()
            }
            backgroundTopColor() {
                return this._pane.state().model().backgroundTopColor().value()
            }
            lineColor() {
                return this._properties.childs().lineColor.value()
            }
            textColor() {
                return this._properties.childs().textColor.value()
            }
            fontSize() {
                return this._properties.childs().fontSize.value()
            }
            baseFont() {
                return (0,
                Yt.makeFont)(this.fontSize(), ei.CHART_FONT_FAMILY, "")
            }
            rendererOptions() {
                let e = this._rendererOptionsProvider.options();
                return this._color === e.color && this._fontSize === e.fontSize || (this._color = e.color),
                this._fontSize !== e.fontSize && (this._widthCache.reset(),
                this._fontSize = e.fontSize,
                this._currencyLabelWidth = null,
                this._currencyFontSize = 0,
                this._updateCurrencyLabelFont(),
                this.onOptimalWidthNeedToBeRecalculated()),
                this._chart.onWidget() || (e = Object.assign({}, e, {
                    paddingInner: Math.max(e.paddingInner, li.ALERT_LABEL_WIDTH)
                })),
                e
            }
            mouseEnterEvent(e) {
                this._chart.setPriceAxisHovered(this, !0),
                this._isHovered.setValue(!0),
                this._applyLightUpdateIfRequired(),
                this._mouseEnterOrTouchStartEvent(e)
            }
            mouseMoveEvent(e) {
                this._mouseOrTouchMoveEvent(e)
            }
            mouseDownEvent(e) {
                this._mouseDownOrTouchStartEvent(e)
            }
            touchStartEvent(e) {
                this._mouseOrTouchMoveEvent(e),
                this._mouseEnterOrTouchStartEvent(e),
                this._mouseDownOrTouchStartEvent(e)
            }
            pressedMouseMoveEvent(e) {
                this._pressedMouseOrTouchMoveEvent(e)
            }
            touchMoveEvent(e) {
                this._pressedMouseOrTouchMoveEvent(e)
            }
            pinchStartEvent(e, t, i, s) {
                return s.bothPointsOnTargetElement
            }
            pinchEvent(e, t, i) {
                if (this._zoomAvailable() && this._options.pinchScale) {
                    if (this._dragScaleActive && this._finishScale(),
                    !this._pinching)
                        return this._pinching = !0,
                        void this._undoModel.startTwoPointsScalePrice(this._pane.state(), this.priceScale(), t.y, i.y);
                    this._undoModel.twoPointsScalePriceTo(this._pane.state(), this.priceScale(), t.y, i.y)
                }
            }
            pinchEndEvent() {
                this._pinching = !1,
                this._undoModel.endTwoPointsScalePrice(this._pane.state(), this.priceScale())
            }
            mouseDownOutsideEvent() {
                this._finishScale()
            }
            touchStartOutsideEvent() {
                this._finishScale(),
                this._selectedViaTap.setValue(!1)
            }
            mouseUpEvent(e) {
                this._mouseUpOrTouchEndEvent(e)
            }
            touchEndEvent(e) {
                this._mouseLeaveOrTouchEndEvent(e),
                this._mouseUpOrTouchEndEvent(e)
            }
            mouseClickEvent(e) {
                this._mouseClickOrTapEvent(e)
            }
            tapEvent(e) {
                this._mouseClickOrTapEvent(e)
            }
            mouseLeaveEvent(e) {
                this._chart.setPriceAxisHovered(this, !1),
                this._isHovered.setValue(!1),
                this._applyLightUpdateIfRequired(),
                this._mouseLeaveOrTouchEndEvent(e)
            }
            mouseDoubleClickEvent(e) {
                this._mouseDoubleClickOrDoubleTapEvent(e)
            }
            doubleTapEvent(e) {
                this._mouseDoubleClickOrDoubleTapEvent(e)
            }
            contextMenuEvent(e) {
                this._contextMenuOrTouchContextMenuEvent(e)
            }
            touchContextMenuEvent(e) {
                this._contextMenuOrTouchContextMenuEvent(e)
            }
            dataSourceAtPoint(e, t) {
                const i = this._pane.state();
                if (!i.maximized().value() && i.collapsed().value())
                    return null;
                const s = this._groupedSources()
                  , n = [...s.sources, ...s.topLevelSources, ...i.customSources(), ...i.sourcesByGroup().multipaneSources()];
                let r = null
                  , a = null;
                if (!this._priceScale)
                    return null;
                const l = (e,t)=>{
                    var i;
                    const s = null !== (i = null == a ? void 0 : a.target()) && void 0 !== i ? i : 0;
                    e.target() > s && (a = e,
                    r = t)
                }
                  , c = new o.Point(e,t)
                  , d = (0,
                Qe.getBindingRenderingInfo)(this._canvasBinding);
                for (let e = n.length - 1; e >= 0; --e) {
                    const t = n[e]
                      , s = t.priceAxisViews(i, this._priceScale);
                    if (s && 0 !== s.length)
                        for (let e = s.length - 1; e >= 0; --e) {
                            const i = s[e].renderer();
                            if (void 0 !== i.hitTest) {
                                const e = i.hitTest(c, d, this._isLeft ? "left" : "right");
                                null !== e && l(e, t)
                            }
                        }
                }
                return this._lastHittestResult = a,
                r
            }
            reset() {
                const e = this._pane.state()
                  , t = this.priceScale();
                this._undoModel.resetPriceScale(e, t),
                this.onOptimalWidthNeedToBeRecalculated(!0)
            }
            updateCurrencyLabel() {
                if (null === this._currencyLabel)
                    return;
                let e = !1;
                if (this._options.currencyConversionEnabled) {
                    const t = this.priceScale().currency(this._undoModel.model().availableCurrencies());
                    null === t || "alwaysOff" === (0,
                    vi.actualCurrencyUnitVisibility)().value() ? (e = this._currencyLabel.currencyLabelEnabled(),
                    this._currencyLabel.disableCurrency()) : (e = !this._currencyLabel.currencyLabelEnabled(),
                    this._currencyLabel.enableCurrency(),
                    e = this._currencyLabel.setCurrencyInfo(t) || e)
                } else
                    this._currencyLabel.disableCurrency();
                if (this._options.unitConversionEnabled) {
                    const t = "alwaysOff" === (0,
                    vi.actualCurrencyUnitVisibility)().value()
                      , i = this._undoModel.model().availableUnits()
                      , s = this.priceScale().unit(i);
                    null === s || t ? (e = e || this._currencyLabel.unitLabelEnabled(),
                    this._currencyLabel.disableUnit()) : (e = e || !this._currencyLabel.unitLabelEnabled(),
                    this._currencyLabel.enableUnit(),
                    e = this._currencyLabel.setUnitInfo(s) || e);
                    const o = this.priceScale().measureUnitId(i);
                    null === o || t ? (e = e || this._currencyLabel.measureUnitIdLableEnabled(),
                    this._currencyLabel.disableMeasureUnitId()) : (e = e || !this._currencyLabel.measureUnitIdLableEnabled(),
                    this._currencyLabel.enableMeasureUnitId(),
                    e = this._currencyLabel.setMeasureUnitIdInfo(o) || e)
                } else
                    this._currencyLabel.disableUnit(),
                    this._currencyLabel.disableMeasureUnitId();
                this._updateCurrencyLabelFont(),
                e && (this._currencyLabelWidth = null)
            }
            _groupedSources() {
                var e;
                const t = this._pane.state()
                  , i = t.model()
                  , s = this._pane.state().sourcesByGroup()
                  , o = this._isLeft ? s.leftPriceScalesSources() : s.rightPriceScalesSources()
                  , n = this._priceScale === t.defaultPriceScale()
                  , r = new Set(t.customSources())
                  , a = e=>!!r.has(e) || (e.priceScale() === this._priceScale || n && t.isOverlay(e))
                  , l = {
                    sources: [...o.filter(a), ...t.customSources()],
                    topLevelSources: new Set
                };
                if (n) {
                    const e = this._pane.state().dataSources();
                    for (const i of e)
                        t.isOverlay(i) && l.sources.push(i)
                }
                const c = null !== (e = i.lineBeingEdited()) && void 0 !== e ? e : i.lineBeingCreated();
                c && a(c) && (l.topLevelSources.add(c),
                l.lineBeingEditedOrCreated = c);
                const d = i.customSourceBeingMoved();
                d && a(d) && (l.topLevelSources.add(d),
                l.customSourceBeingMoved = d);
                const u = i.sourcesBeingMoved().filter(a);
                u.length > 0 && (i.sourcesBeingMoved().forEach((e=>l.topLevelSources.add(e))),
                l.sourcesBeingMoved = u);
                const h = i.selection().allSources().filter(a);
                h.length > 0 && (h.forEach((e=>l.topLevelSources.add(e))),
                l.selectedSources = h);
                const p = i.hoveredSource();
                return p && a(p) && (l.topLevelSources.add(p),
                l.hoveredSource = p),
                l
            }
            _isCurrencyLabelEnabled() {
                return null !== this._currencyLabel && this._currencyLabel.isEnabled()
            }
            _updateCurrencyLabelFont() {
                if (null === this._currencyLabel)
                    return;
                const e = this.fontSize();
                e !== this._currencyFontSize && (this._currencyLabel.setFontSize(e),
                this._currencyFontSize = e,
                this._currencyLabelWidth = null,
                this.onOptimalWidthNeedToBeRecalculated())
            }
            _alignLabels() {
                var e, t, i, s, o;
                const n = this._size.height;
                let r = n / 2;
                const a = []
                  , l = this.priceScale()
                  , c = l.orderedSources().slice()
                  , d = this._pane.state()
                  , u = this.rendererOptions();
                if (l === d.defaultPriceScale()) {
                    const e = d.priceDataSources();
                    for (let t = 0; t < e.length; t++)
                        d.isOverlay(e[t]) && c.push(e[t])
                }
                const h = l.mainSource()
                  , p = d.sourcesByGroup().multipaneSources();
                for (const s of [c, d.customSources(), p])
                    for (let o = 0; o < s.length; ++o) {
                        const c = s[o]
                          , p = [...null !== (e = c.priceAxisViews(d, l)) && void 0 !== e ? e : [], ...null !== (i = null === (t = c.topPriceAxisViews) || void 0 === t ? void 0 : t.call(c, d, l)) && void 0 !== i ? i : []];
                        if (p) {
                            const e = p.filter((e=>{
                                if (e.ignoreAlignment() || !e.isVisible())
                                    return !1;
                                const {total: t} = e.topBottomTotalHeight(u)
                                  , i = e.floatCoordinate();
                                return i > -t && i < n + t
                            }
                            ));
                            if (!e.length)
                                continue;
                            a.push(...e),
                            h === c && (r = e[0].floatCoordinate())
                        }
                    }
                const m = a.filter((e=>e.floatCoordinate() <= r))
                  , g = a.filter((e=>e.floatCoordinate() > r));
                m.sort(((e,t)=>t.floatCoordinate() - e.floatCoordinate())),
                m.length > 0 && g.length > 0 && g.push(m[0]),
                g.sort(((e,t)=>e.floatCoordinate() - t.floatCoordinate()));
                for (const e of a)
                    e.setFixedCoordinate(e.coordinate());
                if (l.properties().childs().alignLabels.value()) {
                    if (g.length > 0 || m.length > 0) {
                        {
                            const e = null !== (s = m[0]) && void 0 !== s ? s : g[0]
                              , t = e.getFixedCoordinate()
                              , {top: i, bottom: o, total: r} = e.topBottomTotalHeight(u);
                            r < n && t - i < 0 && t + o > 0 && e.setFixedCoordinate(i)
                        }
                        {
                            const e = null !== (o = g[0]) && void 0 !== o ? o : m[0]
                              , t = e.getFixedCoordinate()
                              , {top: i, bottom: s, total: r} = e.topBottomTotalHeight(u);
                            r < n && t - i < n && t + s > n && e.setFixedCoordinate(n - s)
                        }
                    }
                    for (let e = 1; e < m.length; e++) {
                        const t = m[e]
                          , i = m[e - 1]
                          , {top: s, bottom: o, total: n} = t.topBottomTotalHeight(u)
                          , r = t.getFixedCoordinate()
                          , a = i.getFixedCoordinate();
                        if (r > a - n)
                            t.setFixedCoordinate(a - n);
                        else if (a > 0 && r - s < 0 && r + o > 0) {
                            const {top: e} = i.topBottomTotalHeight(u);
                            t.setFixedCoordinate(Math.min(a - e - o, s))
                        }
                    }
                    for (let e = 1; e < g.length; e++) {
                        const t = g[e]
                          , i = g[e - 1]
                          , {bottom: s, total: o} = i.topBottomTotalHeight(u)
                          , r = t.getFixedCoordinate()
                          , a = i.getFixedCoordinate();
                        if (r < a + o)
                            t.setFixedCoordinate(a + o);
                        else if (a < n) {
                            const {top: e, bottom: i} = t.topBottomTotalHeight(u);
                            r - e < n && r + i > n && t.setFixedCoordinate(Math.max(a + s + e, n - i))
                        }
                    }
                }
            }
            _drawTickMarks(e, t) {
                const i = this.priceScale().marks();
                e.save(),
                e.font = this.baseFont();
                const o = this.rendererOptions()
                  , {horizontalPixelRatio: n, verticalPixelRatio: r} = t
                  , a = this._isLeft ? Math.floor((this._size.width - o.additionalPaddingInner) * n) : 0
                  , l = this._isLeft ? Math.round(a - o.paddingInner * n) : Math.round(a + (o.additionalPaddingInner + o.paddingInner) * n)
                  , c = this.fontSize()
                  , d = this._isCurrencyLabelEnabled() ? (0,
                s.ensureNotNull)(this._currencyLabel).labelBottom() : 0
                  , u = i.map((t=>{
                    if (this._options.croppedTickMarks)
                        return {
                            visible: !0,
                            yCorrection: this._widthCache.yMidCorrection(e, t.label)
                        };
                    const i = t.coord - c / 2
                      , s = t.coord + c / 2
                      , o = !(s > this._size.height || i < d);
                    return {
                        visible: !(s > this._size.height || i < d),
                        yCorrection: o ? this._widthCache.yMidCorrection(e, t.label) : 0
                    }
                }
                ));
                e.fillStyle = this.textColor(),
                e.textAlign = this._isLeft ? "right" : "left",
                e.textBaseline = "middle",
                (0,
                Qe.drawScaled)(e, n, r, (()=>{
                    for (let t = i.length; t--; ) {
                        if (!u[t].visible)
                            continue;
                        const s = i[t];
                        e.fillText(s.label, l / n, s.coord + u[t].yCorrection)
                    }
                }
                )),
                e.restore()
            }
            async _showCurrenciesContextMenu() {
                var e;
                if (null !== this._currencyMenu && this._currencyMenu.isOpened())
                    return void this._currencyMenu.close();
                (0,
                Ne.trackEvent)("GUI", "Currency conversion");
                const {currencyActions: t} = await Promise.all([i.e(69093), i.e(93703), i.e(75816), i.e(44524), i.e(21356), i.e(62093), i.e(53953), i.e(2520), i.e(59258), i.e(82421), i.e(67158), i.e(74600), i.e(98734), i.e(93523), i.e(43362), i.e(5463), i.e(16164), i.e(38985), i.e(32227), i.e(62526), i.e(32704)]).then(i.bind(i, 639403))
                  , o = await hi(Pi, (()=>t(this._undoModel, (0,
                s.ensureNotNull)(this._currencyLabel).currencyInfo(), this.priceScale())), (0,
                s.ensureNotNull)(this._currencyLabel).currencyLabelElement(), Ri, (()=>["toggle_currency_menu_inner", this._undoModel.model().id(), this._pane.state().id(), this.priceScale().id()]), (()=>{
                    var e;
                    this._recalcCurrencyAndUnitVisibility(),
                    null === (e = this._currencyLabel) || void 0 === e || e.setCurrencyExpanded(!1)
                }
                ));
                null === (e = this._currencyLabel) || void 0 === e || e.setCurrencyExpanded(!0),
                this._destroyed ? o.close() : this._currencyMenu = o
            }
            async _showUnitsContextMenu() {
                var e;
                if (null !== this._unitMenu && this._unitMenu.isOpened())
                    return void this._unitMenu.close();
                (0,
                Ne.trackEvent)("GUI", "Unit conversion");
                const {unitActions: t} = await Promise.all([i.e(69093), i.e(93703), i.e(75816), i.e(44524), i.e(21356), i.e(62093), i.e(53953), i.e(2520), i.e(59258), i.e(82421), i.e(67158), i.e(74600), i.e(98734), i.e(93523), i.e(43362), i.e(5463), i.e(16164), i.e(38985), i.e(32227), i.e(62526), i.e(32704)]).then(i.bind(i, 748543))
                  , o = await hi(xi, (()=>t(this._undoModel, (0,
                s.ensureNotNull)(this._currencyLabel).unitInfo(), this.priceScale())), (0,
                s.ensureNotNull)(this._currencyLabel).unitLabelElement(), Oi, (()=>["toggle_unit_menu_inner", this._undoModel.model().id(), this._pane.state().id(), this.priceScale().id()]), (()=>{
                    var e;
                    this._recalcCurrencyAndUnitVisibility(),
                    null === (e = this._currencyLabel) || void 0 === e || e.setUnitExpanded(!1)
                }
                ));
                null === (e = this._currencyLabel) || void 0 === e || e.setUnitExpanded(!0),
                this._destroyed ? o.close() : this._unitMenu = o
            }
            _onFontSizeChanged() {
                this._currencyLabelWidth = null,
                this._currencyFontSize = 0,
                this._updateCurrencyLabelFont(),
                this.onOptimalWidthNeedToBeRecalculated()
            }
            _mouseOrTouchMoveEvent(e) {
                var t, i, s, o;
                if (!this._priceScale)
                    return;
                if (e.localX < 0 || e.localY < 0 || e.localX >= this._size.width || e.localY >= this._size.height)
                    return;
                let n = !0;
                const r = this.dataSourceAtPoint(e.localX, e.localY);
                r ? (this._setCursorClassName("pointer"),
                (null === (i = null === (t = this._lastHittestResult) || void 0 === t ? void 0 : t.data()) || void 0 === i ? void 0 : i.hoverModelFromAxis) && (this._undoModel.model().setHoveredSource(r, null !== (o = null === (s = this._lastHittestResult) || void 0 === s ? void 0 : s.data()) && void 0 !== o ? o : null, 0),
                n = !1)) : this._setResizeCursor(),
                n && this._undoModel.model().setHoveredSource(null, null)
            }
            _mouseDownOrTouchStartEvent(e) {
                this._zoomAvailable() && this._options.pressedMouseMoveScale && !this._pinching && (this._dragScaleActive = !0,
                this._undoModel.startScalePrice(this._pane.state(), this.priceScale(), e.localY))
            }
            _mouseEnterOrTouchStartEvent(e) {
                this._setResizeCursor()
            }
            _pressedMouseOrTouchMoveEvent(e) {
                if (this._dragScaleActive) {
                    const t = this.priceScale();
                    this._undoModel.scalePriceTo(this._pane.state(), t, e.localY)
                }
            }
            _mouseUpOrTouchEndEvent(e) {
                this._finishScale()
            }
            _finishScale() {
                this._dragScaleActive && (this._undoModel.endScalePrice(this._pane.state(), this.priceScale()),
                this.restoreDefaultCursor(),
                this._dragScaleActive = !1)
            }
            _mouseClickOrTapEvent(e) {
                if (this._currencyLabel) {
                    if (this._currencyLabel.currencyConversionAvailable() && this._currencyLabel.currencyLabelElement().contains(e.target))
                        return this._showCurrenciesContextMenu(),
                        void e.preventDefault();
                    if (this._currencyLabel.unitConversionAvailable() && this._currencyLabel.unitLabelElement().contains(e.target))
                        return this._showUnitsContextMenu(),
                        void e.preventDefault()
                }
                e.isTouch && this._selectedViaTap.setValue(!this._selectedViaTap.value());
                const t = this.dataSourceAtPoint(e.localX, e.localY);
                t && this._undoModel.selectionMacro((e=>{
                    var i, s, o;
                    e.selection().isSelected(t) && this._undoModel.model().lastSelectedHittestData() === (null === (i = this._lastHittestResult) || void 0 === i ? void 0 : i.data()) || (e.clearSelection(),
                    e.addSourceToSelection(t, null !== (o = null === (s = this._lastHittestResult) || void 0 === s ? void 0 : s.data()) && void 0 !== o ? o : null))
                }
                ))
            }
            _mouseLeaveOrTouchEndEvent(e) {
                this._setCursorClassName("")
            }
            _mouseDoubleClickOrDoubleTapEvent(e) {
                var t, i, s;
                if ((null === (t = this._currencyLabel) || void 0 === t ? void 0 : t.currencyLabelElement().contains(e.target)) || (null === (i = this._currencyLabel) || void 0 === i ? void 0 : i.unitLabelElement().contains(e.target)))
                    return;
                const o = this.dataSourceAtPoint(e.localX, e.localY);
                o ? this._pane.processDoubleClickOnSource(o, null !== (s = this._lastHittestResult) && void 0 !== s ? s : void 0, {
                    origin: "price_scale"
                }) : (this.reset(),
                (0,
                Ne.trackEvent)("GUI", "Double click price scale"))
            }
            _contextMenuOrTouchContextMenuEvent(e) {
                if (this._options.contextMenuEnabled) {
                    const t = this.dataSourceAtPoint(e.localX, e.localY);
                    if (null !== t && this._options.contextMenu.source) {
                        return void this._undoModel.model().selectionMacro((i=>{
                            i.selection().isSelected(t) || (i.clearSelection(),
                            i.addSourceToSelection(t)),
                            this._pane.showContextMenuForSelection(e, {
                                origin: "price_scale"
                            })
                        }
                        ))
                    }
                    this._options.contextMenu.general && Jt.ContextMenuManager.showMenu(this.getContextMenuActions(!0), e, {
                        statName: "PriceScaleContextMenu"
                    }, {
                        menuName: "PriceScaleContextMenu"
                    })
                }
            }
            _setResizeCursor() {
                const e = this.priceScale();
                e.isPercentage() || e.isIndexedTo100() ? this._setCursorClassName("") : this._zoomAvailable() && (this._options.pressedMouseMoveScale || this._options.mouseWheelScale) && this._setCursorClassName("ns-resize")
            }
            _setCursorClassName(e) {
                let t = "";
                e && (t = "price-axis--cursor-" + e),
                this._currentCursorClassName !== t && (this._currentCursorClassName && this._cell.classList.remove(this._currentCursorClassName),
                t && this._cell.classList.add(t),
                this._currentCursorClassName = t)
            }
            _zoomAvailable() {
                return !this.priceScale().isEmpty() && this.priceScale().hasCalculatedPriceRange() && this._undoModel.model().zoomEnabled()
            }
            _onMousewheel(e) {
                if (!this._zoomAvailable() || !this._options.mouseWheelScale)
                    return;
                const t = (0,
                s.ensureNotNull)(this._mouseWheelHelper).processWheel(e).deltaY;
                if (0 === t)
                    return;
                e.cancelable && e.preventDefault();
                const i = this._undoModel
                  , o = this._pane.state()
                  , n = this.priceScale()
                  , r = this._cell.getBoundingClientRect()
                  , a = e.clientY - r.top
                  , l = a + 15 * t;
                i.startScalePrice(o, this.priceScale(), a, !0),
                i.scalePriceTo(o, n, l),
                i.endScalePrice(o, n),
                e.stopPropagation()
            }
            _drawCrossHairLabel(e, t) {
                const i = this._pane.state()
                  , s = i.model()
                  , o = this.priceScale()
                  , n = s.crossHairSource().priceAxisViews(i, o);
                n && n.length > 0 && this._drawLabels(n, e, t)
            }
            _drawBackground(e, t) {
                const i = this.backgroundTopColor()
                  , s = this.backgroundColor()
                  , {bitmapSize: o} = t;
                if (i === s ? (0,
                Qe.clearRect)(e, 0, 0, o.width, o.height, this.backgroundColor()) : (0,
                Kt.clearRectWithGradient)(e, 0, 0, o.width, o.height, i, s),
                this._highlighted) {
                    e.globalAlpha = .5;
                    const t = Ce.themes[this._backgroundBasedTheme.value()].getThemedColor("color-price-axis-highlight");
                    (0,
                    Qe.fillRect)(e, 0, 0, o.width, o.height, t),
                    e.globalAlpha = 1
                }
            }
            _drawDrawingsHighlight(e, t) {
                const i = this._pane.state().model()
                  , s = this.priceScale()
                  , o = i.selection().lineDataSources().filter((e=>e.priceScale() === s)).reduce(((e,t)=>{
                    const i = t.priceAxisPoints();
                    return 0 === i.length ? e : e.concat(i)
                }
                ), []);
                o.length > 0 && this._hightlightBackground(e, o, this.priceScale().mainSource(), t);
                const n = i.crossHairSource();
                n.startMeasurePoint() && this._hightlightBackground(e, n.measurePoints(), this.priceScale().mainSource(), t)
            }
            _drawBorder(e, t) {
                e.save(),
                e.fillStyle = this.lineColor();
                const {horizontalPixelRatio: i} = t
                  , s = Math.max(1, Math.floor(this.rendererOptions().borderSize * i))
                  , o = this._isLeft ? t.bitmapSize.width - s : 0;
                e.fillRect(o, 0, s, t.bitmapSize.height),
                e.restore()
            }
            _drawLabels(e, t, i) {
                const s = this.rendererOptions()
                  , o = this._isLeft ? "right" : "left";
                for (const n of e)
                    n.isAxisLabelVisible() && (t.save(),
                    n.renderer().draw(t, i, s, this._widthCache, o),
                    t.restore())
            }
            _hightlightBackground(e, t, i, s) {
                if (!i)
                    return;
                const o = i.firstValue();
                if (null === o)
                    return;
                let n = t[0].price
                  , r = t[0].price;
                for (let e = 1; e < t.length; e++)
                    n = Math.min(n, t[e].price),
                    r = Math.max(r, t[e].price);
                const {horizontalPixelRatio: a, verticalPixelRatio: l} = s
                  , c = this.priceScale()
                  , d = Math.floor(c.priceToCoordinate(n, o) * l)
                  , u = Math.ceil(c.priceToCoordinate(r, o) * l);
                (0,
                Qe.fillRect)(e, Math.floor(a), d, s.bitmapSize.width, u - d, this._properties.childs().axisHighlightColor.value())
            }
            _viewsOrMaxMinViews(e) {
                var t, i;
                const s = this._pane.state()
                  , o = this.priceScale();
                if (0 === e.length)
                    return [];
                if (1 === e.length)
                    return null !== (t = e[0].priceAxisViews(s, o)) && void 0 !== t ? t : [];
                {
                    let t = 1 / 0
                      , n = -1 / 0
                      , r = null
                      , a = null;
                    for (const l of e) {
                        const e = null !== (i = l.priceAxisViews(s, o)) && void 0 !== i ? i : [];
                        for (const i of e) {
                            const e = i.coordinate();
                            e >= n && (n = e,
                            a = i),
                            e <= t && (t = e,
                            r = i)
                        }
                    }
                    return a && r ? [a, r] : []
                }
            }
            _views(e, t) {
                var i, s;
                const o = this._pane.state()
                  , n = this.priceScale()
                  , r = [];
                if (1 !== e)
                    for (const e of t.sources)
                        t.topLevelSources.has(e) || r.push(...null !== (i = e.priceAxisViews(o, n)) && void 0 !== i ? i : []);
                if (0 !== e) {
                    const e = new Set
                      , i = t=>!e.has(t)
                      , a = t=>{
                        const s = t.filter(i);
                        r.push(...this._viewsOrMaxMinViews(s));
                        for (const t of s)
                            e.add(t)
                    }
                    ;
                    t.customSourceBeingMoved && a([t.customSourceBeingMoved]),
                    t.sourcesBeingMoved && a(t.sourcesBeingMoved),
                    t.selectedSources && a(t.selectedSources),
                    t.hoveredSource && a([t.hoveredSource]),
                    t.lineBeingEditedOrCreated && a([t.lineBeingEditedOrCreated]);
                    for (const e of [...t.sources, ...o.customSources()])
                        e.topPriceAxisViews && r.push(...null !== (s = e.topPriceAxisViews(o, n)) && void 0 !== s ? s : [])
                }
                return r
            }
            _initActions() {
                if (!this._pane.hasState() || null !== this._actions)
                    return;
                const e = this._undoModel
                  , t = new fi.ActionWithStandardIcon({
                    actionId: "Chart.PriceScale.Reset",
                    options: {
                        label: Mi,
                        iconId: "Chart.Reset",
                        shortcutHint: (0,
                        k.humanReadableHash)(k.Modifiers.Alt + 82),
                        statName: "ResetScale",
                        onExecute: ()=>this.reset()
                    }
                })
                  , i = new _i.Action({
                    actionId: "Chart.PriceScale.ToggleAutoScale",
                    options: {
                        label: Ii,
                        checkable: !0,
                        checked: !0,
                        statName: "ToggleAutoScale",
                        onExecute: ()=>{
                            e.togglePriceScaleAutoScaleMode(this.priceScale()),
                            this._updateScalesActions()
                        }
                    }
                })
                  , s = new _i.Action({
                    actionId: "Chart.PriceScale.TogglePercentage",
                    options: {
                        label: Ai,
                        checkable: !0,
                        checked: this.priceScale().isPercentage(),
                        statName: "TogglePercantage",
                        onExecute: ()=>{
                            e.togglePriceScalePercentageScaleMode(this.priceScale()),
                            this._updateScalesActions()
                        }
                    }
                })
                  , o = new _i.Action({
                    actionId: "Chart.PriceScale.ToggleIndexedTo100",
                    options: {
                        label: Li,
                        checkable: !0,
                        checked: this.priceScale().isIndexedTo100(),
                        statName: "ToggleIndexedTo100",
                        onExecute: ()=>{
                            e.togglePriceScaleIndexedTo100ScaleMode(this.priceScale()),
                            this._updateScalesActions()
                        }
                    }
                })
                  , n = new _i.Action({
                    actionId: "Chart.PriceScale.ToggleLogarithmic",
                    options: {
                        label: Ei,
                        checkable: !0,
                        checked: this.priceScale().isLog(),
                        statName: "ToggleLogScale",
                        onExecute: ()=>{
                            e.togglePriceScaleLogScaleMode(this.priceScale()),
                            this._updateScalesActions()
                        }
                    }
                })
                  , r = new _i.Action({
                    actionId: "Chart.PriceScale.ToggleRegular",
                    options: {
                        label: ki,
                        checkable: !0,
                        checked: this.priceScale().isRegular(),
                        statName: "ToggleRegularScale",
                        onExecute: ()=>{
                            e.setPriceScaleRegularScaleMode(this.priceScale()),
                            this._updateScalesActions()
                        }
                    }
                })
                  , a = new pi.PropertyBoundAction({
                    actionId: "Chart.PriceScale.Labels.ToggleNoOverlappingLabelsVisibility",
                    options: {
                        label: Di,
                        checkable: !0,
                        checked: this.priceScale().properties().childs().alignLabels.value(),
                        statName: "TogglePreciseLabels"
                    }
                },{
                    property: this.priceScale().properties().childs().alignLabels,
                    undoModel: e,
                    undoText: bi
                })
                  , l = new _i.Action({
                    actionId: "Chart.PriceScale.ToggleInvertScale",
                    options: {
                        label: Ni,
                        checkable: !0,
                        checked: this.priceScale().isInverted(),
                        statName: "Invert Scale",
                        onExecute: ()=>{
                            e.invertPriceScale(this.priceScale()),
                            this._updateScalesActions()
                        }
                    }
                });
                this._actions = {
                    reset: t,
                    setAutoScale: i,
                    setPercentage: s,
                    setIndexedTo100: o,
                    setLog: n,
                    setRegular: r,
                    alignLabels: a,
                    invertScale: l
                },
                this._updateScalesActions()
            }
            _logAction() {
                return this._isMainSeriesAxis() ? this._chart.actions().logSeriesScale : (0,
                s.ensureNotNull)(this._actions).setLog
            }
            _percentageAction() {
                return this._isMainSeriesAxis() ? this._chart.actions().percentSeriesScale : (0,
                s.ensureNotNull)(this._actions).setPercentage
            }
            _indexedTo100Action() {
                return this._isMainSeriesAxis() ? this._chart.actions().indexedTo100SeriesScale : (0,
                s.ensureNotNull)(this._actions).setIndexedTo100
            }
            _autoScaleAction() {
                return this._isMainSeriesAxis() ? this._chart.actions().autoSeriesScale : (0,
                s.ensureNotNull)(this._actions).setAutoScale
            }
            _regularScaleAction() {
                return this._isMainSeriesAxis() ? this._chart.actions().regularSeriesScale : (0,
                s.ensureNotNull)(this._actions).setRegular
            }
            _lockScaleAction() {
                const e = this._chart.actions().lockSeriesScale
                  , t = Bi(this.priceScale(), this._undoModel.model().mainSeriesScaleRatio());
                return e.update({
                    hint: t
                }),
                e
            }
            _invertAction() {
                return this._isMainSeriesAxis() ? this._chart.actions().invertSeriesScale : (0,
                s.ensureNotNull)(this._actions).invertScale
            }
            _isMainSeriesAxis() {
                return this.priceScale().hasMainSeries()
            }
            _updateScalesActions() {
                const e = this.priceScale()
                  , t = this._isMainSeriesAxis()
                  , i = (0,
                s.ensureNotNull)(e.mainSource()).properties()
                  , o = t && e.isLockScale()
                  , n = t && 6 === i.style.value()
                  , r = (0,
                s.ensureNotNull)(this._actions);
                r.setRegular.update({
                    checked: e.isRegular(),
                    disabled: o || n
                }),
                r.setPercentage.update({
                    checked: e.isPercentage(),
                    disabled: o || n
                }),
                r.setIndexedTo100.update({
                    checked: e.isIndexedTo100(),
                    disabled: o || n
                }),
                r.setLog.update({
                    checked: e.isLog(),
                    disabled: o || n
                }),
                r.setAutoScale.update({
                    checked: e.isAutoScale(),
                    disabled: e.properties().childs().autoScaleDisabled.value()
                })
            }
            _createMergeScalesAction() {
                const e = this._chart.actions()
                  , t = this._undoModel.model().priceScaleSlotsCount();
                if (t.left + t.right === 1)
                    return 0 === t.left ? e.moveScaleToLeft : e.moveScaleToRight;
                const i = [];
                return i.push(e.mergeLeftScalesAction),
                i.push(e.mergeRightScalesAction),
                new _i.Action({
                    actionId: "Chart.PriceScale.MergeAllScales",
                    options: {
                        label: wi,
                        subItems: i
                    }
                })
            }
            _setCursor(e) {
                let t = "";
                "grabbing" !== e && "ns-resize" !== e || (t = "price-axis--cursor-" + e),
                this._currentCursorClassName !== t && (this._currentCursorClassName && this._cell.classList.remove(this._currentCursorClassName),
                t && this._cell.classList.add(t),
                this._currentCursorClassName = t,
                this._cell.style.cursor)
            }
            async _createScaleModeButtons() {
                var e;
                const {PriceScaleModeButtonsRenderer: t} = await Promise.all([i.e(98975), i.e(43848), i.e(64159), i.e(32227), i.e(23555)]).then(i.bind(i, 347742))
                  , s = new t({
                    className: "price-axis__modeButtons",
                    setMode: e=>{
                        this._priceScale && ("log" === e ? this._chart.model().setPriceScaleMode({
                            log: !this._priceScale.isLog()
                        }, this._priceScale, Ci) : this._chart.model().setPriceScaleMode({
                            autoScale: !this._priceScale.isAutoScale()
                        }, this._priceScale, yi))
                    }
                    ,
                    getMode: ()=>{
                        var e;
                        return null === (e = this._priceScale) || void 0 === e ? void 0 : e.mode()
                    }
                });
                return s.element().style.background = this.backgroundColor(),
                this._cell.appendChild(s.element()),
                null === (e = this._priceScale) || void 0 === e || e.modeChanged().subscribe(this, this._updateScaleModeButtons),
                s
            }
            _destroyScaleModeButtons() {
                var e;
                this._scaleModeButtons && (this._isHovered.unsubscribe(this._updatePriceScaleModeButtonsVisibility),
                null === (e = this._priceScale) || void 0 === e || e.modeChanged().unsubscribe(this, this._updateScaleModeButtons),
                this._scaleModeButtons.destroy(),
                this._scaleModeButtons = null)
            }
            _highlightColor() {
                const e = this.backgroundColor()
                  , t = this._backgroundBasedTheme.value();
                if (null === this._highlightColorCache || this._highlightColorCache.backgroundColor !== e || this._highlightColorCache.theme !== t) {
                    const i = (0,
                    Re.applyTransparency)(Ce.themes[this._backgroundBasedTheme.value()].getThemedColor("color-price-axis-highlight"), 50)
                      , s = (0,
                    Bt.rgbaToString)((0,
                    Bt.blendRgba)((0,
                    Bt.parseRgba)(this.backgroundColor()), (0,
                    Bt.parseRgba)(i)));
                    this._highlightColorCache = {
                        theme: t,
                        backgroundColor: e,
                        resultColor: s
                    }
                }
                return this._highlightColorCache.resultColor
            }
            _applyLightUpdateIfRequired() {
                "visibleOnMouseOver" === (0,
                vi.actualCurrencyUnitVisibility)().value() && this._undoModel.model().lightUpdate()
            }
        }
        var Fi = i(689010);
        const Hi = (0,
        n.getLogger)("Chart.ChartUndoModel");
        class zi extends m.UndoCommand {
            constructor(e, t, i, s=!0) {
                super(i, !1, s),
                this._newRightOffsetAndBarSpacing = null,
                this._model = e,
                this._rightOffsetAndBarSpacing = t
            }
            undo() {
                if (null !== this._newRightOffsetAndBarSpacing)
                    return void Hi.logDebug("TimeScaleChangeUndoCommand.undo: Command is already undone");
                const e = this._model.timeScale();
                this._newRightOffsetAndBarSpacing = {
                    barSpacing: e.barSpacing(),
                    rightOffset: e.rightOffset()
                },
                e.setBarSpacing(this._rightOffsetAndBarSpacing.barSpacing),
                e.setRightOffset(this._rightOffsetAndBarSpacing.rightOffset),
                this._model.lightUpdate()
            }
            redo() {
                if (null === this._newRightOffsetAndBarSpacing)
                    return void Hi.logDebug("TimeScaleChangeUndoCommand.redo: Command is not undone");
                const e = this._model.timeScale();
                e.setBarSpacing(this._newRightOffsetAndBarSpacing.barSpacing),
                e.setRightOffset(this._newRightOffsetAndBarSpacing.rightOffset),
                this._model.lightUpdate(),
                this._newRightOffsetAndBarSpacing = null
            }
        }
        const Ui = (0,
        n.getLogger)("Chart.ChartUndoModel")
          , Gi = new c.TranslatedString("scale price",r.t(null, void 0, i(394981)));
        class ji extends m.UndoCommand {
            constructor(e, t, i, s, o, n=!0) {
                super(Gi, !1, n),
                this._newPriceScaleState = null,
                this._model = e,
                this._paneIndex = e.panes().indexOf(t),
                this._priceScaleId = i.id(),
                this._state = s,
                this._timestamp = o ? performance.now() : null
            }
            undo() {
                if (null !== this._newPriceScaleState)
                    return void Ui.logDebug("PriceScaleChangeUndoCommand.undo: Command is already undone");
                const [e,t] = this._paneAndScale();
                this._newPriceScaleState = t.state(),
                this._model.restorePriceScaleState(e, t, this._state)
            }
            redo() {
                if (null === this._newPriceScaleState)
                    return void Ui.logDebug("PriceScaleChangeUndoCommand.redo: Command is not undone");
                const [e,t] = this._paneAndScale();
                this._model.restorePriceScaleState(e, t, this._newPriceScaleState),
                this._newPriceScaleState = null
            }
            canMerge(e) {
                return e instanceof ji && null !== this._timestamp && null !== e._timestamp && null === this._newPriceScaleState && e._model === this._model && e._paneIndex === this._paneIndex && e._priceScaleId === this._priceScaleId && Math.abs(e._timestamp - this._timestamp) < 1e3
            }
            merge(e) {
                this._timestamp = e._timestamp
            }
            _paneAndScale() {
                const e = this._model.panes()[this._paneIndex]
                  , t = (0,
                s.ensureNotNull)(e.getPriceScaleById(this._priceScaleId));
                return [e, t]
            }
        }
        var qi = i(558634)
          , Xi = i(475892)
          , Ki = i(447935)
          , Yi = i(55907)
          , Zi = i(15144)
          , $i = i(776734);
        function Ji(e, t) {
            (0,
            $i.getTracker)().then((i=>{
                if (null !== i) {
                    const o = (0,
                    s.ensureNotNull)(e.model().mainSeries().symbolInfo())
                      , n = o.pro_name || o.name;
                    i.trackDrawingsAnalytics(n, e.name(), t)
                }
            }
            ))
        }
        function Qi(e) {
            Ji(e, "create")
        }
        function es(e) {
            Ji(e, "paste")
        }
        var ts = i(86e3)
          , is = i(309103)
          , ss = i(195121);
        function os(e) {
            return "startMoving"in e && "move"in e && "endMoving"in e && "convertYCoordinateToPriceForMoving"in e
        }
        var ns = i(526910)
          , rs = i(813442)
          , as = i(169532)
          , ls = i(945982);
        i(126572);
        const cs = parseInt(ls["css-value-pane-controls-padding-left"])
          , ds = parseInt(ls["css-value-pane-controls-padding-right"])
          , us = (0,
        pt.getHexColorByName)("color-cold-gray-700")
          , hs = (0,
        pt.getHexColorByName)("color-cold-gray-400")
          , ps = new c.TranslatedString("scroll",r.t(null, void 0, i(42070)))
          , ms = r.t(null, void 0, i(566005))
          , gs = r.t(null, void 0, i(978972));
        function _s(e, t, i) {
            e.drawBackground && e.drawBackground(t, i)
        }
        function vs(e, t, i) {
            e.draw(t, i)
        }
        function Ss(e, t) {
            return e.paneViews(t)
        }
        function fs(e, t) {
            var i, s;
            return null !== (s = null === (i = e.topPaneViews) || void 0 === i ? void 0 : i.call(e, t)) && void 0 !== s ? s : []
        }
        function bs(e, t) {
            return e.labelPaneViews(t)
        }
        function ys(e, t) {
            const i = e.strategyOrdersPaneView();
            return null === i ? null : [i]
        }
        function Cs(e, t) {
            return null === e || e.source !== t ? null : e.hittest.data()
        }
        function ws(e, t, i, s, o) {
            var n, r;
            const a = null !== (r = null === (n = e.result) || void 0 === n ? void 0 : n.hittest.target()) && void 0 !== r ? r : 0;
            t.target() > a && (e.result = {
                hittest: t,
                source: i,
                renderer: s,
                isCustom: o
            })
        }
        const Ts = {
            contextMenuEnabled: !0,
            contextMenu: gi.defaultContextMenuOptions,
            priceScaleContextMenuEnabled: !0,
            legendWidgetEnabled: !0,
            controlsEnabled: !0,
            propertyPagesEnabled: !0,
            sourceSelectionEnabled: !0,
            countdownEnabled: !0
        }
          , Ps = new Map([[zt.AreaName.Text, "Text"], [zt.AreaName.Style, "Style"]])
          , xs = !d.enabled("display_legend_on_all_charts");
        let Ms = null;
        function Is(e, t) {
            return !(0,
            zt.shouldDefaultActionBeExecuted)(e, t, "pressedMouseMoveHandler", "touchMoveHandler")
        }
        class As {
            constructor(e, t, i, s) {
                this._legendWidget = null,
                this._paneControls = null,
                this._isDestroyed = !1,
                this._trackCrosshairOnlyAfterLongTap = (0,
                Mt.lastMouseOrTouchEventInfo)().isTouch,
                this._startTrackPoint = null,
                this._exitTrackingModeOnNextTry = !1,
                this._startMoveSourceParams = null,
                this._startChangeLineToolParams = null,
                this._preventSourceChange = !1,
                this._preventScrollUntilNextMouseDownOrTouchStart = !1,
                this._clonningAtMoveLineTools = null,
                this._startCloningPoint = null,
                this._size = (0,
                Ae.size)({
                    width: 0,
                    height: 0
                }),
                this._themedTopColor = null,
                this._initCrossHairPosition = null,
                this._firstZoomPoint = null,
                this._editDialog = null,
                this._processing = !1,
                this._pressedMoveStage = 0,
                this._touchMove = !1,
                this._startTouchPoint = null,
                this._isSelecting = !1,
                this._prevHoveredHittest = null,
                this._contextMenuX = 0,
                this._contextMenuY = 0,
                this._startScrollingPos = null,
                this._isScrolling = !1,
                this._scrollPriceScale = null,
                this._scrollXAnimation = null,
                this._prevPinchScale = 1,
                this._pinching = !1,
                this._wasPinched = !1,
                this._longTap = !1,
                this._contextMenuOpenedOnLastTap = !1,
                this._paneControlsResizeObserver = null,
                this._lastClickedSource = null,
                this._customLegendWidgetsFactoryMap = new Map,
                this._prevMoveEventPosition = null,
                this._onMagnetStateChangedListener = this._onMagnetStateChanged.bind(this),
                this._onShiftKeyStateChangedListener = this._onShiftKeyStateChanged.bind(this),
                this._currentCursorClassName = "",
                this._lastFinishedToolId = null,
                this._needResetMeasureLater = !1,
                this._currentChangingLineToolHitTest = null,
                this._currentMovingHitTest = null,
                this._prevTooltipData = null,
                this._errorRenderer = null,
                this._highlightedPriceAxis = new h.WatchedValue({
                    owner: "",
                    axis: null
                }),
                this._visuallyCollapsed = new h.WatchedValue(!1),
                this._endOfSeriesDataBanner = null,
                this._selectionBeforeMouseDown = new WeakSet,
                this._canvasConfiguredHandler = ()=>this._state && this._chartModel().lightUpdate(),
                this._updateVisuallyCollapsed = ()=>{
                    this._visuallyCollapsed.setValue(!this.state().maximized().value() && this.state().collapsed().value())
                }
                ,
                this._chart = e,
                this._state = t,
                this._options = (0,
                Ue.merge)((0,
                Ue.clone)(Ts), i),
                this._paneWidgetsSharedState = s,
                this._state && this._subscribeToState();
                const o = {
                    contextMenuEnabled: this._options.priceScaleContextMenuEnabled,
                    pressedMouseMoveScale: this._options.handleScale.axisPressedMouseMove.price,
                    mouseWheelScale: this._options.handleScale.mouseWheel,
                    currencyConversionEnabled: this._options.currencyConversionEnabled,
                    unitConversionEnabled: this._options.unitConversionEnabled,
                    countdownEnabled: this._options.countdownEnabled,
                    croppedTickMarks: this._options.croppedTickMarks
                };
                void 0 !== this._options.priceScaleContextMenu && (o.contextMenu = this._options.priceScaleContextMenu);
                const n = (e,t,i,s,n)=>new Wi(this._chart,this,this._chartUndoModel(),i,t,e,o,s,n)
                  , r = e.properties().childs().scalesProperties
                  , a = this._chartModel().rendererOptionsProvider()
                  , l = {
                    backgroundBasedTheme: e.backgroundBasedTheme().spawnOwnership(),
                    stubContextMenuProvider: ()=>[],
                    titlesProvider: ()=>[],
                    rendererOptionsProvider: a,
                    getBackgroundTopColor: ()=>this._chartModel().backgroundTopColor().value(),
                    getBackgroundBottomColor: ()=>this._chartModel().backgroundColor().value(),
                    requestRepaint: ()=>this._chartModel().lightUpdate()
                }
                  , c = {
                    showLabels: !1
                };
                this._lhsPriceAxisesContainer = new ai(r,"left",n,l,c),
                this._rhsPriceAxisesContainer = new ai(r,"right",n,l,c),
                this._paneCell = document.createElement("div"),
                this._paneCell.classList.add("chart-markup-table", "pane"),
                this._div = document.createElement("div"),
                this._div.classList.add("chart-gui-wrapper"),
                this._div.setAttribute("data-name", "pane-widget-chart-gui-wrapper"),
                this._paneCell.appendChild(this._div),
                this._canvasBinding = (0,
                Qe.createBoundCanvas)(this._div, (0,
                Ae.size)({
                    width: 16,
                    height: 16
                })),
                this._canvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
                const d = this._canvasBinding.canvasElement;
                d.style.position = "absolute",
                d.style.left = "0",
                d.style.top = "0",
                this._topCanvasBinding = (0,
                Qe.createBoundCanvas)(this._div, (0,
                Ae.size)({
                    width: 16,
                    height: 16
                })),
                this._topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
                const u = this._topCanvasBinding.canvasElement;
                u.style.position = "absolute",
                u.style.left = "0",
                u.style.top = "0",
                this._rowElement = document.createElement("div"),
                this._rowElement.style.display = "flex",
                this._rowElement.appendChild(this._lhsPriceAxisesContainer.getElement()),
                this._rowElement.appendChild(this._paneCell),
                this._rowElement.appendChild(this._rhsPriceAxisesContainer.getElement()),
                d.setAttribute("aria-hidden", "true");
                const p = this._chartModel().mainSeries();
                p.dataEvents().symbolResolved().subscribe(this, this._updateAccesibilityAttr),
                p.onIntervalChanged().subscribe(this, this._updateAccesibilityAttr),
                this._updateAccesibilityAttr(),
                this._options.legendWidgetEnabled && (this._options.customLegendWidgetFactories && (this._customLegendWidgetsFactoryMap = this._options.customLegendWidgetFactories),
                this._loadAndCreateLegendWidget()),
                this._state && !this._chart.readOnly() && this._options.controlsEnabled && this._loadAndCreatePaneControlsWidget(),
                (0,
                ss.magnetEnabled)().subscribe(this._onMagnetStateChangedListener),
                (0,
                et.shiftPressed)().subscribe(this._onShiftKeyStateChangedListener),
                this._paneCell.addEventListener("dragover", (e=>{
                    e.dataTransfer && Array.from(e.dataTransfer.files).some(Yi.blobImageFilter) && e.preventDefault()
                }
                )),
                this._paneCell.addEventListener("drop", (e=>{
                    if (window.user.id && e.dataTransfer && this._state) {
                        const t = Array.from(e.dataTransfer.files).find(Yi.blobImageFilter);
                        if (t) {
                            e.preventDefault();
                            const i = (0,
                            Yi.uploadImage)(t)
                              , s = URL.createObjectURL(t);
                            this._chartUndoModel().pasteImageAsLineTool(i, s, this._state),
                            i.catch((e=>{
                                (0,
                                E.showChartWarningNotification)("copy", {
                                    title: gs,
                                    text: e.message
                                })
                            }
                            ))
                        }
                    }
                }
                )),
                this.setCursorForTool(),
                this._mouseEventHandler = new Ot.MouseEventHandler(this._topCanvasBinding.canvasElement,this,{
                    treatVertTouchDragAsPageScroll: !this._options.handleScroll.vertTouchDrag,
                    treatHorzTouchDragAsPageScroll: !this._options.handleScroll.horzTouchDrag
                }),
                this._prevHoveredHittest = null,
                this._highlightedPriceAxis.subscribe((e=>this._highlightPriceAxisByLabel(e.axis))),
                this._prevPinchScale = 0,
                this._isDestroyed = !1
            }
            destroy() {
                var e;
                this._chart.onPaneWidgetDestroyed(this);
                const t = this._chartModel().mainSeries();
                t.dataEvents().symbolResolved().unsubscribeAll(this),
                t.onIntervalChanged().unsubscribeAll(this),
                this._customLegendWidgetsFactoryMap.clear(),
                this._topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler),
                this._topCanvasBinding.dispose(),
                this._canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler),
                this._canvasBinding.dispose(),
                this._legendWidget && (this._legendWidget.destroy(),
                this._legendWidget = null),
                null !== this._paneControlsResizeObserver && this._paneControlsResizeObserver.disconnect(),
                null !== this._paneControls && (this._paneControls.destroy(),
                this._paneControls = null),
                this._lhsPriceAxisesContainer.destroy(),
                this._rhsPriceAxisesContainer.destroy(),
                this.hasState() && this._unsubscribeFromState(),
                (0,
                ss.magnetEnabled)().unsubscribe(this._onMagnetStateChangedListener),
                (0,
                et.shiftPressed)().unsubscribe(this._onShiftKeyStateChangedListener),
                this._paneWidgetsSharedState.onPaneDestroyed(this),
                this._errorRenderer && this._errorRenderer.then((e=>{
                    e.destroy(),
                    this._errorRenderer = null
                }
                )),
                this._prevHoveredHittest = null,
                this._mouseEventHandler.destroy(),
                null === (e = this._rowElement.parentElement) || void 0 === e || e.removeChild(this._rowElement),
                this._isDestroyed = !0
            }
            size() {
                return this._size
            }
            setSize(e) {
                (0,
                Ae.equalSizes)(this._size, e) || (this._size = e,
                this._canvasBinding.resizeCanvasElement(e),
                this._topCanvasBinding.resizeCanvasElement(e),
                this._paneCell.style.width = e.width + "px",
                this._paneCell.style.height = e.height + "px",
                this._div.style.width = e.width + "px",
                this._div.style.height = e.height + "px",
                this._rowElement.classList.toggle("js-hidden", 0 === e.height),
                null !== this._legendWidget && this._legendWidget.updateWidgetModeBySize(e),
                null !== this._paneControls && this._paneControls.updateWidgetModeByWidth(e.width))
            }
            width() {
                return this._size.width
            }
            height() {
                return this._size.height
            }
            backgroundColor() {
                return this._chartModel().backgroundColor().value()
            }
            highlightedPriceAxis() {
                return this._highlightedPriceAxis
            }
            processDoubleClickOnSource(e, t, i) {
                if ((0,
                li.isAlertLabel)(e)) {
                    const t = e.alert()
                      , s = t.id().value();
                    if (t.isNew() || !s)
                        return;
                    (0,
                    Ki.getChartAlertsFacade)().then((e=>{
                        var t;
                        (0,
                        Ne.trackEvent)("chart_alert", "edit", `double_click_on_${null !== (t = null == i ? void 0 : i.origin) && void 0 !== t ? t : "line"}`),
                        e.openEditDialog(s, {
                            actionSource: "alert_label_double_click",
                            dataSourceHub: this._chartModel()
                        })
                    }
                    ))
                } else
                    (0,
                    jt.isDataSource)(e) && e.id() !== this._lastFinishedToolId && this._showEditDialogForSource(e, t)
            }
            stretchFactor() {
                return this._state ? this._state.stretchFactor() : 0
            }
            setStretchFactor(e) {
                this.hasState() && this.state().setStretchFactor(e)
            }
            setCursorForTool(e, t, i) {
                if (t && t.mod() && e && e !== this._chartModel().crossHairSource())
                    return void this._setCursorClassName("pointer");
                if (void 0 !== i) {
                    switch (i) {
                    case ts.PaneCursorType.VerticalResize:
                        this._setCursorClassName("ns-resize");
                        break;
                    case ts.PaneCursorType.HorizontalResize:
                        this._setCursorClassName("ew-resize");
                        break;
                    case ts.PaneCursorType.DiagonalNeSwResize:
                        this._setCursorClassName("nesw-resize");
                        break;
                    case ts.PaneCursorType.DiagonalNwSeResize:
                        this._setCursorClassName("nwse-resize");
                        break;
                    case ts.PaneCursorType.Default:
                        this._setCursorClassName("default");
                        break;
                    case ts.PaneCursorType.Pointer:
                        this._setCursorClassName("pointer");
                        break;
                    case ts.PaneCursorType.Grabbing:
                        this._setCursorClassName("grabbing");
                        break;
                    case ts.PaneCursorType.Text:
                        this._setCursorClassName("text")
                    }
                    return
                }
                const s = qt.tool.value();
                if ((0,
                qt.toolIsCursor)(s)) {
                    if (null !== this._paneWidgetsSharedState.draggingSource() || this._isScrolling || this._chartUndoModel() && this._chartUndoModel().model().sourcesBeingMoved().length)
                        return void this._setCursorClassName("grabbing");
                    if (e && this._options.sourceSelectionEnabled)
                        return void this._setCursorClassName("pointer")
                }
                if ("eraser" === s)
                    return void this._setCursorClassName("eraser");
                if ("performance" === s)
                    return void this._setCursorClassName("performance");
                if ("zoom" === s)
                    return void this._setCursorClassName("zoom-in");
                const o = qt.cursorTool.value();
                "dot" !== o ? "arrow" !== o ? this._setCursorClassName("") : this._setCursorClassName("default") : this._setCursorClassName("dot")
            }
            showContextMenuForSelection(e, t, i) {
                const s = this._chartUndoModel().selection();
                if (s.isEmpty())
                    return;
                const o = s.dataSources().filter((e=>e.hasContextMenu()));
                this.showContextMenuForSources(o, e, void 0, t, i)
            }
            async showContextMenuForSources(e, t, i, s, o) {
                var n, r, a, l, c;
                if (!e.length || !this._state)
                    return Promise.resolve(null);
                const d = e[0]
                  , u = (0,
                Ue.merge)((0,
                Ue.clone)(this._options.contextMenu), i || {})
                  , h = new gi.ActionsProvider(this._chart,u);
                if (d === this._chartUndoModel().crossHairSource())
                    return d.handleContextMenuEvent(t),
                    Promise.resolve(null);
                {
                    const i = await h.contextMenuActionsForSources(e, this._state, t, null == s ? void 0 : s.origin, null === (n = null == o ? void 0 : o.data()) || void 0 === n ? void 0 : n.customActions);
                    if (0 === i.length)
                        return Promise.resolve(null);
                    {
                        let e;
                        return e = d instanceof ns.Series ? {
                            menuName: null !== (r = null == s ? void 0 : s.origin) && void 0 !== r ? r : "ObjectTreeContextMenu",
                            detail: {
                                type: "series",
                                id: d.instanceId()
                            }
                        } : (0,
                        ct.isLineTool)(d) ? {
                            menuName: null !== (a = null == s ? void 0 : s.origin) && void 0 !== a ? a : "ObjectTreeContextMenu",
                            detail: {
                                type: "shape",
                                id: null !== (l = null == d ? void 0 : d.id()) && void 0 !== l ? l : null
                            }
                        } : {
                            menuName: null !== (c = null == s ? void 0 : s.origin) && void 0 !== c ? c : "ObjectTreeContextMenu",
                            detail: {
                                type: "study",
                                id: (null == d ? void 0 : d.id()) || null
                            }
                        },
                        Jt.ContextMenuManager.createMenu(i, {
                            takeFocus: !0,
                            returnFocus: !0,
                            isKeyboardEvent: u.isKeyboardEvent
                        }, e).then((e=>(e.show(t),
                        e)))
                    }
                }
            }
            leftPriceAxisesContainer() {
                return this._lhsPriceAxisesContainer
            }
            rightPriceAxisesContainer() {
                return this._rhsPriceAxisesContainer
            }
            setPriceAxisSizes(e, t, i) {
                this._priceAxisesContainer(e).setSizes(t, i)
            }
            state() {
                return (0,
                s.ensureNotNull)(this._state)
            }
            hasState() {
                return null !== this._state
            }
            setState(e) {
                this._state !== e && (this.hasState() && this._unsubscribeFromState(),
                this._state = e,
                this.hasState() && (this._subscribeToState(),
                this.updatePriceAxisWidgetsStates()))
            }
            getScreenshotData(e) {
                var t, i, s, o;
                const n = []
                  , r = [];
                let a, l = [];
                const c = this.state().sourcesByGroup().priceSources().slice().reverse()
                  , u = this._chart.properties().childs().paneProperties.childs().legendProperties.childs();
                for (const h of c) {
                    const c = h.statusView();
                    if ((0,
                    rt.isStudy)(h) && (u.showLegend.value() || (null == e ? void 0 : e.showCollapsedStudies))) {
                        const s = u.showStudyTitles.value()
                          , o = !0;
                        if (h.properties().childs().visible.value() && this._chartModel().paneForSource(h) === this.state() && c && o) {
                            n.push(s ? h.statusProvider(null == e ? void 0 : e.status).text() : "");
                            const o = d.enabled("use_last_visible_bar_value_in_legend") && null !== (i = null === (t = this._chartModel().timeScale().visibleBarsStrictRange()) || void 0 === t ? void 0 : t.lastBar()) && void 0 !== i ? i : null
                              , a = h.legendValuesProvider().getValues(o);
                            r.push(a)
                        }
                    } else if (h === this._chartModel().mainSeries() && c && u.showSeriesTitle.value()) {
                        a = h.statusProvider((null == e ? void 0 : e.status) || {}).text();
                        const t = d.enabled("use_last_visible_bar_value_in_legend") && null !== (o = null === (s = this._chartModel().timeScale().visibleBarsStrictRange()) || void 0 === s ? void 0 : s.lastBar()) && void 0 !== o ? o : null;
                        l = h.legendValuesProvider().getValues(t)
                    }
                }
                return {
                    type: "pane",
                    leftAxis: this._lhsPriceAxisesContainer.getScreenshotData(),
                    rightAxis: this._rhsPriceAxisesContainer.getScreenshotData(),
                    content: this._canvasBinding.canvasElement.toDataURL(),
                    canvas: this._canvasBinding.canvasElement,
                    contentWidth: this._size.width,
                    contentHeight: this._size.height,
                    studies: n,
                    studiesValues: r,
                    containsMainSeries: this.containsMainSeries(),
                    mainSeriesText: a,
                    mainSeriesValues: l
                }
            }
            updatePriceAxisWidgetsStates() {
                if (!this.hasState())
                    return;
                const e = this._chartModel()
                  , t = e.paneForSource(e.mainSeries());
                if (!t)
                    return;
                const i = e.priceScaleSlotsCount()
                  , s = this.state()
                  , o = s.visibleLeftPriceScales()
                  , n = s.visibleRightPriceScales();
                this._lhsPriceAxisesContainer.setScales(o, i.left, t.leftPriceScales().length, i.left + i.right),
                this._rhsPriceAxisesContainer.setScales(n, i.right, t.rightPriceScales().length, i.left + i.right)
            }
            updatePriceAxisWidgets() {
                this._lhsPriceAxisesContainer.update(),
                this._rhsPriceAxisesContainer.update()
            }
            update() {
                this.hasState() && (this.updatePriceAxisWidgets(),
                null !== this._legendWidget && this._legendWidget.update(),
                this.updateControls())
            }
            updateStatusWidget(e) {
                this.hasState() && null !== this._legendWidget && (e.legendWidgetLayoutInvalidated() ? this._legendWidget.updateLayout() : this._legendWidget.update())
            }
            updateControls() {
                this.hasState() && null !== this._paneControls && this._paneControls.update()
            }
            updateThemedColors(e) {
                this._themedTopColor = e.topColor,
                this._updateByThemedColors()
            }
            statusWidget() {
                return this._legendWidget
            }
            getElement() {
                return this._rowElement
            }
            canvasElement() {
                return this._canvasBinding.canvasElement
            }
            hasCanvas(e) {
                return this._canvasBinding.canvasElement === e || this._topCanvasBinding.canvasElement === e
            }
            pinchStartEvent() {
                return null === this._paneWidgetsSharedState.scrollingPane() && null === this._paneWidgetsSharedState.pinchingPane() && (this._onTouchEvent(),
                !!this._options.handleScale.pinch && (this._chartModel().stopTimeScaleAnimation(),
                this._prevPinchScale = 1,
                this._pinching = !0,
                this._wasPinched = !0,
                this._paneWidgetsSharedState.setPinchingPane(this),
                !0))
            }
            pinchEvent(e, t, i, s) {
                if (null !== this._paneWidgetsSharedState.scrollingPane() || this._paneWidgetsSharedState.pinchingPane() !== this)
                    return;
                if (this._onTouchEvent(),
                !this._options.handleScale.pinch)
                    return;
                const o = 10 * (s - this._prevPinchScale);
                this._prevPinchScale = s,
                this._chartModel().zoomTime(e.x, o, !0),
                this._prevPinchScale = s
            }
            pinchEndEvent() {
                null === this._paneWidgetsSharedState.scrollingPane() && this._paneWidgetsSharedState.pinchingPane() === this && (this._onTouchEvent(),
                this._pinching = !1,
                this._paneWidgetsSharedState.setPinchingPane(null))
            }
            mouseClickEvent(e) {
                this._onMouseEvent(),
                this._mouseClickOrTapEvent(e)
            }
            tapEvent(e) {
                this._preventTouchEventsExceptPinch() || (this._onTouchEvent(),
                this._mouseClickOrTapEvent(e))
            }
            mouseDownEvent(e) {
                this._onMouseEvent(),
                this.hasState() && this._mouseDownOrTouchStartEvent(e, this._dataSourceAtPoint(e.localX, e.localY))
            }
            touchStartEvent(e) {
                if (this._paneWidgetsSharedState.startTouch(this),
                this._preventTouchEventsExceptPinch())
                    return;
                const t = !this._trackCrosshairOnlyAfterLongTap && null !== Ms && Ms.stateId === this.state().id() && Math.abs(Ms.x - e.localX) + Math.abs(Ms.y - e.localY) < 5;
                this._onTouchEvent(),
                this._chart.setActivePaneWidget(this);
                const i = this._dataSourceAtPoint(e.localX, e.localY);
                if (t) {
                    const t = this._chartModel().crossHairSource();
                    null !== i && i.source === t || t.selectPointMode().value() !== qt.SelectPointMode.None ? this.startTrackingMode(new o.Point(e.localX,e.localY), new o.Point(e.localX,e.localY)) : !this._chart.readOnly() && null !== i && ((0,
                    ct.isLineTool)(i.source) && i.source.userEditEnabled() || (0,
                    li.isAlertLabel)(i.source)) && this._chartUndoModel().selectionMacro((e=>{
                        e.clearSelection(),
                        e.addSourceToSelection(i.source, i.hittest.data())
                    }
                    ))
                }
                this._mouseDownOrTouchStartEvent(e, i),
                this._mouseOrTouchMoveEvent(e)
            }
            mouseUpEvent(e) {
                this._onMouseEvent(),
                this._mouseUpOrTouchEndEvent(e)
            }
            touchEndEvent(e) {
                this._paneWidgetsSharedState.endTouch(this),
                this._preventTouchEventsExceptPinch() || (this._onTouchEvent(),
                this._mouseOrTouchLeaveEvent(e),
                this._mouseUpOrTouchEndEvent(e))
            }
            mouseMoveEvent(e) {
                this._onMouseEvent(),
                this._mouseOrTouchMoveEvent(e)
            }
            pressedMouseMoveEvent(e) {
                this._onMouseEvent(),
                this._pressedMouseOrTouchMoveEvent(e)
            }
            touchMoveEvent(e) {
                this._preventTouchEventsExceptPinch() || (this._onTouchEvent(),
                this._pressedMouseOrTouchMoveEvent(e))
            }
            mouseLeaveEvent(e) {
                this._onMouseEvent(),
                this._updateHoveredSource(null, new Gt.EnvironmentState(e)),
                this._mouseOrTouchLeaveEvent(e)
            }
            mouseDoubleClickEvent(e) {
                this._onMouseEvent(),
                this._mouseDoubleClickOrDoubleTapEvent(e)
            }
            wheelClickEvent(e) {
                if (this._chart.readOnly())
                    return;
                const t = this._dataSourceAtPoint(e.localX, e.localY);
                if (null === t || t.isCustom)
                    return;
                if ((t.hittest.target() || 0) <= zt.HitTarget.MovePointBackground)
                    return;
                const i = new Gt.EnvironmentState(e)
                  , o = t.hittest.eraseMarker();
                if (i.mod() && void 0 !== o && t.source.processErase)
                    return void t.source.processErase(this._chartUndoModel(), o);
                const n = this._chartUndoModel();
                n.selection().isSelected(t.source) || n.selectionMacro((e=>{
                    e.clearSelection();
                    const i = (0,
                    s.ensureNotNull)(t.source);
                    e.addSourceToSelection(i, Cs(t, i))
                }
                )),
                this._chart.removeSelectedSources()
            }
            doubleTapEvent(e) {
                this._preventTouchEventsExceptPinch() || (this._onTouchEvent(),
                this._mouseDoubleClickOrDoubleTapEvent(e))
            }
            longTapEvent(e) {
                if (null === this._state || this._preventTouchEventsExceptPinch())
                    return;
                if (this._onTouchEvent(),
                this._longTap = !0,
                null !== this._startTrackPoint || !this._trackingModeShouldBeActive())
                    return;
                const t = this._chartModel().selection();
                if (!t.isEmpty()) {
                    const i = this._dataSourceAtPoint(e.localX, e.localY);
                    if (null !== i && t.isSelected(i.source))
                        return
                }
                this.startTrackingMode(new o.Point(e.localX,e.localY), new o.Point(e.localX,e.localY), new Gt.EnvironmentState(e))
            }
            mouseEnterEvent(e) {
                if (this._onMouseEvent(),
                !this.hasState())
                    return;
                this._chart.setActivePaneWidget(this);
                const t = this._dataSourceAtPoint(e.localX, e.localY);
                this._updateHoveredSource(t, new Gt.EnvironmentState(e)),
                this.setCursorPosition(e.localX, e.localY, new Gt.EnvironmentState(e))
            }
            contextMenuEvent(e) {
                this._onMouseEvent(),
                this._contextMenuEvent(e)
            }
            touchContextMenuEvent(e) {
                this._preventTouchEventsExceptPinch() || (this._onTouchEvent(),
                this._contextMenuEvent(e))
            }
            mouseDownOutsideEvent(e) {
                this._processOutsideClick(null, e)
            }
            touchStartOutsideEvent(e) {
                this._processOutsideClick(null, e)
            }
            cancelZoom() {
                this._chartModel().crossHairSource().clearSelection(),
                this._firstZoomPoint = null,
                this._preventCrossHairMove() && this._clearCursorPosition()
            }
            startTrackingMode(e, t, i) {
                this._startChangeLineToolParams = null,
                this._startMoveSourceParams = null,
                this._currentChangingLineToolHitTest = null,
                this._currentMovingHitTest = null,
                this._chartUndoModel().selectionMacro((e=>e.clearSelection())),
                this._startTrackPoint = e,
                this._exitTrackingModeOnNextTry = !1,
                this.setCursorPosition(t.x, t.y, i),
                this._initCrossHairPosition = this._chartModel().crossHairSource().currentPoint()
            }
            setDragToAnotherPaneCursor() {
                this._setCursorClassName("grabbing")
            }
            cloneLineTools(e, t) {
                return this._chartUndoModel().cloneLineTools(e, t)
            }
            exitTrackingMode() {
                null !== this._state && null !== this._startTrackPoint && (this._exitTrackingModeOnNextTry = !0,
                this._tryExitTrackingMode())
            }
            trackingModeEnabled() {
                return null !== this._state && null !== this._startTrackPoint
            }
            addCustomWidgetToLegend(e, t) {
                this._options.legendWidgetEnabled && (this._customLegendWidgetsFactoryMap.set(e, t),
                null !== this._legendWidget && this._legendWidget.addCustomWidgetToLegend(e, t))
            }
            containsMainSeries() {
                return !!this.hasState() && this.state().containsMainSeries()
            }
            paint(e) {
                if (!this._chartUndoModel() || !this.hasState() || 0 === this._size.width || 0 === this._size.height)
                    return;
                (0,
                Qe.tryApplySuggestedCanvasBitmapSize)(this._canvasBinding),
                (0,
                Qe.tryApplySuggestedCanvasBitmapSize)(this._topCanvasBinding),
                this._state && (e.priceScaleSideMaxLevel("left") > N.InvalidationLevel.Cursor || e.priceScaleSideMaxLevel("right") > N.InvalidationLevel.Cursor) && (this._recalculatePriceScales((0,
                as.viewportChangeEvent)(this.state())),
                null !== Ms && Ms.stateId === this.state().id() && this.setCursorPosition(Ms.x, Ms.y, Ms.envState));
                const t = e.fullInvalidation();
                if (t > N.InvalidationLevel.Cursor && null !== Ms && Ms.stateId === this.state().id()) {
                    const e = this._dataSourceAtPoint(Ms.x, Ms.y);
                    this._updateHoveredSource(e, (0,
                    et.globalEnvironmentState)())
                }
                if (this._lhsPriceAxisesContainer.paint(e.getterForPriceScaleInvalidationLevelBySide("left")),
                this._rhsPriceAxisesContainer.paint(e.getterForPriceScaleInvalidationLevelBySide("right")),
                t === N.InvalidationLevel.None)
                    return;
                const i = this._state && (this._state.maximized().value() || !this._state.collapsed().value());
                if (t > N.InvalidationLevel.Cursor) {
                    const e = (0,
                    s.ensureNotNull)(this._canvasBinding.canvasElement.getContext("2d"));
                    e.setTransform(1, 0, 0, 1, 0, 0);
                    const t = (0,
                    Qe.getBindingRenderingInfo)(this._canvasBinding);
                    this._makeSureIsUpdated(t),
                    this._drawBackground(e, t),
                    i && this._drawSources(e, t)
                }
                if (null !== this._state) {
                    const e = (0,
                    s.ensureNotNull)(this._topCanvasBinding.canvasElement.getContext("2d"));
                    e.setTransform(1, 0, 0, 1, 0, 0);
                    const t = (0,
                    Qe.getBindingRenderingInfo)(this._topCanvasBinding);
                    e.clearRect(0, 0, t.bitmapSize.width, t.bitmapSize.height),
                    i && this._drawTopViews(e, t),
                    this._drawCrossHair(e, t),
                    i && this._drawActiveLineTools(e, t)
                }
                this._updateEndOfSeriesBanner()
            }
            cancelCreatingLineTool() {
                const e = this._chartUndoModel()
                  , t = this._chartUndoModel().lineBeingCreated();
                if (t)
                    if (t.pointsCount() <= 0 && !(0,
                    U.isLineDrawnWithPressedButton)(t.toolname)) {
                        const i = t.points();
                        if (i.length > 2) {
                            const s = i[i.length - 2];
                            e.continueCreatingLine(s),
                            this._finishTool(t)
                        } else
                            e.cancelCreatingLine()
                    } else
                        e.cancelCreatingLine();
                null !== this._firstZoomPoint && this.cancelZoom(),
                this._clearCursorPosition(),
                this.setCursorForTool()
            }
            drawRightThere(e) {
                if ((0,
                U.isLineToolName)(e) && this.hasState()) {
                    const t = this._chartUndoModel()
                      , i = t.crossHairSource()
                      , s = t.model().magnet().align(i.price, i.index, this.state());
                    t.createLineTool({
                        pane: this.state(),
                        point: {
                            index: i.index,
                            price: s
                        },
                        linetool: e
                    })
                }
            }
            cancelMeasuring() {
                this._chartUndoModel().crossHairSource().clearMeasure(),
                (0,
                qt.resetToCursor)(),
                this.setCursorForTool()
            }
            async setErrorMessage(e) {
                var t, i, s;
                e && !this._errorRenderer && (this._errorRenderer = this._createErrorBlock()),
                null === (t = await this._errorRenderer) || void 0 === t || t.update({
                    message: null == e ? void 0 : e.message,
                    icon: (null === (i = this._state) || void 0 === i ? void 0 : i.containsMainSeries()) || (null === (s = this._state) || void 0 === s ? void 0 : s.maximized().value()) ? null == e ? void 0 : e.icon : void 0,
                    backgroundColor: `linear-gradient(${this._chartModel().backgroundTopColor().value()}, ${this._chartModel().backgroundColor().value()})`,
                    textColor: this._chartModel().dark().value() ? hs : us,
                    solutionId: null == e ? void 0 : e.solutionId,
                    rawHtml: null == e ? void 0 : e.rawHtml,
                    buttons: this.containsMainSeries() ? null == e ? void 0 : e.buttons : void 0,
                    maxWidth: null == e ? void 0 : e.maxWidth,
                    maxHeight: null == e ? void 0 : e.maxHeight,
                    zeroHeight: null == e ? void 0 : e.zeroHeight
                })
            }
            collapsedHeight() {
                var e, t;
                return Math.max(Math.ceil(null !== (t = null === (e = this._paneControls) || void 0 === e ? void 0 : e.bottomWithMargin()) && void 0 !== t ? t : 0), 33)
            }
            setCursorPosition(e, t, i) {
                this._updateLastCrosshairPosition(e, t, i),
                this._chartModel().setAndSaveCurrentPosition(this._correctXCoord(e), this._correctYCoord(t), this.state(), i)
            }
            _tryExitTrackingMode(e) {
                this._exitTrackingModeOnNextTry && (this._startTrackPoint = null,
                e || this._clearCursorPosition())
            }
            _tryStartMeasure(e, t, i, s, o) {
                return !(!(0,
                qt.toolIsMeasure)(qt.tool.value()) || t.startMeasurePoint()) && (e.isTouch || this._preventCrossHairMove() || this.setCursorPosition(e.localX, e.localY, i),
                s = this._chartModel().magnet().align(s, o, this.state()),
                t.startMeasuring({
                    price: s,
                    index: o
                }, this.state()),
                !0)
            }
            _tryFinishMeasure(e, t) {
                if (t.startMeasurePoint() && !t.endMeasurePoint()) {
                    let i = t.price;
                    const s = t.index;
                    return i = this._chartModel().magnet().align(i, s, this.state()),
                    t.finishMeasure({
                        price: i,
                        index: s
                    }),
                    e.isTouch ? (0,
                    qt.resetToCursor)() : this._needResetMeasureLater = !0,
                    this._preventCrossHairMove() && this._clearCursorPosition(),
                    !0
                }
                return !1
            }
            _tryStartZoom(e, t, i, s) {
                const o = this._chart.model().model().zoomEnabled();
                if ("zoom" === qt.tool.value() && o) {
                    const o = this._chartUndoModel()
                      , n = o.timeScale().indexToCoordinate(i) - .5 * o.timeScale().barSpacing();
                    return this._firstZoomPoint = {
                        price: t,
                        index: i,
                        x: n,
                        y: e.localY
                    },
                    this._preventCrossHairMove() || this.setCursorPosition(e.localX, e.localY, s),
                    this._chartModel().crossHairSource().startSelection(this.state()),
                    !0
                }
                return !1
            }
            _finishZoom(e) {
                const t = this.state()
                  , i = t.defaultPriceScale()
                  , o = (0,
                s.ensureNotNull)(t.mainDataSource()).firstValue()
                  , n = i.coordinateToPrice(e.localY, (0,
                s.ensureNotNull)(o))
                  , r = this._chartUndoModel()
                  , a = Math.round(r.timeScale().coordinateToIndex(e.localX))
                  , l = (0,
                s.ensureNotNull)(this._firstZoomPoint);
                a !== l.index && r.zoomToViewport(l.index, a, l.price, n, t),
                this._chartModel().crossHairSource().clearSelection(),
                this._firstZoomPoint = null,
                (0,
                qt.resetToCursor)(),
                this._preventCrossHairMove() && this._clearCursorPosition()
            }
            _tryFinishZoom(e) {
                return null !== this._firstZoomPoint && (this._finishZoom(e),
                !0)
            }
            _tryHandleEraserMouseDown(e, t) {
                if (!("eraser" !== qt.tool.value() || e.isCustom || (i = e.source,
                i && i.customization && i.customization.disableErasing))) {
                    const i = this._chartUndoModel();
                    if ((0,
                    ct.isLineTool)(e.source) || (0,
                    rt.isStudy)(e.source)) {
                        const s = e.hittest.eraseMarker();
                        return t.mod() && void 0 !== s && e.source.processErase ? e.source.processErase(i, s) : i.removeSource(e.source, !1),
                        !0
                    }
                }
                var i;
                return !1
            }
            _tryStartChangingLineTool(e, t, i, o) {
                var n, r, a;
                if (e.isTouch && null !== this._startTrackPoint)
                    return !1;
                const l = t.hittest;
                if ((!e.isTouch || !this._preventSourceChange) && l && (0,
                ct.isLineTool)(t.source) && l.target() === zt.HitTarget.ChangePoint) {
                    const c = this._chartUndoModel()
                      , d = (0,
                    s.ensure)(null === (n = this.state().mainDataSource()) || void 0 === n ? void 0 : n.firstValue())
                      , u = (0,
                    s.ensureNotNull)(t.source.priceScale()).coordinateToPrice(e.localY, d);
                    c.selectionMacro((e=>{
                        e.clearSelection(),
                        e.addSourceToSelection(t.source, l.data())
                    }
                    ));
                    let h = u;
                    t.source.priceScale() === c.mainSeries().priceScale() && (h = c.model().magnet().align(u, o, this.state()));
                    const p = null === (r = l.data()) || void 0 === r ? void 0 : r.nonDiscreteIndex;
                    p && (o = c.timeScale().coordinateToFloatIndex(e.localX));
                    const m = null === (a = l.data()) || void 0 === a ? void 0 : a.pointIndex;
                    return this._startChangeLineToolParams = {
                        source: t.source,
                        startPoint: {
                            index: o,
                            price: h,
                            nonDiscreteIndex: p
                        },
                        screenPoint: {
                            x: e.localX,
                            y: e.localY
                        },
                        pointIndex: m,
                        envState: i
                    },
                    !0
                }
                return this._startChangeLineToolParams = null,
                !1
            }
            _tryStartCloning(e, t, i, s) {
                if (i.mod()) {
                    const t = this._chartUndoModel().selection().dataSources().filter((e=>e.cloneable()));
                    if (s && s.cloneable() && t.push(s),
                    t.length > 0)
                        return this._clonningAtMoveLineTools = t.map((e=>e.id())),
                        this._startCloningPoint = new o.Point(e.localX,e.localY),
                        !0
                }
                return !1
            }
            _tryFinishClonning(e, t, i) {
                const n = this._chartUndoModel()
                  , r = this._chartModel();
                if (t.mod() && this._clonningAtMoveLineTools) {
                    const a = new o.Point(e.localX,e.localY)
                      , l = (0,
                    s.ensureNotNull)(this._startCloningPoint).subtract(a).length()
                      , c = [];
                    for (const e of this._clonningAtMoveLineTools) {
                        const t = r.dataSourceForId(e);
                        null !== t && c.push(t)
                    }
                    if (0 === c.length)
                        return !1;
                    if (l > 8) {
                        const r = this.cloneLineTools(c, !0).map((e=>(0,
                        s.ensureNotNull)(n.model().dataSourceForId(e))));
                        n.selectionMacro((e=>{
                            e.clearSelection();
                            let t = null;
                            r.forEach((s=>{
                                null === t && (t = Cs(i, s)),
                                e.addSourceToSelection(s, t)
                            }
                            ))
                        }
                        ));
                        const a = new o.Point(e.localX,e.localY)
                          , l = (0,
                        s.ensureNotNull)(r[0].priceScale())
                          , d = (0,
                        s.ensureNotNull)(this.state().mainDataSource()).firstValue()
                          , u = {
                            index: n.timeScale().coordinateToIndex(e.localX),
                            price: l.coordinateToPrice(e.localY, (0,
                            s.ensureNotNull)(d))
                        };
                        n.startMovingSources(r, {
                            logical: u,
                            screen: a
                        }, null, t),
                        this._clonningAtMoveLineTools = null,
                        this._startCloningPoint = null
                    }
                    return !0
                }
                return !1
            }
            _mouseDownEventForLineTool(e, t, i, n) {
                var r, a;
                const l = qt.tool.value();
                if (!this.hasState() || (0,
                U.isLineToolDrawWithoutPoints)(l))
                    return;
                const c = this._chartUndoModel();
                let d = !1
                  , u = null;
                (0,
                qt.hideAllDrawings)().value() && (0,
                He.toggleHideMode)(),
                (0,
                qt.lockDrawings)().setValue(!1),
                e.isTouch && !e.stylus && ((0,
                U.isLineToolName)(l) && !(0,
                U.isLineDrawnWithPressedButton)(l) || c.lineBeingCreated()) && this._initToolCreationModeParams(e);
                const h = c.lineBeingCreated();
                if (h && !(0,
                U.isLineDrawnWithPressedButton)(h.toolname)) {
                    const l = (0,
                    s.ensure)(null === (r = h.ownerSource()) || void 0 === r ? void 0 : r.firstValue());
                    if (e.isTouch && !e.stylus) {
                        if (!this._startTouchPoint) {
                            this._startTouchPoint = new o.Point(e.pageX,e.pageY);
                            const t = h.points()
                              , i = t[t.length - 1]
                              , n = c.timeScale().indexToCoordinate(i.index)
                              , r = (0,
                            s.ensureNotNull)(h.priceScale()).priceToCoordinate(i.price, l);
                            return void (this._initCrossHairPosition = new o.Point(n,r))
                        }
                    } else if (!e.isTouch) {
                        u = h;
                        const o = c.model().paneForSource(h);
                        if (o !== this._state && null !== o) {
                            const i = this._externalPaneXCoord(o, e.localX)
                              , n = this._externalPaneYCoord(o, e.localY);
                            d = c.continueCreatingLine({
                                index: Math.round(c.timeScale().coordinateToIndex(i)),
                                price: (0,
                                s.ensure)(null === (a = h.priceScale()) || void 0 === a ? void 0 : a.coordinateToPrice(n, l))
                            }, t)
                        } else {
                            const e = c.model().magnet().align(n, i, this.state());
                            d = c.continueCreatingLine({
                                index: i,
                                price: e
                            }, t)
                        }
                    }
                } else {
                    const t = (0,
                    U.isLineDrawnWithPressedButton)(l);
                    if (!e.isTouch || e.stylus || t) {
                        const e = {
                            index: i,
                            price: t ? n : c.model().magnet().align(n, i, this.state())
                        };
                        u = c.createLineTool({
                            pane: this.state(),
                            point: e,
                            linetool: l
                        }),
                        c.lineBeingCreated() || (d = !0)
                    }
                }
                const p = this._dataSourceAtPoint(e.localX, e.localY);
                u && c.selectionMacro((e=>{
                    e.addSourceToSelection((0,
                    s.ensureNotNull)(u), null == p ? void 0 : p.hittest.data())
                }
                )),
                d && u && (this._finishTool(u, p),
                e.preventDefault())
            }
            _handleSelectionMouseDownAndGetJustDeselectedSource(e, t, i) {
                const s = this._chartUndoModel();
                let o = null;
                return (null === t || t.source.isSelectionEnabled()) && s.selectionMacro((s=>{
                    !this._preventSourceChange && null !== t && (e.isTouch ? t.hittest.target() >= zt.HitTarget.MovePointBackground : t.hittest.target() > zt.HitTarget.MovePointBackground) ? (i.mod() || s.selection().isSelected(t.source) || s.clearSelection(),
                    i.mod() && s.selection().isSelected(t.source) ? (o = t.source,
                    s.removeSourceFromSelection(t.source)) : s.addSourceToSelection(t.source, t.hittest.data()),
                    s.selection().allSources().length > 1 && (0,
                    Ne.trackEvent)("GUI", "Multiselect", "Click Select")) : i.mod() || s.clearSelection()
                }
                )),
                o
            }
            _processMouseMoveWhileZoom(e, t) {
                this._preventCrossHairMove() || this.setCursorPosition(e.localX, e.localY, t)
            }
            _updateCommonTooltip(e, t) {
                let i = null;
                if (null !== e && null !== e.hittest) {
                    const t = e.hittest.data();
                    t && (i = t.tooltip || null)
                }
                if (null === this._prevTooltipData && null === i)
                    return;
                if (null === i || "" === i.text)
                    return this._prevTooltipData = null,
                    void (0,
                    is.hide)(t);
                if (this._prevTooltipData && (0,
                Ft.default)(i, this._prevTooltipData))
                    return;
                this._prevTooltipData = i;
                const s = (0,
                Ue.clone)(i);
                if (void 0 !== s.rect) {
                    const e = this._paneCell.getBoundingClientRect();
                    s.rect.x += e.left,
                    s.rect.y += e.top
                }
                (0,
                is.show)(s)
            }
            _setCursorPositionOnExternalPane(e, t, i, s) {
                t = this._externalPaneXCoord(e, t),
                i = this._externalPaneYCoord(e, i);
                this._chart.paneByState(e).setCursorPosition(t, i, s)
            }
            _updateLastCrosshairPosition(e, t, i) {
                const s = this.state().id();
                Ms = {
                    x: e,
                    y: t,
                    envState: i,
                    stateId: s
                }
            }
            _setCursorClassName(e) {
                let t = "";
                e && (t = "pane--cursor-" + e),
                this._currentCursorClassName !== t && (this._currentCursorClassName && this._paneCell.classList.remove(this._currentCursorClassName),
                t && this._paneCell.classList.add(t),
                this._currentCursorClassName = t,
                this._paneCell.style.cursor)
            }
            _processMouseUpOrTouchEndHandler(e) {
                const t = this._dataSourceAtPoint(e.localX, e.localY);
                if (null !== t) {
                    const i = this._sourceWasSelected(t);
                    t.hittest.tryCallMouseUpOrTouchEndHandler(e, {
                        sourceWasSelected: i
                    })
                }
            }
            _crossHairShouldBeVisible() {
                const e = this._chartModel().crossHairSource();
                return (0,
                U.isLineToolName)(qt.tool.value()) || (0,
                qt.toolIsMeasure)(qt.tool.value()) || e.startMeasurePoint() && !e.endMeasurePoint() || null !== this._firstZoomPoint || null !== this._chartModel().lineBeingEdited() || null !== this._chartModel().lineBeingCreated()
            }
            _clearCursorPosition() {
                Ms = null,
                this._chartModel().clearCurrentPosition()
            }
            _dataSourceAtPoint(e, t) {
                var i, s;
                if (!this.hasState())
                    return null;
                const n = {
                    result: null
                }
                  , r = this._chartUndoModel();
                if ((0,
                U.isLineToolName)(qt.tool.value()) || null !== r.lineBeingCreated())
                    return n.result;
                if (this._currentChangingLineToolHitTest)
                    return this._currentChangingLineToolHitTest;
                const a = new Set;
                if (this._currentMovingHitTest && this._currentMovingHitTest.sourceAtPoint.hittest.data()) {
                    if (!(null === (i = this._currentMovingHitTest.cancelledContainer) || void 0 === i ? void 0 : i.cancelled))
                        return this._currentMovingHitTest.sourceAtPoint;
                    a.add(this._currentMovingHitTest.sourceAtPoint.source.id())
                }
                if (this._currentMovingHitTest && this._currentMovingHitTest.sourceAtPoint.hittest.data() && !(null === (s = this._currentMovingHitTest.cancelledContainer) || void 0 === s ? void 0 : s.cancelled))
                    return this._currentMovingHitTest.sourceAtPoint;
                const l = this.state()
                  , c = (0,
                Qe.getBindingRenderingInfo)(this._canvasBinding);
                this._makeSureIsUpdated(c);
                const d = ws.bind(null, n)
                  , u = new o.Point(e,t);
                if (!l.maximized().value() && l.collapsed().value() || (0,
                Mt.lastMouseOrTouchEventInfo)().isTouch && (qt.activePointSelectionMode.value() !== qt.SelectPointMode.None || null !== this._startTrackPoint))
                    return this._hitTestSources(c, [r.crossHairSource()], u, d, !1, a),
                    n.result;
                const h = l.sourcesByGroup()
                  , p = r.selection()
                  , m = p.dataSources().filter((e=>e.isMultiPaneEnabled() || r.paneForSource(e) === l));
                this._hitTestSources(c, m, u, d, !1, a),
                this._hitTestSources(c, p.customSources(), u, d, !0, a),
                p.allSources().forEach((e=>a.add(e.id()))),
                this._hitTestSources(c, [r.crossHairSource()], u, d, !1, a),
                this._hitTestSources(c, l.customSources(Ut.CustomSourceLayer.Topmost), u, d, !0, a),
                this._hitTestSources(c, h.tradingSources(), u, d, !1, a),
                this._hitTestSources(c, l.customSources(Ut.CustomSourceLayer.Foreground), u, d, !0, a);
                const g = h.hitTestSources();
                if (this._hitTestSources(c, g, u, d, !1, a),
                this.containsMainSeries()) {
                    const e = r.activeStrategySource().value();
                    if (null !== e && !a.has(e.id())) {
                        const t = e.strategyOrdersPaneView();
                        if (null !== t) {
                            const i = t.renderer(c);
                            if (null !== i) {
                                const t = i.hitTest(u, c);
                                t && ws(n, t, e, i, !1)
                            }
                        }
                    }
                }
                return null === n.result && this._hitTestSources(c, l.customSources(Ut.CustomSourceLayer.Background), u, d, !0, a),
                n.result
            }
            _sourceWasSelected(e) {
                return !!e && this._selectionBeforeMouseDown.has(e.source)
            }
            _hitTestSources(e, t, i, o, n, r) {
                const a = (0,
                s.ensureNotNull)(this._state);
                for (let s = t.length - 1; s >= 0; --s) {
                    const l = t[s];
                    if (r.has(l.id()))
                        continue;
                    const c = l.paneViews(a);
                    if (null !== c && 0 !== c.length)
                        for (let t = c.length - 1; t >= 0; --t) {
                            const s = c[t].renderer(e);
                            if (s && s.hitTest) {
                                const t = s.hitTest(i, e);
                                null !== t && o(t, l, s, n)
                            }
                        }
                }
            }
            _tryStartMovingLineTool(e, t, i, n) {
                var r;
                if (null === t.source || !t.source.movable() || null !== this._startTrackPoint)
                    return !1;
                if (!this._preventSourceChange) {
                    const a = this._chartUndoModel()
                      , l = (0,
                    s.ensureNotNull)((0,
                    s.ensureNotNull)(this._state).mainDataSource()).firstValue()
                      , c = (0,
                    s.ensureNotNull)(t.source.priceScale())
                      , d = null === l ? NaN : c.coordinateToPrice(e.localY, l);
                    let u = (t.source.isSelectionEnabled() ? a.selection().allSources() : [t.source]).filter(os);
                    const h = u.filter(ct.isLineTool);
                    u = h.length > 0 ? h : u.includes(t.source) ? [t.source] : [u[0]];
                    const p = new o.Point(e.localX,e.localY)
                      , m = {
                        index: n,
                        price: d
                    }
                      , g = null === (r = t.hittest.data()) || void 0 === r ? void 0 : r.activeItem;
                    return this._startMoveSourceParams = {
                        source: u,
                        startPoint: {
                            logical: m,
                            screen: p
                        },
                        activeItem: void 0 === g ? null : g,
                        envState: i
                    },
                    !0
                }
                return this._startMoveSourceParams = null,
                !1
            }
            _chartModel() {
                return this._chart.model().model()
            }
            _chartUndoModel() {
                return this._chart.model()
            }
            _externalPaneXCoord(e, t) {
                t += this._div.getBoundingClientRect().left + document.body.scrollLeft;
                const i = (0,
                s.ensureNotNull)(this._chart.paneByState(e))
                  , o = i._div.getBoundingClientRect().left + document.body.scrollLeft;
                return i._correctXCoord(t - o)
            }
            _externalPaneYCoord(e, t) {
                t += this._div.getBoundingClientRect().top + document.body.scrollTop;
                const i = (0,
                s.ensureNotNull)(this._chart.paneByState(e))
                  , o = i._div.getBoundingClientRect().top + document.body.scrollTop;
                return i._correctYCoord(t - o)
            }
            _correctXCoord(e) {
                return Math.max(0, Math.min(e, this._size.width - 1))
            }
            _correctYCoord(e) {
                return Math.max(0, Math.min(e, this._size.height - 1))
            }
            _processScroll(e) {
                if (!this._chart.model().model().scrollEnabled())
                    return;
                const t = performance.now();
                this._startScrollingPos || this._preventScroll() || (this._startScrollingPos = {
                    x: e.clientX,
                    y: e.clientY,
                    timestamp: t,
                    localX: e.localX,
                    localY: e.localY
                });
                const i = this._chartUndoModel();
                let s = this.state().defaultPriceScale();
                if (this._startScrollingPos && !this._isScrolling && (this._startScrollingPos.x !== e.clientX || this._startScrollingPos.y !== e.clientY))
                    return i.beginUndoMacro(ps),
                    null === this._scrollXAnimation && this._options.useKineticScroll && (this._scrollXAnimation = new Fi.KineticAnimation(.2,7,.997,15),
                    this._scrollXAnimation.addPosition(e.clientX, this._startScrollingPos.timestamp)),
                    i.selection().isEmpty() || (s = i.selection().allSources()[0].priceScale()),
                    null === s || s.isEmpty() || (this._scrollPriceScale = s,
                    i.startScrollPrice(this.state(), s, e.localY)),
                    i.startScrollTime(e.localX),
                    this._isScrolling = !0,
                    this.setCursorForTool(),
                    void this._paneWidgetsSharedState.setScrollingPane(this);
                this._isScrolling && (null !== this._scrollPriceScale && i.scrollPriceTo(this.state(), this._scrollPriceScale, e.localY),
                i.scrollTimeTo(e.localX),
                null !== this._scrollXAnimation && this._scrollXAnimation.addPosition(e.clientX, t))
            }
            _finishScroll() {
                const e = this._chartUndoModel();
                e.endScrollTime(),
                null !== this._scrollPriceScale && e.endScrollPrice(this.state(), this._scrollPriceScale),
                e.endUndoMacro(),
                this._isScrolling = !1,
                this._startScrollingPos = null,
                this._scrollPriceScale = null,
                this.setCursorForTool(),
                this._paneWidgetsSharedState.setScrollingPane(null)
            }
            _endScroll(e) {
                if (!this._isScrolling)
                    return !1;
                this._finishScroll();
                const t = this._scrollUndoCommandInStack()
                  , i = performance.now();
                return null !== this._scrollXAnimation && (this._scrollXAnimation.start(e.clientX, i),
                this._scrollXAnimation.finished(i) || (this._chartModel().stopTimeScaleAnimation(),
                this._chartModel().setTimeScaleAnimation(this._scrollXAnimation),
                this._scrollXAnimation = null)),
                t
            }
            _preventScroll() {
                return this._trackCrosshairOnlyAfterLongTap && this._longTap || this._contextMenuOpenedOnLastTap || (0,
                U.isLineToolName)(qt.tool.value()) || Boolean(this._chartUndoModel().lineBeingCreated()) || null !== this._startTrackPoint || this._preventScrollUntilNextMouseDownOrTouchStart
            }
            _isSelectPointModeEnabled() {
                return this._chartUndoModel().crossHairSource().selectPointMode().value() !== qt.SelectPointMode.None
            }
            _preventCrossHairMove() {
                return !!this._trackCrosshairOnlyAfterLongTap && (null === this._chart.trackingModePaneWidget() && (!!this._contextMenuOpenedOnLastTap || !this._crossHairShouldBeVisible() && null === this._startTrackPoint))
            }
            _finishTool(e, t=null) {
                const i = this._chartUndoModel()
                  , s = e.toolname;
                if (s === qt.tool.value() && (0,
                qt.resetToCursor)(),
                this._preventCrossHairMove() && this._clearCursorPosition(),
                i.selectionMacro((i=>{
                    i.addSourceToSelection(e, Cs(t, e))
                }
                )),
                (0,
                ct.isEditableTextLineTool)(e) && e.activateEditingOnCreation())
                    e.activateTextEditingOn(this._div, !0);
                else if ((0,
                U.isTextToolName)(s)) {
                    const t = i.createUndoCheckpoint();
                    this._chart.showChartPropertiesForSource(e, ot.TabNames.text, void 0, t)
                }
                this._lastFinishedToolId = e.id(),
                (0,
                Me.emit)("drawing_event", e.id(), "create"),
                Qi(e)
            }
            _alignSourcesThatBeingMoved(e, t, i, s, n) {
                const r = this._chartUndoModel()
                  , a = 2 === n ? NaN : r.timeScale().coordinateToIndex(t);
                r.model().sourcesBeingMoved().forEach((e=>{
                    var l;
                    let c = a
                      , d = e.convertYCoordinateToPriceForMoving(i, this.state().mainDataSource());
                    if (null === d) {
                        if (1 !== n)
                            return;
                        d = NaN
                    }
                    if ((0,
                    rt.isStudy)(e)) {
                        const e = r.mainSeries()
                          , t = e.bars().firstIndex()
                          , i = e.bars().lastIndex();
                        null !== t && null !== i && 2 !== n && (c = Math.min(Math.max(a, t), i)),
                        1 !== n && (d = this._chartModel().magnet().align(d, a, this.state()))
                    }
                    null !== this._currentMovingHitTest && void 0 !== (null === (l = this._currentMovingHitTest.sourceAtPoint.hittest.data()) || void 0 === l ? void 0 : l.cursorType) || this.setCursorForTool(),
                    r.moveSources({
                        screen: new o.Point(t,i),
                        logical: {
                            index: c,
                            price: d
                        }
                    }, s)
                }
                ))
            }
            _resetMeasureIfRequired() {
                this._needResetMeasureLater && ((0,
                qt.resetToCursor)(),
                this._needResetMeasureLater = !1)
            }
            _makeSureIsUpdated(e) {
                var t;
                const i = this.state()
                  , s = [...i.dataSources(), ...i.customSources()];
                for (const o of s) {
                    const s = o.paneViews(i);
                    if (null !== s)
                        for (const i of s)
                            null === (t = i.makeSureIsUpdated) || void 0 === t || t.call(i, e)
                }
            }
            _drawBackground(e, t) {
                const i = this._chartModel()
                  , s = i.backgroundTopColor().value()
                  , o = i.backgroundColor().value();
                s === o ? (0,
                Qe.clearRect)(e, 0, 0, t.bitmapSize.width, t.bitmapSize.height, o) : (0,
                Kt.clearRectWithGradient)(e, 0, 0, t.bitmapSize.width, t.bitmapSize.height, s, o)
            }
            _drawWatermark(e, t) {
                const i = this._chartModel().watermarkSource();
                if (null === i)
                    return;
                if (!this.state().containsMainSeries())
                    return;
                const s = i.paneViews();
                for (const i of s) {
                    e.save();
                    const s = i.renderer(t);
                    s && s.draw(e, t),
                    e.restore()
                }
            }
            _drawCrossHair(e, t) {
                const i = this._chartUndoModel().crossHairSource();
                i.invalidateLockPosition(),
                i.visible || null === qt.crosshairLock.value() || i.updateAllViews((0,
                as.sourceChangeEvent)(i.id())),
                this._drawSourceImpl(e, t, Ss, vs, i)
            }
            _drawActiveLineTools(e, t) {
                const i = this._chartModel()
                  , s = [i.lineBeingCreated(), i.lineBeingEdited(), ...i.sourcesBeingMoved(), i.customSourceBeingMoved()].filter((e=>!!e));
                for (const o of s) {
                    (i.paneForSource(o) === this.state() || (0,
                    jt.isDataSource)(o) && o.isMultiPaneEnabled()) && this._drawSourceImpl(e, t, Ss, vs, o)
                }
            }
            _drawTopViews(e, t) {
                for (const i of this.state().sourcesByGroup().all())
                    i.topPaneViews && this._drawSourceImpl(e, t, fs, vs, i)
            }
            _drawSources(e, t) {
                const i = this.state()
                  , s = i.model()
                  , o = i.sourcesByGroup()
                  , n = o.tradingSources()
                  , r = o.generalSources()
                  , a = o.phantomSources()
                  , l = i.customSources(Ut.CustomSourceLayer.Background).slice()
                  , c = i.customSources(Ut.CustomSourceLayer.Foreground).slice()
                  , d = i.customSources(Ut.CustomSourceLayer.Topmost).slice()
                  , u = s.activeStrategySource().value()
                  , h = s.replayStudyStrategy().value();
                this._drawSourceImpl(e, t, Ss, vs, s.gridSource()),
                this._drawWatermark(e, t);
                for (const i of l)
                    this._drawSourceImpl(e, t, Ss, _s, i);
                for (const i of r)
                    this._drawSourceImpl(e, t, Ss, _s, i);
                for (const i of c)
                    this._drawSourceImpl(e, t, Ss, _s, i);
                for (const i of a)
                    this._drawSourceImpl(e, t, Ss, _s, i);
                const p = new Set;
                [s.lineBeingCreated(), s.lineBeingEdited(), ...s.sourcesBeingMoved(), s.customSourceBeingMoved()].filter(Ue.notNull).forEach((e=>p.add(e.id())));
                let m = s.hoveredSource();
                null !== m && ((0,
                jt.isDataSource)(m) && !m.showOnTopOnHovering() || p.has(m.id()) || (0,
                jt.isDataSource)(m) && !r.includes(m) ? m = null : p.add(m.id()));
                const g = s.selection().allSources().filter((e=>!((0,
                jt.isDataSource)(e) && !r.includes(e)) && !p.has(e.id())));
                g.forEach((e=>p.add(e.id())));
                for (const i of l)
                    this._drawSourceImpl(e, t, Ss, vs, i, p);
                for (const i of r)
                    this._drawSourceImpl(e, t, Ss, vs, i, p);
                for (const i of c)
                    this._drawSourceImpl(e, t, Ss, vs, i, p);
                u && this.containsMainSeries() && this._drawSourceImpl(e, t, ys, vs, u, p),
                h && this._drawSourceImpl(e, t, ys, vs, h, p);
                for (const i of n)
                    this._drawSourceImpl(e, t, Ss, _s, i);
                for (const i of d)
                    this._drawSourceImpl(e, t, Ss, _s, i);
                for (const i of r)
                    this._drawSourceImpl(e, t, bs, vs, i, p);
                for (const i of c)
                    this._drawSourceImpl(e, t, bs, vs, i, p);
                for (const i of n)
                    this._drawSourceImpl(e, t, Ss, vs, i, p);
                for (const i of d)
                    this._drawSourceImpl(e, t, Ss, vs, i, p);
                for (const i of g)
                    this._drawSourceImpl(e, t, Ss, vs, i),
                    i === u && this.containsMainSeries() && this._drawSourceImpl(e, t, ys, vs, u);
                for (const i of g)
                    this._drawSourceImpl(e, t, bs, vs, i);
                m && (this._drawSourceImpl(e, t, Ss, vs, m),
                m === u && this.containsMainSeries() && this._drawSourceImpl(e, t, ys, vs, u),
                this._drawSourceImpl(e, t, bs, vs, m));
                for (const i of a)
                    this._drawSourceImpl(e, t, Ss, vs, i, p)
            }
            _drawSourceImpl(e, t, i, s, o, n) {
                if (n && n.has(o.id()))
                    return;
                const r = i(o, this.state());
                if (r)
                    for (const i of r) {
                        const o = i.renderer(t);
                        o && (e.save(),
                        s(o, e, t),
                        e.restore())
                    }
            }
            _updateByThemedColors() {
                null !== this._legendWidget && this._legendWidget.updateThemedColors(this._themedTopColor),
                null !== this._paneControls && this._paneControls.updateThemedColors(this._themedTopColor)
            }
            _scrollUndoCommandInStack() {
                const e = this._chartUndoModel().undoHistory().undoStack();
                if (e.isEmpty())
                    return !1;
                const t = e.head();
                if (!(t instanceof Xt.UndoMacroCommand))
                    return !1;
                if (t.isEmpty())
                    return !1;
                const i = t.commands()[0];
                return i instanceof ji || i instanceof zi
            }
            _onStateDestroyed() {
                this.setState(null)
            }
            _onDataSourcesCollectionChanged() {
                this._startMoveSourceParams = null
            }
            _processMouseEnterLeaveMoveHandlers(e, t) {
                var i, s, o, n;
                if (null !== this._prevHoveredHittest && (this._prevHoveredHittest.renderer !== (null == e ? void 0 : e.renderer) || (null === (i = this._prevHoveredHittest.hittest.data()) || void 0 === i ? void 0 : i.activeItem) !== (null === (s = e.hittest.data()) || void 0 === s ? void 0 : s.activeItem))) {
                    const e = this._sourceWasSelected(this._prevHoveredHittest);
                    (0,
                    zt.tryCallHandler)(t, {
                        sourceWasSelected: e
                    }, null === (o = this._prevHoveredHittest.hittest.data()) || void 0 === o ? void 0 : o.mouseLeaveHandler),
                    this._prevHoveredHittest = null
                }
                if (!t.isTouch && null !== e) {
                    const i = this._sourceWasSelected(e);
                    (null === (n = this._prevHoveredHittest) || void 0 === n ? void 0 : n.renderer) !== e.renderer && (e.hittest.tryCallMouseEnterHandler(t, {
                        sourceWasSelected: i
                    }),
                    this._prevHoveredHittest = e),
                    e.hittest.tryCallMouseMoveHandler(t, {
                        sourceWasSelected: i
                    })
                }
            }
            _startChangeOrMoveLineToolIfNeeded() {
                if (null !== this._startChangeLineToolParams) {
                    const e = this._startChangeLineToolParams;
                    this._chartUndoModel().startChangingLinetool(e.source, e.startPoint, e.pointIndex, e.envState)
                }
                if (null !== this._startMoveSourceParams) {
                    const e = this._startMoveSourceParams;
                    this._chartUndoModel().startMovingSources(e.source, e.startPoint, e.activeItem, e.envState)
                }
                this._startMoveSourceParams = null,
                this._startChangeLineToolParams = null
            }
            _trackingModeShouldBeActive() {
                return !(!this._trackCrosshairOnlyAfterLongTap || this._contextMenuOpenedOnLastTap || this._crossHairShouldBeVisible()) && this._longTap
            }
            _processOutsideClick(e, t) {
                var i;
                let s = null;
                const o = this._chartModel();
                if (null !== e && (s = e.isCustom ? o.customSourceName(e.source) : e.source.id()),
                null !== this._lastClickedSource && this._lastClickedSource.id !== s) {
                    const e = this._lastClickedSource.id;
                    let i = this._lastClickedSource.isCustom ? o.customSourceForName(e) : o.dataSourceForId(e);
                    null !== i || this._lastClickedSource.isCustom || (i = o.dataSourceForId(e)),
                    null !== i && i.onClickOutside && (i.onClickOutside((0,
                    Qe.getBindingRenderingInfo)(this._canvasBinding), t),
                    this._chartModel().updateSource(i))
                }
                this._lastClickedSource = null !== s ? {
                    id: s,
                    isCustom: null !== (i = null == e ? void 0 : e.isCustom) && void 0 !== i && i
                } : null
            }
            async showConfetti(e, t) {
                {
                    const s = await i.e(4036).then(i.bind(i, 485537));
                    "performance" === qt.tool.value() && s.confetti(e, t)
                }
            }
            _mouseClickOrTapEvent(e) {
                var t;
                if (!this.hasState())
                    return;
                Zi.performanceTestMode && "performance" === qt.tool.value() && this.showConfetti(e.pageX, e.pageY);
                const i = this._dataSourceAtPoint(e.localX, e.localY)
                  , o = i && i.source
                  , n = this._chartUndoModel()
                  , r = Boolean(null === (t = null == i ? void 0 : i.hittest.data()) || void 0 === t ? void 0 : t.hideCrosshairLinesOnHover);
                this._processOutsideClick(i, e),
                !this._isSelectPointModeEnabled() || r || e.isTouch && this.trackingModeEnabled() && !this._exitTrackingModeOnNextTry || n.crossHairSource().trySelectCurrentPoint();
                const a = this._sourceWasSelected(i);
                null !== i && i.hittest.tryCallClickOrTapHandler(e, {
                    sourceWasSelected: a
                }) && n.model().updateSource((0,
                s.ensureNotNull)(o)),
                !e.isTouch || this._isSelectPointModeEnabled() || i && i.source === n.crossHairSource() || this._tryExitTrackingMode(),
                o && (0,
                ct.isLineTool)(o) && this._lastFinishedToolId !== o.id() && (0,
                Me.emit)("drawing_event", o.id(), "click"),
                this._resetMeasureIfRequired()
            }
            _mouseDownOrTouchStartEvent(e, t) {
                var i, n, r, a, l, c, d;
                this._pressedMoveStage = 1,
                this._preventScrollUntilNextMouseDownOrTouchStart = !1,
                this._selectionBeforeMouseDown = new Set(this._chartModel().selection().allSources()),
                e.isTouch && (this._longTap = !1,
                this._exitTrackingModeOnNextTry = null !== this._startTrackPoint,
                this._paneWidgetsSharedState.clearDraggingSource()),
                this._contextMenuOpenedOnLastTap = !1,
                this._lastFinishedToolId = null;
                const u = this._chartModel();
                if (u.stopTimeScaleAnimation(),
                e.isTouch && this._switchTrackingModeFromAnotherPaneIfNeeded(e),
                document.activeElement !== document.body && document.activeElement !== document.documentElement)
                    document.activeElement && document.activeElement.blur ? document.activeElement.blur() : document.body.focus();
                else {
                    const e = document.getSelection();
                    null !== e && e.removeAllRanges()
                }
                (0,
                Me.emit)("mouse_down", {
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pageX: e.pageX,
                    pageY: e.pageY,
                    screenX: e.screenX,
                    screenY: e.screenY
                }),
                this._updateCommonTooltip(null);
                const h = this._chartUndoModel()
                  , p = new Gt.EnvironmentState(e);
                h.mainSeries().clearGotoDateResult();
                const m = this.state().defaultPriceScale();
                if (h.timeScale().isEmpty())
                    return;
                const g = h.crossHairSource();
                if (!e.isTouch && !(0,
                U.isLineDrawnWithPressedButton)(qt.tool.value())) {
                    const t = h.lineBeingCreated()
                      , i = null !== t ? h.model().paneForSource(t) : null;
                    null !== i && i !== this._state ? this._setCursorPositionOnExternalPane(i, e.localX, e.localY, p) : this.setCursorPosition(e.localX, e.localY, p)
                }
                e.isTouch && (0,
                U.isLineToolName)(qt.tool.value()) && ((0,
                U.isLineDrawnWithPressedButton)(qt.tool.value()) || null !== g.pane ? (0,
                U.isLineDrawnWithPressedButton)(qt.tool.value()) && this._clearCursorPosition() : this._chart.updateCrossHairPositionIfNeeded());
                const _ = (0,
                s.ensureNotNull)(this.state().mainDataSource()).firstValue();
                let v = null == _ ? null : m.coordinateToPrice(e.localY, _)
                  , S = u.timeScale().coordinateToIndex(e.localX);
                if (g.startMeasurePoint() && g.endMeasurePoint() && g.clearMeasure(),
                p.shift() && (null === t || !(null === (n = null === (i = t.hittest.data()) || void 0 === i ? void 0 : i.hasOwnShortcutsBehaviourFor) || void 0 === n ? void 0 : n.shiftKey)) && (0,
                qt.toolIsCursor)(qt.tool.value()) && h.selection().isEmpty() && qt.tool.setValue("measure"),
                (e.isTouch && !e.stylus || null === v || !this._tryStartMeasure(e, g, p, v, S)) && (e.isTouch && !e.stylus || !this._tryFinishMeasure(e, g)) && !(this._tryFinishZoom(e) || null !== v && this._tryStartZoom(e, v, S, p))) {
                    if (e.isTouch && (null !== this._startTrackPoint ? (this._initCrossHairPosition = g.currentPoint(),
                    this._startTrackPoint = new o.Point(e.localX,e.localY)) : this._isSelectPointModeEnabled() && null === this._chart.trackingModePaneWidget() && this.startTrackingMode(new o.Point(e.localX,e.localY), new o.Point(e.localX,e.localY), new Gt.EnvironmentState(e))),
                    e.isTouch && (this._preventSourceChange = null === t || !h.selection().isSelected(t.source)),
                    !this._isSelectPointModeEnabled() && !this._isScrolling) {
                        if (e.isTouch && !e.stylus && ((0,
                        qt.toolIsMeasure)(qt.tool.value()) || null !== g.measurePane().value()))
                            return void this._initToolCreationModeParams(e);
                        if (null !== v && ((0,
                        U.isLineToolName)(qt.tool.value()) || h.lineBeingCreated()))
                            return p.shift() || h.selectionMacro((e=>e.clearSelection())),
                            void this._mouseDownEventForLineTool(e, p, S, v)
                    }
                    if (null !== t) {
                        const i = this._sourceWasSelected(t);
                        t.hittest.tryCallMouseDownOrTouchStartHandler(e, {
                            sourceWasSelected: i
                        })
                    }
                    if (!this._chart.readOnly()) {
                        const i = this._handleSelectionMouseDownAndGetJustDeselectedSource(e, t, p);
                        if (null !== t && !this._preventSourceChange) {
                            const i = t.hittest.data();
                            if (t.isCustom) {
                                if (t.hittest.hasPressedMoveHandler(e))
                                    return h.model().setMovingCustomSource(t.source, i),
                                    this._preventScrollUntilNextMouseDownOrTouchStart = !0,
                                    this._currentMovingHitTest = {
                                        sourceAtPoint: t,
                                        cancelledContainer: null !== (r = h.model().customSourceMovingHitTestData()) && void 0 !== r ? r : void 0
                                    },
                                    void h.selectionMacro((e=>{
                                        e.clearSelection(),
                                        e.addSourceToSelection((0,
                                        s.ensureNotNull)(t.source), (0,
                                        s.ensureNotNull)(i))
                                    }
                                    ))
                            } else if ((null == i ? void 0 : i.areaName) === zt.AreaName.SourceItemMove) {
                                const o = null == i ? void 0 : i.activeItem;
                                if (void 0 !== o)
                                    return h.startCustomMoving(t.source, o, e),
                                    this._currentMovingHitTest = {
                                        sourceAtPoint: t
                                    },
                                    void h.selectionMacro((e=>{
                                        e.clearSelection(),
                                        e.addSourceToSelection((0,
                                        s.ensureNotNull)(t.source), (0,
                                        s.ensureNotNull)(i))
                                    }
                                    ))
                            }
                        }
                        if (null !== t && this._tryHandleEraserMouseDown(t, p))
                            return;
                        const o = null !== t && (0,
                        ct.isLineTool)(t.source) && t.source.isLocked && t.source.isLocked();
                        if (!((0,
                        qt.lockDrawings)().value() || o) && null !== t && !t.isCustom) {
                            if (!t.source.userEditEnabled())
                                return;
                            const o = null === (a = t.hittest.data()) || void 0 === a ? void 0 : a.snappingPrice
                              , n = null === (l = t.hittest.data()) || void 0 === l ? void 0 : l.snappingIndex;
                            let r = e.localY
                              , d = e.localX;
                            if (void 0 !== o && null !== _ && (r = (0,
                            s.ensure)(null === (c = t.source) || void 0 === c ? void 0 : c.priceScale()).priceToCoordinate(o, _),
                            v = o),
                            void 0 !== n && (d = u.timeScale().indexToCoordinate(n),
                            S = n),
                            r === e.localY && d === e.localX || (e = {
                                ...e,
                                localY: r,
                                localX: d
                            },
                            this.setCursorPosition(e.localX, e.localY, p)),
                            this._tryStartChangingLineTool(e, t, p, S))
                                return void (this._currentChangingLineToolHitTest = t);
                            if (this._currentChangingLineToolHitTest = null,
                            (f = t.hittest.target()) === zt.HitTarget.MovePoint || f === zt.HitTarget.MovePointBackground && (0,
                            Mt.lastMouseOrTouchEventInfo)().isTouch) {
                                if (this._tryStartCloning(e, t, p, i))
                                    return;
                                if (this._tryStartMovingLineTool(e, t, p, S))
                                    return void (this._currentMovingHitTest = {
                                        sourceAtPoint: t
                                    });
                                this._currentMovingHitTest = null
                            }
                        }
                        if (null !== t && (0,
                        Xi.isPriceDataSource)(t.source) && t.source.isDraggable() && (null === (d = this._state) || void 0 === d ? void 0 : d.hasDataSource(t.source)) && this._paneWidgetsSharedState.trySetDraggingSource(t.source, this))
                            return
                    }
                    var f;
                    null !== t && t.hittest.target() === zt.HitTarget.Regular || (this._processing = !0)
                }
            }
            _mouseUpOrTouchEndEvent(e) {
                var t, i;
                if (!this.hasState())
                    return;
                this._pressedMoveStage = 0;
                const o = e.isTouch && null !== this._startTrackPoint
                  , n = e.isTouch && this._wasPinched;
                e.isTouch && (this._wasPinched = !1,
                this._longTap = !1),
                this._startMoveSourceParams = null,
                this._startChangeLineToolParams = null,
                this._currentChangingLineToolHitTest = null,
                this._currentMovingHitTest = null;
                const r = this._chartUndoModel()
                  , a = r.model().customSourceMovingHitTestData();
                null !== a || r.customMoveBeingProcessed() || this._processMouseUpOrTouchEndHandler(e),
                this._isSelecting = !1;
                const l = r.model()
                  , c = l.crossHairSource()
                  , d = this._dataSourceAtPoint(e.localX, e.localY);
                if (c.selection() && null === this._firstZoomPoint) {
                    const e = this.state().lineToolsForArea(c.selection(), (0,
                    Qe.getBindingRenderingInfo)(this._canvasBinding));
                    r.selectionMacro((t=>{
                        let i = null;
                        e.forEach((e=>{
                            null === i && (i = Cs(d, e)),
                            t.addSourceToSelection(e, i)
                        }
                        ))
                    }
                    )),
                    c.clearSelection(),
                    (0,
                    Ne.trackEvent)("GUI", "Multiselect", "Area Select")
                }
                (0,
                Me.emit)("mouse_up", {
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pageX: e.pageX,
                    pageY: e.pageY,
                    screenX: e.screenX,
                    screenY: e.screenY
                });
                const u = e.isTouch && this._touchMove;
                e.isTouch && (this._touchMove = !1);
                const h = new Gt.EnvironmentState(e)
                  , p = qt.tool.value();
                if (e.isTouch && ((0,
                qt.toolIsMeasure)(p) || null !== c.measurePane().value())) {
                    if (!u && !e.stylus && null === c.measurePane().value() && c.pane !== this._state)
                        return void this.setCursorPosition(e.localX, e.localY);
                    if (!u && !e.stylus && this._tryStartMeasure(e, c, h, c.price, c.index))
                        return;
                    if ((!u || e.stylus) && this._tryFinishMeasure(e, c))
                        return
                }
                if (e.isTouch && !u && !(0,
                U.isLineDrawnWithPressedButton)(p) && (0,
                U.isLineToolName)(p) && !r.lineBeingCreated()) {
                    if (this._chart.justActivated())
                        return;
                    if (c.pane !== this._state)
                        return void this.setCursorPosition(e.localX, e.localY, h);
                    const i = c.currentPoint()
                      , o = this.state().defaultPriceScale()
                      , n = (0,
                    s.ensure)(null === (t = this.state().mainDataSource()) || void 0 === t ? void 0 : t.firstValue())
                      , a = {
                        index: Math.round(r.timeScale().coordinateToIndex(i.x)),
                        price: o.coordinateToPrice(i.y, n)
                    }
                      , l = (0,
                    s.ensureNotNull)(r.createLineTool({
                        pane: this.state(),
                        point: a,
                        linetool: p
                    }));
                    return r.selectionMacro((e=>{
                        e.addSourceToSelection(l)
                    }
                    )),
                    r.lineBeingCreated() || (this._finishTool(l, d),
                    e.preventDefault()),
                    void (this._startTouchPoint = null)
                }
                const m = r.lineBeingCreated();
                if (m && !(0,
                U.isLineDrawnWithPressedButton)(m.toolname) && e.isTouch && (this._startTouchPoint || e.stylus)) {
                    if (this._startTouchPoint = null,
                    !u || e.stylus) {
                        const t = (0,
                        s.ensureNotNull)(m.lastPoint())
                          , i = r.continueCreatingLine({
                            index: t.index,
                            price: t.price
                        }, new Gt.EnvironmentState(e));
                        this._initCrossHairPosition = null,
                        i && (this._finishTool(m, d),
                        e.preventDefault())
                    }
                    return
                }
                if (null !== this._firstZoomPoint && this._firstZoomPoint.draggingMode)
                    return void this._finishZoom(e);
                if (this._processing = !1,
                r.customMoveBeingProcessed())
                    return void r.endCustomMoving();
                if (null !== a) {
                    if (a.beingMoved && !a.cancelled) {
                        const t = this._sourceWasSelected(d);
                        (0,
                        zt.tryCallHandler)(e, {
                            sourceWasSelected: t
                        }, a.mouseUpHandler, a.touchEndHandler),
                        this.setCursorForTool()
                    }
                    if (l.setMovingCustomSource(null, null),
                    Is(e, a))
                        return
                }
                if (l.lineBeingEdited())
                    return r.endChangingLinetool(!1),
                    void (this._preventCrossHairMove() && this._clearCursorPosition());
                if ((0,
                U.isLineDrawnWithPressedButton)(p) && !this._isSelectPointModeEnabled()) {
                    const t = r.lineBeingCreated();
                    null !== t && (Qi(t),
                    t.finish(),
                    "LineToolBrush" === t.toolname && (0,
                    Me.emit)("drawing_event", t.id(), "create"));
                    const o = this.state().defaultPriceScale();
                    if (o.isEmpty())
                        return;
                    if (!t)
                        return;
                    const n = (0,
                    s.ensure)(null === (i = t.ownerSource()) || void 0 === i ? void 0 : i.firstValue())
                      , a = o.coordinateToPrice(e.localY, n)
                      , l = {
                        index: Math.round(r.timeScale().coordinateToIndex(e.localX)),
                        price: a
                    };
                    return void r.continueCreatingLine(l)
                }
                if (l.sourcesBeingMoved().length)
                    return r.endMovingSource(!1, !1),
                    l.sourcesBeingMoved().filter(ct.isLineTool).forEach((e=>{
                        this.setCursorForTool(e)
                    }
                    )),
                    void l.invalidate(N.InvalidationMask.cursor());
                if (!this._chart.readOnly()) {
                    const t = e.localX >= 0 && e.localX < this._size.width;
                    if ((!d || d.source !== c) && t) {
                        const t = r.timeScale().coordinateToIndex(e.localX);
                        l.onSyncScrollNeeded(t)
                    }
                }
                const g = this._isScrolling
                  , _ = this._endScroll(e)
                  , v = this._paneWidgetsSharedState.draggingSource();
                if (null !== v) {
                    const t = e.target
                      , i = this._chart.paneByCanvas(t);
                    i && i !== this && (_ && r.undoHistory().undo(),
                    r.mergeToPane(v, i.state()));
                    if (this._chart.timeAxisByCanvas(t))
                        if (l.isUnmergeAvailableForSource(v))
                            _ && r.undoHistory().undo(),
                            r.unmergeToNewBottomPane(v);
                        else {
                            const e = l.panes()
                              , t = (0,
                            s.ensureNotNull)(l.paneForSource(v))
                              , i = e.indexOf(t);
                            i !== e.length - 1 && (_ && r.undoHistory().undo(),
                            t.maximized().value() && this._chart.toggleMaximizePane(null),
                            r.movePane(i, e.length - 1))
                        }
                    this._paneWidgetsSharedState.clearDraggingSource();
                    const o = this._chart.getTimeScale();
                    o && o.restoreDefaultCursor();
                    const n = this._chart.paneWidgets();
                    for (let e = 0; e < n.length; e++) {
                        const t = n[e];
                        t === this && d && !d.isCustom ? t.setCursorForTool(d.source || void 0) : t.setCursorForTool(),
                        t.leftPriceAxisesContainer().restoreDefaultCursor(),
                        t.rightPriceAxisesContainer().restoreDefaultCursor()
                    }
                }
                this._chart.readOnly() || o || h.mod() || g || n || null !== this._lastFinishedToolId || null !== d && (d.hittest.target() > zt.HitTarget.MovePointBackground || (0,
                Mt.lastMouseOrTouchEventInfo)().isTouch) && r.selectionMacro((e=>{
                    e.clearSelection();
                    const t = (0,
                    s.ensureNotNull)(d.source);
                    e.addSourceToSelection(t, Cs(d, t))
                }
                )),
                e.isTouch && (this._touchMove = !1)
            }
            _mouseOrTouchMoveEvent(e) {
                if (!this.hasState())
                    return;
                this._resetMeasureIfRequired();
                const t = this._dataSourceAtPoint(e.localX, e.localY);
                this._processMouseEnterLeaveMoveHandlers(t, e);
                const i = this._chartUndoModel();
                if (!i)
                    return;
                const s = e.localX
                  , n = e.localY;
                this._prevMoveEventPosition = new o.Point(s,n);
                const r = new Gt.EnvironmentState(e);
                if (null === this._firstZoomPoint) {
                    if (this._updateHoveredSource(t, r, e),
                    !e.isTouch && i.lineBeingCreated()) {
                        const e = i.lineBeingCreated()
                          , t = null === e ? null : i.model().paneForSource(e);
                        if (null !== t && t !== this._state)
                            return void this._setCursorPositionOnExternalPane(t, s, n, r)
                    }
                    e.isTouch || this.setCursorPosition(s, n, r)
                } else
                    this._processMouseMoveWhileZoom(e, r)
            }
            _pressedMouseOrTouchMoveEvent(e) {
                var t, i;
                if (!this.hasState() || this._pinching || e.isTouch && this._contextMenuOpenedOnLastTap)
                    return;
                this._pressedMoveStage = 2,
                this._resetMeasureIfRequired(),
                this._startChangeOrMoveLineToolIfNeeded(),
                e.isTouch && (this._touchMove = !0,
                this._preventSourceChange = !1);
                const n = new Gt.EnvironmentState(e)
                  , r = this._chartUndoModel()
                  , a = r.crossHairSource()
                  , l = e.localX
                  , c = e.localY;
                if (this._prevMoveEventPosition = new o.Point(l,c),
                null !== this._firstZoomPoint)
                    return this._processMouseMoveWhileZoom(e),
                    void (this._firstZoomPoint.draggingMode = !0);
                const d = qt.tool.value();
                if (e.isTouch && this._startTouchPoint && (0,
                U.isLineToolName)(d) && !(0,
                U.isLineDrawnWithPressedButton)(d) && !r.lineBeingCreated() && !this._isSelectPointModeEnabled())
                    return void this._updateCrosshairPositionInToolCreationMode(e, this.state());
                const u = a.measurePane().value();
                if (e.isTouch && (this._startTouchPoint || e.stylus) && ((0,
                qt.toolIsMeasure)(d) || null !== u))
                    return void (e.stylus ? this.setCursorPosition(e.localX, e.localY, new Gt.EnvironmentState(e)) : this._updateCrosshairPositionInToolCreationMode(e, u || this.state()));
                const h = r.lineBeingCreated();
                if (e.isTouch && !e.stylus && h && !(0,
                U.isLineDrawnWithPressedButton)(h.toolname)) {
                    if (this._startTouchPoint) {
                        const t = (0,
                        s.ensureNotNull)(r.lineBeingCreated())
                          , i = (0,
                        s.ensureNotNull)(r.model().paneForSource(t));
                        this._updateCrosshairPositionInToolCreationMode(e, i)
                    }
                    return
                }
                if (e.isTouch && null !== this._startTrackPoint) {
                    this._exitTrackingModeOnNextTry = !1;
                    const e = (0,
                    s.ensureNotNull)(this._initCrossHairPosition)
                      , t = new o.Point(l,c).subtract(this._startTrackPoint)
                      , i = e.add(t);
                    this.setCursorPosition(i.x, i.y, n)
                } else
                    e.isTouch && this._preventCrossHairMove() || this.setCursorPosition(l, c, n);
                const p = this._isSelectPointModeEnabled();
                if ((0,
                U.isLineToolName)(d) && !(0,
                U.isLineDrawnWithPressedButton)(d) && !p && !n.mod())
                    return;
                if ((0,
                U.isLineDrawnWithPressedButton)(d) && !p) {
                    const i = this.state().defaultPriceScale();
                    if (i.isEmpty())
                        return;
                    const n = r.lineBeingCreated();
                    if (!n)
                        return;
                    const a = new o.Point(e.localX,e.localY)
                      , l = (0,
                    s.ensure)(null === (t = n.ownerSource()) || void 0 === t ? void 0 : t.firstValue());
                    return a.price = i.coordinateToPrice(e.localY, l),
                    a.index = Math.round(r.timeScale().coordinateToIndex(e.localX)),
                    void r.continueCreatingLine(a)
                }
                if (null !== this._paneWidgetsSharedState.draggingSource()) {
                    const t = e.target
                      , i = this._chart.paneByCanvas(t);
                    i && (i !== this ? i.setDragToAnotherPaneCursor() : i.setCursorForTool());
                    const s = this._chart.timeAxisByCanvas(t);
                    s && s.setCursor("grabbing")
                }
                if (r.timeScale().isEmpty())
                    return;
                const m = this._options.handleScroll;
                if ((!m.pressedMouseMove || e.isTouch) && (!m.horzTouchDrag && !m.vertTouchDrag || !e.isTouch))
                    return;
                if (r.customMoveBeingProcessed())
                    return void r.processCustomMove(e);
                const g = r.model().customSourceMovingHitTestData();
                if (null !== g && (this._updateCommonTooltip(null, !0),
                g.cancelled || (r.model().processingCustomSourceMove(),
                (0,
                zt.tryCallHandler)(e, {
                    sourceWasSelected: this._selectionBeforeMouseDown.has(r.model().customSourceBeingMoved())
                }, g.pressedMouseMoveHandler, g.touchMoveHandler)),
                Is(e, g)))
                    return;
                if (r.model().lineBeingEdited())
                    return void this.setCursorPosition(l, c, n);
                if (r.model().sourcesBeingMoved().length)
                    return void this._alignSourcesThatBeingMoved(r.model().sourcesBeingMoved(), e.localX, e.localY, n, null === (i = r.model().lastHittestData()) || void 0 === i ? void 0 : i.possibleMovingDirections);
                const _ = this._dataSourceAtPoint(e.localX, e.localY);
                if (this._tryFinishClonning(e, new Gt.EnvironmentState(e), _))
                    return;
                const v = (0,
                qt.toolIsMeasure)(d) || a.startMeasurePoint() && a.endMeasurePoint();
                this._chart.readOnly() || !n.mod() || (0,
                U.isLineToolName)(d) || v || p ? (this._processScroll(e),
                this._preventScroll() && !this._preventCrossHairMove() && null === this._startTrackPoint && this.setCursorPosition(e.localX, e.localY, new Gt.EnvironmentState(e))) : this._isSelecting || (a.startSelection(this.state()),
                this._isSelecting = !0)
            }
            _mouseOrTouchLeaveEvent(e) {
                var t;
                if (!this.hasState())
                    return;
                const i = this._chartUndoModel();
                if (!i)
                    return;
                const s = i.crossHairSource();
                e.isTouch || null !== s.measurePane().value() && null === s.endMeasurePoint() || this._clearCursorPosition();
                if (this._chartModel().setHoveredSource(null, null),
                null !== this._prevHoveredHittest) {
                    const i = this._sourceWasSelected(this._prevHoveredHittest);
                    (0,
                    zt.tryCallHandler)(e, {
                        sourceWasSelected: i
                    }, null === (t = this._prevHoveredHittest.hittest.data()) || void 0 === t ? void 0 : t.mouseLeaveHandler),
                    this._prevHoveredHittest = null
                }
                this._updateCommonTooltip(null),
                this._chart.unsetActivePaneWidget()
            }
            _mouseDoubleClickOrDoubleTapEvent(e) {
                if (!this.hasState())
                    return;
                const t = !this._chart.readOnly() && !(0,
                U.isLineToolName)(qt.tool.value()) && this._dataSourceAtPoint(e.localX, e.localY) || null
                  , i = this._sourceWasSelected(t);
                if (null !== t && t.isCustom)
                    t.hittest.tryCallDblClickOrDblTapHandler(e, {
                        sourceWasSelected: i
                    });
                else if (null !== t && (e.isTouch || t.hittest.target() > zt.HitTarget.MovePointBackground))
                    t.hittest.tryCallDblClickOrDblTapHandler(e, {
                        sourceWasSelected: i
                    }) && !(0,
                    zt.shouldDefaultActionBeExecuted)(e, (0,
                    s.ensureNotNull)(t.hittest.data()), "doubleClickHandler", "doubleTapHandler") || this.processDoubleClickOnSource(t.source, t.hittest ? t.hittest : void 0);
                else if (!this._chart.readOnly() && !(0,
                U.isLineToolName)(qt.tool.value()) && !this._chartUndoModel().lineBeingCreated() && this._chartUndoModel().selection().isEmpty()) {
                    const t = this.state();
                    new Gt.EnvironmentState(e).mod() && !t.maximized().value() ? (t.collapsed().value() || this._chartModel().paneCollapsingAvailable().value()) && this._chartUndoModel().toggleCollapsedPane(this.state()) : this._chart.toggleMaximizePane(this)
                }
            }
            _contextMenuEvent(e) {
                const t = this._chartUndoModel();
                if (t.crossHairSource().startMeasurePoint() && !this._trackCrosshairOnlyAfterLongTap)
                    return t.crossHairSource().clearMeasure(),
                    void (0,
                    qt.resetToCursor)(!0);
                if (this._pinching)
                    return;
                if (null === this._firstZoomPoint || this._trackCrosshairOnlyAfterLongTap || this.cancelZoom(),
                !(0,
                qt.toolIsCursor)(qt.tool.value()) || this._isSelectPointModeEnabled()) {
                    if (e.isTouch)
                        return;
                    return (0,
                    qt.resetToCursor)(!0),
                    this.setCursorForTool(),
                    void (t.lineBeingCreated() && t.cancelCreatingLine())
                }
                if (!this._options.contextMenuEnabled)
                    return;
                const i = this._dataSourceAtPoint(e.localX, e.localY)
                  , s = i ? i.source : null;
                if (e.isTouch && null !== this._startTrackPoint) {
                    if (this._preventSourceChange)
                        return;
                    this._clearCursorPosition()
                }
                e.isTouch && (this._contextMenuOpenedOnLastTap = !0,
                this._startTrackPoint = null),
                this._contextMenuX = e.localX,
                this._contextMenuY = e.localY;
                const o = i && i.hittest ? i.hittest.target() : 0
                  , n = o >= zt.HitTarget.Regular || o >= zt.HitTarget.MovePointBackground && e.isTouch;
                if (this._chart.updateActions(),
                t.selectionMacro((t=>{
                    null !== s && n ? t.selection().isSelected(s) || (t.clearSelection(),
                    t.addSourceToSelection(s, Cs(i, s))) : (this._options.contextMenu.general && this._showContextMenu(e),
                    t.clearSelection())
                }
                )),
                null !== i && n && null !== s)
                    if ((0,
                    jt.isDataSource)(s) && s.hasContextMenu())
                        s.isSelectionEnabled() ? this.showContextMenuForSelection(e, void 0, i.hittest) : this.showContextMenuForSources([s], e, void 0, void 0, i.hittest);
                    else {
                        const t = this._sourceWasSelected(i);
                        i.hittest.tryCallContextMenuHandler(e, {
                            sourceWasSelected: t
                        })
                    }
            }
            _onMouseEvent() {
                this._preventSourceChange = !1,
                this._startTrackPoint = null,
                this._trackCrosshairOnlyAfterLongTap = !1
            }
            _onTouchEvent() {
                this._trackCrosshairOnlyAfterLongTap = !0
            }
            _switchTrackingModeFromAnotherPaneIfNeeded(e) {
                const t = this._chart.trackingModePaneWidget();
                if (null !== t && t !== this) {
                    const i = this._chartModel().crossHairSource().currentPoint();
                    t._exitTrackingModeOnNextTry = !0,
                    t._tryExitTrackingMode(!0),
                    this.startTrackingMode(new o.Point(e.localX,e.localY), new o.Point(i.x,e.localY), new Gt.EnvironmentState(e))
                }
            }
            async _showContextMenu(e) {
                const t = e=>e instanceof _i.Separator
                  , i = this._customActions()
                  , s = (await this._initActions(e)).filter((e=>null !== e));
                i.remove.forEach((e=>{
                    for (let t = 0; t < s.length; t++) {
                        const i = s[t];
                        if (i instanceof _i.Action && i.getLabel() === e) {
                            s.splice(t, 1);
                            break
                        }
                    }
                }
                ));
                const o = i.top.concat(s).concat(i.bottom);
                for (let e = o.length - 1; e > 0; e--)
                    t(o[e]) && t(o[e - 1]) && o.splice(e, 1);
                o.length && t(o[0]) && o.splice(0, 1),
                o.length && t(o[o.length - 1]) && o.splice(o.length - 1, 1),
                Jt.ContextMenuManager.showMenu(o, e, {
                    statName: "ChartContextMenu"
                }, {
                    menuName: "ChartContextMenu"
                })
            }
            async _initActions(e) {
                var t;
                const i = this._chart.actions()
                  , o = [];
                if (this._chart.model().model().resetScalesAvailable().value() && (o.push(i.chartReset),
                o.push(new _i.Separator)),
                !this.state().isEmpty() && d.enabled("datasource_copypaste")) {
                    const t = (0,
                    gi.createActionCopyPrice)(this.state(), e.localY)
                      , i = (0,
                    gi.createPasteAction)(this._chart, this.state());
                    (t || i) && (t && o.push(t),
                    i && o.push(i),
                    o.push(new _i.Separator))
                }
                if (d.enabled("alerts") && (o.length && o.push(new _i.Separator),
                (0,
                s.ensureNotNull)(this.state().mainDataSource()).alertCreationAvailable().value())) {
                    const t = (await (0,
                    qi.getAlertsChartActionCreators)()).createAlert(this._chart, {
                        localY: e.localY,
                        pane: this.state()
                    });
                    null !== t && o.push(t)
                }
                if (this._options.contextMenu.mainSeriesTrade && this.containsMainSeries()) {
                    const t = await (0,
                    gi.createActionTrade)(this._chart, this.state(), e);
                    t && o.push(t)
                }
                o[o.length - 1]instanceof _i.Separator || o.push(new _i.Separator);
                return Boolean(null === (t = window.widgetbar) || void 0 === t ? void 0 : t.widget("watchlist")) && i.addToWatchlist && o.push(i.addToWatchlist),
                d.enabled("text_notes") && o.push(i.addToTextNotes),
                o[o.length - 1]instanceof _i.Separator || o.push(new _i.Separator),
                i.moveChartAction && !i.moveChartAction.isDisabled() && o.push(i.moveChartAction, new _i.Separator),
                o.push(this._createLockTimeAxisAction(e)),
                o.push(new _i.Separator),
                i.paneObjectTree && o.push(i.paneObjectTree),
                i.applyColorTheme && o.push(i.applyColorTheme),
                o[o.length - 1]instanceof _i.Separator || o.push(new _i.Separator),
                this._chart.applyIndicatorsToAllChartsAvailable() && (o.push(i.applyStudiesToAllCharts),
                o.push(new _i.Separator)),
                o.push(i.paneRemoveAllDrawingTools),
                o.push(i.paneRemoveAllStudies),
                o.push(new _i.Separator),
                d.enabled("show_chart_property_page") && o.push(i.chartProperties),
                o[o.length - 1]instanceof _i.Separator && o.pop(),
                o
            }
            _loadAndCreateLegendWidget() {
                Promise.all([i.e(65073), i.e(46445), i.e(93703), i.e(75816), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(2520), i.e(25480), i.e(62564), i.e(46489), i.e(58985), i.e(75826), i.e(74600), i.e(88015), i.e(86605), i.e(41243), i.e(7001), i.e(71329), i.e(51488), i.e(59470), i.e(75364), i.e(79753), i.e(77183), i.e(58357), i.e(80269), i.e(32227), i.e(50030), i.e(18405), i.e(98422), i.e(5093)]).then(i.bind(i, 31225)).then((e=>{
                    if (this._isDestroyed)
                        return;
                    const t = e.LegendWidget
                      , i = (0,
                    Ht.deepExtend)({}, this._options.legendWidget);
                    i.canShowSourceCode = !this._chart.onWidget() && !l.CheckMobile.any(),
                    i.readOnlyMode = i.readOnlyMode || this._chart.readOnly(),
                    i.statusesWidgets = {
                        sourceStatusesEnabled: this._options.sourceStatusesWidgetEnabled,
                        sourceStatuses: this._options.sourceStatusesWidget || {},
                        marketStatusEnabled: this._options.marketStatusWidgetEnabled,
                        dataUpdateModeEnabled: this._options.chartWarningWidgetEnabled,
                        dataUpdateMode: this._options.chartWarningWidget || {},
                        dataProblemEnabled: this._options.dataProblemWidgetEnabled,
                        pineSourceStatusEnabled: this._options.pineSourceStatusEnabled
                    };
                    const o = (0,
                    Ye.combine)(((e,t)=>xs && this._chart !== e && !t), this._chart.chartWidgetCollection().activeChartWidget.weakReference(), this._chart.chartWidgetCollection().lock.crosshair.weakReference())
                      , n = (0,
                    Ye.combine)(((e,t)=>null !== e ? e === this._state : (0,
                    qt.toolIsMeasure)(t)), this._chartModel().crossHairSource().measurePane().weakReference(), qt.tool.weakReference());
                    this._legendWidget = new t(this._chartUndoModel(),this,this._chart.backgroundTopTheme().spawnOwnership(),o.ownership(),this._visuallyCollapsed.spawnOwnership(),n.ownership(),i,{
                        showContextMenuForSelection: this.showContextMenuForSelection.bind(this),
                        showContextMenuForSources: this.showContextMenuForSources.bind(this),
                        updateActions: this._chart.updateActions.bind(this._chart),
                        showChartPropertiesForSource: this._chart.showChartPropertiesForSource.bind(this._chart),
                        showGeneralChartProperties: this._chart.showGeneralChartProperties.bind(this._chart),
                        showObjectsTreeDialog: this._chart.showObjectsTreeDialog.bind(this._chart),
                        onLegendRowFocused: ()=>{
                            this._chart.chartWidgetCollection().activeChartWidget.setValue(this._chart)
                        }
                    }),
                    this._div.appendChild(this._legendWidget.getElement()),
                    this._legendWidget.updateLayout(),
                    this._legendWidget.updateWidgetModeBySize(this._size),
                    this._legendWidget.updateThemedColors(this._themedTopColor);
                    for (const e of Array.from(this._customLegendWidgetsFactoryMap.keys()))
                        this._legendWidget.addCustomWidgetToLegend(e, (0,
                        s.ensureDefined)(this._customLegendWidgetsFactoryMap.get(e)))
                }
                ))
            }
            _loadAndCreatePaneControlsWidget() {
                Promise.all([i.e(65073), i.e(46445), i.e(93703), i.e(75816), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(2520), i.e(25480), i.e(62564), i.e(46489), i.e(58985), i.e(75826), i.e(74600), i.e(88015), i.e(86605), i.e(41243), i.e(7001), i.e(71329), i.e(51488), i.e(59470), i.e(75364), i.e(79753), i.e(77183), i.e(58357), i.e(80269), i.e(32227), i.e(50030), i.e(18405), i.e(98422), i.e(5093)]).then(i.bind(i, 897672)).then((e=>{
                    var t;
                    if (this._isDestroyed)
                        return;
                    const i = e.PaneControlsWidget;
                    this._paneControls = new i(this._chartUndoModel(),this,{
                        backgroundThemeName: this._chart.backgroundTopTheme()
                    },{
                        toggleMaximizePane: this._chart.toggleMaximizePane.bind(this._chart)
                    },this._div),
                    this._paneControls.updateWidgetModeByWidth(this._size.width),
                    this._paneControls.updateThemedColors(this._themedTopColor),
                    this._paneControlsResizeObserver = new ResizeObserver(this._handleRestrictLegendWidth.bind(this)),
                    this._paneControlsResizeObserver.observe(this._paneControls.getElement()),
                    (null === (t = this._state) || void 0 === t ? void 0 : t.collapsed().value()) && this._chartModel().fullUpdate()
                }
                ))
            }
            _handleRestrictLegendWidth(e) {
                if (null === this._legendWidget || null === this._paneControls)
                    return;
                const t = e[e.length - 1].contentRect.width
                  , i = 0 === t ? 0 : t + cs + ds;
                this._legendWidget.addMargin(i)
            }
            _onMagnetStateChanged() {
                this._chart.isActive().value() && (this._isSelectPointModeEnabled() || this._isToolActionActiveOnPane(!0)) && this._chartModel().crossHairSource().visible && this._updateLineToolUsingMagnetOrShift()
            }
            _onShiftKeyStateChanged() {
                this._chart.isActive().value() && this._isToolActionActiveOnPane(!1) && this._chartModel().crossHairSource().visible && this._updateLineToolUsingMagnetOrShift(Gt.EnvironmentState.create((0,
                et.shiftPressed)().value()))
            }
            _isToolActionActiveOnPane(e) {
                const t = this._chartModel()
                  , i = t.lineBeingCreated() || t.lineBeingEdited() || t.sourcesBeingMoved().length > 0 && t.sourcesBeingMoved()[0];
                return i ? t.paneForSource(i) === this._state : e && (0,
                U.isLineToolName)(qt.tool.value()) && t.crossHairSource().pane === this._state
            }
            _updateLineToolUsingMagnetOrShift(e) {
                if (null === this._prevMoveEventPosition)
                    return;
                const {x: t, y: i} = this._prevMoveEventPosition
                  , s = this._chartModel().sourcesBeingMoved();
                s.length > 0 ? (qt.isStudyEditingNow.value() && this.setCursorPosition(t, i, e),
                this._alignSourcesThatBeingMoved(s, t, i, e)) : this.setCursorPosition(t, i, e)
            }
            _showEditDialogForSource(e, t) {
                if (this._options.propertyPagesEnabled && e.userEditEnabled())
                    if (e === this._chartUndoModel().mainSeries())
                        this._chart.showGeneralChartProperties(ot.TabNames.symbol);
                    else if ((0,
                    ct.isLineTool)(e) || (0,
                    rt.isStudy)(e) || (0,
                    lt.isLollipopDataSource)(e)) {
                        let i;
                        const s = null == t ? void 0 : t.data();
                        if (null != s) {
                            const e = s.areaName;
                            void 0 !== e && (i = Ps.get(e))
                        }
                        this._chart.showChartPropertiesForSource(e, i).then((e=>{
                            this._editDialog = e
                        }
                        ))
                    }
            }
            _initToolCreationModeParams(e) {
                this._startTouchPoint = new o.Point(e.pageX,e.pageY),
                this._initCrossHairPosition = this._chartModel().crossHairSource().currentPoint()
            }
            _updateCrosshairPositionInToolCreationMode(e, t) {
                if (t !== this._state) {
                    const i = this._chart.paneByState(t);
                    return i._startTouchPoint = this._startTouchPoint,
                    i._initCrossHairPosition = this._initCrossHairPosition,
                    void i._updateCrosshairPositionInToolCreationMode(e, t)
                }
                const i = this._chartModel().crossHairSource();
                this._chart.justActivated() && (this._initCrossHairPosition = i.currentPoint());
                const n = e.pageX
                  , r = e.pageY
                  , a = (0,
                s.ensureNotNull)(this._initCrossHairPosition)
                  , l = new o.Point(n,r).subtract((0,
                s.ensureNotNull)(this._startTouchPoint))
                  , c = a.add(l);
                this.setCursorPosition(c.x, c.y, new Gt.EnvironmentState(e))
            }
            _priceAxisesContainer(e) {
                return "left" === e ? this._lhsPriceAxisesContainer : this._rhsPriceAxisesContainer
            }
            _recalculatePriceScales(e) {
                const t = this.state();
                for (const i of t.leftPriceScales())
                    t.recalculatePriceScale(i, e);
                for (const i of t.rightPriceScales())
                    t.recalculatePriceScale(i, e);
                for (const i of t.sourcesByGroup().overlayPriceScaleSources())
                    (0,
                    ct.isLineTool)(i) || t.recalculatePriceScale(i.priceScale(), e)
            }
            _createLockTimeAxisAction(e) {
                var t;
                const i = 0 === (null === (t = qt.crosshairLock.value()) || void 0 === t ? void 0 : t.type);
                return new _i.Action({
                    actionId: "Chart.Crosshair.LockVerticalCursor",
                    options: {
                        label: ms,
                        statName: "LockCursorInTime",
                        checkable: !0,
                        checked: i,
                        onExecute: ()=>this._toggleLockTimeAxis(e.localX, !i)
                    }
                })
            }
            _toggleLockTimeAxis(e, t) {
                if (t) {
                    const t = this._chartUndoModel().timeScale()
                      , i = t.coordinateToIndex(e)
                      , s = t.points().roughTime(i);
                    if (null !== s)
                        return void qt.crosshairLock.setValue({
                            type: 0,
                            time: s
                        })
                }
                qt.crosshairLock.setValue(null)
            }
            _preventTouchEventsExceptPinch() {
                return this._paneWidgetsSharedState.hasTouchesOnOtherPanes(this) || null !== this._paneWidgetsSharedState.pinchingPane()
            }
            _updateHoveredSource(e, t, i) {
                var s, o;
                const n = this._chartUndoModel()
                  , r = n.model();
                let a = !1;
                const l = e && e.source
                  , c = this._chart.readOnly();
                if (r.crossHairSource().isReplaySelection())
                    this._setCursorClassName("none");
                else if (!(!c || e && (0,
                ct.isLineTool)(e.source)) || this._editDialog && this._editDialog.visible().value())
                    c && (r.setHoveredSource(null, null),
                    this.setCursorForTool());
                else {
                    const d = qt.tool.value();
                    let u = null;
                    if (!this._processing && ((0,
                    qt.toolIsCursor)(d) || "eraser" === d && !c || t.mod() || !n.lineBeingCreated())) {
                        const t = null == e ? void 0 : e.hittest;
                        a = Boolean(null === (s = null == t ? void 0 : t.data()) || void 0 === s ? void 0 : s.hideCrosshairLinesOnHover),
                        t && t.target() > zt.HitTarget.MovePointBackground ? (u = l,
                        !(null == l ? void 0 : l.isHoveredEnabled()) || "eraser" === d && l === n.mainSeries() ? r.setHoveredSource(null, null) : r.setHoveredSource(l, t.data(), 0)) : r.setHoveredSource(null, null)
                    }
                    c ? this.setCursorForTool(u, t, ts.PaneCursorType.Default) : this._options.sourceSelectionEnabled && (this._isSelectPointModeEnabled() ? this._setCursorClassName("pointer") : this.setCursorForTool(u, t, null === (o = null == e ? void 0 : e.hittest.data()) || void 0 === o ? void 0 : o.cursorType));
                    const h = r.customSourceBeingMoved()
                      , p = null !== h ? [h] : r.sourcesBeingMoved();
                    if ((!p.length || null !== e && -1 === p.indexOf(e.source)) && this._updateCommonTooltip(e),
                    !c && null !== e && i && e.hittest.hasPressedMoveHandler(i)) {
                        switch ((e.hittest.data() || {}).cursorType) {
                        case ts.PaneCursorType.VerticalResize:
                            this._setCursorClassName("ns-resize");
                            break;
                        case ts.PaneCursorType.HorizontalResize:
                            this._setCursorClassName("we-resize");
                            break;
                        case ts.PaneCursorType.DiagonalNeSwResize:
                            this._setCursorClassName("nesw-resize");
                            break;
                        case ts.PaneCursorType.DiagonalNwSeResize:
                            this._setCursorClassName("nwse-resize")
                        }
                    }
                }
                this._preventCrossHairMove() && this._clearCursorPosition(),
                1 !== this._pressedMoveStage && r.crossHairSource().setLinesShouldBeHidden(a)
            }
            async _createErrorBlock() {
                const e = new (await (0,
                _t.getErrorCardRenderer)());
                return this._div.insertBefore(e.container, this._topCanvasBinding.canvasElement.nextSibling),
                e
            }
            _customActions() {
                const e = {
                    top: [],
                    bottom: [],
                    remove: []
                }
                  , t = this._chartUndoModel().timeScale()
                  , i = this._state && this._state.defaultPriceScale();
                if (!d.enabled("custom_items_in_context_menu"))
                    return e;
                const o = t.isEmpty() ? void 0 : t.indexToUserTime(t.coordinateToIndex(this._contextMenuX));
                let n;
                if (i && !i.isEmpty()) {
                    const e = (0,
                    s.ensureNotNull)(this.state().mainDataSource()).firstValue();
                    n = i.coordinateToPrice(this._contextMenuY, (0,
                    s.ensureNotNull)(e))
                }
                return (0,
                Me.emit)("onContextMenu", {
                    unixtime: null != o ? o.getTime() / 1e3 : void 0,
                    price: n,
                    callback: t=>{
                        [...t].forEach((t=>{
                            if (t.text)
                                if (t.text.length > 1 && "-" === t.text[0])
                                    e.remove.push(t.text.slice(1));
                                else {
                                    let i;
                                    i = "-" === t.text ? new _i.Separator : new _i.Action({
                                        actionId: "Chart.ExternalActionId",
                                        options: {
                                            label: t.text,
                                            onExecute: t.click
                                        }
                                    }),
                                    t.position && "top" === t.position ? e.top.push(i) : e.bottom.push(i)
                                }
                        }
                        ))
                    }
                }),
                e
            }
            _highlightPriceAxisByLabel(e) {
                this._lhsPriceAxisesContainer.highlightPriceAxisByLabel(e),
                this._rhsPriceAxisesContainer.highlightPriceAxisByLabel(e)
            }
            _subscribeToState() {
                const e = this.state();
                e.onDestroyed().subscribe(this, this._onStateDestroyed, !0),
                e.dataSourcesCollectionChanged().subscribe(this, this._onDataSourcesCollectionChanged),
                e.maximized().subscribe(this._updateVisuallyCollapsed),
                e.collapsed().subscribe(this._updateVisuallyCollapsed)
            }
            _unsubscribeFromState() {
                const e = this.state();
                e.onDestroyed().unsubscribeAll(this),
                e.dataSourcesCollectionChanged().unsubscribeAll(this),
                e.maximized().unsubscribe(this._updateVisuallyCollapsed),
                e.collapsed().unsubscribe(this._updateVisuallyCollapsed)
            }
            _updateAccesibilityAttr() {
                if (this.state().isMainPane()) {
                    const e = this._chartModel().mainSeries()
                      , t = e.symbol()
                      , s = (0,
                    rs.getTranslatedResolutionModel)(e.interval()).hint
                      , o = r.t(null, {
                        replace: {
                            symbol: t,
                            interval: s
                        }
                    }, i(501136));
                    this._topCanvasBinding.canvasElement.setAttribute("aria-label", o)
                } else
                    this._topCanvasBinding.canvasElement.setAttribute("aria-hidden", "true")
            }
            async _updateEndOfSeriesBanner() {
                var e, t, o, n;
                {
                    const r = ()=>{
                        var e, t;
                        if (window.user.is_pro)
                            return null;
                        const i = this._state;
                        if (!i)
                            return null === (e = this._endOfSeriesDataBanner) || void 0 === e || e.setVisible(!1),
                            null;
                        if (!this._chart.isActive().value())
                            return null;
                        const s = i.model().mainSeries();
                        if (!s)
                            return null;
                        if (!i.isMainPane())
                            return null;
                        if (2 === s.status() || s.requestMoreDataAvailable())
                            return null === (t = this._endOfSeriesDataBanner) || void 0 === t || t.setVisible(!1),
                            null;
                        const o = s.bars().firstIndex();
                        return null === o ? null : {
                            state: i,
                            series: s,
                            firstIndex: o
                        }
                    }
                      , a = ()=>{
                        if (this._legendWidget) {
                            const e = this._legendWidget.getElement().getBoundingClientRect();
                            return e.bottom - e.top
                        }
                        return 0
                    }
                    ;
                    let l = r();
                    if (!l || "end" === l.series.endOfDataType())
                        return void (null === (e = this._endOfSeriesDataBanner) || void 0 === e || e.setVisible(!1));
                    l.series.doNotShowLastAvailableBar(!1);
                    const c = l.series.endOfDataType()
                      , u = (0,
                    s.ensureNotNull)(this._state).model().timeScale().indexToCoordinate(l.firstIndex) - l.state.model().timeScale().barSpacing();
                    if (!this._endOfSeriesDataBanner && !d.enabled("widget")) {
                        const e = await Promise.all([i.e(66476), i.e(46445), i.e(93703), i.e(75816), i.e(44524), i.e(21356), i.e(62093), i.e(46489), i.e(88015), i.e(61443), i.e(32227), i.e(62526), i.e(66849)]).then(i.bind(i, 73345));
                        if (l = r(),
                        !l)
                            return;
                        this._endOfSeriesDataBanner || (this._endOfSeriesDataBanner = new e.EndOfSeriesBanner,
                        this._div.appendChild(this._endOfSeriesDataBanner.element()))
                    }
                    const h = a();
                    null === (t = this._endOfSeriesDataBanner) || void 0 === t || t.setVisible(!0),
                    null === (o = this._endOfSeriesDataBanner) || void 0 === o || o.update(l.state, h, u, c);
                    const p = null === (n = this._endOfSeriesDataBanner) || void 0 === n ? void 0 : n.currentSize();
                    l.series.doNotShowLastAvailableBar(null !== p && 0 !== p)
                }
            }
        }
        class Ls {
            constructor() {
                this._draggingSource = null,
                this._activeTouchPanes = new Set,
                this._scrollingPane = null,
                this._pinchingPane = null
            }
            onPaneDestroyed(e) {
                this._activeTouchPanes.delete(e),
                this._scrollingPane === e && (this._scrollingPane = null),
                this._pinchingPane === e && (this._pinchingPane = null)
            }
            startTouch(e) {
                this._activeTouchPanes.add(e)
            }
            endTouch(e) {
                this._activeTouchPanes.delete(e)
            }
            hasTouchesOnOtherPanes(e) {
                return this._activeTouchPanes.size > 1 || 1 === this._activeTouchPanes.size && !this._activeTouchPanes.has(e)
            }
            trySetDraggingSource(e, t) {
                return !this.hasTouchesOnOtherPanes(t) && ((0,
                s.assert)(null === this._draggingSource || this._draggingSource === e),
                this._draggingSource = e,
                !0)
            }
            clearDraggingSource() {
                null !== this._draggingSource && (this._draggingSource = null)
            }
            draggingSource() {
                return this._draggingSource
            }
            setScrollingPane(e) {
                (0,
                s.assert)(null === e || null === this._scrollingPane || this._scrollingPane === e),
                this._scrollingPane = e
            }
            scrollingPane() {
                return this._scrollingPane
            }
            setPinchingPane(e) {
                (0,
                s.assert)(null === e || null === this._pinchingPane || this._pinchingPane === e),
                this._pinchingPane = e
            }
            pinchingPane() {
                return this._pinchingPane
            }
        }
        var Es = i(596673)
          , ks = i(472051);
        i(660070);
        const Ds = {
            contextMenuEnabled: !0,
            timezoneMenuEnabled: !0,
            pressedMouseMoveScale: !0
        }
          , Ns = new c.TranslatedString("change session",r.t(null, void 0, i(887041)))
          , Bs = r.t(null, void 0, i(194031));
        class Rs {
            constructor(e, t, i, s, o) {
                this._rendererOptions = null,
                this._onLabelHovered = new le.Delegate,
                this._mousedown = !1,
                this._currentCursorClassName = "invalid",
                this._options = (0,
                Ue.merge)((0,
                Ue.clone)(Ds), t || {}),
                this.chart = e,
                this._properties = e.properties().childs().scalesProperties,
                this._element = document.createElement("div"),
                this._element.style.display = "flex",
                this._backgroundBasedTheme = o;
                const n = e.model().model().rendererOptionsProvider()
                  , r = ()=>this.backgroundColor()
                  , a = ()=>{
                    throw new Error("Time axis does not support real price scales")
                }
                  , l = {
                    titlesProvider: i,
                    stubContextMenuProvider: (e,t)=>{
                        const i = s(e, t)
                          , o = this.getContextMenuActions(!0);
                        return 0 === o.length ? i : i.concat(new _i.Separator, o)
                    }
                    ,
                    backgroundBasedTheme: o.spawnOwnership(),
                    onActiveOrHoveredChart: (0,
                    Ye.combine)(((e,t)=>e || t), this.chart.isActive().weakReference(), this.chart.isHovered().weakReference()).ownership(),
                    rendererOptionsProvider: n,
                    getBackgroundTopColor: r,
                    getBackgroundBottomColor: r,
                    requestRepaint: ()=>this.chart.model().model().lightUpdate(),
                    showHorizontalBorder: !0
                };
                this._lhsStubContainer = new ai(this._properties,"left",a,l,this._options.priceAxisLabelsOptions,this),
                this._lhsStubContainer.onLabelHovered().subscribe(this, ((e,t)=>{
                    this._onLabelHovered.fire(e, t)
                }
                )),
                this._rhsStubContainer = new ai(this._properties,"right",a,l,this._options.priceAxisLabelsOptions,this),
                this._rhsStubContainer.onLabelHovered().subscribe(this, ((e,t)=>{
                    this._onLabelHovered.fire(e, t)
                }
                )),
                this._element.appendChild(this._lhsStubContainer.getElement()),
                this._cell = document.createElement("div"),
                this._element.appendChild(this._cell),
                this._cell.classList.add("chart-markup-table", "time-axis"),
                this._cell.style.height = "25px",
                this._dv = document.createElement("div"),
                this._dv.style.width = "100%",
                this._dv.style.height = "100%",
                this._dv.style.position = "relative",
                this._dv.style.overflow = "hidden",
                this._cell.appendChild(this._dv),
                this._canvasConfiguredHandler = ()=>this.chart.model().model().lightUpdate(),
                this._canvasBinding = (0,
                Qe.createBoundCanvas)(this._dv, (0,
                Ae.size)({
                    width: 16,
                    height: 16
                })),
                this._canvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
                const c = this._canvasBinding.canvasElement;
                c.style.position = "absolute",
                c.style.zIndex = "1",
                c.style.left = "0",
                c.style.top = "0",
                this._topCanvasBinding = (0,
                Qe.createBoundCanvas)(this._dv, (0,
                Ae.size)({
                    width: 16,
                    height: 16
                })),
                this._topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
                const d = this._topCanvasBinding.canvasElement;
                d.style.position = "absolute",
                d.style.zIndex = "2",
                d.style.left = "0",
                d.style.top = "0",
                this._dv.setAttribute("aria-hidden", "true"),
                this._element.appendChild(this._rhsStubContainer.getElement()),
                this.restoreDefaultCursor(),
                this.update(),
                this._minVisibleSpan = Es.MINUTE_SPAN,
                this._mouseEventHandler = new Ot.MouseEventHandler(this._topCanvasBinding.canvasElement,this,{
                    treatVertTouchDragAsPageScroll: !0,
                    treatHorzTouchDragAsPageScroll: !1
                }),
                this.size = (0,
                Ae.size)({
                    width: 0,
                    height: 0
                })
            }
            destroy() {
                this._mouseEventHandler.destroy(),
                this._topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler),
                this._topCanvasBinding.dispose(),
                this._canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler),
                this._canvasBinding.dispose(),
                this._rhsStubContainer.onLabelHovered().unsubscribeAll(this),
                this._lhsStubContainer.onLabelHovered().unsubscribeAll(this),
                this._lhsStubContainer.destroy(),
                this._rhsStubContainer.destroy(),
                this.chart.properties().childs().paneProperties.childs().background.unsubscribeAll(this),
                this._backgroundBasedTheme.release()
            }
            setCursor(e) {
                let t = "";
                "grabbing" !== e && "ew-resize" !== e || (t = "time-axis--cursor-" + e),
                this._currentCursorClassName !== t && (this._currentCursorClassName && this._cell.classList.remove(this._currentCursorClassName),
                t && this._cell.classList.add(t),
                this._currentCursorClassName = t,
                this._cell.style.cursor)
            }
            restoreDefaultCursor() {
                this.setCursor("")
            }
            getElement() {
                return this._element
            }
            optimalHeight() {
                const e = this.rendererOptions();
                return Math.ceil(e.borderSize + e.offsetSize + e.fontSize + e.paddingTop + e.paddingBottom + e.labelBottomOffset)
            }
            setSizes(e, t, i) {
                this.size && (0,
                Ae.equalSizes)(this.size, e) || (this.size = e,
                this._canvasBinding.resizeCanvasElement(e),
                this._topCanvasBinding.resizeCanvasElement(e),
                this._cell.style.width = e.width + "px",
                this._cell.style.height = e.height + "px"),
                this._lhsStubContainer.setSizes(e.height, t),
                this._rhsStubContainer.setSizes(e.height, i)
            }
            rendererOptions() {
                if (!this._rendererOptions || this._rendererOptions.fontSize !== this.fontSize()) {
                    const e = this.fontSize();
                    this._rendererOptions = {
                        borderSize: 1,
                        offsetSize: 5,
                        fontSize: e,
                        font: (0,
                        Yt.makeFont)(e, ei.CHART_FONT_FAMILY, ""),
                        widthCache: new $t.TextWidthCache,
                        paddingTop: 3 * e / 12,
                        paddingBottom: 3 * e / 12,
                        paddingHorizontal: 9 * e / 12,
                        labelBottomOffset: 4 * e / 12
                    }
                }
                return this._rendererOptions
            }
            backgroundColor() {
                return this.chart.model().model().backgroundColor().value()
            }
            lineColor() {
                const e = this._properties.childs().lineColor.value();
                if (0 === (0,
                Bt.parseRgba)(e)[3]) {
                    const e = this.chart.model().model().lastPane();
                    if (e && (e.collapsed().value() || e.isMainPane() && this._areEventsEnabled()))
                        return this.chart.properties().childs().paneProperties.childs().separatorColor.value()
                }
                return e
            }
            textColor() {
                return this._properties.childs().textColor.value()
            }
            fontSize() {
                return this._properties.childs().fontSize.value()
            }
            baseFont() {
                return (0,
                Yt.makeFont)(this.fontSize(), ei.CHART_FONT_FAMILY)
            }
            baseBoldFont() {
                return (0,
                Yt.makeFont)(this.fontSize(), ei.CHART_FONT_FAMILY, "", "bold")
            }
            hasCanvas(e) {
                return this._canvasBinding.canvasElement === e || this._topCanvasBinding.canvasElement === e
            }
            onLabelHovered() {
                return this._onLabelHovered
            }
            getScreenshotData() {
                return {
                    content: this._canvasBinding.canvasElement.toDataURL(),
                    canvas: this._canvasBinding.canvasElement,
                    contentWidth: this.size.width,
                    contentHeight: this.size.height,
                    lhsStub: this._lhsStubContainer.getScreenshotData(),
                    rhsStub: this._rhsStubContainer.getScreenshotData()
                }
            }
            getContextMenuActions(e) {
                var t;
                const i = this.chart;
                i.updateActions();
                const s = i.actions()
                  , o = [];
                if (e || (i.model().timeScale().resetAvailable().value() && (o.push(s.timeScaleReset),
                o.push(new _i.Separator)),
                this._options.timezoneMenuEnabled && o.push(s.applyTimeZone),
                o.push(s.sessionBreaks)),
                !i.model().mainSeries().isDWM()) {
                    const e = null === (t = i.model()) || void 0 === t ? void 0 : t.mainSeries().symbolInfo();
                    if (e) {
                        const t = i.model().mainSeries().properties().childs().sessionId
                          , s = (e.subsessions || []).filter((e=>!e.private));
                        if (s.length > 1) {
                            const e = s.map((e=>new _i.Action({
                                actionId: "Chart.SetSession",
                                options: {
                                    label: (0,
                                    ks.translateSessionDescription)(e.description),
                                    checkable: !0,
                                    checked: t.value() === e.id,
                                    statName: "SetSession",
                                    onExecute: ()=>{
                                        i.model().setProperty(t, e.id, Ns)
                                    }
                                }
                            })))
                              , n = new _i.Action({
                                actionId: "Chart.SetSession",
                                options: {
                                    label: Bs,
                                    statName: "SetSession",
                                    subItems: e
                                }
                            });
                            o.push(n)
                        }
                    }
                }
                return !i.onWidget() && d.enabled("show_chart_property_page") && d.enabled("chart_property_page_scales") && s.scalesProperties && (o.length && o.push(new _i.Separator),
                o.push(s.scalesProperties)),
                o
            }
            update() {
                if (!this.chart.hasModel())
                    return;
                const e = this.chart.model().timeScale().marks();
                if (e) {
                    this._minVisibleSpan = Es.YEAR_SPAN;
                    for (const t of e)
                        this._minVisibleSpan = Math.min(t.span, this._minVisibleSpan)
                }
            }
            updatePriceAxisStubs() {
                const e = this.chart.model().model()
                  , t = this.chart.isMaximizedPane() ? (0,
                s.ensureNotNull)(this.chart.maximizedPaneWidget()).state() : e.paneForSource(e.mainSeries());
                if (!t)
                    return;
                const i = e.priceScaleSlotsCount();
                this._lhsStubContainer.setScales([], i.left, t.leftPriceScales().length, i.left + i.right),
                this._rhsStubContainer.setScales([], i.right, t.rightPriceScales().length, i.left + i.right)
            }
            paint(e) {
                if (e === N.InvalidationLevel.None || 0 === this.size.width || 0 === this.size.height)
                    return;
                (0,
                Qe.tryApplySuggestedCanvasBitmapSize)(this._canvasBinding),
                (0,
                Qe.tryApplySuggestedCanvasBitmapSize)(this._topCanvasBinding);
                const t = (0,
                Qe.getContext2D)(this._topCanvasBinding.canvasElement);
                if (e > N.InvalidationLevel.Cursor) {
                    const i = (0,
                    Qe.getContext2D)(this._canvasBinding.canvasElement)
                      , s = (0,
                    Qe.getBindingRenderingInfo)(this._canvasBinding);
                    this.drawBackground(i, s),
                    this.chart.hasModel() && (this.drawBorder(i, s),
                    this.drawTickMarks(i, s),
                    this.drawBackLabels(i, s),
                    this.drawCrossHairLabel(t, s)),
                    this._lhsStubContainer.paintStubs(e),
                    this._rhsStubContainer.paintStubs(e)
                }
                this.drawCrossHairLabel(t, (0,
                Qe.getBindingRenderingInfo)(this._topCanvasBinding))
            }
            drawBackground(e, t) {
                if ((0,
                Qe.clearRect)(e, 0, 0, t.bitmapSize.width, t.bitmapSize.height, this.backgroundColor()),
                !this.chart.hasModel())
                    return;
                const i = this.chart.model();
                if (!i.timeScale().isEmpty()) {
                    const s = i.model().selection().lineDataSources().reduce(((e,t)=>{
                        const i = t.timeAxisPoints();
                        return 0 === i.length ? e : e.concat(i)
                    }
                    ), []);
                    s.length > 0 && this._highlightBackground(e, s, t)
                }
                const s = i.model().crossHairSource();
                s.startMeasurePoint() && this._highlightBackground(e, s.measurePoints(), t)
            }
            drawBorder(e, t) {
                e.save(),
                e.fillStyle = this.lineColor();
                const i = Math.max(1, Math.floor(this.rendererOptions().borderSize * t.verticalPixelRatio))
                  , s = t.bitmapSize.width;
                e.fillRect(0, 0, s, i),
                e.restore()
            }
            drawTickMarks(e, t) {
                const i = this.chart.model().timeScale().marks();
                if (!i || 0 === i.length)
                    return;
                let s = i.reduce(((e,t)=>e.span > t.span ? e : t), i[0]).span;
                s > 30 && s < 40 && (s = 30),
                e.save(),
                e.strokeStyle = this.lineColor();
                const o = this.rendererOptions()
                  , n = o.borderSize + o.offsetSize + o.paddingTop + o.fontSize / 2;
                e.textAlign = "center",
                e.textBaseline = "middle",
                e.fillStyle = this.textColor(),
                (0,
                Qe.drawScaled)(e, t.horizontalPixelRatio, t.verticalPixelRatio, (()=>{
                    e.font = this.baseFont();
                    for (let t = 0; t < i.length; t++) {
                        const o = i[t];
                        o.span < s && e.fillText(o.label, o.coord, n)
                    }
                    e.font = this.baseBoldFont();
                    for (let t = 0; t < i.length; t++) {
                        const o = i[t];
                        o.span >= s && e.fillText(o.label, o.coord, n)
                    }
                }
                )),
                e.restore()
            }
            drawBackLabels(e, t) {
                var i;
                e.save();
                const s = new Set
                  , o = this.chart.model().model();
                let n = o.dataSources();
                const r = o.selection().allSources();
                for (const e of r)
                    s.add(e);
                o.hoveredSource() && s.add(o.hoveredSource());
                for (const e of o.sourcesBeingMoved())
                    s.add(e);
                const a = o.customSourceBeingMoved();
                null !== a && s.add(a);
                const l = null !== (i = o.lineBeingEdited()) && void 0 !== i ? i : o.lineBeingCreated();
                l && s.add(l),
                s.add(this.chart.model().crossHairSource()),
                n = n.concat(o.customSources());
                const c = this.rendererOptions();
                for (let i = 0; i < n.length; i++) {
                    const o = n[i];
                    if (!s.has(o) && o.timeAxisViews) {
                        const i = o.timeAxisViews();
                        if (i)
                            for (let s = 0; s < i.length; s++)
                                i[s].renderer().draw(e, t, c)
                    }
                }
                e.restore()
            }
            drawCrossHairLabel(e, t) {
                var i;
                e.save(),
                e.clearRect(0, 0, t.bitmapSize.width, t.bitmapSize.height);
                const s = this.chart.model().model()
                  , o = []
                  , n = null !== (i = s.lineBeingEdited()) && void 0 !== i ? i : s.lineBeingCreated();
                if (n && n.timeAxisViews) {
                    const e = n.timeAxisViews();
                    e && e.length && o.push(e)
                }
                const r = s.customSourceBeingMoved();
                this._addViewsOrMaxMin(null === r ? [] : [r], o),
                this._addViewsOrMaxMin(s.sourcesBeingMoved(), o),
                this._addViewsOrMaxMin(s.selection().allSources(), o);
                const a = s.hoveredSource();
                if (a && (0,
                jt.isDataSource)(a) && !s.selection().isSelected(a) && a.timeAxisViews) {
                    const e = a.timeAxisViews();
                    e && e.length && o.push(e)
                }
                const l = s.crossHairSource()
                  , c = l.timeAxisViews && l.timeAxisViews();
                c && c.length && o.push(c);
                const d = this.rendererOptions();
                for (const i of o)
                    for (const s of i)
                        e.save(),
                        s.renderer().draw(e, t, d),
                        e.restore();
                e.restore()
            }
            mouseDownEvent(e) {
                this._mouseDownOrTouchStartEvent(e)
            }
            touchStartEvent(e) {
                this._mouseOrTouchEnterEvent(e),
                this._mouseDownOrTouchStartEvent(e)
            }
            mouseDownOutsideEvent() {
                this._outsideMouseDownOrTouchStartEvent()
            }
            touchStartOutsideEvent() {
                this._outsideMouseDownOrTouchStartEvent()
            }
            pressedMouseMoveEvent(e) {
                this._pressedMouseOrTouchMoveEvent(e)
            }
            touchMoveEvent(e) {
                this._pressedMouseOrTouchMoveEvent(e)
            }
            mouseUpEvent(e) {
                this._mouseUpOrTouchEndEvent(e)
            }
            touchEndEvent(e) {
                this._mouseUpOrTouchEndEvent(e),
                this._mouseOrTouchLeaveEvent(e)
            }
            contextMenuEvent(e) {
                this._contextMenuOrTouchContextMenuEvent(e)
            }
            touchContextMenuEvent(e) {
                this._contextMenuOrTouchContextMenuEvent(e)
            }
            mouseEnterEvent(e) {
                this._mouseOrTouchEnterEvent(e)
            }
            mouseLeaveEvent(e) {
                this._mouseOrTouchLeaveEvent(e)
            }
            mouseDoubleClickEvent(e) {
                this._mouseDoubleClickOrDoubleTapEvent(e)
            }
            doubleTapEvent(e) {
                this._mouseDoubleClickOrDoubleTapEvent(e)
            }
            _outsideMouseDownOrTouchStartEvent() {
                this._zoomAvailable() && this._mousedown && (this._mousedown = !1,
                this.chart.model().endScaleTime(),
                this.restoreDefaultCursor())
            }
            _highlightBackground(e, t, i) {
                const s = this.chart.model().timeScale();
                let o = t[0].index
                  , n = t[0].index;
                for (let e = 1; e < t.length; e++)
                    o = Math.min(o, t[e].index),
                    n = Math.max(n, t[e].index);
                const {horizontalPixelRatio: r} = i
                  , a = Math.floor(s.indexToCoordinate(o) * r)
                  , l = Math.ceil(s.indexToCoordinate(n) * r);
                (0,
                Qe.fillRect)(e, a, 0, l - a, i.bitmapSize.height, this._properties.childs().axisHighlightColor.value())
            }
            _addViewsOrMaxMin(e, t) {
                if (e.length <= 1) {
                    for (const i of e)
                        if (i.timeAxisViews) {
                            const e = i.timeAxisViews();
                            e && e.length && t.push(e)
                        }
                } else
                    t.push(this._minMaxViews(e))
            }
            _minMaxViews(e) {
                const t = [];
                let i = 1 / 0
                  , s = -1 / 0
                  , o = null
                  , n = null;
                for (const t of e)
                    if (t.timeAxisViews) {
                        const e = t.timeAxisViews();
                        if (e && e.length)
                            for (let t = 0; t < e.length; ++t) {
                                const r = e[t]
                                  , a = r.coordinate();
                                a >= s && (s = a,
                                n = r),
                                a <= i && (i = a,
                                o = r)
                            }
                    }
                return n && t.push(n),
                o && t.push(o),
                t
            }
            _zoomAvailable() {
                return !this.chart.model().timeScale().isEmpty() && this.chart.model().model().zoomEnabled() && this._options.pressedMouseMoveScale
            }
            _mouseDownOrTouchStartEvent(e) {
                if (this._mousedown || !this._zoomAvailable())
                    return;
                this._mousedown = !0;
                const t = this.chart.model();
                t.timeScale().isEmpty() || t.startScaleTime(e.localX)
            }
            _pressedMouseOrTouchMoveEvent(e) {
                this._zoomAvailable() && this.chart.model().scaleTimeTo(e.localX)
            }
            _mouseUpOrTouchEndEvent(e) {
                this._zoomAvailable() && (this._mousedown = !1,
                this.chart.model().endScaleTime(),
                this.restoreDefaultCursor())
            }
            _contextMenuOrTouchContextMenuEvent(e) {
                this._options.contextMenuEnabled && Jt.ContextMenuManager.showMenu(this.getContextMenuActions(), e, {
                    statName: "TimeScaleContextMenu"
                }, {
                    menuName: "TimeScaleContextMenu"
                })
            }
            _mouseOrTouchEnterEvent(e) {
                this._zoomAvailable() && this.setCursor("ew-resize")
            }
            _mouseOrTouchLeaveEvent(e) {
                this.restoreDefaultCursor()
            }
            _mouseDoubleClickOrDoubleTapEvent(e) {
                (0,
                Ne.trackEvent)("GUI", "Double click time scale"),
                this.chart.model().resetTimeScale()
            }
            _areEventsEnabled() {
                var e;
                {
                    const t = this.chart.model().mainSeries();
                    switch (null === (e = t.symbolInfo()) || void 0 === e ? void 0 : e.type) {
                    case "forex":
                    case "cfd":
                        return !d.enabled("widget") && this.chart.model().model().properties().childs().chartEventsSourceProperties.childs().visible.value();
                    case "stock":
                    case "fund":
                        if (!d.enabled("widget") || d.enabled("esdonwidget")) {
                            const {esdShowDividends: e, esdShowSplits: i, esdShowEarnings: s} = t.properties().childs();
                            return e.value() || i.value() || s.value()
                        }
                        return !1;
                    default:
                        return !1
                    }
                }
            }
        }
        var Os = i(685459)
          , Vs = i.n(Os)
          , Ws = i(930203)
          , Fs = (i(545437),
        i(637761))
          , Hs = i(570701)
          , zs = i(378975);
        function Us(e, t) {
            return !!zs.Interval.isEqual(e.res, t.res) && (0,
            Hs.areEqualTimeFrames)(e.val, t.val)
        }
        var Gs = i(375727)
          , js = i(848891)
          , qs = i(898192)
          , Xs = i(939656)
          , Ks = i(615914);
        const Ys = new c.TranslatedString("toggle collapsed pane state",r.t(null, void 0, i(846054)));
        class Zs extends m.UndoCommand {
            constructor(e, t) {
                super(Ys),
                this._chartModel = e,
                this._paneIndex = t
            }
            redo() {
                this._chartModel.toggleCollapsedPane(this._paneIndex)
            }
            undo() {
                this._chartModel.toggleCollapsedPane(this._paneIndex)
            }
        }
        var $s = i(310681)
          , Js = i(152463);
        const Qs = new c.TranslatedString("move all scales to left",r.t(null, void 0, i(864077)))
          , eo = new c.TranslatedString("move all scales to right",r.t(null, void 0, i(519013)))
          , to = (0,
        n.getLogger)("Chart.MergeAllScales");
        class io extends m.UndoCommand {
            constructor(e, t, i, s, o, n) {
                super(n),
                this._model = e,
                this._paneIndex = e.panes().indexOf(t),
                this._targetPosition = s,
                this._targetIndex = o,
                this._scaleId = i.id(),
                this._sourcePosition = t.priceScalePosition(i),
                "overlay" !== this._sourcePosition && (this._sourceIndex = t.priceScaleIndex(i, this._sourcePosition))
            }
            redo() {
                const e = this._model.panes()[this._paneIndex]
                  , t = (0,
                s.ensureNotNull)(e.getPriceScaleById(this._scaleId));
                e.movePriceScale(t, this._targetPosition, this._targetIndex),
                this._model.fullUpdate()
            }
            undo() {
                const e = this._model.panes()[this._paneIndex]
                  , t = (0,
                s.ensureNotNull)(e.getPriceScaleById(this._scaleId));
                e.movePriceScale(t, this._sourcePosition, this._sourceIndex),
                this._model.fullUpdate()
            }
        }
        var so = i(469805);
        class oo extends m.UndoCommand {
            constructor(e, t, i, s) {
                super(s, void 0, !so.lineToolsDoNotAffectChartInvalidation),
                this._createdIds = [],
                this._model = e,
                this._withoutShift = i,
                this._origStates = t.map((e=>e.state(!0)));
                const o = e.lineToolsGroupModel();
                this._origGroups = t.map((e=>{
                    const t = o.groupForLineTool(e);
                    return t && t.id
                }
                ))
            }
            redo() {
                const e = this._model.lineToolsGroupModel()
                  , t = this._origStates.map(((t,i)=>{
                    const o = (0,
                    s.ensureNotNull)(this._model.dataSourceForId(t.id))
                      , n = 0 === this._createdIds.length ? void 0 : (0,
                    s.ensureDefined)(this._createdIds[i])
                      , r = (0,
                    ct.cloneLineTool)(this._model, o, !this._withoutShift, n);
                    void 0 !== t.sharingMode && r.share(t.sharingMode);
                    const a = (0,
                    s.ensureNotNull)(o.priceScale());
                    (0,
                    s.ensureNotNull)(this._model.paneForSource(o)).addDataSource(r, a, !1);
                    const l = this._origGroups[i];
                    if (null !== l) {
                        const t = e.groupForId(l);
                        t && t.addLineTools([r])
                    }
                    return this._model.updateSource(r),
                    r
                }
                ));
                0 === this._createdIds.length && (this._createdIds = t.map((e=>e.id()))),
                this._model.selectionMacro((e=>{
                    e.clearSelection(),
                    t.forEach((t=>{
                        e.addSourceToSelection(t)
                    }
                    ))
                }
                )),
                this._model.setShouldBeSavedEvenIfHidden(!0)
            }
            undo() {
                const e = this._model.lineToolsGroupModel();
                this._createdIds.forEach((t=>{
                    const i = (0,
                    s.ensureNotNull)(this._model.dataSourceForId(t))
                      , o = e.groupForLineTool(i);
                    null !== o && o.excludeLineTool(i),
                    this._model.removeSource(i)
                }
                ))
            }
            newIds() {
                return this._createdIds
            }
        }
        var no = i(661725)
          , ro = i(204425)
          , ao = i(375308);
        class lo extends m.UndoCommand {
            constructor(e, t, i, s=!0) {
                super(i, s, (0,
                ao.sourcesAffectState)(t)),
                this._newStates = [],
                this._model = e,
                this._savedStates = t.map((e=>e.state(!1)))
            }
            redo() {
                this._applyState(this._newStates)
            }
            undo() {
                0 === this._newStates.length && this.saveNewState(),
                this._applyState(this._savedStates)
            }
            saveNewState() {
                const e = this._savedStates.filter(Ue.notNull).map((e=>(0,
                s.ensureNotNull)(this._model.dataSourceForId(e.id))));
                this._newStates = e.map((e=>e.state(!1)))
            }
            _applyState(e) {
                for (const t of e)
                    if (null !== t) {
                        const e = this._model.dataSourceForId(t.id);
                        if (null !== e)
                            if ((0,
                            rt.isStudy)(e)) {
                                const i = t.state.inputs
                                  , s = e.properties().childs().inputs.childs();
                                for (const e in i)
                                    s[e] && s[e].setValue(i[e])
                            } else
                                this._model.restoreLineToolState(e, t, !0)
                    }
            }
        }
        var co = i(781178)
          , uo = i(479935)
          , ho = i(343272)
          , po = i(903424)
          , mo = i(121760)
          , go = i(889301);
        const _o = new c.TranslatedString("create {tool}",r.t(null, void 0, i(12898)));
        class vo extends mo.LineToolSynchronizeUndoCommand {
            constructor({model: e, pane: t, lineTool: i, ownerSource: s, drawOnAllChartsMode: o=0, id: n}) {
                super(e, _o.format({
                    tool: new c.TranslatedString(i,go.lineToolsLocalizedNames[i])
                }), !1, !so.lineToolsDoNotAffectChartInvalidation),
                this._lineId = null,
                this._lineState = null,
                this._paneIndex = e.panes().indexOf(t),
                this._lineTool = i,
                this._ownerSourceId = s.id(),
                this._lineId = null != n ? n : null,
                this._drawOnAllChartsMode = o
            }
            startCreatingLine(e, t, i, s, o) {
                var n;
                const r = this._chartModel.panes()[this._paneIndex]
                  , a = this._chartModel.dataSourceForId(this._ownerSourceId) || void 0
                  , l = this._chartModel.createLineTool({
                    pane: r,
                    point: e,
                    linetool: this._lineTool,
                    properties: t,
                    linkKey: i,
                    sharingMode: s,
                    ownerSource: a,
                    id: null !== (n = this._lineId) && void 0 !== n ? n : void 0,
                    fromExternalModel: o
                });
                return this._lineId = l.id(),
                this._fromExternalModel = o,
                !this._chartModel.lineBeingCreated()
            }
            continueCreatingLine(e, t, i, s) {
                const o = this._chartModel.continueCreatingLine(e, t, i, s, this._fromExternalModel);
                return o && this._chartModel.setShouldBeSavedEvenIfHidden(!0),
                o
            }
            line() {
                return null === this._lineId ? null : this._chartModel.dataSourceForId(this._lineId)
            }
            drawOnAllCharts() {
                return 0 !== this._drawOnAllChartsMode
            }
            _redo() {
                if (null === this._lineState)
                    return;
                const e = this._chartModel.restoreSource(!1, this._paneIndex, null, (0,
                s.ensureNotNull)(this._lineState), null);
                null !== e && (this._lineId = e.id(),
                this._lineState = null,
                e.share(this._drawOnAllChartsMode))
            }
            _undo() {
                const e = this.line();
                null !== e && (this._lineState = e.state(!1),
                this._chartModel.removeSource(e),
                this._lineId = null)
            }
        }
        var So = i(287741);
        const fo = new c.TranslatedString("bring {title} to front",r.t(null, void 0, i(453159)))
          , bo = new c.TranslatedString("send {title} to back",r.t(null, void 0, i(105005)))
          , yo = new c.TranslatedString("insert {title} after {targetTitle}",r.t(null, void 0, i(956307)))
          , Co = new c.TranslatedString("insert {title} before {targetTitle}",r.t(null, void 0, i(946229)))
          , wo = new c.TranslatedString("send {title} backward",r.t(null, void 0, i(540962)))
          , To = new c.TranslatedString("bring {title} forward",r.t(null, void 0, i(941966)))
          , Po = new c.TranslatedString("send group {title} backward",r.t(null, void 0, i(969546)))
          , xo = new c.TranslatedString("bring group {title} forward",r.t(null, void 0, i(601979)));
        function Mo(e) {
            return new c.TranslatedString(e.name(),e.title(So.TitleDisplayTarget.StatusLine))
        }
        class Io extends m.UndoCommand {
            constructor(e, t, i) {
                super(i, void 0, (0,
                ao.sourcesAffectState)(t)),
                this._sourcesByPanes = new Map,
                this._originalState = new Map,
                this._model = e,
                t.forEach((t=>{
                    const i = (0,
                    s.ensureNotNull)(e.paneForSource(t))
                      , o = e.panes().indexOf(i)
                      , n = this._sourcesByPanes.get(o) || [];
                    n.push(t.id()),
                    this._sourcesByPanes.set(o, n)
                }
                )),
                Array.from(this._sourcesByPanes.keys()).forEach((t=>{
                    const i = e.panes()[t]
                      , s = new Map
                      , o = new Set(i.sourcesByGroup().multipaneSources());
                    i.sourcesByGroup().allIncludingHidden().filter((e=>!o.has(e))).forEach((e=>{
                        s.set(e.id(), e.zorder())
                    }
                    )),
                    this._originalState.set(t, s)
                }
                ))
            }
            undo() {
                this._originalState.forEach(((e,t)=>{
                    const i = this._model.panes()[t]
                      , o = new Map;
                    e.forEach(((e,t)=>{
                        const n = (0,
                        s.ensureNotNull)(i.dataSourceForId(t));
                        o.set(n, e)
                    }
                    )),
                    i.setZOrders(o)
                }
                ))
            }
            redo() {
                this._sourcesByPanes.forEach(((e,t)=>{
                    const i = this._model.panes()[t]
                      , o = e.map((e=>(0,
                    s.ensureNotNull)(i.dataSourceForId(e))));
                    this._paneOperation(i, o)
                }
                ))
            }
        }
        class Ao extends Io {
            constructor(e, t) {
                super(e, t, fo.format({
                    title: Mo(t[0])
                }))
            }
            _paneOperation(e, t) {
                e.bringToFront(t)
            }
        }
        class Lo extends Io {
            constructor(e, t) {
                super(e, t, bo.format({
                    title: Mo(t[0])
                }))
            }
            _paneOperation(e, t) {
                e.sendToBack(t)
            }
        }
        class Eo extends Io {
            constructor(e, t, i, s) {
                super(e, t, s),
                this._targetSource = i
            }
            _paneOperation(e, t) {
                e.insertAfter(t, this._targetSource)
            }
        }
        class ko extends Eo {
            constructor(e, t, i) {
                super(e, t, i, yo.format({
                    title: Mo(t[0]),
                    targetTitle: Mo(i)
                }))
            }
        }
        class Do extends Io {
            constructor(e, t, i, s) {
                super(e, t, s),
                this._targetSource = i
            }
            _paneOperation(e, t) {
                e.insertBefore(t, this._targetSource)
            }
        }
        class No extends Do {
            constructor(e, t, i) {
                super(e, t, i, Co.format({
                    title: Mo(t[0]),
                    targetTitle: Mo(i)
                }))
            }
        }
        function Bo(e, t) {
            const i = t[0]
              , s = e.sourcesByGroup().all().filter((e=>e.zorder() < i.zorder()));
            if (0 === s.length)
                throw new Error("Cannot move backward source that alreadt on back");
            let o = s[s.length - 1];
            if ((0,
            ct.isLineTool)(o)) {
                const t = e.model().lineToolsGroupModel().groupForLineTool(o);
                null !== t && (o = t.lineTools()[0])
            }
            return o
        }
        class Ro extends Do {
            constructor(e, t, i) {
                super(e, i, Bo(t, i), wo.format({
                    title: Mo(i[0])
                }))
            }
        }
        function Oo(e, t) {
            const i = t[t.length - 1]
              , s = e.sourcesByGroup().allExceptSpecialSources().filter((e=>e.zorder() > i.zorder()));
            if (0 === s.length)
                throw new Error("Cannot bring forward source that alreadt on back");
            let o = s[0];
            if ((0,
            ct.isLineTool)(o)) {
                const t = e.model().lineToolsGroupModel().groupForLineTool(o);
                if (null !== t) {
                    const e = t.lineTools();
                    o = e[e.length - 1]
                }
            }
            return o
        }
        class Vo extends Eo {
            constructor(e, t, i) {
                super(e, i, Oo(t, i), To.format({
                    title: Mo(i[0])
                }))
            }
        }
        function Wo(e, t) {
            return (0,
            s.ensureNotNull)(e.paneForSource(t.lineTools()[0]))
        }
        class Fo extends Do {
            constructor(e, t) {
                super(e, t.lineTools(), Bo(Wo(e, t), t.lineTools()), Po.format({
                    title: t.name().value()
                }))
            }
        }
        class Ho extends Eo {
            constructor(e, t) {
                super(e, t.lineTools(), Oo(Wo(e, t), t.lineTools()), xo.format({
                    title: t.name().value()
                }))
            }
        }
        const zo = new c.TranslatedString("rearrange panes",r.t(null, void 0, i(202618)));
        class Uo extends m.UndoCommand {
            constructor(e, t, i) {
                super(zo),
                this._chartModel = e,
                this._index = t,
                (0,
                Ue.isNumber)(i) ? this._dstIndex = i : this._dstIndex = "up" === i ? t - 1 : t + 1
            }
            redo() {
                this._checkIndices() && this._chartModel.movePane(this._index, this._dstIndex)
            }
            undo() {
                this._checkIndices() && this._chartModel.movePane(this._dstIndex, this._index)
            }
            _checkIndices() {
                const e = this._chartModel.panes().length;
                return this._index >= 0 && this._index < e && this._dstIndex >= 0 && this._dstIndex < e
            }
        }
        var Go = i(262624)
          , jo = i(583912);
        function qo(e) {
            var t, i;
            return {
                val: e.value(),
                dependenValues: null !== (i = null === (t = e.dependents) || void 0 === t ? void 0 : t.call(e).map(qo)) && void 0 !== i ? i : []
            }
        }
        function Xo(e) {
            var t, i;
            return (null !== (i = null === (t = e.dependents) || void 0 === t ? void 0 : t.call(e)) && void 0 !== i ? i : []).map(qo)
        }
        function Ko(e, t) {
            var i, s;
            (null !== (s = null === (i = e.dependents) || void 0 === i ? void 0 : i.call(e)) && void 0 !== s ? s : []).forEach(((e,i)=>{
                var s, o;
                e.setValue(t[i].val),
                (null !== (o = null === (s = e.dependents) || void 0 === s ? void 0 : s.call(e)) && void 0 !== o ? o : []).forEach((e=>Ko(e, t[i].dependenValues)))
            }
            ))
        }
        class Yo extends m.UndoCommand {
            constructor(e, t, i, s, o=!0) {
                super(i, void 0, o),
                this._targetObj = e,
                this._newValue = t,
                this._oldValue = this._targetObj.value(),
                this._dependentValues = Xo(this._targetObj),
                this._model = s
            }
            redo() {
                (0,
                Go.allowSavingDefaults)(!0),
                this._targetObj.setValue(this._newValue),
                (0,
                Go.allowSavingDefaults)(!1),
                this._model.recalculateAllPanes((0,
                as.globalChangeEvent)()),
                this._model.lightUpdate()
            }
            undo() {
                (0,
                Go.allowSavingDefaults)(!0),
                this._targetObj.setValue(this._oldValue),
                Ko(this._targetObj, this._dependentValues),
                (0,
                Go.allowSavingDefaults)(!1),
                this._model.recalculateAllPanes((0,
                as.globalChangeEvent)()),
                this._model.lightUpdate()
            }
        }
        class Zo extends m.UndoCommand {
            constructor(e, t, i, s, o, n) {
                super(s),
                this._prevPriceAxisProps = {},
                this._dependentValues = [],
                this._property = e,
                this._mainSeries = i,
                this._value = t,
                this._model = o,
                this._chartWidget = n
            }
            redo() {
                const e = this._mainSeries
                  , t = e.properties().childs();
                this._dependentValues = Xo(this._property),
                this._prevResolution = t.interval.value(),
                this._prevValue = this._property.value(),
                this._storePriceAxisProps(),
                (0,
                Go.allowSavingDefaults)(!0);
                const i = t.interval.value()
                  , s = this._model.defaultResolutions()
                  , o = (0,
                rs.getResolutionByChartStyle)(this._value, i, s);
                jo.linking.interval.setValue(o),
                e.setChartStyleWithIntervalIfNeeded(this._value, o),
                (0,
                ye.setLastUsedStyle)(this._value, e.symbolInfo()),
                (0,
                ye.preparePriceAxisProperties)(t),
                (0,
                Go.allowSavingDefaults)(!1),
                this._invalidateModel(),
                this._chartWidget.screen.show(!0)
            }
            undo() {
                const e = this._mainSeries;
                (0,
                Go.allowSavingDefaults)(!0),
                e.setChartStyleWithIntervalIfNeeded(this._prevValue, this._prevResolution),
                this._restorePriceAxisProps(),
                jo.linking.interval.setValue(this._prevResolution),
                Ko(this._property, this._dependentValues),
                (0,
                Go.allowSavingDefaults)(!1),
                this._invalidateModel(),
                this._chartWidget.screen.show(!0)
            }
            _storePriceAxisProps() {
                const e = this._mainSeries.priceScale();
                this._prevPriceAxisProps = e.mode()
            }
            _restorePriceAxisProps() {
                this._mainSeries.priceScale().setMode(this._prevPriceAxisProps)
            }
            _invalidateModel() {
                this._model && (this._model.recalculateAllPanes((0,
                as.sourceChangeEvent)(this._model.mainSeries().id())),
                this._model.lightUpdate())
            }
        }
        const $o = new c.TranslatedString("change date range",r.t(null, void 0, i(316979)));
        class Jo extends m.UndoCommand {
            constructor(e, t) {
                super($o),
                this._modelsData = [],
                this._rangeOptions = t,
                this._modelsData.push({
                    model: e,
                    prevResolution: e.mainSeries().properties().childs().interval.value(),
                    barSpacing: e.timeScale().barSpacing(),
                    rightOffset: e.timeScale().rightOffset(),
                    rangeOptions: e.appliedTimeFrame().value()
                })
            }
            redo() {
                for (const e of this._modelsData) {
                    const t = e.model.mainSeries()
                      , i = t.properties().childs().interval;
                    zs.Interval.isEqual(this._rangeOptions.res, i.value()) ? t.loadDataTo(this._rangeOptions.val) : (t.setDefaultTimeframe(this._rangeOptions.val),
                    t.setSymbolParams({
                        interval: this._rangeOptions.res
                    }))
                }
            }
            undo() {
                for (const e of this._modelsData) {
                    const t = e.model.mainSeries()
                      , i = t.properties().childs().interval;
                    e.prevResolution !== i.value() ? (null !== e.rangeOptions && t.setDefaultTimeframe(e.rangeOptions.val),
                    t.setSymbolParams({
                        interval: e.prevResolution
                    })) : null !== e.rangeOptions && t.loadDataTo(e.rangeOptions.val);
                    const s = e.model.timeScale();
                    s.setBarSpacing(e.barSpacing),
                    s.setRightOffset(e.rightOffset)
                }
            }
            canMerge(e) {
                return e instanceof Jo && Us(e._rangeOptions, this._rangeOptions)
            }
            merge(e) {
                if (!(e instanceof Jo))
                    throw new Error("Invalid command to merge");
                this._modelsData = this._modelsData.concat(e._modelsData)
            }
        }
        var Qo = i(684634);
        i(466281);
        class en extends m.UndoCommand {
            constructor(e, t, i) {
                super(i, void 0, !so.lineToolsDoNotAffectChartInvalidation),
                this._model = e,
                this._groupId = t.id,
                this._groupName = t.name().value(),
                this._lineToolsIds = t.lineTools().map((e=>e.id()))
            }
            redo() {
                const e = (0,
                s.ensureNotNull)(this._model.lineToolsGroupModel().groupForId(this._groupId));
                this._model.lineToolsGroupModel().removeGroup(e)
            }
            undo() {
                const e = this._lineToolsIds.map((e=>this._model.dataSourceForId(e)))
                  , t = new Qo.LineToolsGroup(e,this._groupName,this._groupId);
                this._model.lineToolsGroupModel().addGroup(t)
            }
        }
        const tn = new c.TranslatedString("create line tools group",r.t(null, void 0, i(746219)));
        class sn extends m.UndoCommand {
            constructor(e, t) {
                super(tn, void 0, !so.lineToolsDoNotAffectChartInvalidation),
                this._groupId = null,
                this._model = e,
                this._sourcesIds = t.map((e=>e.id()))
            }
            redo() {
                const e = this._sourcesIds.map((e=>this._model.dataSourceForId(e)))
                  , t = null === this._groupId ? void 0 : this._groupId;
                this._groupId = this._model.lineToolsGroupModel().createGroup(e, this._title, t).id
            }
            undo() {
                const e = (0,
                s.ensureNotNull)(this._model.lineToolsGroupModel().groupForId((0,
                s.ensureNotNull)(this._groupId)));
                this._model.lineToolsGroupModel().removeGroup(e)
            }
            createdGroupId() {
                return this._groupId
            }
        }
        const on = new c.TranslatedString("add line tool(s) to group {group}",r.t(null, void 0, i(21162)));
        class nn extends m.UndoCommand {
            constructor(e, t, i) {
                super(on.format({
                    group: t.name().value()
                }), void 0, !so.lineToolsDoNotAffectChartInvalidation),
                this._model = e,
                this._groupId = t.id,
                this._lineToolsIds = i.map((e=>e.id()))
            }
            redo() {
                const e = (0,
                s.ensureNotNull)(this._model.lineToolsGroupModel().groupForId(this._groupId))
                  , t = this._lineToolsIds.map((e=>this._model.dataSourceForId(e)));
                e.addLineTools(t)
            }
            undo() {
                const e = this._lineToolsIds.map((e=>this._model.dataSourceForId(e)));
                (0,
                s.ensureNotNull)(this._model.lineToolsGroupModel().groupForId(this._groupId)).excludeLineTools(e)
            }
        }
        class rn extends m.UndoCommand {
            constructor(e, t, i, s) {
                super(s, void 0, !so.lineToolsDoNotAffectChartInvalidation),
                this._chartModel = e,
                this._groupId = t.id,
                this._oldName = t.name().value(),
                this._newName = i
            }
            redo() {
                (0,
                s.ensureNotNull)(this._chartModel.lineToolsGroupModel().groupForId(this._groupId)).setName(this._newName)
            }
            undo() {
                (0,
                s.ensureNotNull)(this._chartModel.lineToolsGroupModel().groupForId(this._groupId)).setName(this._oldName)
            }
        }
        class an extends m.UndoCommand {
            constructor(e, t, i, s) {
                super(s, void 0, !so.lineToolsDoNotAffectChartInvalidation),
                this._model = i,
                this._id = e.id(),
                this._targetSharingMode = t,
                this._originSharingMode = e.sharingMode().value()
            }
            redo() {
                const e = this._model.dataSourceForId(this._id);
                e && (e.share(this._targetSharingMode),
                0 !== this._targetSharingMode && 0 === this._originSharingMode && (e.linkKey().setValue((0,
                Pe.randomHash)()),
                this._model.copyToOtherCharts([e], !1)))
            }
            undo() {
                const e = this._model.dataSourceForId(this._id);
                e && (e.share(this._originSharingMode),
                0 === this._originSharingMode && ((0,
                qt.removeLineTool)({
                    withUndo: !1,
                    model: this._model,
                    symbol: e.symbol(),
                    linkKey: (0,
                    s.ensureNotNull)(e.linkKey().value()),
                    sourceTitle: (0,
                    po.getTranslatedStringForSource)(So.TitleDisplayTarget.StatusLine, e),
                    lineToolState: e.state(!1),
                    unlink: !0
                }),
                e.linkKey().setValue(null)))
            }
        }
        const ln = new c.TranslatedString("create line tools group from selection",r.t(null, void 0, i(695394)))
          , cn = new c.TranslatedString("removing line tools group {name}",r.t(null, void 0, i(241430)))
          , dn = new c.TranslatedString("add line tool {lineTool} to group {name}",r.t(null, void 0, i(612570)))
          , un = new c.TranslatedString("make group {group} visible",r.t(null, void 0, i(645987)))
          , hn = new c.TranslatedString("make group {group} invisible",r.t(null, void 0, i(576709)))
          , pn = new c.TranslatedString("lock group {group}",r.t(null, void 0, i(720453)))
          , mn = new c.TranslatedString("unlock group {group}",r.t(null, void 0, i(974590)))
          , gn = new c.TranslatedString("rename group {group} to {newName}",r.t(null, void 0, i(80491)));
        class _n {
            constructor(e) {
                this._environment = e
            }
            createGroupFromSelection() {
                const e = this._environment.model();
                (0,
                s.assert)(!e.selection().isEmpty(), "Cannot create group from empty selection");
                const t = (0,
                ho.sortSources)(e.selection().lineDataSources());
                (0,
                s.assert)(t.length === e.selection().allSources().length, "A group could contain line tools only");
                const i = t.length > 1 || null !== this._environment.model().lineToolsGroupModel().groupForLineTool(t[0])
                  , o = t.reduce(((e,t)=>e.zorder() > t.zorder() ? e : t), t[0]);
                let n = o;
                const r = e.lineToolsGroupModel().groupForLineTool(o);
                if (null !== r) {
                    const e = r.lineTools();
                    n = e[e.length - 1]
                }
                this._environment.beginUndoMacro(ln);
                const a = new Map
                  , l = new Set;
                t.forEach((t=>{
                    const i = this._groupForLineTool(t);
                    if (null === i)
                        return;
                    const o = a.get(i) || [];
                    o.push(t),
                    a.set(i, o);
                    const n = (0,
                    s.ensureNotNull)(e.paneForSource(t));
                    l.add(n)
                }
                )),
                (0,
                s.assert)(l.size <= 1, "All selected sources should be on the same pane"),
                a.forEach(((t,i)=>{
                    const s = new ro.ExcludeLineToolsFromGroupUndoCommand(e,i,t);
                    this._environment.pushUndoCommand(s)
                }
                ));
                const c = new sn(e,(0,
                ho.sortSources)(t));
                if (this._environment.pushUndoCommand(c),
                i) {
                    const i = new ko(e,t,n);
                    this._environment.pushUndoCommand(i)
                }
                this._environment.endUndoMacro();
                const d = (0,
                s.ensureNotNull)(c.createdGroupId());
                return (0,
                s.ensureNotNull)(e.lineToolsGroupModel().groupForId(d))
            }
            removeGroup(e) {
                const t = this._environment.model()
                  , i = e.lineTools();
                this._environment.beginUndoMacro(cn.format({
                    name: e.name().value()
                }));
                const o = new en(t,e,null);
                this._environment.pushUndoCommand(o);
                const n = new no.RemoveSourcesUndoCommand(t,i,null);
                this._environment.pushUndoCommand(n);
                const r = t.mainSeries().symbol();
                i.forEach((e=>{
                    null !== e.linkKey().value() && (0,
                    qt.removeLineTool)({
                        withUndo: !0,
                        model: t,
                        symbol: r,
                        sourceTitle: new c.TranslatedString(e.name(),e.title(So.TitleDisplayTarget.DataWindow)),
                        lineToolState: e.state(!1),
                        linkKey: (0,
                        s.ensureNotNull)(e.linkKey().value())
                    })
                }
                )),
                this._environment.endUndoMacro()
            }
            groups() {
                return this._environment.model().lineToolsGroupModel().groups()
            }
            excludeLineToolFromGroup(e, t) {
                const i = this._environment.model()
                  , s = new ro.ExcludeLineToolsFromGroupUndoCommand(i,e,[t]);
                this._environment.pushUndoCommand(s)
            }
            addLineToolToGroup(e, t) {
                const i = this._environment.model()
                  , s = i.lineToolsGroupModel().groupForLineTool(t);
                if (s === e)
                    return;
                const o = dn.format({
                    lineTool: new c.TranslatedString(t.name(),t.title(So.TitleDisplayTarget.StatusLine)),
                    name: e.name().value()
                });
                this._environment.beginUndoMacro(o),
                null !== s && this._environment.pushUndoCommand(new ro.ExcludeLineToolsFromGroupUndoCommand(i,s,[t]));
                {
                    const s = e.sharingMode().value();
                    t.sharingMode().value() !== s && this._environment.pushUndoCommand(new an(t,s,i,null))
                }
                this._environment.pushUndoCommand(new nn(i,e,[t])),
                this._environment.endUndoMacro()
            }
            bringToFront(e) {
                const t = this._environment.model()
                  , i = new Ao(t,e.lineTools());
                this._environment.pushUndoCommand(i),
                this._environment.emitEvent("changeZOrder", [e.lineTools()])
            }
            sendToBack(e) {
                const t = this._environment.model()
                  , i = new Lo(t,e.lineTools());
                this._environment.pushUndoCommand(i),
                this._environment.emitEvent("changeZOrder", [e.lineTools()])
            }
            bringForward(e) {
                const t = this._environment.model()
                  , i = new Ho(t,e);
                this._environment.pushUndoCommand(i),
                this._environment.emitEvent("changeZOrder", [e.lineTools()])
            }
            sendBackward(e) {
                const t = this._environment.model()
                  , i = new Fo(t,e);
                this._environment.pushUndoCommand(i),
                this._environment.emitEvent("changeZOrder", [e.lineTools()])
            }
            insertAfter(e, t) {
                const i = this._environment.model();
                let s;
                if (t instanceof Qo.LineToolsGroup) {
                    const e = t.lineTools();
                    s = e[e.length - 1]
                } else
                    s = t;
                const o = new ko(i,e.lineTools(),s);
                this._environment.pushUndoCommand(o),
                this._environment.emitEvent("changeZOrder", [e.lineTools()])
            }
            insertBefore(e, t) {
                const i = this._environment.model();
                let s;
                if (t instanceof Qo.LineToolsGroup) {
                    s = t.lineTools()[0]
                } else
                    s = t;
                const o = new No(i,e.lineTools(),s);
                this._environment.pushUndoCommand(o),
                this._environment.emitEvent("changeZOrder", [e.lineTools()])
            }
            availableZOrderOperations(e) {
                const t = this._environment.model()
                  , i = e.lineTools()
                  , o = i[0]
                  , n = i[i.length - 1]
                  , r = (0,
                s.ensureNotNull)(t.paneForSource(i[0])).sourcesByGroup().allExceptSpecialSources()
                  , a = r[0]
                  , l = r[r.length - 1];
                return {
                    bringForwardEnabled: n !== l,
                    bringToFrontEnabled: n !== l,
                    sendBackwardEnabled: o !== a,
                    sendToBackEnabled: o !== a
                }
            }
            setGroupVisibility(e, t) {
                const i = (t ? un : hn).format({
                    group: e.name().value()
                })
                  , s = this._environment.model();
                this._environment.beginUndoMacro(i),
                e.lineTools().forEach((e=>{
                    const i = e.properties().visible
                      , o = new Yo(i,t,null,s,!so.lineToolsDoNotAffectChartInvalidation);
                    this._environment.pushUndoCommand(o)
                }
                )),
                this._environment.endUndoMacro()
            }
            setGroupLock(e, t) {
                const i = (t ? pn : mn).format({
                    group: e.name().value()
                })
                  , s = this._environment.model();
                this._environment.beginUndoMacro(i),
                e.lineTools().forEach((e=>{
                    const i = e.properties().frozen
                      , o = new Yo(i,t,null,s,!so.lineToolsDoNotAffectChartInvalidation);
                    this._environment.pushUndoCommand(o)
                }
                )),
                this._environment.endUndoMacro()
            }
            setGroupName(e, t) {
                const i = this._environment.model()
                  , s = gn.format({
                    group: e.name().value(),
                    newName: t
                })
                  , o = new rn(i,e,t,s);
                this._environment.pushUndoCommand(o)
            }
            canBeGroupped(e) {
                const t = this._environment.model();
                return new Set(e.map((e=>t.paneForSource(e)))).size <= 1
            }
            _groupForLineTool(e) {
                return this._environment.model().lineToolsGroupModel().groups().find((t=>t.containsLineTool(e))) || null
            }
        }
        var vn = i(998034)
          , Sn = i(632911)
          , fn = i(198930)
          , bn = i(691246);
        const yn = new c.TranslatedString("apply study template {template}",r.t(null, void 0, i(69604)));
        function Cn(e) {
            for (const t of e.panes)
                for (const e of t.sources)
                    if ((0,
                    fn.isMainSeriesState)(e))
                        return e.id;
            return null
        }
        class wn extends m.UndoCommand {
            constructor(e, t, i) {
                var o, n;
                super(yn.format({
                    template: i
                })),
                this._newSymbolParams = {},
                this._model = e,
                this._templateContent = function(e, t) {
                    const i = (0,
                    vn.default)({}, e)
                      , o = (0,
                    s.ensureNotNull)(Cn(i));
                    for (const e of i.panes) {
                        e.mainSourceId === o && (e.mainSourceId = t);
                        for (const i of e.sources)
                            if (i.id === o) {
                                i.id = t;
                                const s = e=>{
                                    const i = e.indexOf(o);
                                    -1 !== i && e.splice(i, 1, t)
                                }
                                ;
                                if (e.leftAxisesState && e.rightAxisesState ? (e.leftAxisesState.forEach((e=>s(e.sources))),
                                e.rightAxisesState.forEach((e=>s(e.sources)))) : (s(e.leftAxisSources),
                                s(e.rightAxisSources)),
                                e.overlayPriceScales) {
                                    const i = e.overlayPriceScales[o];
                                    i && (delete e.overlayPriceScales[o],
                                    e.overlayPriceScales[t] = i)
                                }
                            } else
                                i.ownerSource === o && (i.ownerSource = t)
                    }
                    return i
                }(t, e.mainSeries().id()),
                this._initialState = e.studyTemplate(!0, !0, !0);
                const r = e.mainSeries();
                t.symbol && (this._newSymbolParams = {
                    symbol: t.symbol,
                    currency: null !== (o = t.currency) && void 0 !== o ? o : null,
                    unit: null !== (n = t.unit) && void 0 !== n ? n : null
                }),
                t.interval && (this._newSymbolParams.interval = t.interval,
                this._newSymbolParams.style = (0,
                ye.getChartStyleByResolution)(t.interval, r.style())),
                this._initialSymbolParams = {
                    symbol: r.symbol(),
                    currency: r.currency(),
                    unit: r.unit(),
                    interval: r.interval(),
                    style: r.style()
                },
                this._initialState = e.studyTemplate(),
                this._initialGroupsState = e.lineToolsGroupModel().state()
            }
            redo() {
                this._model.mainSeries().setSymbolParams(this._newSymbolParams);
                const e = this._merge(this._templateContent).filter(ct.isLineTool);
                this._model.lineToolsGroupModel().removeLineTools(e);
                const t = this._model.mainSeries().properties();
                (0,
                ye.preparePriceAxisProperties)(t),
                this._model.recalcVisibleRangeStudies(Ut.RecalcVisibleRangeStudiesReason.StudyCreation),
                this._model.setShouldBeSavedEvenIfHidden(!0)
            }
            undo() {
                this._model.mainSeries().setSymbolParams(this._initialSymbolParams),
                this._merge(this._initialState)
            }
            _merge(e) {
                const t = e.version || 0
                  , i = this._model
                  , o = i.mainSeries();
                (0,
                s.assert)(o.id() === Cn(e)),
                o.priceScale().properties().childs().lockScale.setValue(!1);
                const n = i.panes()
                  , r = [];
                for (let e = n.length; e--; ) {
                    const t = n[e]
                      , i = t.containsMainSeries()
                      , s = t.dataSources();
                    for (let e = s.length; e--; ) {
                        const t = s[e];
                        (!i || ((0,
                        rt.isStudy)(t) || (0,
                        rt.isStudyStub)(t)) && t.isRemovedByStudyTemplates()) && r.push(t)
                    }
                }
                i.resetDeferredStudies();
                const a = (0,
                Sn.closeSourcesSet)(i, r);
                for (let e = 0; e < a.length; ++e)
                    i.removeSource(a[e]);
                const l = e.panes;
                for (let e = 0; e < l.length; e++) {
                    let o = -1;
                    const r = (0,
                    Ue.clone)(l[e]);
                    r.sources.sort(((e,t)=>e.zorder - t.zorder));
                    for (let e = 0; e < r.sources.length; e++) {
                        const t = r.sources[e];
                        if ((0,
                        fn.isMainSeriesState)(t)) {
                            delete t.state,
                            o = e;
                            break
                        }
                    }
                    const a = o > -1
                      , c = a ? n[e] : i.createPane(e);
                    if (a && t < 3 && (0,
                    bn.reorderDataSourcesStateZOrder)(r.sources),
                    c.restoreState({
                        state: r,
                        withData: !1,
                        version: t
                    }),
                    null !== c.mainDataSource()) {
                        const e = (0,
                        s.ensureNotNull)(this._model.alertsWatcher());
                        for (const t of c.dataSources())
                            e.syncSourceAlertLabels(t)
                    } else
                        i.removePane(c)
                }
                return i.syncLollipopSources(),
                o.priceScale().setMode({
                    autoScale: !0
                }),
                i.startNotStartedStudies(),
                i.recalculateAllPanes((0,
                as.globalChangeEvent)()),
                i.fullUpdate(),
                a
            }
        }
        var Tn = i(487945);
        const Pn = (0,
        n.getLogger)("Chart.ChartUndoModel")
          , xn = new c.TranslatedString("paste drawing",r.t(null, void 0, i(862192)));
        class Mn extends m.UndoCommand {
            constructor(e, t, i, o, n) {
                super(xn, void 0, !so.lineToolsDoNotAffectChartInvalidation),
                this._needCopyToOtherCharts = !1,
                this._sourceState = null,
                this._model = e,
                this._clipboardData = t,
                this._paneIndex = this._model.panes().indexOf(i || (0,
                s.ensureNotNull)(this._model.paneForSource(this._model.mainSeries()))),
                this._pasteWithData = !!o,
                this._keepZIndex = !!n
            }
            redo() {
                const e = this._model.panes()[this._paneIndex]
                  , t = (0,
                s.ensureNotNull)(e.clipboardLineToolOwnerSource(this._clipboardData.source.id))
                  , i = t === this._model.mainSeries();
                null === this._sourceState && (this._sourceState = this._getSourceState(t, i));
                const o = (0,
                s.ensureNotNull)(e.restoreLineTool(this._sourceState, this._pasteWithData, this._keepZIndex, void 0, t));
                (0,
                s.ensureNotNull)(t.priceScale()).addDataSource(o),
                this._clipboardData.centeredOnChart && o.centerPosition && o.centerPosition(),
                o.restoreFixedPoint(),
                o.createServerPoints(),
                this._needCopyToOtherCharts = Boolean(i && o.isSynchronizable() && 0 !== o.sharingMode().value()),
                this._model.setShouldBeSavedEvenIfHidden(!0)
            }
            undo() {
                if (!this._sourceState)
                    return void Pn.logError("This command was never executed - nothing to undo");
                const e = this.source();
                this._clipboardData.centeredOnChart && (this._clipboardData.centeredOnChart = !1,
                this._sourceState.points = e.normalizedPoints()),
                this._model.removeSource(e)
            }
            source() {
                return (0,
                s.ensureNotNull)(this._model.dataSourceForId((0,
                s.ensureNotNull)(this._sourceState).id))
            }
            needCopyToOtherCharts() {
                return this._needCopyToOtherCharts
            }
            _getSourceState(e, t) {
                const i = (0,
                Ue.clone)(this._clipboardData.source);
                delete i.state.symbol,
                t ? (null != i.linkKey || void 0 !== i.sharingMode && 0 !== i.sharingMode) && (i.linkKey = (0,
                Pe.randomHash)()) : (i.linkKey = null,
                i.sharingMode = 0);
                const n = (0,
                s.ensureNotNull)(e.priceScale())
                  , r = this._model
                  , {symbol: a, currencyId: l, unitId: c} = this._clipboardData.source.state
                  , d = (0,
                s.ensureNotNull)(e.symbolSource());
                let u = !1;
                !d.symbolSameAsCurrent(a) || (null !== l ? l !== (0,
                ye.symbolCurrency)(d.symbolInfo(), void 0, !0) : d.isConvertedToOtherCurrency()) || (null !== c ? c !== (0,
                ye.symbolUnit)(d.symbolInfo(), this._model.unitConversionEnabled()) : d.isConvertedToOtherUnit()) || ((0,
                Tn.isActingAsSymbolSource)(e) ? u = !0 : (0,
                rt.isStudy)(e) && (u = Boolean(e.metaInfo().is_price_study))),
                i.state.currencyId = r.currencyConversionEnabled() && d.isConvertedToOtherCurrency() ? d.currency() : null,
                i.state.unitId = r.unitConversionEnabled() && d.isConvertedToOtherUnit() ? d.unit() : null;
                const h = e=>{
                    const t = e.x * r.timeScale().width()
                      , i = e.y * n.height() - 40;
                    return new o.Point(t,i)
                }
                  , p = (0,
                s.ensureNotNull)(e.firstValue());
                if (this._model.id() === this._clipboardData.modelId || !u) {
                    for (let e = 0; e < this._clipboardData.geometry.length; ++e) {
                        const t = h(this._clipboardData.geometry[e])
                          , s = r.timeScale().coordinateToIndex(t.x)
                          , o = r.timeScale().normalizeBarIndex(s);
                        if (u) {
                            const t = n.priceToCoordinate(i.points[e].price, p) + -40;
                            o.price = n.coordinateToPrice(t, p)
                        } else
                            o.price = n.coordinateToPrice(t.y, p);
                        i.points[e] = o
                    }
                    i.state.interval = r.mainSeries().interval()
                }
                return i.id = (0,
                Pe.randomHashN)(6),
                i
            }
        }
        var In = i(344409)
          , An = i(473936)
          , Ln = i(995625);
        class En extends m.UndoCommand {
            constructor(e, t, i, s) {
                super(e),
                this._charts = new Map,
                this._firstRedo = !0,
                this._creationTime = performance.now(),
                this._linkingGroupIndex = s.linkingGroupIndex().value(),
                this._charts.set(s, {
                    sourceId: t.id(),
                    newSymbolParams: i,
                    prevSymbolParams: t.symbolParams(),
                    showFade: this._showFade(t, s),
                    chartWidget: s
                })
            }
            redo() {
                this._firstRedo || (0,
                a.muteLinkingGroup)(this._linkingGroupIndex, !0),
                this._charts.forEach((e=>{
                    this._symbolSource(e).setSymbolParams(e.newSymbolParams),
                    e.showFade && e.chartWidget.screen.show(!0)
                }
                )),
                this._firstRedo || (0,
                a.muteLinkingGroup)(this._linkingGroupIndex, !1),
                this._firstRedo = !1
            }
            undo() {
                (0,
                a.muteLinkingGroup)(this._linkingGroupIndex, !0),
                this._charts.forEach((e=>{
                    this._symbolSource(e).setSymbolParams(e.prevSymbolParams),
                    e.showFade && e.chartWidget.screen.show(!0)
                }
                )),
                (0,
                a.muteLinkingGroup)(this._linkingGroupIndex, !1)
            }
            canMerge(e) {
                if (!(e instanceof En) || e._linkingGroupIndex !== this._linkingGroupIndex || !this._containsMainSeriesOnly() || !e._containsMainSeriesOnly() || e._creationTime - this._creationTime > 500)
                    return !1;
                for (const [t] of e._charts)
                    if (this._charts.has(t))
                        return !1;
                return !0
            }
            merge(e) {
                if (e instanceof En)
                    for (const [t,i] of e._charts)
                        this._charts.set(t, i)
            }
            _showFade(e, t) {
                return e === t.model().mainSeries()
            }
            _symbolSource(e) {
                return (0,
                s.ensureNotNull)(e.chartWidget.model().model().dataSourceForId(e.sourceId))
            }
            _containsMainSeriesOnly() {
                for (const [e,t] of this._charts)
                    if (t.sourceId !== e.model().mainSeries().id())
                        return !1;
                return !0
            }
        }
        const kn = new c.TranslatedString("change symbol",r.t(null, void 0, i(435400)));
        class Dn extends En {
            constructor(e, t, i) {
                super(kn, e, {
                    symbol: t,
                    currency: null,
                    unit: null
                }, i),
                this._symbol = t
            }
            canMerge(e) {
                return e instanceof Dn && e._symbol === this._symbol && super.canMerge(e)
            }
        }
        const Nn = (0,
        n.getLogger)("Chart.ChartUndoModel")
          , Bn = new c.TranslatedString("paste indicator",r.t(null, void 0, i(901064)));
        class Rn extends m.UndoCommand {
            constructor(e, t, i) {
                super(Bn),
                this._sourceState = null,
                this._model = e,
                this._clipboardData = t,
                this._paneId = i
            }
            redo() {
                if (!this._sourceState) {
                    const e = (0,
                    Ue.clone)(this._clipboardData.source);
                    e.id = (0,
                    Pe.randomHashN)(6),
                    this._sourceState = e
                }
                let e, t;
                e = this._paneId ? (0,
                s.ensureNotNull)(this._model.paneForId(this._paneId)) : this._sourceState.metaInfo.is_price_study ? (0,
                s.ensureNotNull)(this._model.paneForSource(this._model.mainSeries())) : this._model.createPane();
                const i = !e.mainDataSource();
                this._sourceState.zorder = e.newStudyZOrder();
                const o = (0,
                s.ensureNotNull)(e.restoreStudy(this._sourceState, !1));
                i || (t = this._sourceState.metaInfo.is_price_study ? t = this._model.mainSeries().priceScale() : this._paneId ? e.findSuitableScale(o) : e.defaultPriceScale(),
                t !== o.priceScale() && e.move(o, t)),
                (0,
                rt.isStudy)(o) && o.start()
            }
            undo() {
                if (null === this._sourceState)
                    return void Nn.logError("This command was never executed - nothing to undo");
                const e = (0,
                s.ensureNotNull)(this._model.dataSourceForId(this._sourceState.id));
                this._model.removeSource(e)
            }
            state() {
                return this._sourceState
            }
        }
        class On extends m.UndoCommand {
            constructor(e, t, i, s, o) {
                super(null, !1),
                this._model = e,
                this._paneA = t,
                this._paneB = i,
                this._prevStretchA = s,
                this._currStretchA = o
            }
            redo() {
                const e = this._paneA.stretchFactor() + this._paneB.stretchFactor();
                this._paneA.setStretchFactor(this._currStretchA),
                this._paneB.setStretchFactor(e - this._currStretchA),
                this._model.fullUpdate()
            }
            undo() {
                const e = this._paneA.stretchFactor() + this._paneB.stretchFactor();
                this._paneA.setStretchFactor(this._prevStretchA),
                this._paneB.setStretchFactor(e - this._prevStretchA),
                this._model.fullUpdate()
            }
        }
        const Vn = new c.TranslatedString("move",r.t(null, void 0, i(398277)));
        class Wn extends m.UndoCommand {
            constructor(e, t, i, s) {
                super(Vn, !1),
                this._endEvent = null,
                this._model = e,
                this._sourceId = t.id(),
                this._itemIndex = i,
                this._startEvent = s
            }
            move(e) {
                this._endEvent = e,
                this._move(e)
            }
            hasChanges() {
                return null !== this._endEvent
            }
            undo() {
                this._move(this._startEvent)
            }
            redo() {
                this._move((0,
                s.ensureNotNull)(this._endEvent))
            }
            _move(e) {
                const t = (0,
                s.ensureNotNull)(this._model.dataSourceForId(this._sourceId));
                (0,
                s.assert)(void 0 !== t.moveItem, 'The method "moveItem" is not defined'),
                t.moveItem && t.moveItem(new o.Point(e.localX,e.localY), this._itemIndex, new Gt.EnvironmentState(e))
            }
        }
        var Fn = i(414358)
          , Hn = i(696459)
          , zn = i(7462)
          , Un = i.n(zn)
          , Gn = i(674720)
          , jn = i(393747)
          , qn = i(63171);
        var Xn = i(163130)
          , Kn = i(296842)
          , Yn = i(967805)
          , Zn = i(552279);
        const $n = new c.TranslatedString("zoom",r.t(null, void 0, i(991084)));
        class Jn extends m.UndoCommand {
            constructor(e, t, i, s, o, n) {
                super($n),
                this._barSpacing = null,
                this._rightBarsOffset = null,
                this._leftBarsOffset = null,
                this._priceMode = null,
                this._model = e,
                this._startBar = t,
                this._endBar = i,
                this._startPrice = s,
                this._endPrice = o,
                this._pane = n
            }
            redo() {
                const e = (0,
                s.ensureNotNull)(this._model.timeScale().visibleBarsStrictRange());
                this._leftBarsOffset = e.firstBar() - this._startBar,
                this._rightBarsOffset = e.lastBar() - this._endBar,
                this._barSpacing = this._model.timeScale().barSpacing(),
                this._priceMode = this._pane.defaultPriceScale().mode(),
                this._model.zoomToViewport(this._startBar, this._endBar, this._startPrice, this._endPrice, this._pane)
            }
            undo() {
                const e = this._model.timeScale()
                  , t = this._pane.defaultPriceScale()
                  , i = (0,
                s.ensureNotNull)(e.visibleBarsStrictRange());
                e.setBarSpacing((0,
                s.ensureNotNull)(this._barSpacing)),
                e.zoomToBarsRange(i.firstBar() + (0,
                s.ensureNotNull)(this._leftBarsOffset), i.lastBar() + (0,
                s.ensureNotNull)(this._rightBarsOffset)),
                t.setMode((0,
                s.ensureNotNull)(this._priceMode)),
                t.recalculatePriceRange((0,
                s.ensureNotNull)(e.visibleBarsStrictRange())),
                this._model.recalculateAllPanes((0,
                as.viewportChangeEvent)()),
                this._model.lightUpdate()
            }
        }
        const Qn = (0,
        n.getLogger)("Chart.ChartUndoModel")
          , er = new c.TranslatedString("zoom",r.t(null, void 0, i(991084)));
        class tr extends m.UndoCommand {
            constructor(e, t, i) {
                super(er),
                this._baseCmd = e,
                this._zoomStack = t,
                this._inOut = i
            }
            undo() {
                if (this._inOut) {
                    if (this._baseCmd !== this._zoomStack.head())
                        return void Qn.logDebug("zoom stack inconsistency");
                    this._baseCmd.undo(),
                    this._zoomStack.pop()
                } else
                    this._baseCmd.redo(),
                    this._zoomStack.push(this._baseCmd)
            }
            redo() {
                if (this._inOut)
                    this._baseCmd.redo(),
                    this._zoomStack.push(this._baseCmd);
                else {
                    if (this._baseCmd !== this._zoomStack.head())
                        return void Qn.logDebug("zoom stack inconsistency");
                    this._baseCmd.undo(),
                    this._zoomStack.pop()
                }
            }
        }
        const ir = new c.TranslatedString("stop syncing drawing",r.t(null, void 0, i(703350)));
        class sr extends m.UndoCommand {
            constructor(e, t) {
                super(ir, void 0, !so.lineToolsDoNotAffectChartInvalidation),
                this._model = e,
                this._sourceId = t.id(),
                this._linkKey = t.linkKey().value()
            }
            redo() {
                (0,
                s.ensureNotNull)(this._model.dataSourceForId(this._sourceId)).linkKey().setValue(null)
            }
            undo() {
                (0,
                s.ensureNotNull)(this._model.dataSourceForId(this._sourceId)).linkKey().setValue(this._linkKey)
            }
        }
        var or = i(985429);
        const nr = new c.TranslatedString("restore defaults",r.t(null, void 0, i(985815)));
        class rr extends m.UndoCommand {
            constructor(e, t, i=nr, s=!0) {
                super(i, void 0, s),
                this._chartModel = e,
                this._defaultProperty = t,
                this._state = t.state()
            }
            redo() {
                this._chartModel.restoreFactoryDefaults(this._defaultProperty)
            }
            undo() {
                this._defaultProperty.mergeAndFire(this._state),
                this._chartModel.mainSeries().onChartStyleChanged()
            }
        }
        class ar extends rr {
            constructor(e, t, i, s) {
                super(e, t, i, null != s ? s : !so.lineToolsDoNotAffectChartInvalidation)
            }
            redo() {
                this._defaultProperty.hasChild("intervalsVisibilities") && this._defaultProperty.childs().intervalsVisibilities.mergeAndFire(or.intervalsVisibilitiesDefaults),
                super.redo()
            }
        }
        var lr = i(923451);
        const cr = new c.TranslatedString("restore study defaults",r.t(null, void 0, i(796881)));
        class dr extends ar {
            constructor(e, t, i=cr) {
                super(e, t.properties(), i, !0),
                this._study = t
            }
            redo() {
                super.redo(),
                this._chartModel.recalcColorStudies(!0),
                this._patchProperties()
            }
            undo() {
                super.undo(),
                this._chartModel.recalcColorStudies(!0),
                this._patchProperties()
            }
            _patchProperties() {
                {
                    const e = this._study.inputs();
                    Object.keys(e).some((e=>(0,
                    Ge.isStudyInputDependsOnChart)({
                        id: e
                    }))) && (0,
                    lr.patchPropertiesAsync)(this._study.properties(), this._study.metaInfo(), e)
                }
            }
        }
        var ur = i(412788)
          , hr = i(211183);
        function pr(e, t) {
            return (0,
            Go.extractState)(e, t.map((e=>e.path)))
        }
        function mr(e) {
            var t, i;
            e.wickUpColor = null !== (t = e.wickUpColor) && void 0 !== t ? t : e.wickColor,
            e.wickDownColor = null !== (i = e.wickDownColor) && void 0 !== i ? i : e.wickColor,
            delete e.wickColor
        }
        const gr = new c.TranslatedString("apply chart theme",r.t(null, void 0, i(368231)));
        class _r extends m.UndoCommand {
            constructor(e, t, i) {
                var s, o, n;
                super(gr),
                this._model = e,
                t.sessions && (this._newSessionProps = i ? t.sessions : pr(t.sessions, (0,
                Go.extractThemedColors)(De.lightTheme.content.sessions, De.darkTheme.content.sessions))),
                mr(t.mainSourceProperties.candleStyle),
                mr(t.mainSourceProperties.hollowCandleStyle),
                mr(t.mainSourceProperties.haStyle);
                const r = t;
                r.chartProperties = null !== (s = r.chartProperties) && void 0 !== s ? s : {
                    paneProperties: {},
                    scalesProperties: void 0
                };
                const a = r.chartProperties.paneProperties.gridProperties;
                r.chartProperties.paneProperties.vertGridProperties = null !== (o = r.chartProperties.paneProperties.vertGridProperties) && void 0 !== o ? o : a,
                r.chartProperties.paneProperties.horzGridProperties = null !== (n = r.chartProperties.paneProperties.horzGridProperties) && void 0 !== n ? n : a;
                const l = this._model.properties().state().paneProperties.legendProperties;
                delete l.backgroundTransparency;
                const c = r.chartProperties.paneProperties;
                i && (c.legendProperties = {
                    ...c.legendProperties,
                    ...l
                });
                const d = (0,
                hr.factoryDefaults)("chartproperties")
                  , u = (0,
                Ht.deepExtend)({}, d, t.chartProperties);
                this._newChartProps = i ? u : pr(u, (0,
                Go.extractThemedColors)(De.lightTheme.content.chartProperties, De.darkTheme.content.chartProperties)),
                e.timeScale().preserveBarSpacing() && "barSpacing"in this._newChartProps.scalesProperties && delete this._newChartProps.scalesProperties.barSpacing;
                const h = (0,
                hr.factoryDefaults)("chartproperties.mainSeriesProperties")
                  , p = (0,
                Ht.deepExtend)({}, h, t.mainSourceProperties);
                this._newSeriesProps = i ? p : pr(p, (0,
                Go.extractThemedColors)(De.lightTheme.content.mainSourceProperties, De.darkTheme.content.mainSourceProperties)),
                this._oldChartProps = i ? e.properties().state() : e.properties().themeState(),
                this._oldSeriesProps = i ? e.mainSeries().properties().state() : e.mainSeries().properties().themeState(),
                this._oldSessionProps = i ? this._model.sessions().properties().state() : this._model.sessions().properties().themeState()
            }
            undo() {
                this._merge(this._oldChartProps, this._oldSeriesProps, this._oldSessionProps),
                this._model.mainSeries().onChartStyleChanged(),
                this._model.updateScales(),
                this._model.chartThemeLoaded()
            }
            redo() {
                this._merge(this._newChartProps, this._newSeriesProps, this._newSessionProps),
                this._model.mainSeries().onChartStyleChanged(),
                this._model.updateScales(),
                this._model.chartThemeLoaded()
            }
            _merge(e, t, i) {
                var s, o, n, r;
                const a = this._model;
                (0,
                Go.allowSavingDefaults)(!0);
                const l = a.properties()
                  , c = a.mainSeries().properties()
                  , d = a.sessions().properties();
                l.applyDefaultThemedProperties(mt.watchedTheme.value()),
                l.mergeAndFire(e),
                l.saveDefaults(),
                "priceAxisProperties"in t && a.mainSeries().priceScale().setMode({
                    autoScale: null === (s = t.priceAxisProperties) || void 0 === s ? void 0 : s.autoScale,
                    percentage: null === (o = t.priceAxisProperties) || void 0 === o ? void 0 : o.percentage,
                    log: null === (n = t.priceAxisProperties) || void 0 === n ? void 0 : n.log,
                    lockScale: null === (r = t.priceAxisProperties) || void 0 === r ? void 0 : r.lockScale
                }),
                c.applyDefaultThemedProperties(mt.watchedTheme.value()),
                c.mergeAndFire(t),
                c.saveDefaults(),
                a.mainSeries().createPaneView(),
                a.mainSeries().invalidateBarStylesCache(),
                a.recalculateAllPanes((0,
                as.globalChangeEvent)()),
                i && (d.applyDefaultThemedProperties(mt.watchedTheme.value()),
                d.mergeAndFire(i),
                d.saveDefaults()),
                a.fullUpdate(),
                (0,
                Go.allowSavingDefaults)(!1)
            }
        }
        const vr = new c.TranslatedString("change resolution",r.t(null, void 0, i(932829)));
        class Sr extends En {
            constructor(e, t, i) {
                super(vr, e, function(e, t) {
                    let i;
                    const s = (0,
                    ye.isRangeStyle)(e.style())
                      , o = zs.Interval.isRange(t);
                    return !s && o ? i = 11 : s && !o && (i = (0,
                    ye.getLastUsedStyle)()),
                    {
                        interval: t,
                        style: i
                    }
                }(e, t), i),
                this._resolution = t
            }
            canMerge(e) {
                return e instanceof Sr && e._resolution === this._resolution && super.canMerge(e)
            }
            _showFade(e, t) {
                return !0
            }
        }
        var fr = i(109117);
        class br extends fr.SetWatchedValueCommand {
            constructor() {
                super(...arguments),
                this._firstRedo = !0
            }
            redo() {
                this._firstRedo || (0,
                a.muteLinkingGroup)(this._newValue, !0),
                (0,
                a.muteLinkingGroup)(this._oldValue, !0),
                super.redo(),
                this._firstRedo || (0,
                a.muteLinkingGroup)(this._newValue, !1),
                (0,
                a.muteLinkingGroup)(this._oldValue, !1),
                this._firstRedo = !1
            }
            undo() {
                (0,
                a.muteLinkingGroup)(this._newValue, !0),
                (0,
                a.muteLinkingGroup)(this._oldValue, !0),
                super.undo(),
                (0,
                a.muteLinkingGroup)(this._newValue, !1),
                (0,
                a.muteLinkingGroup)(this._oldValue, !1)
            }
        }
        var yr = i(348065)
          , Cr = i(850986);
        class wr extends m.UndoCommand {
            constructor(e, t, i) {
                super(i),
                this._chartModel = e,
                this._stubDescriptor = (0,
                s.ensureNotNull)(t.getDescriptor())
            }
            redo() {
                this._chartModel.dataSourceForId(this._stubDescriptor.id) || this._chartModel.restoreStudyStub(this._stubDescriptor)
            }
            undo() {
                this._chartModel.removeStudyStub(this._stubDescriptor.id)
            }
        }
        class Tr extends m.UndoCommand {
            constructor(e, t, i) {
                super(i, void 0, !so.lineToolsDoNotAffectChartInvalidation),
                this._source = e,
                this._newState = t,
                this._oldState = e.properties().state()
            }
            redo() {
                this._source.applyTemplate(this._newState)
            }
            undo() {
                this._source.applyTemplate(this._oldState)
            }
        }
        var Pr = i(496416)
          , xr = i(590250)
          , Mr = i(220003)
          , Ir = i(875678)
          , Ar = i(235853)
          , Lr = i(836861)
          , Er = i(373313)
          , kr = i(893556)
          , Dr = i(376036)
          , Nr = i(995152)
          , Br = i(84281)
          , Rr = i(344158);
        const Or = new c.TranslatedString("apply all chart properties",r.t(null, void 0, i(299551)));
        class Vr extends m.UndoCommand {
            constructor(e) {
                super(Or),
                this._trading = null,
                this._oldShowSellBuyButtons = null,
                this._oldNoConfirmEnabled = null,
                this._oldShowOnlyRejectionNotifications = null,
                this._oldShowPricesWithZeroVolume = null,
                this._oldShowPricesWithSpread = null,
                this._oldOrderExecutedSoundEnabled = null,
                this._prevWatermarkPreferences = null,
                this._prevAlertPreferences = null,
                this._model = e,
                this._trading = (0,
                Br.tradingService)(),
                null !== this._trading && (this._oldShowSellBuyButtons = this._trading.showSellBuyButtons.value(),
                this._oldNoConfirmEnabled = this._trading.noConfirmEnabled.value(),
                this._oldShowOnlyRejectionNotifications = this._trading.showOnlyRejectionNotifications.value(),
                this._oldShowPricesWithZeroVolume = this._trading.showPricesWith().zeroVolume.value(),
                this._oldShowPricesWithSpread = this._trading.showPricesWith().spread.value(),
                this._oldOrderExecutedSoundEnabled = this._trading.orderExecutedSoundParams.enabled.value()),
                this._defaultsPreferences = (0,
                Pr.defaultsPreferencesByWhiteList)(this._model, this._model.mainSeries()),
                this._oldPreferences = e.preferences(),
                this._prevDateFormat = xr.dateFormatProperty.value(),
                this._prevAlertPreferences = (0,
                Nr.getSettingsProperty)().state(),
                this._model.onWidget() || (this._prevWithWeekday = kr.withWeekdayProperty.value()),
                this._prevTimeHoursFormat = Mr.timeHoursFormatProperty.value(),
                this._prevAddPlusButton = Rr.addPlusButtonProperty.value(),
                this._prevShowOpenMarkerStatus = Ir.showMarketOpenStatusProperty.value(),
                this._prevCurrencyUnitVisibility = (0,
                vi.currencyUnitVisibilityProperty)().value(),
                this._prevAutoLogButtonsVisibility = (0,
                Si.autoLogButtonsVisibilityProperty)().value(),
                this._prevNavigationButtonsVisibility = (0,
                Ar.property)().value(),
                this._prevPaneButtonsVisibility = (0,
                Lr.property)().value();
                const t = this._model.watermarkSource();
                null !== t && (this._prevWatermarkPreferences = t.properties().state())
            }
            redo() {
                var e, t, i;
                null !== this._trading && (this._trading.showSellBuyButtons.setValue(!0),
                this._trading.noConfirmEnabled.setValue(!1),
                this._trading.showOnlyRejectionNotifications.setValue(!1),
                this._trading.showPricesWith().zeroVolume.setValue(!0),
                this._trading.showPricesWith().spread.setValue(!0),
                this._trading.orderExecutedSoundParams.enabled.setValue(!1)),
                "Auto" === (null === (i = null === (t = null === (e = this._defaultsPreferences.mainSeries) || void 0 === e ? void 0 : e.tpoStyle) || void 0 === t ? void 0 : t.inputs) || void 0 === i ? void 0 : i.rowSize) && delete this._defaultsPreferences.mainSeries.tpoStyle.inputs.ticksPerRow,
                this._model.applyPreferences(this._defaultsPreferences),
                this._model.updateScales(),
                (0,
                xr.restoreDateFormatSettingsValue)(),
                (0,
                Mr.restoreTimeHoursFormatSettingsValue)(),
                (0,
                Rr.restoreAddPlusButtonSettingsValue)(),
                (0,
                Ir.restoreShowMarketOpenStatusProperty)(),
                (0,
                vi.restoreCurrencyUnitVisibilitySettingsValue)(),
                (0,
                Si.restoreAutoLogButtonsVisibilitySettingsValue)(),
                (0,
                Ar.restoreNavigationButtonsVisibilitySettingsValue)(),
                (0,
                Lr.restorePaneButtonsVisibilitySettingsValue)(),
                (0,
                kr.restoreWithWeekdaySettingsValue)(),
                (0,
                Dr.restoreShowOnScreenshotSettingsValue)(),
                (0,
                Er.restoreShowNewsNotificationSettingsValue)(),
                (0,
                Nr.restoreSettingsProperty)();
                const s = this._model.watermarkSource();
                null !== s && s.restorePropertiesDefaults()
            }
            undo() {
                null !== this._trading && (this._trading.showSellBuyButtons.setValue((0,
                s.ensureNotNull)(this._oldShowSellBuyButtons)),
                this._trading.noConfirmEnabled.setValue((0,
                s.ensureNotNull)(this._oldNoConfirmEnabled)),
                this._trading.showOnlyRejectionNotifications.setValue((0,
                s.ensureNotNull)(this._oldShowOnlyRejectionNotifications)),
                this._trading.showPricesWith().zeroVolume.setValue((0,
                s.ensureNotNull)(this._oldShowPricesWithZeroVolume)),
                this._trading.showPricesWith().spread.setValue((0,
                s.ensureNotNull)(this._oldShowPricesWithSpread)),
                this._trading.orderExecutedSoundParams.enabled.setValue((0,
                s.ensureNotNull)(this._oldOrderExecutedSoundEnabled))),
                this._model.applyPreferences(this._oldPreferences),
                this._model.updateScales(),
                xr.dateFormatProperty.setValue(this._prevDateFormat),
                Mr.timeHoursFormatProperty.setValue(this._prevTimeHoursFormat),
                Ir.showMarketOpenStatusProperty.setValue(this._prevShowOpenMarkerStatus),
                Rr.addPlusButtonProperty.setValue(this._prevAddPlusButton),
                (0,
                vi.currencyUnitVisibilityProperty)().setValue(this._prevCurrencyUnitVisibility),
                (0,
                Si.autoLogButtonsVisibilityProperty)().setValue(this._prevAutoLogButtonsVisibility),
                (0,
                Ar.property)().setValue(this._prevNavigationButtonsVisibility),
                (0,
                Lr.property)().setValue(this._prevPaneButtonsVisibility),
                null !== this._prevAlertPreferences && (0,
                Nr.getSettingsProperty)().mergeAndFire(this._prevAlertPreferences),
                this._model.onWidget() || kr.withWeekdayProperty.setValue(this._prevWithWeekday);
                const e = this._model.watermarkSource();
                null !== e && null !== this._prevWatermarkPreferences && e.properties().mergeAndFire(this._prevWatermarkPreferences)
            }
        }
        var Wr = i(246020)
          , Fr = i(25043);
        class Hr extends m.UndoCommand {
            constructor(e, t) {
                var o, n;
                super(new c.TranslatedString("apply all chart properties",r.t(null, void 0, i(299551)))),
                this._model = e,
                this._newProperties = t,
                o = (0,
                s.ensureDefined)(this._newProperties.mainSeries),
                n = (0,
                s.ensureDefined)(this._newProperties.paneProperties),
                ["candleStyle", "hollowCandleStyle", "haStyle"].forEach((e=>{
                    const t = o[e];
                    void 0 !== t && (t.wickUpColor = t.wickUpColor || t.wickColor,
                    t.wickDownColor = t.wickDownColor || t.wickColor)
                }
                )),
                n.vertGridProperties = n.vertGridProperties || (0,
                Fr.default)(n.gridProperties),
                n.horzGridProperties = n.horzGridProperties || (0,
                Fr.default)(n.gridProperties),
                void 0 === o.hollowCandleStyle && (o.hollowCandleStyle = (0,
                Fr.default)(o.candleStyle)),
                this._oldProperties = (0,
                Pr.preferencesByWhiteList)(e, e.mainSeries())
            }
            redo() {
                this._merge(this._newProperties),
                this._model.mainSeries().onChartStyleChanged(),
                this._model.updateScales()
            }
            undo() {
                this._merge(this._oldProperties),
                this._model.mainSeries().onChartStyleChanged(),
                this._model.updateScales()
            }
            _merge(e) {
                (0,
                Go.allowSavingDefaults)(!0),
                this._model.applyPreferences(e),
                (0,
                Go.allowSavingDefaults)(!1)
            }
        }
        var zr = i(128011);
        class Ur {
            constructor(e) {
                this._leftScales = e.leftPriceScales().map((e=>e.id())),
                this._rightScales = e.rightPriceScales().map((e=>e.id()))
            }
            restorePane(e) {
                this._leftScales.reverse().map((t=>(0,
                s.ensureNotNull)(e.getPriceScaleById(t)))).forEach((t=>e.movePriceScale(t, "left"))),
                this._rightScales.reverse().map((t=>(0,
                s.ensureNotNull)(e.getPriceScaleById(t)))).forEach((t=>e.movePriceScale(t, "right")))
            }
        }
        class Gr extends m.UndoCommand {
            constructor(e, t, i) {
                super(i),
                this._chartModel = e,
                this._targetStrategy = (0,
                zr.createPriceScaleSelectionStrategy)(t),
                this._initialState = e.panes().map((e=>new Ur(e)))
            }
            redo() {
                this._chartModel.panes().forEach((e=>e.setPriceScaleSelectionStrategy(this._targetStrategy))),
                this._chartModel.fullUpdate()
            }
            undo() {
                const e = this._chartModel.panes();
                for (let t = 0; t < e.length; t++)
                    this._initialState[t].restorePane(e[t]);
                this._chartModel.fullUpdate()
            }
        }
        const jr = new c.TranslatedString("send {title} backward",r.t(null, void 0, i(540962)))
          , qr = new c.TranslatedString("bring {title} forward",r.t(null, void 0, i(941966)))
          , Xr = new c.TranslatedString("insert {title} after {target}",r.t(null, void 0, i(432960)))
          , Kr = new c.TranslatedString("insert {title} before {target}",r.t(null, void 0, i(557106)))
          , Yr = new c.TranslatedString("cut {title}",r.t(null, void 0, i(411500)))
          , Zr = new c.TranslatedString("cut sources",r.t(null, void 0, i(194227)))
          , $r = new c.TranslatedString("remove {title}",r.t(null, void 0, i(94543)))
          , Jr = new c.TranslatedString("remove drawings group",r.t(null, void 0, i(501193)))
          , Qr = new c.TranslatedString("move scale",r.t(null, void 0, i(444854)))
          , ea = new c.TranslatedString("stop syncing line tool(s)",r.t(null, void 0, i(922)))
          , ta = new c.TranslatedString("zoom out",r.t(null, void 0, i(673638)))
          , ia = new c.TranslatedString("zoom in",r.t(null, void 0, i(49856)))
          , sa = new c.TranslatedString("move drawing(s)",r.t(null, void 0, i(752510)))
          , oa = new c.TranslatedString("load default drawing template",r.t(null, void 0, i(743364)))
          , na = new c.TranslatedString("apply factory defaults to selected sources",r.t(null, void 0, i(727851)))
          , ra = new c.TranslatedString("change currency",r.t(null, void 0, i(832302)))
          , aa = new c.TranslatedString("change unit",r.t(null, void 0, i(185975)))
          , la = new c.TranslatedString("clone line tools",r.t(null, void 0, i(132943)))
          , ca = new c.TranslatedString("merge up",r.t(null, void 0, i(452458)))
          , da = new c.TranslatedString("merge down",r.t(null, void 0, i(778055)))
          , ua = new c.TranslatedString("merge to pane",r.t(null, void 0, i(341866)))
          , ha = new c.TranslatedString("unmerge up",r.t(null, void 0, i(379443)))
          , pa = new c.TranslatedString("unmerge down",r.t(null, void 0, i(246453)))
          , ma = new c.TranslatedString("unmerge to new bottom pane",r.t(null, void 0, i(981576)))
          , ga = new c.TranslatedString("move {title} to new right scale",r.t(null, void 0, i(177482)))
          , _a = new c.TranslatedString("move {title} to new left scale",r.t(null, void 0, i(158228)))
          , va = new c.TranslatedString("make {title} no scale (Full screen)",r.t(null, void 0, i(910625)))
          , Sa = new c.TranslatedString("scroll time",r.t(null, void 0, i(787840)))
          , fa = new c.TranslatedString("scale time",r.t(null, void 0, i(470771)))
          , ba = new c.TranslatedString("reset time scale",r.t(null, void 0, i(17336)))
          , ya = new c.TranslatedString("reset scales",r.t(null, void 0, i(703323)))
          , Ca = new c.TranslatedString("create {tool}",r.t(null, void 0, i(12898)))
          , wa = new c.TranslatedString("change {pointIndex} point",r.t(null, void 0, i(763058)))
          , Ta = new c.TranslatedString("paste {title}",r.t(null, void 0, i(657010)))
          , Pa = new c.TranslatedString("insert {title}",r.t(null, void 0, i(848818)))
          , xa = new c.TranslatedString("remove pane",r.t(null, void 0, i(693333)))
          , Ma = new c.TranslatedString("invert scale",r.t(null, void 0, i(6830)))
          , Ia = new c.TranslatedString("toggle auto scale",r.t(null, void 0, i(642240)))
          , Aa = new c.TranslatedString("toggle lock scale",r.t(null, void 0, i(949695)))
          , La = new c.TranslatedString("toggle regular scale",r.t(null, void 0, i(680688)))
          , Ea = new c.TranslatedString("toggle indexed to 100 scale",r.t(null, void 0, i(824736)))
          , ka = new c.TranslatedString("toggle percentage scale",r.t(null, void 0, i(398994)))
          , Da = new c.TranslatedString("toggle log scale",r.t(null, void 0, i(149403)))
          , Na = new c.TranslatedString("move left",r.t(null, void 0, i(179209)))
          , Ba = new c.TranslatedString("move right",r.t(null, void 0, i(360114)))
          , Ra = new c.TranslatedString("align to 45 degrees",r.t(null, void 0, i(4128)))
          , Oa = new c.TranslatedString("set price scale selection strategy to {title}",r.t(null, void 0, i(782241)))
          , Va = new c.TranslatedString("remove all studies",r.t(null, void 0, i(643172)))
          , Wa = new c.TranslatedString("remove drawings",r.t(null, void 0, i(530538)))
          , Fa = new c.TranslatedString("remove all studies and drawing tools",r.t(null, void 0, i(556253)))
          , Ha = new c.TranslatedString("turn line tools sharing off",r.t(null, void 0, i(508040)))
          , za = new c.TranslatedString("share line tools in layout",r.t(null, void 0, i(90221)))
          , Ua = new c.TranslatedString("share line tools globally",r.t(null, void 0, i(263934)))
          , Ga = new c.TranslatedString("change linking group",r.t(null, void 0, i(688849)))
          , ja = (0,
        n.getLogger)("Chart.ChartUndoModel")
          , qa = (0,
        ce.isFeatureEnabled)("hide_tweet_drawingtool");
        function Xa(e, t) {
            return {
                bringForwardEnabled: e.bringForwardEnabled || t.bringForwardEnabled,
                bringToFrontEnabled: e.bringToFrontEnabled || t.bringToFrontEnabled,
                sendBackwardEnabled: e.sendBackwardEnabled || t.sendBackwardEnabled,
                sendToBackEnabled: e.sendToBackEnabled || t.sendToBackEnabled
            }
        }
        function Ka() {
            return (0,
            qt.drawOnAllCharts)().value() ? 1 === (0,
            qt.drawOnAllChartsMode)().value() ? 1 : 2 : 0
        }
        function Ya(e, t) {
            (0,
            l.onWidget)() ? (0,
            $s.showGoToTradingViewReferralDialog)({
                feature: "indicators"
            }) : (0,
            Js.showStudiesLimitGoProDialog)(e, t)
        }
        class Za extends (Vs()) {
            constructor(e, t, i, s, o, n, r, a, l, c, d) {
                super(),
                this._createLineCommand = null,
                this._initialTimeScrollState = null,
                this._initialTimeScrollPos = null,
                this._initialTimeScaleState = null,
                this._scalePriceInfo = null,
                this._currentSourceMoveCommand = null,
                this._currentLineChangeCommand = null,
                this._currentCustomMoveCommand = null,
                this._zoomStack = new Gs.UndoStack,
                this._initialPriceScrollState = null,
                this._initialPriceScrollPos = null,
                this._chartWidget = o,
                this.m_model = new (Un())(e,t,i,s,this,r,a,l,c,d),
                this._undoHistory = n,
                this._lineToolsGroupController = new _n({
                    model: this._model.bind(this),
                    pushUndoCommand: this._pushUndoCommand.bind(this),
                    beginUndoMacro: e=>{
                        this._undoHistory.beginUndoMacro(e)
                    }
                    ,
                    endUndoMacro: this._undoHistory.endUndoMacro.bind(this._undoHistory),
                    emitEvent: this.emitEvent.bind(this)
                })
            }
            id() {
                return this._model().id()
            }
            undoHistory() {
                return this._undoHistory
            }
            setWatchedValue(e, t, i) {
                this._undoHistory.setWatchedValue(e, t, i)
            }
            lineToolsGroupController() {
                return this._lineToolsGroupController
            }
            mergeAllScales(e) {
                !function(e, t) {
                    e.beginUndoMacro("left" === t ? Qs : eo),
                    e.model().panes().forEach((i=>{
                        const s = "left" === t ? i.rightPriceScales() : i.leftPriceScales()
                          , o = ("left" === t ? i.leftPriceScales() : i.rightPriceScales()).concat(s)
                          , n = "overlay" === i.priceScalePosition(i.defaultPriceScale()) ? o[0] : i.defaultPriceScale();
                        e.movePriceScale(i, n, t, 0),
                        o.forEach((t=>{
                            if (t === n)
                                return;
                            let s = t.mainSource();
                            for (; null !== s; ) {
                                e.moveToScale(s, i, n, null, !0);
                                const o = t.mainSource();
                                if (o === s) {
                                    to.logError("Loop detected while trying to merge scales");
                                    break
                                }
                                s = o
                            }
                        }
                        ))
                    }
                    )),
                    e.endUndoMacro(),
                    e.model().fullUpdate()
                }(this, e)
            }
            movePriceScale(e, t, i, s) {
                const o = new io(this._model(),e,t,i,s,Qr);
                this._pushUndoCommand(o)
            }
            createLineTool({pane: e, point: t, linetool: i, properties: o, linkKey: n, ownerSource: r, disableSynchronization: a, sharingMode: l=Ka(), id: d}) {
                const u = Cr.lineToolsStudyIds[i];
                if ((0,
                s.assert)(!(0,
                U.isStudyLineToolName)(u) || !!u),
                u) {
                    const e = this.canCreateStudy({
                        id: u
                    });
                    if (!e.success)
                        return Ya(this.model(), e),
                        (0,
                        U.isStudyLineToolName)(qt.tool.value()) && (0,
                        qt.resetToCursor)(),
                        null
                }
                const h = Ca.format({
                    tool: new c.TranslatedString(i,go.lineToolsLocalizedNames[i])
                });
                this.beginUndoMacro(h);
                const p = !a;
                this._createLineCommand = new vo({
                    model: this._model(),
                    pane: e,
                    lineTool: i,
                    ownerSource: r || (0,
                    s.ensureNotNull)(e.mainDataSource()),
                    drawOnAllChartsMode: l,
                    id: d
                });
                const m = this._createLineCommand.startCreatingLine(t, o, n || null, l, a)
                  , g = (0,
                s.ensureNotNull)(this._createLineCommand.line());
                let _ = null;
                if (m && (p && this.finishLineTool(g),
                this._pushUndoCommand(this._createLineCommand),
                this._createLineCommand = null,
                _ = {
                    points: g.normalizedPoints(),
                    interval: this.mainSeries().interval()
                }),
                p && void 0 === n && (0,
                qt.drawOnAllCharts)().value() && g.isSynchronizable()) {
                    const e = (0,
                    s.ensureNotNull)(this.model().externalTimeStamp(t.index))
                      , o = {
                        point: {
                            price: t.price,
                            timeStamp: e
                        },
                        linetool: i,
                        properties: g.properties(),
                        symbol: this.mainSeries().symbol(),
                        model: this.model(),
                        linkKey: (0,
                        s.ensureNotNull)(g.linkKey().value()),
                        finalState: _,
                        id: g.id(),
                        sharingMode: g.sharingMode().value()
                    };
                    g.isFixed() && (o.pointPositionPercents = g.calcPositionPercents()),
                    (0,
                    qt.createLineTool)(o)
                }
                return this.endUndoMacro(),
                g
            }
            continueCreatingLine(e, t, i, o) {
                const n = (0,
                s.ensureNotNull)(this._createLineCommand);
                this.beginUndoMacro(n.text());
                const r = (0,
                s.ensureNotNull)(this._model().lineBeingCreated())
                  , a = n.continueCreatingLine(e, t, i, o);
                let l = null;
                if (a && (this.finishLineTool(r),
                this._pushUndoCommand(n),
                this._createLineCommand = null,
                l = {
                    points: r.normalizedPoints(),
                    interval: this.mainSeries().interval()
                }),
                n.drawOnAllCharts() && r.isSynchronizable()) {
                    const i = (0,
                    s.ensureNotNull)(this._model().externalTimeStamp(e.index));
                    (0,
                    qt.continueLineTool)({
                        point: {
                            price: e.price,
                            timeStamp: i
                        },
                        envState: t,
                        finalState: l,
                        model: this._model()
                    })
                }
                return this.endUndoMacro(),
                a
            }
            continueExternalLine(e, t, i) {
                const o = (0,
                s.ensureNotNull)(this._createLineCommand)
                  , n = o.continueCreatingLine(e, t, i);
                return n && (this._pushUndoCommand(o),
                this._createLineCommand = null),
                n
            }
            finishLineTool(e) {
                this._model().finishLineTool(e)
            }
            cancelCreatingLine() {
                this.m_model.cancelCreatingLine()
            }
            lineBeingCreated() {
                return this.m_model.lineBeingCreated()
            }
            pasteImageAsLineTool(e, t, i, o) {
                const n = this._model().timeScale()
                  , r = n.width()
                  , a = i.height()
                  , l = i.defaultPriceScale()
                  , d = (0,
                s.ensureNotNull)((0,
                s.ensureNotNull)(l.mainSource()).firstValue())
                  , u = {
                    price: l.coordinateToPrice(a / 2, d),
                    index: n.coordinateToIndex(r / 2)
                }
                  , h = (0,
                ct.createLineToolProperties)("LineToolImage", void 0, this.model());
                void 0 !== o && h.childs().transparency.setValue(o);
                const p = (0,
                s.ensureNotNull)(l.mainSource());
                (0,
                ct.prepareLineToolPropertiesByOwnerSource)(h, p);
                const m = this.createLineTool({
                    pane: i,
                    point: u,
                    linetool: "LineToolImage",
                    properties: h
                });
                return m && (m.setBlobImageUrl(t),
                this.selectionMacro((e=>{
                    e.clearSelection(),
                    e.addSourceToSelection(m, null)
                }
                )),
                e.then((e=>{
                    m.properties().childs().url.setValue(e)
                }
                )).catch((e=>{
                    const t = m.linkKey().value()
                      , i = this.model();
                    null !== t && (0,
                    qt.removeLineTool)({
                        withUndo: !1,
                        model: i,
                        linkKey: t,
                        symbol: m.symbol(),
                        sourceTitle: new c.TranslatedString(m.name(),m.translatedType()),
                        lineToolState: m.state(!1)
                    }),
                    i.removeSource(m)
                }
                ))),
                m
            }
            loadRange(e) {
                const t = this._model()
                  , i = t.appliedTimeFrame().value();
                return (null === i || !Us(i, e)) && (this._pushUndoCommand(new Jo(t,e)),
                !0)
            }
            mainSeries() {
                return this.m_model.mainSeries()
            }
            model() {
                return this.m_model
            }
            publishedChartsTimelineSource() {
                return this.m_model.publishedChartsTimelineSource()
            }
            unlinkLines(e) {
                const t = this.model();
                this.beginUndoMacro(ea);
                for (const i of e)
                    null !== i.linkKey().value() && (0,
                    qt.removeLineTool)({
                        withUndo: !0,
                        model: this.model(),
                        symbol: i.symbol(),
                        linkKey: (0,
                        s.ensureNotNull)(i.linkKey().value()),
                        sourceTitle: (0,
                        po.getTranslatedStringForSource)(So.TitleDisplayTarget.StatusLine, i),
                        lineToolState: i.state(!1),
                        unlink: !0
                    }),
                    this._pushUndoCommand(new sr(t,i));
                this.endUndoMacro()
            }
            zoomFromViewport() {
                const e = new tr((0,
                s.ensureDefined)(this._zoomStack.head()),this._zoomStack,!1);
                this._pushUndoCommand(e)
            }
            zoomToViewport(e, t, i, s, o) {
                const n = new Jn(this.m_model,e,t,i,s,o)
                  , r = new tr(n,this._zoomStack,!0);
                this._pushUndoCommand(r)
            }
            zoomStack() {
                return this._zoomStack
            }
            timeScale() {
                return this.m_model.timeScale()
            }
            selection() {
                return this.m_model.selection()
            }
            selectionMacro(e, t) {
                return this.m_model.selectionMacro(e, t)
            }
            onSelectedSourceChanged() {
                return this.m_model.onSelectedSourceChanged()
            }
            onTagsChanged() {
                return this.m_model.onTagsChanged()
            }
            lineCancelled() {
                return this.m_model.lineCancelled()
            }
            hoveredSource() {
                return this.m_model.hoveredSource()
            }
            crossHairSource() {
                return this.m_model.crossHairSource()
            }
            activeStrategySource() {
                return this.m_model.activeStrategySource()
            }
            setProperty(e, t, i, s) {
                if (e && e.value() !== t) {
                    this.beginUndoMacro(i);
                    const o = new Yo(e,t,i,this.m_model,!s);
                    this._pushUndoCommand(o),
                    this.endUndoMacro(),
                    this.emitEvent("setProperty")
                }
            }
            setProperties(e, t, i, s=!0) {
                this.beginUndoMacro(i),
                this.m_model.selectionMacro((()=>{
                    for (let o = 0; o < e.length; o++)
                        this.setProperty(e[o], t[o], i, !s)
                }
                )),
                this.endUndoMacro()
            }
            beginUndoMacro(e) {
                return this._undoHistory.beginUndoMacro(e)
            }
            endUndoMacro() {
                this._undoHistory.endUndoMacro()
            }
            invertPriceScale(e) {
                const t = e.properties().childs().isInverted;
                this.setProperty(t, !t.value(), Ma)
            }
            togglePriceScaleAutoScaleMode(e) {
                const t = {
                    autoScale: !e.isAutoScale()
                };
                this.setPriceScaleMode(t, e, Ia)
            }
            togglePriceScaleLockScaleMode(e) {
                const t = {
                    lockScale: !e.isLockScale()
                };
                this.setPriceScaleMode(t, e, Aa)
            }
            togglePriceScalePercentageScaleMode(e) {
                const t = {
                    percentage: !e.isPercentage()
                };
                this.setPriceScaleMode(t, e, ka)
            }
            togglePriceScaleIndexedTo100ScaleMode(e) {
                const t = {
                    indexedTo100: !e.isIndexedTo100()
                };
                this.setPriceScaleMode(t, e, Ea)
            }
            togglePriceScaleLogScaleMode(e) {
                const t = {
                    log: !e.isLog()
                };
                this.setPriceScaleMode(t, e, Da)
            }
            setPriceScaleRegularScaleMode(e) {
                this.setPriceScaleMode({
                    log: !1,
                    percentage: !1,
                    indexedTo100: !1
                }, e, La)
            }
            withMacro(e, t) {
                const i = this.beginUndoMacro(e);
                try {
                    t()
                } finally {
                    this.endUndoMacro()
                }
                return i
            }
            dataSources() {
                return this.m_model.dataSources()
            }
            orderedDataSources(e) {
                return this.m_model.orderedDataSources(e)
            }
            barsMarksSources() {
                return this.m_model.barsMarksSources()
            }
            removeAllDrawingTools() {
                this.beginUndoMacro(Wa),
                this._removeAllDrawingToolsImpl(),
                this.endUndoMacro()
            }
            removeAllStudiesAndDrawingTools() {
                this.beginUndoMacro(Fa),
                this._removeAllDrawingToolsImpl(),
                this._removeAllStudiesImpl(),
                this.endUndoMacro()
            }
            removeAllStudies() {
                this.beginUndoMacro(Va),
                this._removeAllStudiesImpl(),
                this.endUndoMacro()
            }
            scrollChartByBar(e) {
                if (!this.m_model.scrollEnabled())
                    return;
                const t = e * this.m_model.timeScale().barSpacing();
                this.startScrollTime(0),
                this.scrollTimeTo(t),
                this.endScrollTime()
            }
            canZoomIn() {
                return this.model().canZoomIn()
            }
            canZoomOut() {
                return this.model().canZoomOut()
            }
            zoomOut() {
                const e = this.timeScale().width();
                this.canZoomOut() && (this.changeTimeScale(ta),
                (0,
                Xs.doAnimate)({
                    to: e / 5,
                    onStep: e=>{
                        this.startScaleTime(0),
                        this.scaleTimeTo(e),
                        this.endScaleTime()
                    }
                }))
            }
            zoomIn() {
                const e = this.timeScale().width();
                this.canZoomIn() && (this.changeTimeScale(ia),
                (0,
                Xs.doAnimate)({
                    to: e / 5,
                    onStep: e=>{
                        this.startScaleTime(e),
                        this.scaleTimeTo(0),
                        this.endScaleTime()
                    }
                }))
            }
            scrollChart(e) {
                this.m_model.scrollEnabled() && (this.startScrollTime(0),
                this.scrollTimeTo(e),
                this.endScrollTime())
            }
            startMovingSources(e, t, i, s) {
                e.filter((e=>e.doesMovingAffectsUndo())).length && (this._currentSourceMoveCommand = new lo(this.model(),e,sa,!1)),
                this.model().startMovingSources(e, t, i, new Map, s)
            }
            moveSources(e, t) {
                this.model().moveSources(e, new Map, t)
            }
            endMovingSource(e, t) {
                this.model().endMovingSources(e, void 0, t),
                null !== this._currentSourceMoveCommand && (this._currentSourceMoveCommand.saveNewState(),
                this._pushUndoCommand(this._currentSourceMoveCommand)),
                this._currentSourceMoveCommand = null
            }
            startChangingLinetool(e, t, i, s, o) {
                this._currentLineChangeCommand = new lo(this.model(),[e],wa.format({
                    pointIndex: i
                }),!1),
                this.model().startChangingLinetool(e, t, i, s, o)
            }
            changeLinePoint(e, t) {
                this.model().changeLinePoint(e, t)
            }
            alignToolTo45Degrees(e) {
                const t = e.alignTo45DegreesPoints();
                t && (this._pushUndoCommand(new lo(this.model(),[e],Ra,!1)),
                this.model().alignTo45Degrees(e, t))
            }
            endChangingLinetool(e) {
                this.model().endChangingLinetool(e),
                null !== this._currentLineChangeCommand && (this._currentLineChangeCommand.saveNewState(),
                this._pushUndoCommand(this._currentLineChangeCommand)),
                this._currentLineChangeCommand = null
            }
            setChartStyleProperty(e, t, i) {
                if (e.value() !== t) {
                    const s = Yn.chartStylePermissions.get(t)
                      , o = ()=>{
                        this.beginUndoMacro(i);
                        const s = new Zo(e,t,this.mainSeries(),i,this.model(),this._chartWidget);
                        var o;
                        this._pushUndoCommand(s),
                        this.emitEvent("setChartStyleProperty"),
                        o = e.value(),
                        (0,
                        $i.getTracker)().then((e=>{
                            if (null !== e) {
                                const t = Lt.STYLE_SHORT_NAMES[o];
                                e.trackChartStyle(t)
                            }
                        }
                        )),
                        this.endUndoMacro()
                    }
                    ;
                    s ? (0,
                    Zn.runOrGoPro)(o, s.feature, {
                        feature: s.featureName
                    }) : o()
                }
            }
            setPriceAutoScale(e, t, i) {
                this._pushUndoCommand(new ji(this.m_model,e,t,t.state())),
                this.m_model.setPriceAutoScale(e, t, i)
            }
            setPriceScaleMode(e, t, i) {
                if (!(0,
                Ft.default)(t.mode(), e)) {
                    const s = new Hn.SetPriceScaleModeCommand(e,t,i,this.m_model);
                    this._pushUndoCommand(s)
                }
            }
            setPriceScaleSelectionStrategy(e) {
                if (this.m_model.properties().priceScaleSelectionStrategyName.value() === e)
                    return;
                (0,
                Ne.trackEvent)("Chart", "Change PriceScale Selection Strategy");
                const t = Oa.format({
                    title: e
                });
                this.beginUndoMacro(t),
                this.setProperty(this.m_model.properties().priceScaleSelectionStrategyName, e, t);
                const i = new Gr(this.m_model,e,t);
                this._pushUndoCommand(i),
                this.endUndoMacro()
            }
            setScaleRatioProperty(e, t, i) {
                if (e.value() !== t) {
                    const s = new Wr.SetScaleRatioPropertiesCommand(e,t,i,this.m_model);
                    this._pushUndoCommand(s)
                }
            }
            createUndoCheckpoint() {
                return this._undoHistory.createUndoCheckpoint()
            }
            undoToCheckpoint(e) {
                this._undoHistory.undoToCheckpoint(e)
            }
            restorePropertiesForSource(e) {
                (0,
                ct.isLineTool)(e) ? this._restoreLineToolFactoryDefaults(e) : this._restoreStudyFactoryDefaults(e)
            }
            restoreLineToolsFactoryDefaults(e) {
                1 === e.length ? this._restoreLineToolFactoryDefaults(e[0]) : (this.beginUndoMacro(na),
                e.forEach((e=>this._restoreLineToolFactoryDefaults(e))),
                this.endUndoMacro())
            }
            restorePreferences() {
                const e = new Vr(this.model());
                this._pushUndoCommand(e)
            }
            restoreState(e, t, i) {
                return this.m_model.restoreState(e, t, i)
            }
            async clipboardCopy(e, t=this.selection().dataSources()) {
                if (!(0,
                d.enabled)("datasource_copypaste"))
                    return;
                const i = t.filter((e=>e.copiable()));
                if (0 === i.length)
                    return;
                for (const e of i)
                    if ((0,
                    rt.isStudy)(e) && e.isChildStudy())
                        throw new Error("Can not copy child study");
                const s = (0,
                qs.clipboardDataForSources)(this._model().id(), i);
                return null !== s ? e.write({
                    app: JSON.stringify(s),
                    text: s.title
                }) : void 0
            }
            async clipboardCut(e, t=this.selection().dataSources()) {
                if (!(0,
                d.enabled)("datasource_copypaste"))
                    return;
                const i = t.filter((e=>e.copiable()));
                if (0 === i.length)
                    return;
                await this.clipboardCopy(e, i);
                const s = i.filter((e=>e.isUserDeletable()));
                if (0 === s.length)
                    return;
                const o = (1 === s.length ? Yr : Zr).format({
                    title: (0,
                    po.getTranslatedStringForSource)(So.TitleDisplayTarget.StatusLine, s[0])
                });
                this.beginUndoMacro(o),
                this.m_model.selectionMacro((()=>this.removeSources(s, !1, o)), !0),
                this.endUndoMacro()
            }
            async clipboardPaste(e, t) {
                let i = null;
                if ((0,
                d.enabled)("datasource_copypaste") && (i = i || await e.read(),
                i.app)) {
                    const e = JSON.parse(i.app);
                    if (null !== await this.pasteSourceFromClip(t, e))
                        return
                }
                await this._processSpecialLineToolsContents(e, i, t)
            }
            applyStudyTemplate(e, t) {
                const i = new wn(this._model(),e,t);
                this._pushUndoCommand(i),
                (0,
                Me.emit)("load_study_template")
            }
            createStudyInserter(e, t, i={}) {
                const {stubTitle: s, isOverlay: o} = i
                  , n = {
                    createStudy: (e,t,i,s,o,n,r,a,l,c,d,u)=>{
                        if (!this.checkIfFeatureAvailable(e, r))
                            return ja.logNormal("Cannot insert study " + e.id),
                            null;
                        (0,
                        Ne.trackEvent)("studies", "Study_" + e.id),
                        "Compare@tv-basicstudies" === e.id && (0,
                        Ne.trackEvent)("compare", "symbol:" + t.symbol),
                        s && this.m_model.removeSource(s);
                        const h = this._insertStudy(e, t, o, n, r, a, l, c, d, null, u);
                        return h.study.then((e=>(0,
                        Me.emit)("study_event", e.id(), "create"))),
                        h
                    }
                    ,
                    storeFailedStub: e=>{
                        this._storeFailedStub(e)
                    }
                };
                void 0 !== s && (n.createStub = ()=>this.m_model.insertStudyStub(s, o).id(),
                n.removeStub = e=>this.m_model.removeStudyStub(e));
                const r = new yr.StudyInserter(e,n);
                return r.setParentSources(t),
                r
            }
            applyLineToolTemplate(e, t, i) {
                this.beginUndoMacro(i),
                this.saveLineToolState(e, i);
                const s = new Tr(e,t,i);
                this._pushUndoCommand(s),
                this.saveLineToolState(e, i),
                this.endUndoMacro(),
                this.model().updateSource(e)
            }
            replayStatus() {
                return this.m_model.replayStatus()
            }
            setReplayStatus(e) {
                return this.m_model.setReplayStatus(e)
            }
            isInReplay() {
                return this.m_model.isInReplay()
            }
            getSymbolString() {
                return this.m_model.getSymbolString()
            }
            interval() {
                return this.m_model.interval()
            }
            onInReplayStateChanged() {
                return this.m_model.onInReplayStateChanged()
            }
            switchToReplay(e, t) {
                this._undoHistory.clearStack(),
                this.m_model.switchToReplay(e, t)
            }
            switchToRealtime() {
                this._undoHistory.clearStack(),
                this.m_model.switchToRealtime()
            }
            canChangeResolution(e) {
                return this.model().canChangeResolution(e)
            }
            canChangeSymbol(e) {
                return this.model().canChangeSymbol(e)
            }
            startCustomMoving(e, t, i) {
                this._currentCustomMoveCommand = new Wn(this.model(),e,t,i)
            }
            customMoveBeingProcessed() {
                return null !== this._currentCustomMoveCommand
            }
            processCustomMove(e) {
                (0,
                s.ensureNotNull)(this._currentCustomMoveCommand).move(e)
            }
            endCustomMoving() {
                null !== this._currentCustomMoveCommand && this._currentCustomMoveCommand.hasChanges() && (this._pushUndoCommand(this._currentCustomMoveCommand),
                this._currentCustomMoveCommand = null)
            }
            state(e, t, i, s) {
                return this.m_model.state(e, t, i, s)
            }
            panes() {
                return this.m_model.panes()
            }
            cloneLineTools(e, t) {
                for (let t = 0; t < Math.min(5, e.length); ++t)
                    Ji(e[t], "clone");
                this.beginUndoMacro(la);
                const i = new oo(this._model(),e,t,la);
                this._pushUndoCommand(i);
                const o = i.newIds().map((e=>(0,
                s.ensureNotNull)(this.model().dataSourceForId(e)))).filter((e=>0 !== e.sharingMode().value()));
                return o.length && this._model().copyToOtherCharts(o, !0),
                this.endUndoMacro(),
                this.emitEvent("cloneLineTools"),
                i.newIds()
            }
            removeSource(e, t, i) {
                this.lineBeingCreated() !== e ? this.removeSources([e], t, $r.format({
                    title: (0,
                    po.getTranslatedStringForSource)(So.TitleDisplayTarget.StatusLine, e)
                }), i) : this.cancelCreatingLine()
            }
            removeSelectedSources() {
                const e = this._model().selection().dataSources();
                if (!e.length)
                    return;
                const t = (e.length > 1 ? Jr : $r).format({
                    title: (0,
                    po.getTranslatedStringForSource)(So.TitleDisplayTarget.StatusLine, e[0])
                });
                this.removeSources(e, !1, t)
            }
            removeSources(e, t, i, o) {
                o || (e = e.filter((e=>e.isUserDeletable())));
                const n = this._model()
                  , r = n.lineToolsGroupModel();
                this.beginUndoMacro(i),
                n.selectionMacro((o=>{
                    const a = new Map;
                    e.forEach((e=>{
                        if ((0,
                        ct.isLineTool)(e)) {
                            const t = r.groupForLineTool(e);
                            if (null !== t) {
                                const i = a.get(t) || [];
                                i.push(e),
                                a.set(t, i)
                            }
                            null !== e.linkKey().value() && (0,
                            qt.removeLineTool)({
                                withUndo: !0,
                                model: this.model(),
                                linkKey: (0,
                                s.ensureNotNull)(e.linkKey().value()),
                                symbol: this.model().mainSeries().symbol(),
                                lineToolState: e.state(!1),
                                sourceTitle: (0,
                                po.getTranslatedStringForSource)(So.TitleDisplayTarget.StatusLine, e)
                            })
                        }
                    }
                    ));
                    const l = new no.RemoveSourcesUndoCommand(n,e,i)
                      , c = l.removedIds();
                    this._pushUndoCommand(l),
                    !t && c.length > 0 && (1 === c.length ? this.emitEvent("removeSource", [c[0]]) : this.emitEvent("removeSources", [c]))
                }
                ), !0),
                this.endUndoMacro()
            }
            async scrollToLineTool(e) {
                const t = this.timeScale().logicalRange();
                if (null === t)
                    return;
                const i = e.points().map((e=>e.index))
                  , o = this.timeScale().points().range().value();
                if (null === o)
                    return;
                let n = o.firstIndex;
                const r = o.lastIndex
                  , a = t.length() / 2;
                if (0 === i.length || i.some((e=>t.contains(e))))
                    return;
                const l = ()=>{
                    const t = e.points().map((e=>e.index))
                      , i = t.filter((e=>e <= r)).reduce(((e,t)=>null === e ? t : Math.max(e, t)), null);
                    return null !== i ? i : t.reduce(((e,t)=>Math.min(e, t)))
                }
                ;
                let c = l();
                if (n - a > c) {
                    const t = e.points().map((e=>e.time)).filter(Ue.notUndefined).map((e=>1e3 * e));
                    if (0 === t.length)
                        return;
                    const i = t.reduce(((e,t)=>Math.min(e, t)), t[0]);
                    await this.model().gotoTime(i),
                    c = l();
                    if ((0,
                    s.ensureNotNull)(this.timeScale().logicalRange()).contains(c))
                        return;
                    n = (0,
                    s.ensureNotNull)(this.timeScale().points().range().value()).firstIndex
                }
                n - a > c && this.mainSeries().setGotoDateResult({
                    timestamp: (0,
                    s.ensureNotNull)(this.timeScale().points().valueAt(n)),
                    eod: !0
                });
                const d = this.timeScale().width() / 2
                  , u = this.timeScale().indexToCoordinate(c);
                this.model().stopTimeScaleAnimation(),
                this.model().setTimeScaleAnimation(new js.Animation({
                    from: 0,
                    to: d - u,
                    duration: Ws.dur,
                    easing: Ws.easingFunc.easeInOutCubic
                }))
            }
            mergeSourceUp(e) {
                const t = new uo.MergeUpUndoCommand(this._model(),e,ca);
                this._mergeUnmergeSource(e, t)
            }
            mergeSourceDown(e) {
                const t = new uo.MergeDownUndoCommand(this._model(),e,da);
                this._mergeUnmergeSource(e, t)
            }
            mergeToPane(e, t, i) {
                const s = this._model().panes().indexOf(t)
                  , o = new uo.MergeToTargetPane(this._model(),e,s,ua,i);
                this._mergeUnmergeSource(e, o)
            }
            unmergeSourceUp(e) {
                const t = new co.UnmergeUpUndoCommand(this._model(),e,ha);
                this._mergeUnmergeSource(e, t)
            }
            unmergeSourceDown(e) {
                const t = new co.UnmergeDownUndoCommand(this._model(),e,pa);
                this._mergeUnmergeSource(e, t)
            }
            unmergeToNewBottomPane(e) {
                const t = new co.UnmergeToNewBottomPane(this._model(),e,ma);
                this._mergeUnmergeSource(e, t)
            }
            moveLeft() {
                this.beginUndoMacro(Na),
                (0,
                Xs.doAnimate)({
                    to: this.m_model.timeScale().width() / 5,
                    onStep: e=>{
                        this.startScrollTime(e),
                        this.scrollTimeTo(0),
                        this.endScrollTime()
                    }
                    ,
                    onComplete: ()=>{
                        this.endUndoMacro()
                    }
                })
            }
            moveRight() {
                this.beginUndoMacro(Ba),
                (0,
                Xs.doAnimate)({
                    to: this.m_model.timeScale().width() / 5,
                    onStep: e=>{
                        this.startScrollTime(0),
                        this.scrollTimeTo(e),
                        this.endScrollTime()
                    }
                    ,
                    onComplete: ()=>{
                        this.endUndoMacro()
                    }
                })
            }
            availableZOrderOperations(e) {
                const t = this._model().lineToolsGroupModel()
                  , i = e.filter(ct.isLineTool)
                  , o = i.map((e=>t.groupForLineTool(e)));
                (0,
                s.assert)(new Set(o).size <= 1, "Cannot move line tools from different group");
                const n = 0 === o.length ? null : o[0];
                let r = {
                    bringForwardEnabled: !1,
                    bringToFrontEnabled: !1,
                    sendBackwardEnabled: !1,
                    sendToBackEnabled: !1
                };
                const a = new Set(i);
                for (const t of (0,
                ho.sortSources)(e)) {
                    if ((0,
                    ct.isLineTool)(t) && null !== n) {
                        const e = (0,
                        ho.sortSources)(n.lineTools().filter((e=>!a.has(e) || e === t)));
                        r = Xa(r, {
                            bringForwardEnabled: t !== e[e.length - 1],
                            bringToFrontEnabled: t !== e[e.length - 1],
                            sendBackwardEnabled: t !== e[0],
                            sendToBackEnabled: t !== e[0]
                        });
                        continue
                    }
                    const e = (0,
                    s.ensureNotNull)(this._model().paneForSource(t)).sourcesByGroup().allExceptSpecialSources();
                    if (0 === e.length)
                        continue;
                    const i = t.zorder()
                      , o = e[0].zorder()
                      , l = e[e.length - 1].zorder();
                    r = Xa(r, {
                        bringForwardEnabled: i !== l,
                        bringToFrontEnabled: i !== l,
                        sendBackwardEnabled: i !== o,
                        sendToBackEnabled: i !== o
                    })
                }
                return r
            }
            sendToBack(e) {
                if (!this.availableZOrderOperations(e).sendToBackEnabled)
                    throw new Error("Send to back operation is unavailable");
                let t = null;
                const i = e[0];
                if ((0,
                ct.isLineTool)(i)) {
                    const s = this._model().lineToolsGroupModel().groupForLineTool(i);
                    if (null !== s) {
                        const i = s.lineTools();
                        t = new No(this.model(),(0,
                        ho.sortSources)(e),i[0])
                    }
                }
                null === t && (t = new Lo(this.model(),(0,
                ho.sortSources)(e))),
                this._pushUndoCommand(t),
                this.emitEvent("changeZOrder", [e])
            }
            bringToFront(e) {
                if (!this.availableZOrderOperations(e).bringToFrontEnabled)
                    throw new Error("Bring to front operation is unavailable");
                let t = null;
                const i = e[0];
                if ((0,
                ct.isLineTool)(i)) {
                    const s = this._model().lineToolsGroupModel().groupForLineTool(i);
                    if (null !== s) {
                        const i = s.lineTools();
                        t = new ko(this.model(),(0,
                        ho.sortSources)(e),i[i.length - 1])
                    }
                }
                null === t && (t = new Ao(this.model(),(0,
                ho.sortSources)(e))),
                this._pushUndoCommand(t),
                this.emitEvent("changeZOrder", [e])
            }
            sendBackward(e) {
                if (!this.availableZOrderOperations(e).sendBackwardEnabled)
                    throw new Error("Send backward operation is unavailable");
                const t = jr.format({
                    title: (0,
                    po.getTranslatedStringForSource)(So.TitleDisplayTarget.StatusLine, e[0])
                });
                this._sendBackOrBringForward(t, (0,
                ho.sortSources)(e), ((e,t)=>new Ro(this.model(),e,t)))
            }
            bringForward(e) {
                if (!this.availableZOrderOperations(e).bringForwardEnabled)
                    throw new Error("Bring forward operation is unavailable");
                const t = qr.format({
                    title: (0,
                    po.getTranslatedStringForSource)(So.TitleDisplayTarget.StatusLine, e[0])
                });
                this._sendBackOrBringForward(t, (0,
                ho.sortSources)(e), ((e,t)=>new Vo(this.model(),e,t)))
            }
            insertAfter(e, t) {
                e = (0,
                ho.sortSources)(e);
                const i = Xr.format({
                    title: (0,
                    po.getTranslatedStringForSource)(So.TitleDisplayTarget.StatusLine, e[0]),
                    target: (0,
                    po.getTranslatedStringForSource)(So.TitleDisplayTarget.StatusLine, t)
                });
                this._insertAfterOrBefore(i, e, t, (()=>new ko(this.model(),e,t)))
            }
            insertBefore(e, t) {
                e = (0,
                ho.sortSources)(e);
                const i = Kr.format({
                    title: (0,
                    po.getTranslatedStringForSource)(So.TitleDisplayTarget.StatusLine, e[0]),
                    target: (0,
                    po.getTranslatedStringForSource)(So.TitleDisplayTarget.StatusLine, t)
                });
                this._insertAfterOrBefore(i, e, t, (()=>new No(this.model(),e,t)))
            }
            detachToRight(e, t) {
                (0,
                Ne.trackEvent)("Chart", "Move to new right scale");
                const i = ga.format({
                    title: (0,
                    po.getTranslatedStringForSource)(So.TitleDisplayTarget.StatusLine, e)
                })
                  , s = new Ln.MoveToNewPriceScaleUndoCommand(this.model(),e,t,"right",i);
                this._pushUndoCommand(s),
                this.emitEvent("moveSource", [e])
            }
            detachToLeft(e, t) {
                (0,
                Ne.trackEvent)("Chart", "Move to new left scale");
                const i = _a.format({
                    title: (0,
                    po.getTranslatedStringForSource)(So.TitleDisplayTarget.StatusLine, e)
                })
                  , s = new Ln.MoveToNewPriceScaleUndoCommand(this.model(),e,t,"left",i);
                this._pushUndoCommand(s),
                this.emitEvent("moveSource", [e])
            }
            detachNoScale(e, t) {
                (0,
                Ne.trackEvent)("Chart", "Make source no scale");
                const i = va.format({
                    title: (0,
                    po.getTranslatedStringForSource)(So.TitleDisplayTarget.StatusLine, e)
                })
                  , s = new Ln.MoveToNewPriceScaleUndoCommand(this.model(),e,t,"overlay",i);
                this._pushUndoCommand(s),
                this.emitEvent("moveSource", [e])
            }
            moveToScale(e, t, i, s, o) {
                (0,
                Ne.trackEvent)("Chart", "Move source to target scale"),
                this.beginUndoMacro(s);
                const n = new Ln.MoveToExistingPriceScaleUndoCommand(this.model(),e,t,i,s)
                  , r = o ? null : (0,
                Ks.sourceNewCurrencyOnPinningToPriceScale)(e, i, this._model())
                  , a = o ? null : (0,
                Gn.sourceNewUnitOnPinningToPriceScale)(e, i, this._model());
                this._pushUndoCommand(n),
                null !== r && this.setPriceScaleCurrency(i, r),
                null !== a && this.setPriceScaleUnit(i, a),
                this.endUndoMacro(),
                this.emitEvent("moveSource", [e])
            }
            setLinkingGroupIndex(e) {
                this._undoHistory.beginUndoMacro(Ga),
                this._pushUndoCommand(new br(this.model().linkingGroupIndex(),e,Ga)),
                this._model().setShouldBeSavedEvenIfHidden(!0),
                this._undoHistory.endUndoMacro()
            }
            startScrollPrice(e, t, i) {
                t.isAutoScale() || (this._initialPriceScrollState = t.state(),
                this._initialPriceScrollPos = i,
                this._model().startScrollPrice(e, t, i))
            }
            scrollPriceTo(e, t, i) {
                t.isAutoScale() || (this._initialPriceScrollState && this._initialPriceScrollPos && Math.abs(this._initialPriceScrollPos - i) > 20 && (this._pushUndoCommand(new ji(this.m_model,e,t,this._initialPriceScrollState,void 0,!1)),
                this._initialPriceScrollState = null,
                this._initialPriceScrollPos = null),
                this._model().scrollPriceTo(e, t, i))
            }
            endScrollPrice(e, t) {
                t.isAutoScale() || (this._initialPriceScrollState = null,
                this._initialPriceScrollPos = null,
                this._model().endScrollPrice(e, t))
            }
            startScrollTime(e) {
                const t = this.timeScale();
                this._initialTimeScrollState = {
                    rightOffset: t.rightOffset(),
                    barSpacing: t.barSpacing()
                },
                this._initialTimeScrollPos = e,
                this.model().startScrollTime(e)
            }
            scrollTimeTo(e) {
                null !== this._initialTimeScrollPos && null !== this._initialTimeScrollState && Math.abs(e - this._initialTimeScrollPos) > 20 && (this._pushUndoCommand(new zi(this.model(),this._initialTimeScrollState,Sa,!1)),
                this._initialTimeScrollPos = null,
                this._initialTimeScrollState = null),
                this.model().scrollTimeTo(e)
            }
            endScrollTime() {
                this.model().endScrollTime(),
                this._initialTimeScrollPos = null,
                this._initialTimeScrollState = null
            }
            startScaleTime(e) {
                const t = this.timeScale();
                this._initialTimeScaleState = {
                    rightOffset: t.rightOffset(),
                    barSpacing: t.barSpacing()
                },
                this.model().startScaleTime(e)
            }
            scaleTimeTo(e) {
                null !== this._initialTimeScaleState && this._initialTimeScaleState.barSpacing !== this.timeScale().barSpacing() && (this._pushUndoCommand(new zi(this.model(),this._initialTimeScaleState,fa,!0)),
                this._initialTimeScaleState = null),
                this.model().scaleTimeTo(e)
            }
            endScaleTime() {
                this.model().endScaleTime()
            }
            resetTimeScale() {
                this.changeTimeScale(ba, this.timeScale().resetAvailable().value()),
                this.model().resetTimeScale()
            }
            changeTimeScale(e, t=!0) {
                const i = this.timeScale()
                  , s = {
                    rightOffset: i.rightOffset(),
                    barSpacing: i.barSpacing()
                };
                this._pushUndoCommand(new zi(this.model(),s,e,t))
            }
            startScalePrice(e, t, i, s) {
                this._scalePriceInfo = {
                    priceScaleState: t.state(),
                    tryMergeConsecutiveScales: s
                },
                this.model().startScalePrice(e, t, i)
            }
            scalePriceTo(e, t, i) {
                this.model().scalePriceTo(e, t, i)
            }
            endScalePrice(e, t) {
                this.model().endScalePrice(e, t);
                const i = (0,
                s.ensureNotNull)(this._scalePriceInfo);
                (0,
                Ft.default)(i.priceScaleState, t.state()) || this._pushUndoCommand(new ji(this.model(),e,t,i.priceScaleState,i.tryMergeConsecutiveScales)),
                this._scalePriceInfo = null
            }
            startTwoPointsScalePrice(e, t, i, s, o) {
                this._scalePriceInfo = {
                    priceScaleState: t.state(),
                    tryMergeConsecutiveScales: o
                },
                this.model().startTwoPointsScalePrice(e, t, i, s)
            }
            twoPointsScalePriceTo(e, t, i, s) {
                this.model().twoPointsScalePriceTo(e, t, i, s)
            }
            endTwoPointsScalePrice(e, t) {
                this.model().endTwoPointsScalePrice(e, t);
                const i = (0,
                s.ensureNotNull)(this._scalePriceInfo);
                (0,
                Ft.default)(i.priceScaleState, t.state()) || this._pushUndoCommand(new ji(this.model(),e,t,i.priceScaleState,i.tryMergeConsecutiveScales)),
                this._scalePriceInfo = null
            }
            resetPriceScale(e, t) {
                const i = t.state();
                this.model().resetPriceScale(e, t),
                (0,
                Ft.default)(i, t.state()) || this._pushUndoCommand(new ji(this.m_model,e,t,i))
            }
            rearrangePanes(e, t) {
                const i = new Uo(this._model(),e,t);
                this._pushUndoCommand(i)
            }
            movePane(e, t) {
                const i = new Uo(this._model(),e,t);
                this._pushUndoCommand(i)
            }
            toggleCollapsedPane(e) {
                const t = this.panes().findIndex((t=>t === e));
                t < 0 || this._pushUndoCommand(new Zs(this._model(),t))
            }
            readOnly() {
                return this.m_model.readOnly()
            }
            checkIfFeatureAvailable(e, t) {
                const i = t.length > 0
                  , s = (0,
                Kn.isFundamentalStudyMetaInfo)(e)
                  , o = this.canCreateStudy({
                    id: e.id,
                    child: i,
                    fundamental: s
                });
                return !!o.success || (Ya(this.model(), o),
                !1)
            }
            async pasteSourceFromClip(e, t, i) {
                const o = t;
                if (!o || 0 === o.sources.length)
                    return null;
                const n = e || (0,
                s.ensureNotNull)(this.model().paneForSource(this.mainSeries()));
                if (!o.sources.some((e=>"drawing" !== e.type || null !== n.clipboardLineToolOwnerSource(e.source.id))))
                    return null;
                const r = Array.from(new Set(o.sources.filter(qs.isLineToolClipboardData).map((e=>e.source.type))));
                await Promise.all(r.map((e=>(0,
                ct.initLineTool)(e)))),
                this.beginUndoMacro(Ta.format({
                    title: o.title
                }));
                let a = 0;
                const l = []
                  , c = [];
                for (const t of o.sources)
                    if ("drawing" === t.type && null !== n.clipboardLineToolOwnerSource(t.source.id)) {
                        const e = this.pasteLineTool(n, t);
                        a < 5 && (es(e),
                        a += 1),
                        c.push(e),
                        l.push(e)
                    } else
                        "study" === t.type && t.source && t.source.metaInfo && this.checkIfFeatureAvailable(new Fs.StudyMetaInfo(t.source.metaInfo), []) && l.push(this.pasteStudy(t, i ? e : void 0));
                return c.length && this.selectionMacro((e=>{
                    e.clearSelection(),
                    c.forEach((t=>{
                        e.addSourceToSelection(t, null)
                    }
                    ))
                }
                )),
                this.endUndoMacro(),
                l
            }
            pasteLineTool(e, t, i, s) {
                t.source.state.intervalsVisibilities = (0,
                ur.mergeIntervalVisibilitiesDefaults)(t.source.state.intervalsVisibilities),
                (0,
                ur.makeIntervalsVisibilitiesVisibleAtInterval)(t.source.state.intervalsVisibilities, this.model().mainSeries().intervalObj());
                const o = new Mn(this.model(),t,e,i,s);
                this._pushUndoCommand(o);
                const n = o.source();
                return o.needCopyToOtherCharts() && this._model().copyToOtherCharts([n], !0),
                this.selectionMacro((e=>{
                    e.clearSelection(),
                    e.addSourceToSelection(n, null)
                }
                )),
                n
            }
            pasteStudy(e, t) {
                const i = new Rn(this.model(),e,null == t ? void 0 : t.id());
                this._pushUndoCommand(i);
                const o = (0,
                s.ensureNotNull)(i.state()).id;
                return (0,
                Me.emit)("study_event", o, "paste_study"),
                (0,
                s.ensureNotNull)(this._model().dataSourceForId(o))
            }
            removePane(e) {
                const t = this.m_model.panes()[e].dataSources().slice();
                this.removeSources(t, !1, xa)
            }
            createPane(e) {
                return this.m_model.createPane(e)
            }
            setPriceScaleCurrency(e, t) {
                const i = new In.SetPriceScaleCurrencyUndoCommand(this.m_model,e,t,ra);
                this._pushUndoCommand(i)
            }
            setPriceScaleUnit(e, t) {
                const i = new An.SetPriceScaleUnitUndoCommand(this.m_model,e,t,aa);
                this._pushUndoCommand(i)
            }
            setSymbol(e, t) {
                e.symbolSameAsResolved(t) || this._pushUndoCommand(new Dn(e,t,this._chartWidget))
            }
            setResolution(e, t) {
                zs.Interval.isEqual(e.interval(), t) || this._pushUndoCommand(new Sr(e,t,this._chartWidget))
            }
            hideMaximizedPaneIfRequired() {
                this._chartWidget.isMaximizedPane() && this._chartWidget.toggleMaximizePane(null)
            }
            syncCrosshair(e, t, i) {
                this._chartWidget.chartWidgetCollection().syncCrosshair(e, this._chartWidget.id(), t, i)
            }
            loadingScreen() {
                return this._chartWidget.screen
            }
            chartLoadTheme(e, t, i) {
                const s = new _r(this.model(),e,t);
                i ? s.redo() : this._pushUndoCommand(s)
            }
            isJustClonedChart() {
                return this._chartWidget.isJustClonedChart()
            }
            isMultipleLayout() {
                return this._chartWidget.isMultipleLayout()
            }
            addPaneStretchFactorUndoCommand(e, t, i, s) {
                const o = new On(this.model(),e,t,i,s);
                this._pushUndoCommand(o)
            }
            applyPreferences(e) {
                {
                    const t = new Hr(this.m_model,e);
                    this._pushUndoCommand(t)
                }
            }
            paneForSource(e) {
                return this.m_model.paneForSource(e)
            }
            destroy() {
                this.m_model.destroy()
            }
            moveSelectedToolsLeft() {
                return this._moveSelectedTools(2)
            }
            moveSelectedToolsUp() {
                return this._moveSelectedTools(0)
            }
            moveSelectedToolsRight() {
                return this._moveSelectedTools(3)
            }
            moveSelectedToolsDown() {
                return this._moveSelectedTools(1)
            }
            insertStudyWithoutCheck(e, t, i, s) {
                return this._insertStudy(e, t, {}, !1, [], void 0, void 0, void 0, void 0, null != i ? i : null, void 0, s)
            }
            saveLineToolState(e, t) {
                this._pushUndoCommand(new lo(this.m_model,[e],t))
            }
            resetScales() {
                this._model().stopTimeScaleAnimation(),
                this.beginUndoMacro(ya),
                this.resetTimeScale();
                for (const e of this.m_model.panes()) {
                    for (const t of e.leftPriceScales())
                        this.resetPriceScale(e, t);
                    for (const t of e.rightPriceScales())
                        this.resetPriceScale(e, t)
                }
                this.endUndoMacro(),
                this.m_model.recalculateAllPanes((0,
                as.viewportChangeEvent)())
            }
            shareLineTools(e, t) {
                const i = 0 === t ? Ha : 1 === t ? za : Ua;
                this.withMacro(i, (()=>{
                    0 === t && this.unlinkLines(e),
                    e.forEach((i=>{
                        const s = this.model().lineToolsGroupModel().groupForLineTool(i);
                        if (s) {
                            s.lineTools().every((t=>e.includes(t))) || this.lineToolsGroupController().excludeLineToolFromGroup(s, i)
                        }
                        this._pushUndoCommand(new an(i,t,this.model(),null))
                    }
                    ))
                }
                ))
            }
            canCreateStudy(e, t) {
                return this.model().chartApi().canCreateStudy(e, t)
            }
            chartWidgetCollectionLock() {
                return this._chartWidget.chartWidgetCollection().lock
            }
            onSymbolIntervalChanged() {
                return this.m_model.onSymbolIntervalChanged()
            }
            paneBeingCreatedLineOn() {
                return this.m_model.paneBeingCreatedLineOn()
            }
            invalidate(e) {
                this.m_model.invalidate(e)
            }
            setWidth(e) {
                this.m_model.setWidth(e)
            }
            setPaneHeight(e, t) {
                this.m_model.setPaneHeight(e, t)
            }
            dataSourceForId(e) {
                return this.m_model.dataSourceForId(e)
            }
            lineBeingEdited() {
                return this.m_model.lineBeingEdited()
            }
            sourcesBeingMoved() {
                return this.m_model.sourcesBeingMoved()
            }
            gridSource() {
                return this.m_model.gridSource()
            }
            watermarkSource() {
                return this.m_model.watermarkSource()
            }
            mainSeriesScaleRatioProperty() {
                return this.m_model.mainSeriesScaleRatioProperty()
            }
            setHoveredSource(e, t) {
                this.m_model.setHoveredSource(e, t)
            }
            setCurrentPosition(e, t, i, s) {
                this.m_model.setCurrentPosition(e, t, i, s)
            }
            setAndSaveCurrentPosition(e, t, i, s) {
                this.m_model.setAndSaveCurrentPosition(e, t, i, s)
            }
            version() {
                return this.m_model.version()
            }
            restart() {
                this.m_model.restart()
            }
            disconnect() {
                this.m_model.disconnect()
            }
            calculateDefaultTags() {
                return this.m_model.calculateDefaultTags()
            }
            _model() {
                return this.m_model
            }
            _pushUndoCommand(e) {
                this._undoHistory.pushUndoCommand(e)
            }
            _mergeUnmergeSource(e, t) {
                this.beginUndoMacro(t.text());
                const i = (0,
                s.ensureNotNull)(this._model().paneForSource(e))
                  , o = new Set(i.sourcesByGroup().lineSources().filter((t=>t.ownerSource() === e)));
                this._model().lineToolsGroupModel().groups().filter((e=>{
                    const t = e.lineTools().some((e=>o.has(e)))
                      , i = e.lineTools().some((e=>!o.has(e)));
                    return t && i
                }
                )).forEach((e=>{
                    this._pushUndoCommand(new ro.ExcludeLineToolsFromGroupUndoCommand(this._model(),e,e.lineTools()))
                }
                )),
                this._pushUndoCommand(t),
                this.endUndoMacro()
            }
            _insertStudy(e, t, i, s, o, n, r, a, l, c, d, u) {
                const h = Pa.format({
                    title: e.description
                })
                  , p = new Fn.InsertStudyCommand({
                    chartModel: this.model(),
                    studyMetaInfo: e,
                    inputs: t,
                    props: i,
                    addAsOverlay: s,
                    parentSources: o,
                    preferredPriceScale: n,
                    allowChangeCurrency: r,
                    allowChangeUnit: a,
                    paneSize: l,
                    targetZOrder: null != c ? c : null,
                    targetScaleMode: d,
                    studyId: u,
                    undoText: h
                });
                return this._pushUndoCommand(p),
                p.insertedStudy()
            }
            _storeFailedStub(e) {
                const t = Pa.format({
                    title: e.title()
                });
                this.beginUndoMacro(t);
                const i = new wr(this.model(),e,t);
                this._pushUndoCommand(i),
                this.endUndoMacro()
            }
            async _processSpecialLineToolsContents(e, t, i) {
                if (t = t || await e.read(),
                window.user.id && t.files) {
                    const e = Array.from(t.files).find(Yi.blobImageFilter);
                    if (e) {
                        const t = URL.createObjectURL(e)
                          , o = (0,
                        Yi.uploadImage)(e);
                        return void 0 === i && (i = (0,
                        s.ensureNotNull)(this._model().paneForSource(this.mainSeries()))),
                        this.pasteImageAsLineTool(o, t, i),
                        void await o
                    }
                }
                t.text && (window.user.id && !qa && (0,
                jn.isTwitterUrl)(t.text) ? (0,
                jn.createTweetLineToolByUrl)(t.text, this, !0) : window.user.id && (0,
                Xn.isIdeaUrl)(t.text) ? (0,
                Xn.createIdeaLineToolByUrl)(t.text, this, !0) : function(e, t) {
                    if (null === t.timeScale().logicalRange())
                        return null;
                    const i = t.mainSeries()
                      , o = i.priceScale()
                      , n = t.timeScale()
                      , r = (0,
                    s.ensureNotNull)(t.model().paneForSource(i))
                      , a = (0,
                    s.ensureNotNull)((0,
                    s.ensureNotNull)(o.mainSource()).firstValue())
                      , l = n.coordinateToIndex(t.timeScale().width() / 2)
                      , c = r.height() / 2
                      , d = {
                        price: o.coordinateToPrice(c, a),
                        time_t: (0,
                        s.ensureNotNull)(n.indexToTimePoint(l)),
                        offset: 0
                    }
                      , u = r.newLineToolZOrder(!0)
                      , h = qn.LineToolText.createProperties().state();
                    h.text = e,
                    h.interval = i.interval();
                    const p = {
                        type: "drawing",
                        source: {
                            id: (0,
                            Pe.randomHashN)(6),
                            zorder: u,
                            type: "LineToolText",
                            state: h,
                            symbol: i.symbol(),
                            ownerSource: i.id(),
                            points: [d]
                        },
                        geometry: [],
                        modelId: t.model().id(),
                        centeredOnChart: !0
                    }
                      , m = t.pasteLineTool(r, p, !1, !1);
                    ke.setValue("hint.pasteText", !0, {
                        forceFlush: !0
                    })
                }(t.text, this))
            }
            _insertAfterOrBefore(e, t, i, o) {
                const n = (0,
                s.ensureNotNull)(this._model().paneForSource(i));
                if (t.some((e=>(0,
                ct.isLineTool)(e) && this._model().paneForSource(e) !== n)))
                    throw new Error("Cannot insert line tool after target on another pane");
                this.beginUndoMacro(e),
                t.forEach((e=>{
                    (0,
                    s.ensureNotNull)(this.model().paneForSource(e)) !== n && this.mergeToPane(e, n)
                }
                ));
                const r = o();
                this._pushUndoCommand(r),
                this.emitEvent("changeZOrder", [t]),
                this.endUndoMacro()
            }
            _sendBackOrBringForward(e, t, i) {
                const o = new Map;
                t.forEach((e=>{
                    const t = (0,
                    s.ensureNotNull)(this._model().paneForSource(e))
                      , i = o.get(t) || [];
                    i.push(e),
                    o.set(t, i)
                }
                )),
                this.beginUndoMacro(e),
                o.forEach(((e,t)=>{
                    this._pushUndoCommand(i(t, e))
                }
                )),
                this.endUndoMacro(),
                this.emitEvent("changeZOrder", [t])
            }
            _moveSelectedTools(e) {
                const t = this.model().selection().lineDataSources();
                if (0 === t.length)
                    return !1;
                if ((0,
                qt.lockDrawings)().value())
                    return !0;
                const i = this.timeScale().visibleBarsStrictRange();
                if (null === i)
                    return !1;
                const s = function(e) {
                    const t = new Map;
                    for (const i of e) {
                        const e = i.ownerSource();
                        if (null === e)
                            continue;
                        let s = t.get(e);
                        if (void 0 === s) {
                            const o = e.priceScale()
                              , n = e.priceStep()
                              , r = e.firstValue();
                            if (null === o || null === n || null === r)
                                continue;
                            if (null === o.priceRange())
                                continue;
                            s = {
                                sources: [],
                                priceScale: o,
                                priceStep: n,
                                startPrice: i.points()[0].price,
                                firstValue: r
                            },
                            t.set(e, s)
                        }
                        s.sources.push(i)
                    }
                    return t
                }(t);
                if (0 === s.size)
                    return !1;
                this.beginUndoMacro(sa);
                const n = i.firstBar()
                  , r = this.timeScale().indexToCoordinate(n)
                  , a = n + (3 === e ? 1 : 2 === e ? -1 : 0)
                  , l = this.timeScale().indexToCoordinate(a);
                return qt.isDirectionalMovementActive.setValue(!0),
                s.forEach((t=>{
                    const {startPrice: i, priceStep: s, priceScale: c, firstValue: d} = t
                      , u = i + (0 === e ? s : 1 === e ? -s : 0)
                      , h = c.priceToCoordinate(i, d)
                      , p = c.priceToCoordinate(u, d)
                      , m = {
                        logical: {
                            index: n,
                            price: i
                        },
                        screen: new o.Point(r,h)
                    }
                      , g = {
                        logical: {
                            index: a,
                            price: u
                        },
                        screen: new o.Point(l,p)
                    };
                    this.startMovingSources(t.sources, m, null),
                    this.moveSources(g),
                    this.endMovingSource(!1, !0)
                }
                )),
                qt.isDirectionalMovementActive.setValue(!1),
                this.endUndoMacro(),
                !0
            }
            _restoreStudyFactoryDefaults(e) {
                const t = new dr(this.m_model,e);
                this._pushUndoCommand(t)
            }
            _restoreLineToolFactoryDefaults(e) {
                this.beginUndoMacro(oa),
                this.saveLineToolState(e, oa);
                const t = new ar(this.m_model,e.properties(),oa);
                this._pushUndoCommand(t),
                this.saveLineToolState(e, oa),
                this.endUndoMacro(),
                this.model().updateSource(e)
            }
            _removeAllDrawingToolsImpl(e) {
                this.selectionMacro((()=>{
                    this.lineBeingCreated() && this.cancelCreatingLine();
                    this.dataSources().filter(ct.isLineTool).filter((e=>e.isActualSymbol() && e.isUserDeletable())).filter((t=>!e || e === t.toolname)).forEach((e=>this.removeSource(e, !1)))
                }
                ), !0)
            }
            _removeAllStudiesImpl() {
                const e = this.dataSources()
                  , t = e.filter(rt.isStudy).filter((e=>!e.isChildStudy() && e.removeByRemoveAllStudies()))
                  , i = e.filter(rt.isStudyStub);
                t.concat(i).forEach((e=>this.removeSource(e, !1)))
            }
        }
        var $a = i(850723)
          , Ja = i(359663)
          , Qa = i(709404)
          , el = i(79200);
        class tl {
            constructor() {
                this._session = {
                    startDate: (new Date).toISOString(),
                    url: window.location.href,
                    entries: []
                }
            }
            addPersistentLogEntry(e, t, i) {
                this._session.entries.push({
                    date: (new Date).toISOString(),
                    level: t,
                    message: e,
                    category: i
                })
            }
            async getLastSessions(e) {
                return [this._session]
            }
            pendingEntries() {
                return this._session.entries
            }
        }
        var il = i(927094)
          , sl = i(779923)
          , ol = i(525714)
          , nl = i(786559);
        const rl = r.t(null, void 0, i(22112));
        function al(e) {
            if ("replaced_to_exchange" === e.type)
                return {
                    text: rl,
                    warningIcon: nl,
                    warningType: "notaccurate",
                    solutionId: Q.solutionIds.WHAT_IS_CBOE_BZX_EXCHANGE
                }
        }
        class ll {
            constructor(e) {
                this._activeHint = null,
                this._deferredPromise = null,
                this._chart = e;
                e.model().mainSeries().dataEvents().symbolResolved().subscribe(this, this._onSymbolResolved)
            }
            destroy() {
                this._destroyActiveHint();
                this._chart.model().mainSeries().dataEvents().symbolResolved().unsubscribe(this, this._onSymbolResolved)
            }
            _destroyActiveHint() {
                null !== this._activeHint && (this._activeHint.destroy(),
                this._activeHint = null),
                this._deferredPromise = null
            }
            async _createHint() {
                if (null === this._deferredPromise) {
                    const e = (0,
                    Ve.createDeferredPromise)();
                    this._deferredPromise = e,
                    Promise.all([i.e(29328), i.e(44524), i.e(3062), i.e(2190), i.e(32227), i.e(83129)]).then(i.bind(i, 629981)).then((t=>{
                        e.resolve(new t.ChartWarningHintRenderer(this._chart))
                    }
                    ))
                }
                return this._deferredPromise.promise
            }
            _onSymbolResolved(e) {
                const t = function(e) {
                    const t = (0,
                    ol.firstReplacedByBatsExchange)(e);
                    return null !== t ? {
                        type: "replaced_to_exchange",
                        exchange: t
                    } : null
                }(e)
                  , i = t && function(e) {
                    return `warning.noSubsc_${e.exchange}`
                }(t);
                if (null === t || null === i || Boolean(ke.getBool(i)))
                    return void this._destroyActiveHint();
                const s = {
                    ...al(t),
                    onClose: ()=>{
                        ke.setValue(i, !0, {
                            forceFlush: !0
                        }),
                        this._destroyActiveHint()
                    }
                };
                null !== this._activeHint ? this._activeHint.show(s) : this._createHint().then((e=>{
                    this._activeHint = e,
                    this._activeHint.show(s)
                }
                ))
            }
        }
        var cl = i(475365)
          , dl = i(716004)
          , ul = i(547777)
          , hl = i(104436);
        var pl = i(67302)
          , ml = i(745402)
          , gl = i(390675);
        const _l = r.t(null, void 0, i(747773));
        class vl extends class {
            constructor(e) {
                this._lastResolvedSymbol = null,
                this._chart = e,
                this._chart.withModel(this, this._connectToModel)
            }
            _getPopupContent() {
                const e = this._getProSymbol()
                  , t = new URL("https://www.tradingview.com/chart/");
                t.searchParams.append("symbol", e),
                t.searchParams.append("utm_source", "www.tradingview.com"),
                t.searchParams.append("utm_medium", "widget"),
                t.searchParams.append("utm_campaign", "chart"),
                t.searchParams.append("utm_term", e);
                return _l.format({
                    linkStart: `<a target="_blank" href="${t.toString()}">`,
                    linkEnd: "</a>"
                })
            }
            _onPopupClosed() {
                const e = this._chart.defaultSymbol()
                  , t = this._getSymbol();
                let i;
                i = this._lastResolvedSymbol ? this._lastResolvedSymbol : e !== t ? e : "AAPL",
                this._chart.setSymbol(i)
            }
            _getProSymbol() {
                return this._chart.model().mainSeries().proSymbol()
            }
            _getSymbol() {
                return this._chart.model().mainSeries().actualSymbol()
            }
            _connectToModel() {
                const e = this._chart.model().mainSeries();
                e.dataEvents().symbolResolved().subscribe(this, this._onSymbolResolved),
                e.dataEvents().symbolGroupNotPermitted().subscribe(this, this._onSymbolGroupNotPermitted),
                e.dataEvents().symbolNotPermitted().subscribe(this, this.show)
            }
            _onSymbolResolved() {
                this._lastResolvedSymbol = this._getSymbol()
            }
            _onSymbolGroupNotPermitted() {
                this.show()
            }
        }
        {
            show() {
                (0,
                il.createNoticeDialog)({
                    content: this._getPopupContent()
                }).then((e=>{
                    e.on("destroy", this._onPopupClosed.bind(this)),
                    e.open()
                }
                ))
            }
        }
        var Sl = i(242238)
          , fl = i(242095);
        var bl = i(438036)
          , yl = (i(518439),
        i(290484))
          , Cl = i(523351)
          , wl = i(895370)
          , Tl = i(198303)
          , Pl = i(113610);
        const xl = (0,
        n.getLogger)("Chart.LinkKeyResolver");
        class Ml {
            constructor(e, t, i) {
                this._pendingRequests = new Map,
                this._startRequestingDebounced = (0,
                yl.default)((()=>this._startNextRequest()), 500),
                this._layoutId = e,
                this._chartId = t,
                this._ownerSourceId = i
            }
            resolveLinkKey(e, t, i) {
                var s;
                const o = function(e, t) {
                    return JSON.stringify([e, t])
                }(e, i)
                  , n = null !== (s = this._pendingRequests.get(o)) && void 0 !== s ? s : new Map;
                if (n.has(t))
                    return n.get(t).promise;
                const r = (0,
                Ve.createDeferredPromise)();
                return n.set(t, r),
                this._pendingRequests.set(o, n),
                this._startRequestingDebounced(),
                r.promise
            }
            async _startNextRequest() {
                if (0 === this._pendingRequests.size)
                    return;
                const e = await (0,
                Pl.getChartStorage)()
                  , t = this._pendingRequests.entries().next().value
                  , {symbol: i, brokerName: s} = function(e) {
                    const t = JSON.parse(e);
                    return {
                        symbol: t[0],
                        brokerName: t[1]
                    }
                }(t[0])
                  , o = t[1]
                  , n = {
                    requestType: "mainSeriesLineTools",
                    seriesSourceId: this._ownerSourceId,
                    symbol: i,
                    brokerName: s,
                    sharingMode: 0
                };
                try {
                    const t = await e.loadLineToolsAndGroups(this._layoutId, this._chartId, n, i);
                    null !== t && null !== t.sources && (t.sources.forEach(((e,t)=>{
                        if (null === e)
                            return;
                        const i = e.state.linkKey;
                        if (!i)
                            return;
                        const s = o.get(i);
                        null == s || s.resolve(e.id),
                        o.delete(i)
                    }
                    )),
                    t.serverRequestId && console.log(`PROCESSED:${t.serverRequestId}`))
                } catch (e) {
                    xl.logError(`Error requesting line tools: ${e}`)
                }
                o.forEach((e=>{
                    e.resolve(null)
                }
                )),
                this._pendingRequests.delete(t[0]),
                await this._startNextRequest()
            }
        }
        var Il = i(283323)
          , Al = i(622864);
        const Ll = [0, 1, 2]
          , El = (0,
        n.getLogger)("LineToolsSynchronizer");
        function kl(e, t) {
            return {
                id: e.id,
                name: e.name().value(),
                symbol: e.symbol(),
                currencyId: e.currencyId(),
                unitId: e.unitId()
            }
        }
        function Dl(e, t, i) {
            const s = new Map
              , o = new Set(null == i ? void 0 : i.keys());
            return e.forEach(((e,n)=>{
                const r = !i || i.has(n);
                (e.timestamp > t || !r) && (s.set(n, e),
                o.delete(n))
            }
            )),
            {
                stillInvalidated: s,
                validated: Array.from(o)
            }
        }
        function Nl(e) {
            return (0,
            ct.isLineTool)(e) || (0,
            Il.isStudyLineToolStub)(e)
        }
        const Bl = /(\w+)\/(\w+)\/(\w+)/;
        class Rl {
            constructor(e, t, i) {
                this._invalidatedLineToolsAndStudyStubs = new Map,
                this._allLineToolsAndStudyStubs = new Map,
                this._originalLineToolSharingMode = new Map,
                this._invalidatedLineToolGroups = new Map,
                this._originalLineToolGroupsSharingMode = new Map,
                this._ignoreInvalidatingEventsDepth = 0,
                this._saveChartService = null,
                this._debouncedSave = (0,
                yl.default)((()=>this._saveInvalidatedIfRequired(!1)), 500),
                this._currentlyLoadedSymbol = new Map,
                this._linkKeyResolver = null,
                this._brokerName = "",
                this._hasChanges = new h.WatchedValue(!1),
                this._lastBanTime = null,
                this._invalidateViaSync = 0,
                this._savingAbortControllersBySharingMode = new Map,
                this._onChangeAutosave = e=>{
                    e && this._debouncedSave()
                }
                ,
                this._origin = e,
                this._chartModel = t,
                this._options = i,
                this._assignAllLineTools(this._chartModel.panes()),
                this._chartModel.panesCollectionChanged().subscribe(this, this._processPanesCollectionChanged.bind(this)),
                this._chartModel.dataSourceCollectionChanged().subscribe(this, this._processDataSourceCollectionChanged.bind(this)),
                this._chartModel.lineToolsGroupModel().onChanged().subscribe(this, this._processLineToolsGroupModelChanged.bind(this)),
                this._chartModel.mainSeries().dataEvents().symbolResolved().subscribe(this, this._onSymbolResolved.bind(this)),
                this._chartModel.sourcePropertiesChanged().subscribe(this, this._processPropertiesChanged.bind(this)),
                this._chartModel.sourceZOrderChanged().subscribe(this, this._processPropertiesChanged.bind(this)),
                this._linkKeyResolver = new Ml(e.layoutId,e.chartId,t.mainSeries().id()),
                this._brokerIdSession = new Ja.FeatureToggleWatchedValue("broker_id_session",!1),
                Ll.forEach((e=>{
                    0 === e && this._loadAndMergeLineToolsOnStudies(e, !1),
                    this._loadAndMergeLineToolsWithoutSymbol(e, !1)
                }
                )),
                (0,
                l.onWidget)() || window.loginStateChange.subscribe(this, (()=>{
                    window.is_authenticated && this.reloadAllLineTools()
                }
                ))
            }
            destroy() {
                (0,
                l.onWidget)() || window.loginStateChange.unsubscribeAll(this),
                this._brokerIdSession.destroy(),
                this._chartModel.mainSeries().dataEvents().symbolResolved().unsubscribeAll(this),
                this._chartModel.sourcePropertiesChanged().unsubscribeAll(this),
                this._chartModel.sourceZOrderChanged().unsubscribeAll(this),
                this._chartModel.panesCollectionChanged().unsubscribeAll(this),
                this._chartModel.dataSourceCollectionChanged().unsubscribeAll(this),
                this._chartModel.lineToolsGroupModel().onChanged().unsubscribeAll(this)
            }
            reloadAllLineTools() {
                this._currentlyLoadedSymbol.clear(),
                Ll.forEach((e=>{
                    0 === e && this._loadAndMergeLineToolsOnStudies(e, !0),
                    this._loadAndMergeLineToolsWithoutSymbol(e, !0)
                }
                ));
                const e = this._chartModel.mainSeries().symbolInfo();
                e && this._onSymbolResolved(e)
            }
            hasChanges() {
                return this._hasChanges
            }
            setSaveChartService(e) {
                this._saveChartService && this._saveChartService.autoSaveEnabled().unsubscribe(this._onChangeAutosave),
                this._saveChartService = e,
                this._saveChartService.autoSaveEnabled().subscribe(this._onChangeAutosave)
            }
            prepareDTO(e=!1) {
                const t = new Map;
                return Ll.forEach((i=>{
                    t.set(i, this._prepareDTOItem(e, i))
                }
                )),
                t
            }
            getDTO(e=0, t=!1, i=!1) {
                return i && this.invalidateAll(),
                this._prepareDTOItem(t, e)
            }
            async applyDTO(e, t=0) {
                this.resetInvalidated(Date.now().valueOf(), e, t),
                await this._applyLineToolsAndGroupsDTO(e, t)
            }
            markAsValidatedBecauseOfSavingToContent(e) {
                this._invalidatedLineToolsAndStudyStubs.forEach((t=>{
                    t.savedToChartContent = e
                }
                )),
                this._invalidatedLineToolGroups.forEach((t=>{
                    t.savedToChartContent = e
                }
                )),
                this._recalculateHasChanges()
            }
            resetInvalidated(e, t, i) {
                const s = (e,t,s,o)=>{
                    if (!s.has(o) || s.get(o))
                        s.has(o) && t(o, i);
                    else {
                        const s = e.get(o);
                        s && (s === i ? t(o, null) : 0 === i && t(o, s))
                    }
                }
                ;
                if (null === t.sources)
                    return;
                const {groups: o, sources: n, lineToolsToValidate: r, groupsToValidate: a} = t
                  , l = Dl(this._invalidatedLineToolsAndStudyStubs, e, new Set(null != r ? r : n.keys()));
                this._invalidatedLineToolsAndStudyStubs = l.stillInvalidated,
                l.validated.forEach(s.bind(this, this._originalLineToolSharingMode, this._setOriginalLineToolSharingMode.bind(this), n));
                const c = Dl(this._invalidatedLineToolGroups, e, new Set(null != a ? a : o.keys()));
                l.validated.forEach(s.bind(this, this._originalLineToolGroupsSharingMode, this._setOriginalLineToolGroupsSharingMode.bind(this), o)),
                this._invalidatedLineToolGroups = c.stillInvalidated,
                Array.from(n.keys()).forEach((e=>{
                    const t = this._chartModel.dataSourceForId(e);
                    t && null === t.serverUpdateTime() && t.setServerUpdateTime((new Date).valueOf())
                }
                )),
                this._recalculateHasChanges()
            }
            applyLineToolUpdateNotification(e, t) {
                var i;
                const s = function(e) {
                    const t = Bl.exec(e);
                    return 4 === (null == t ? void 0 : t.length) ? {
                        layoutId: t[1],
                        chartId: t[2],
                        clientId: t[3]
                    } : {
                        layoutId: "",
                        chartId: "",
                        clientId: e
                    }
                }(null !== (i = e.clientId) && void 0 !== i ? i : "");
                s.clientId === this._origin.clientId && s.chartId === this._origin.chartId || (void 0 !== e.symbol && null === e.sources ? this._withoutInvalidating((()=>{
                    const i = this._chartModel.dataSources().filter(ct.isLineTool).filter((i=>i.sharingMode().value() === t && i.symbol() === e.symbol));
                    i.length > 0 && this._chartModel.undoModel().removeSources(i, !0, null)
                }
                )) : this._applyLineToolsAndGroupsDTO(e, t, s))
            }
            startApplyingLineToolUpdateNotification() {
                this._ignoreInvalidatingEventsDepth++
            }
            endApplyingLineToolUpdateNotification() {
                this._ignoreInvalidatingEventsDepth--,
                this._ignoreInvalidatingEventsDepth < 0 && (El.logError("Logic error, startApplyingLineToolUpdateNotification/endApplyingLineToolUpdateNotification mismatch, autofixing"),
                this._ignoreInvalidatingEventsDepth = 0)
            }
            applyAlertIdByExternalSource(e, t) {
                this._withoutInvalidating((()=>{
                    const i = this._chartModel.dataSourceForId(e);
                    i && (0,
                    ct.isLineTool)(i) && i.setAlert(t)
                }
                ))
            }
            deleteAlertByExternalSource(e) {
                this._withoutInvalidating((()=>{
                    const t = this._chartModel.dataSourceForId(e);
                    t && (0,
                    ct.isLineTool)(t) && t.removeAlert()
                }
                ))
            }
            async markSyncedLineToolAsDeleted(e, t) {
                if (this._linkKeyResolver) {
                    const i = await this._linkKeyResolver.resolveLinkKey(t, e, this._brokerName);
                    if (null !== i) {
                        const t = (0,
                        ct.lineToolByLinkKey)(this._chartModel, e);
                        null === t ? this._invalidateLineToolOrStudyStub(i, performance.now()) : this._withoutInvalidating((()=>{
                            const e = (0,
                            s.ensureNotNull)(this._chartModel.paneForSource(t))
                              , i = this._allLineToolsAndStudyStubs.get(e.id()) || new Map;
                            t.detachAlert(),
                            this._chartModel.removeSource(t),
                            i.delete(t.id())
                        }
                        )),
                        this._debouncedSave()
                    }
                    return i
                }
                return null
            }
            invalidateAll() {
                const e = performance.now();
                this._allLineToolsAndStudyStubs.forEach((t=>{
                    t.forEach(((t,i)=>{
                        this._invalidateLineToolOrStudyStub(i, e)
                    }
                    ))
                }
                )),
                this._chartModel.lineToolsGroupModel().groupsForAllSymbols().forEach((t=>{
                    this._invalidateLineToolGroup(t.id, e)
                }
                )),
                this.markAsValidatedBecauseOfSavingToContent(!0)
            }
            executeSyncedAction(e) {
                this._invalidateViaSync += 1;
                try {
                    e()
                } finally {
                    this._invalidateViaSync -= 1
                }
            }
            invalidateViaSync() {
                return this._invalidateViaSync > 0
            }
            flushPendingSavings() {
                return this._invalidatedLineToolGroups.size || this._invalidatedLineToolsAndStudyStubs.size ? this._saveInvalidatedIfRequired(!1, !0) : null
            }
            _assignAllLineTools(e) {
                e.forEach((e=>{
                    const t = e.dataSources().filter(Nl).map((e=>[e.id(), e.linkKey().value()]))
                      , i = new Map(t);
                    this._allLineToolsAndStudyStubs.set(e.id(), i)
                }
                ))
            }
            _processPropertiesChanged(e, t) {
                Nl(t) && this._invalidateLineToolOrStudyStub(t.id(), performance.now())
            }
            _processLineToolsGroupModelChanged(e, t) {
                const i = performance.now();
                this._invalidateLineToolGroup(e, i),
                t && (t.affectedLineTools || []).forEach((e=>this._invalidateLineToolOrStudyStub(e, i)))
            }
            _processPanesCollectionChanged(e) {
                const t = e.map((e=>e.id()))
                  , i = new Set(t)
                  , o = performance.now();
                Array.from(this._allLineToolsAndStudyStubs.keys()).filter((e=>!i.has(e))).forEach((e=>{
                    Array.from((0,
                    s.ensureDefined)(this._allLineToolsAndStudyStubs.get(e)).keys()).forEach((e=>{
                        this._invalidateLineToolOrStudyStub(e, o)
                    }
                    ))
                }
                )),
                e.filter((e=>!this._allLineToolsAndStudyStubs.has(e.id()))).forEach((e=>{
                    e.dataSources().filter(Nl).forEach((e=>this._invalidateLineToolOrStudyStub(e.id(), o)))
                }
                )),
                this._assignAllLineTools(e)
            }
            _processDataSourceCollectionChanged(e) {
                const t = e.dataSources().filter(Nl)
                  , i = t.map((e=>[e.id(), e.linkKey().value()]))
                  , o = new Map(i);
                let n;
                const r = performance.now();
                if (this._allLineToolsAndStudyStubs.has(e.id())) {
                    const i = (0,
                    s.ensureDefined)(this._allLineToolsAndStudyStubs.get(e.id()));
                    n = t.filter((e=>!i.has(e.id()))),
                    n.forEach((e=>this._invalidateLineToolOrStudyStub(e.id(), r))),
                    Array.from(i.entries()).filter((e=>!o.has(e[0]))).forEach((e=>{
                        null !== e[1] && this._debouncedSave(),
                        this._invalidateLineToolOrStudyStub(e[0], r)
                    }
                    ))
                } else
                    n = t,
                    t.forEach((e=>this._invalidateLineToolOrStudyStub(e.id(), r)));
                n.forEach((e=>{
                    if ((0,
                    ct.isLineTool)(e)) {
                        this._setOriginalLineToolSharingMode(e.id(), e.sharingMode().value());
                        const t = this._chartModel.lineToolsGroupModel().groupForLineTool(e);
                        t && this._setOriginalLineToolGroupsSharingMode(t.id, e.sharingMode().value())
                    }
                }
                )),
                this._allLineToolsAndStudyStubs.set(e.id(), o)
            }
            _unloadLineTools(e, t, i) {
                const o = e.filter((e=>!this._invalidatedLineToolsAndStudyStubs.has(e))).map((e=>this._chartModel.dataSourceForId(e))).filter(ct.isLineTool).filter(Ue.notNull).filter((e=>e.sharingMode().value() === i)).filter(t).filter((e=>{
                    const t = this._chartModel.lineToolsGroupModel().groupForLineTool(e);
                    return null === t || !this._invalidatedLineToolGroups.has(t.id)
                }
                ));
                this._withoutInvalidating((()=>{
                    o.forEach((e=>{
                        var t;
                        e.hasAlert().value() && e.detachAlert();
                        const i = (0,
                        s.ensureNotNull)(this._chartModel.paneForSource(e));
                        this._chartModel.removeSource(e);
                        (null !== (t = this._allLineToolsAndStudyStubs.get(i.id())) && void 0 !== t ? t : new Map).delete(e.id())
                    }
                    )),
                    this._chartModel.lineToolsGroupModel().removeLineTools(o)
                }
                ))
            }
            _unloadLinesOnSeries(e, t, i) {
                const s = this._chartModel.mainSeries();
                if (!(null == i ? void 0 : i.size))
                    return;
                const o = Array.from(i.keys()).filter((t=>!e(t)));
                this._unloadLineTools(o, (e=>e.boundToSymbol() && e.ownerSource() === s), t)
            }
            _isAutosaveEnabled() {
                return Boolean(this._saveChartService && this._saveChartService.autoSaveEnabled().value())
            }
            async _saveInvalidatedIfRequired(e, t) {
                if (null !== this._lastBanTime) {
                    if (!(performance.now() - this._lastBanTime >= 3e5))
                        return Promise.resolve();
                    this._lastBanTime = null
                }
                if (!this._isAutosaveEnabled() && !t || this._options.readOnlyMode || !window.is_authenticated || "" === this._origin.layoutId)
                    return;
                const i = this.prepareDTO(e)
                  , o = Ll.map((e=>{
                    var t, o;
                    const n = i.get(e);
                    if (!n || null === n.sources)
                        return null;
                    const r = null !== (t = n.lineToolsToValidate) && void 0 !== t ? t : Array.from(n.sources.keys())
                      , a = null !== (o = n.groupsToValidate) && void 0 !== o ? o : Array.from(n.groups.keys());
                    if (0 === r.length && 0 === a.length)
                        return null;
                    const l = performance.now();
                    if (n.sources.size || n.groups.size) {
                        const t = this._savingAbortControllersBySharingMode.get(e);
                        t && t.abort();
                        const i = new AbortController;
                        return this._savingAbortControllersBySharingMode.set(e, i),
                        n.sources.forEach(((t,i)=>{
                            t && this._setOriginalLineToolSharingMode(i, e)
                        }
                        )),
                        (0,
                        s.ensureNotNull)(this._saveChartService).saveChartLineTools(this._origin.chartId, n, e, i.signal).then((()=>{
                            this.resetInvalidated(l, n, e)
                        }
                        )).catch((async t=>{
                            if (t instanceof Tl.SavingLineToolsError && t.shouldBeCooled && (this._lastBanTime = performance.now()),
                            !(0,
                            Al.isAbortError)(t))
                                throw t;
                            El.logDebug(`Save request has been aborted. ChartId: ${this._origin.chartId} sharingMode: ${e}`)
                        }
                        ))
                    }
                    return this.resetInvalidated(l, n, e),
                    null
                }
                )).filter(Ue.notNull);
                return o.length ? Promise.all(o).then((()=>{}
                )) : void 0
            }
            async _savePromise(e, t) {
                var i, s;
                return this._isAutosaveEnabled() ? null !== (s = null === (i = this._debouncedSave) || void 0 === i ? void 0 : i.flush()) && void 0 !== s ? s : Promise.resolve() : this._saveInvalidatedIfRequired(e, t)
            }
            _seriesLineToolsUnloader(e, t, i) {
                const s = this._chartModel.mainSeries();
                "mainSeriesLineTools" === e.requestType && s.symbolSameAsCurrent(e.symbol) && (this._unloadLinesOnSeries(i, e.sharingMode, t),
                this._currentlyLoadedSymbol.set(e.sharingMode, e.symbol))
            }
            _mainPaneLineToolsAndStubs() {
                const e = this._chartModel.mainSeries()
                  , t = (0,
                s.ensureNotNull)(this._chartModel.paneForSource(e));
                return new Map(this._allLineToolsAndStudyStubs.get(t.id()))
            }
            _onSymbolResolved(e) {
                const t = Ll.map((t=>{
                    const i = {
                        requestType: "mainSeriesLineTools",
                        seriesSourceId: this._chartModel.mainSeries().id(),
                        symbol: e.pro_name,
                        brokerName: "",
                        sharingMode: t
                    }
                      , s = this._seriesLineToolsUnloader.bind(this, i, this._mainPaneLineToolsAndStubs());
                    return this._makeLoadRequestAndMerge(i, s, e.pro_name || e.ticker || e.full_name)
                }
                ));
                Promise.all(t).then((()=>{
                    this._withoutInvalidating((()=>{
                        this._chartModel.dataSources().filter(ct.isLineTool).filter((e=>0 === e.sharingMode().value() && e.linkKey().value())).forEach((e=>{
                            if (e.share(1),
                            this._options.migrateSyncedLineTools) {
                                this._invalidateLineToolOrStudyStub(e.id(), performance.now(), !0);
                                const t = this._chartModel.lineToolsGroupModel().groupForLineTool(e);
                                t && this._invalidateLineToolGroup(t.id, performance.now(), !0)
                            }
                        }
                        ))
                    }
                    ))
                }
                ))
            }
            async _makeLoadRequestAndMerge(e, t, i) {
                var s;
                const o = this._chartModel.mainSeries()
                  , n = null !== (s = this._currentlyLoadedSymbol.get(e.sharingMode)) && void 0 !== s ? s : "";
                if (!!o.symbolSameAsCurrent(n))
                    return;
                this._currentlyLoadedSymbol.delete(e.sharingMode);
                const r = await (0,
                Pl.getChartStorage)();
                return this._savePromise("mainSeriesLineTools" === e.requestType).catch((()=>{}
                )).then((()=>r.loadLineToolsAndGroups(this._origin.layoutId, this._origin.chartId, e, i))).catch((()=>null)).then((async i=>{
                    if (null !== i && null !== i.sources) {
                        const s = i.sources;
                        t((e=>s.has(e))),
                        await this._applyLineToolsAndGroupsDTO(i, e.sharingMode),
                        i.serverRequestId && console.log(`PROCESSED:${i.serverRequestId}`)
                    }
                }
                ))
            }
            _restoreGroups(e, t, i, o) {
                const n = new Map;
                return (t.groups || new Map).forEach(((t,r)=>{
                    const a = this._chartModel.lineToolsGroupModel().groupForId(r);
                    if (null === t) {
                        if (a) {
                            const e = o && o.layoutId === this._origin.layoutId && o.chartId === this._origin.chartId;
                            a.lineTools()[0].sharingMode().value() === i && (e && 0 !== i || (new ro.ExcludeLineToolsFromGroupUndoCommand(this._chartModel,a,a.lineTools()).redo(),
                            this._setOriginalLineToolGroupsSharingMode(r, null)))
                        }
                    } else {
                        if (a && t.serverUpdateTime) {
                            const i = (0,
                            s.ensureDefined)(t.serverUpdateTime);
                            if (null !== e && e >= i)
                                return;
                            a.setName(t.name)
                        } else
                            n.set(r, t);
                        this._setOriginalLineToolGroupsSharingMode(r, i)
                    }
                }
                )),
                n
            }
            _createNewLineTool(e) {
                const t = this._chartModel.dataSourceForId(e.ownerSource);
                if (null === t)
                    return null;
                const i = (0,
                s.ensureNotNull)(this._chartModel.paneForSource(t))
                  , o = this._chartModel.panes().indexOf(i)
                  , n = this._chartModel.restoreSource(!1, o, null, e.state, null);
                if (null !== n) {
                    const e = this._allLineToolsAndStudyStubs.get(i.id()) || new Map;
                    e.set(n.id(), n.linkKey().value()),
                    this._allLineToolsAndStudyStubs.set(i.id(), e)
                }
                return n
            }
            _migrateStateFromMetainfo(e) {
                const t = void 0 !== e.symbol && e.symbol !== e.state.state.symbol;
                t && (e.state.state.symbol = e.symbol);
                const i = void 0 !== e.currencyId && e.currencyId !== e.state.state.currencyId;
                i && (e.state.state.currencyId = e.currencyId);
                const s = void 0 !== e.unitId && e.unitId !== e.state.state.unitId;
                return s && (e.state.state.unitId = e.unitId),
                t || i || s
            }
            _restoreLineTool(e, t, i, s) {
                var o;
                if ((null !== (o = t.state.points) && void 0 !== o ? o : []).some((e=>!(0,
                Ue.isNumber)(e.time_t))))
                    return null;
                let n = this._chartModel.dataSourceForId(t.id);
                if (null === n && t.state.linkKey && (n = (0,
                ct.lineToolByLinkKey)(this._chartModel, t.state.linkKey)),
                null !== n && !(0,
                ct.isLineTool)(n))
                    return null;
                if (this._origin.clientId === (null == s ? void 0 : s.clientId) && !n)
                    return null;
                if (n && t.serverUpdateTime) {
                    const o = t.serverUpdateTime
                      , r = n.serverUpdateTime();
                    if (null !== e && e >= o || null !== r && r >= o)
                        return 0 !== i && (n.share(i),
                        this._setOriginalLineToolSharingMode(n.id(), i)),
                        this._restoreLineToolAlert(n, t.state.alertId),
                        null;
                    this._origin.clientId !== (null == s ? void 0 : s.clientId) && (this._chartModel.restoreLineToolState(n, t.state, !1),
                    n.sharingMode().value() !== i && (n.share(i),
                    this._setOriginalLineToolSharingMode(n.id(), i)),
                    n.calcIsActualSymbol())
                }
                0 !== i && (t.ownerSource = this._chartModel.mainSeries().id(),
                t.state.ownerSource = this._chartModel.mainSeries().id());
                const r = this._migrateStateFromMetainfo(t);
                let a = n || this._createNewLineTool(t);
                if (a && (r && this._invalidateLineToolOrStudyStub(t.id, performance.now(), !0),
                t.serverUpdateTime && a.setServerUpdateTime(t.serverUpdateTime),
                this._restoreLineToolAlert(a, t.state.alertId),
                0 !== i && a.share(i),
                void 0 === s && (0,
                ct.isEditableTextLineTool)(a))) {
                    this._removeTextLineToolIfEmpty(a) && (a = null)
                }
                return a
            }
            _restoreLineToolAlert(e, t) {
                t ? e.restoreAlert(+t, {
                    syncFocusFromAlert: !0
                }).catch((e=>{
                    El.logError(`Failed to restore lineTool alert: ${Error,
                    e}`)
                }
                )) : e.detachAlert()
            }
            _removeLineTool(e) {
                const t = this._chartModel.dataSourceForId(e);
                null !== t && new no.RemoveSourcesUndoCommand(this._chartModel,[t],null).redo()
            }
            _removeTextLineToolIfEmpty(e) {
                return !(!e.removeIfEditableTextIsEmpty() || 0 !== e.editableTextProperties().text.value().length) && (this._chartModel.removeSource(e),
                this._invalidateLineToolOrStudyStub(e.id(), performance.now(), !0),
                !0)
            }
            _restoreLineDTO(e, t, i, o, n, r) {
                if (!this._invalidatedLineToolsAndStudyStubs.get(t))
                    if (null === e) {
                        const e = this._chartModel.dataSourceForId(t);
                        if (!e)
                            return;
                        if (!(0,
                        ct.isLineTool)(e))
                            return;
                        e.sharingMode().value() === n && this._origin.clientId !== (null == r ? void 0 : r.clientId) && (this._removeLineTool(t),
                        this._setOriginalLineToolSharingMode(t, null))
                    } else {
                        const a = this._restoreLineTool(o, e, n, r);
                        if (a) {
                            if (e.groupId) {
                                const t = this._chartModel.lineToolsGroupModel().groupForLineTool(a)
                                  , o = this._chartModel.lineToolsGroupModel().groupForId(e.groupId);
                                if (null !== t && o === t)
                                    return;
                                if (null !== t && (t.excludeLineTool(a),
                                0 === t.lineTools().length && this._chartModel.lineToolsGroupModel().removeGroup(t)),
                                o && !o.containsLineTool(a))
                                    o.addLineTools([a]);
                                else if (!o && i.has(e.groupId)) {
                                    const t = (0,
                                    s.ensureDefined)(i.get(e.groupId));
                                    this._chartModel.lineToolsGroupModel().createGroup([a], t.name, t.id)
                                }
                            } else {
                                this._chartModel.lineToolsGroupModel().removeLineTools([a]).forEach((e=>{
                                    this._invalidateLineToolGroup(e, performance.now(), !0)
                                }
                                ))
                            }
                            void 0 === this._originalLineToolSharingMode.get(t) && this._setOriginalLineToolSharingMode(t, n),
                            this._setOriginalLineToolSharingMode(t, n)
                        }
                    }
            }
            async _applyLineToolsAndGroupsDTO(e, t, i) {
                const s = this._chartModel.chartSaveTime()
                  , o = this._withoutInvalidating((()=>this._restoreGroups(s, e, t, i)))
                  , n = `ChartStorage.Synchronizer.ApplyingDTO.${`${this._origin.layoutId}.${this._origin.chartId}`}`
                  , r = new Set;
                (e.sources || new Map).forEach((e=>{
                    e && r.add(e.state.type)
                }
                )),
                await Promise.all(Array.from(r).map((e=>(0,
                ct.initLineTool)(e)))),
                (0,
                wl.perfMeasureOperation)(n, (()=>this._withoutInvalidating((()=>{
                    (e.sources || new Map).forEach(((e,n)=>{
                        try {
                            if (e && (0,
                            U.isMtpPredictorToolName)(e.state.type))
                                return void El.logWarn(`No longer supported tool ${e.state.type} is skipped while restoring state`);
                            this._restoreLineDTO(e, n, o, s, t, i)
                        } catch (e) {
                            El.logError(`Error restoring line tool ${n}: ${e}`)
                        }
                    }
                    )),
                    (e.groups || new Map).forEach(((e,t)=>{
                        this._invalidatedLineToolGroups.delete(t)
                    }
                    )),
                    this._recalculateHasChanges()
                }
                ))))
            }
            _withoutInvalidating(e) {
                try {
                    return this._ignoreInvalidatingEventsDepth++,
                    e()
                } finally {
                    this._ignoreInvalidatingEventsDepth--
                }
            }
            _invalidateLineToolOrStudyStub(e, t, i) {
                var s;
                if (this._ignoreInvalidatingEventsDepth > 0 && !i)
                    return;
                const o = null === (s = this._invalidatedLineToolsAndStudyStubs.get(e)) || void 0 === s ? void 0 : s.invalidatedViaSyncOnly
                  , n = (void 0 === o || o) && this.invalidateViaSync();
                this._invalidatedLineToolsAndStudyStubs.set(e, {
                    timestamp: t,
                    invalidatedViaSyncOnly: n
                }),
                this._hasChanges.setValue(!0),
                this._debouncedSave()
            }
            _invalidateLineToolGroup(e, t, i) {
                this._ignoreInvalidatingEventsDepth > 0 && !i || (this._invalidatedLineToolGroups.set(e, {
                    timestamp: t,
                    invalidatedViaSyncOnly: this.invalidateViaSync()
                }),
                this._hasChanges.setValue(!0),
                this._debouncedSave())
            }
            _prepareDTOItem(e, t) {
                const i = new Map
                  , o = new Map
                  , n = []
                  , r = [];
                return this._invalidatedLineToolsAndStudyStubs.forEach(((r,a)=>{
                    if (0 !== t && r.invalidatedViaSyncOnly)
                        return void n.push(a);
                    const l = this._chartModel.dataSourceForId(a);
                    if (!(0,
                    Il.isStudyLineToolStub)(l))
                        if (null === l) {
                            this._originalLineToolSharingMode.get(a) === t && i.set(a, null)
                        } else {
                            if (l === this._chartModel.lineBeingCreated() || l === this._chartModel.lineBeingEdited() || !l.isSavedInChart())
                                return;
                            const n = l.ownerSource() === this._chartModel.mainSeries()
                              , r = !e || n
                              , c = l.sharingMode().value() === t;
                            if (r) {
                                const e = this._chartModel.lineToolsGroupModel().groupForLineTool(l);
                                if (c)
                                    i.set(a, function(e, t) {
                                        const i = t.lineToolsGroupModel().groupForLineTool(e)
                                          , o = {
                                            id: e.id(),
                                            ownerSource: (0,
                                            s.ensureNotNull)(e.ownerSource()).id(),
                                            state: e.state(!1)
                                        };
                                        return e.boundToSymbol() && (o.symbol = e.symbol()),
                                        o.currencyId = e.properties().childs().currencyId.value(),
                                        o.unitId = e.properties().childs().unitId.value(),
                                        null !== i && (o.groupId = i.id),
                                        o
                                    }(l, this._chartModel)),
                                    null !== e && o.set(e.id, kl(e, this._chartModel));
                                else {
                                    const s = this._originalLineToolSharingMode.get(a);
                                    s === t && i.set(a, null),
                                    null !== e && s === t && o.set(e.id, null)
                                }
                            }
                        }
                }
                )),
                this._invalidatedLineToolGroups.forEach(((e,i)=>{
                    if (0 !== t && e.invalidatedViaSyncOnly)
                        r.push(i);
                    else if (!o.has(i)) {
                        const e = this._chartModel.lineToolsGroupModel().groupForId(i);
                        if (null === e) {
                            this._originalLineToolGroupsSharingMode.get(i) === t && o.set(i, null)
                        } else
                            e.sharingMode().value() === t && o.set(i, kl(e, this._chartModel))
                    }
                }
                )),
                {
                    sources: i,
                    groups: o,
                    clientId: this._generateOrigin(),
                    lineToolsToValidate: Array.from(i.keys()).concat(n),
                    groupsToValidate: Array.from(o.keys()).concat(r)
                }
            }
            _setOriginalLineToolSharingMode(e, t) {
                null !== t ? this._originalLineToolSharingMode.set(e, t) : this._originalLineToolSharingMode.delete(e)
            }
            _setOriginalLineToolGroupsSharingMode(e, t) {
                null !== t ? this._originalLineToolGroupsSharingMode.set(e, t) : this._originalLineToolGroupsSharingMode.delete(e)
            }
            _loadAndMergeLineToolsOnStudies(e, t) {
                const i = {
                    requestType: "studiesLineTools",
                    seriesSourceId: this._chartModel.mainSeries().id(),
                    sharingMode: e
                }
                  , s = this._chartModel.mainSeries();
                this._makeLoadRequestAndMerge(i, (i=>{
                    const o = t ? (0,
                    Cl.default)(Array.from(this._allLineToolsAndStudyStubs.values()).map((e=>Array.from(e.keys())))).filter((e=>!i(e))) : [];
                    this._unloadLineTools(o, (e=>e.ownerSource() !== s), e)
                }
                ))
            }
            _loadAndMergeLineToolsWithoutSymbol(e, t) {
                const i = {
                    requestType: "lineToolsWithoutSymbol",
                    seriesSourceId: this._chartModel.mainSeries().id(),
                    sharingMode: e
                }
                  , o = this._chartModel.mainSeries()
                  , n = (0,
                s.ensureNotNull)(this._chartModel.paneForSource(o))
                  , r = this._allLineToolsAndStudyStubs.get(n.id());
                this._makeLoadRequestAndMerge(i, (i=>{
                    const s = t && r ? Array.from(r.keys()).filter((e=>!i(e))) : [];
                    this._unloadLineTools(s, (e=>!e.boundToSymbol() && e.ownerSource() === o), e)
                }
                ))
            }
            _recalculateHasChanges() {
                const e = Array.from(this._invalidatedLineToolsAndStudyStubs.values()).some((e=>!e.savedToChartContent))
                  , t = Array.from(this._invalidatedLineToolGroups.values()).some((e=>!e.savedToChartContent));
                this._hasChanges.setValue(e || t)
            }
            _generateOrigin() {
                return `${this._origin.layoutId}/${this._origin.chartId}/${this._origin.clientId}`
            }
        }
        var Ol = i(266621)
          , Vl = i(888194)
          , Wl = i(700134)
          , Fl = i(72368)
          , Hl = i(715518)
          , zl = i(306060)
          , Ul = i(137674)
          , Gl = i(18343);
        var jl = i(676962)
          , ql = i(955931)
          , Xl = i(586450)
          , Kl = i(979822);
        function Yl(e, t) {
            return {
                ...t,
                iconId: "Watchlist.AddSymbol",
                icon: Gl.icons.get("Watchlist.AddSymbol"),
                statName: "AddToWatchlist",
                hotkeyHash: k.Modifiers.Alt + 87,
                onExecute: ()=>{
                    (0,
                    Xl.runOrSigninWithFeature)((()=>{
                        (0,
                        Kl.initWatchlistWidget)((t=>{
                            null == t || t.addSymbols([(0,
                            ql.getWatchlistSymbolFromChart)(e)])
                        }
                        ))
                    }
                    ), {
                        feature: "watchList",
                        source: "add symbol to watchlist"
                    })
                }
            }
        }
        var Zl = i(306388)
          , $l = i(826939)
          , Jl = i(440498);
        class Ql extends _i.Action {
            constructor(e, t) {
                super({
                    actionId: "Chart.AddSymbolToWatchList",
                    options: {
                        ...Yl(e, t),
                        subItems: [new _i.Loader("Loading")]
                    }
                }),
                this._hadSymbolOnInit = !1,
                this._isMobile = (0,
                Fl.isMobile)(),
                this._onRequest = null,
                this._unsubscribe = null,
                this._chart = e,
                this._load()
            }
            updateLabel(e) {
                this.update({
                    label: r.t(null, void 0, i(295829)).format({
                        symbol: e
                    })
                })
            }
            request() {
                var e;
                this._hadSymbolOnInit = !1,
                this._isMobile = (0,
                Fl.isMobile)(),
                this.update({
                    subItems: [new _i.Loader("Loading")]
                }),
                null === (e = this._onRequest) || void 0 === e || e.call(this)
            }
            destroy() {
                var e;
                super.destroy(),
                null === (e = this._unsubscribe) || void 0 === e || e.call(this),
                this._chart = null,
                this._onRequest = null
            }
            async _load() {
                const [e,t,s,o,n,a,l] = await Promise.all([Promise.resolve().then(i.t.bind(i, 50959, 19)), (0,
                Zl.initSymbolListService)(), Promise.all([i.e(23391), i.e(46445), i.e(93703), i.e(75816), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(25480), i.e(46489), i.e(74600), i.e(88015), i.e(86605), i.e(41243), i.e(32227), i.e(50030), i.e(5483), i.e(62526), i.e(18405), i.e(38506), i.e(51666), i.e(90050), i.e(1026)]).then(i.bind(i, 38506)), Promise.all([i.e(23391), i.e(46445), i.e(93703), i.e(75816), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(25480), i.e(46489), i.e(74600), i.e(88015), i.e(86605), i.e(41243), i.e(32227), i.e(50030), i.e(5483), i.e(62526), i.e(18405), i.e(38506), i.e(51666), i.e(90050), i.e(1026)]).then(i.bind(i, 244692)), Promise.all([i.e(24281), i.e(46445), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(53953), i.e(2520), i.e(25480), i.e(22164), i.e(29800), i.e(46489), i.e(58985), i.e(77476), i.e(23141), i.e(95083), i.e(75826), i.e(74600), i.e(61135), i.e(72197), i.e(16190), i.e(92115), i.e(67661), i.e(88015), i.e(32175), i.e(97384), i.e(39963), i.e(3782), i.e(86605), i.e(43362), i.e(41243), i.e(64797), i.e(49325), i.e(22602), i.e(7001), i.e(71329), i.e(17175), i.e(51488), i.e(59470), i.e(75364), i.e(44066), i.e(17762), i.e(77414), i.e(5463), i.e(79412), i.e(65891), i.e(19234), i.e(69504), i.e(46190), i.e(55206), i.e(74510), i.e(88115), i.e(36299), i.e(93871), i.e(49279), i.e(14418), i.e(17341), i.e(46798), i.e(32227), i.e(50030), i.e(87473), i.e(5483), i.e(60473), i.e(22113), i.e(18405), i.e(38506), i.e(84165), i.e(38112), i.e(13505), i.e(87954), i.e(28038), i.e(64536), i.e(91196)]).then(i.bind(i, 291676)), Promise.all([i.e(24281), i.e(46445), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(53953), i.e(2520), i.e(25480), i.e(22164), i.e(29800), i.e(46489), i.e(58985), i.e(77476), i.e(23141), i.e(95083), i.e(75826), i.e(74600), i.e(61135), i.e(72197), i.e(16190), i.e(92115), i.e(67661), i.e(88015), i.e(32175), i.e(97384), i.e(39963), i.e(3782), i.e(86605), i.e(43362), i.e(41243), i.e(64797), i.e(49325), i.e(22602), i.e(7001), i.e(71329), i.e(17175), i.e(51488), i.e(59470), i.e(75364), i.e(44066), i.e(17762), i.e(77414), i.e(5463), i.e(79412), i.e(65891), i.e(19234), i.e(69504), i.e(46190), i.e(55206), i.e(74510), i.e(88115), i.e(36299), i.e(93871), i.e(49279), i.e(14418), i.e(17341), i.e(46798), i.e(32227), i.e(50030), i.e(87473), i.e(5483), i.e(60473), i.e(22113), i.e(18405), i.e(38506), i.e(84165), i.e(38112), i.e(13505), i.e(87954), i.e(28038), i.e(64536), i.e(91196)]).then(i.bind(i, 436779)), Promise.all([i.e(24281), i.e(46445), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(53953), i.e(2520), i.e(25480), i.e(22164), i.e(29800), i.e(46489), i.e(58985), i.e(77476), i.e(23141), i.e(95083), i.e(75826), i.e(74600), i.e(61135), i.e(72197), i.e(16190), i.e(92115), i.e(67661), i.e(88015), i.e(32175), i.e(97384), i.e(39963), i.e(3782), i.e(86605), i.e(43362), i.e(41243), i.e(64797), i.e(49325), i.e(22602), i.e(7001), i.e(71329), i.e(17175), i.e(51488), i.e(59470), i.e(75364), i.e(44066), i.e(17762), i.e(77414), i.e(5463), i.e(79412), i.e(65891), i.e(19234), i.e(69504), i.e(46190), i.e(55206), i.e(74510), i.e(88115), i.e(36299), i.e(93871), i.e(49279), i.e(14418), i.e(17341), i.e(46798), i.e(32227), i.e(50030), i.e(87473), i.e(5483), i.e(60473), i.e(22113), i.e(18405), i.e(38506), i.e(84165), i.e(38112), i.e(13505), i.e(87954), i.e(28038), i.e(64536), i.e(91196)]).then(i.bind(i, 631530))]);
                if (this._destroyed)
                    return;
                const {store: c} = t;
                this._onRequest = ()=>c.dispatch(s.getCustomWatchlistsThunk(null)),
                this._unsubscribe = c.subscribe((()=>{
                    if (!this._chart)
                        return;
                    const t = c.getState();
                    if (null === n.getCustomListsState(t).timestamp)
                        return;
                    const s = (0,
                    ql.getWatchlistSymbolFromChart)(this._chart)
                      , u = n.getCustomLists(t)
                      , {activeSymbolList: h} = t
                      , p = u.find((e=>e.id === h));
                    this._hadSymbolOnInit || (this._hadSymbolOnInit = !!p && p.symbols.includes(s));
                    const m = d.enabled("multiple_watchlists") ? u.filter((e=>e.id !== h)).sort(a.sortComparator) : [];
                    let g = p ? [p, ...m] : m;
                    g = g.filter((e=>!(0,
                    Jl.isDeletedSymbolsList)(e.id)));
                    const _ = g.map((t=>{
                        const i = t.symbols.includes(s)
                          , n = {
                            shortcutHint: t.id === h ? (0,
                            k.humanReadableHash)(k.Modifiers.Alt + 87) : void 0,
                            invisibleHotkey: t.id === h ? i : void 0,
                            doNotCloseOnClick: !0,
                            onExecute: ()=>{
                                const e = i ? o.removeSymbolsThunk($l.WATCHLIST_WIDGET_ID, [s], t.id, !0) : o.addSymbolsToCustomListThunk($l.WATCHLIST_WIDGET_ID, t.id, [s]);
                                t.id !== h || window.is_authenticated || this._hadSymbolOnInit ? c.dispatch(e) : window.runOrSignIn((()=>{
                                    c.dispatch(e)
                                }
                                ), {
                                    source: "Chart context menu"
                                })
                            }
                        };
                        return new _i.Action({
                            actionId: "Watchlist.Actions",
                            options: {
                                ...n,
                                label: t.name,
                                checkable: !0,
                                checked: i
                            },
                            customActionOptions: {
                                ...n,
                                jsxLabel: e.createElement(l.ContextMenuWatchlistItem, {
                                    title: t.name,
                                    isChecked: i,
                                    isSmallSize: this._isMobile
                                })
                            }
                        })
                    }
                    ))
                      , v = new _i.Action({
                        actionId: "Watchlist.Create",
                        options: {
                            label: (0,
                            ul.appendEllipsis)(r.t(null, void 0, i(222556))),
                            iconId: this._isMobile ? "Watchlist.CreateNew" : void 0,
                            onExecute: ()=>{
                                (0,
                                Zn.runOrGoPro)((()=>{
                                    c.dispatch(o.userCreateWatchlistThunk(null, {
                                        symbols: [s]
                                    }))
                                }
                                ), "MULTIPLE_WATCHLISTS", {
                                    feature: "multipleWatchLists",
                                    featureLocation: "moveSymbolsToNew"
                                })
                            }
                        }
                    });
                    this.update({
                        subItems: [..._, new _i.Separator, v]
                    })
                }
                ))
            }
        }
        var ec = i(137685)
          , tc = i(453995)
          , ic = i(721211)
          , sc = i(440075)
          , oc = i(207195);
        var nc = i(214372);
        function rc(e) {
            const t = e.options()
              , s = {
                label: (0,
                ul.appendEllipsis)(Ol.t(null, void 0, i(102569))),
                statName: "ChangeInterval",
                onExecute: ()=>(0,
                nc.showChangeIntervalDialogAsync)({
                    initVal: jo.linking.interval.value(),
                    selectOnInit: !0
                })
            };
            return !(0,
            d.enabled)("show_interval_dialog_on_key_press") || t.readOnly || t.hideSymbolSearch || (s.shortcutHint = ",",
            s.hotkeyGroup = e.hotkeys(),
            s.hotkeyHash = 188),
            new _i.Action({
                actionId: "Chart.Dialogs.ShowChangeInterval",
                options: s
            })
        }
        class ac extends _i.Action {
            constructor(e, t=new h.WatchedValue(!1)) {
                super({
                    ...e,
                    options: {
                        ...e.options,
                        checkable: !0,
                        checked: t.value(),
                        onExecute: ()=>{
                            this._wv.setValue(!this._wv.value())
                        }
                    }
                }),
                this._updateChecked = e=>{
                    this.update({
                        checked: e
                    })
                }
                ,
                t.subscribe(this._updateChecked),
                this._wv = t
            }
            destroy() {
                this._wv.unsubscribe(this._updateChecked),
                super.destroy()
            }
        }
        var lc = i(78007);
        const cc = new c.TranslatedString("scale price chart only",Ol.t(null, void 0, i(763796)))
          , dc = new c.TranslatedString("stay in drawing mode",Ol.t(null, void 0, i(504114)))
          , uc = new c.TranslatedString("hide marks on bars",Ol.t(null, void 0, i(62249)))
          , hc = new c.TranslatedString("change symbol last value visibility",Ol.t(null, void 0, i(467453)))
          , pc = new c.TranslatedString("change symbol previous close value visibility",Ol.t(null, void 0, i(904729)))
          , mc = new c.TranslatedString("change previous close price line visibility",Ol.t(null, void 0, i(958419)))
          , gc = new c.TranslatedString("change symbol labels visibility",Ol.t(null, void 0, i(147074)))
          , _c = new c.TranslatedString("change indicators and financials value labels visibility",Ol.t(null, void 0, i(171161)))
          , vc = new c.TranslatedString("change indicators and financials name labels visibility",Ol.t(null, void 0, i(612411)))
          , Sc = new c.TranslatedString("change bid and ask labels visibility",Ol.t(null, void 0, i(669362)))
          , fc = new c.TranslatedString("change bid and ask lines visibility",Ol.t(null, void 0, i(952919)))
          , bc = new c.TranslatedString("change pre/post market price label visibility",Ol.t(null, void 0, i(530870)))
          , yc = new c.TranslatedString("change pre/post market price line visibility",Ol.t(null, void 0, i(511718)))
          , Cc = new c.TranslatedString("change high and low price labels visibility",Ol.t(null, void 0, i(524226)))
          , wc = new c.TranslatedString("change high and low price lines visibility",Ol.t(null, void 0, i(180692)))
          , Tc = (new c.TranslatedString("change average close price label visibility",Ol.t(null, void 0, i(876852))),
        new c.TranslatedString("change average close price line visibility",Ol.t(null, void 0, i(1022))),
        new c.TranslatedString("change countdown to bar close visibility",Ol.t(null, void 0, i(839383))))
          , Pc = new c.TranslatedString("change plus button visibility",Ol.t(null, void 0, i(796379)))
          , xc = new c.TranslatedString("change session breaks visibility",Ol.t(null, void 0, i(338413)))
          , Mc = new c.TranslatedString("change price line visibility",Ol.t(null, void 0, i(108662)));
        function Ic(e) {
            const t = e.hotkeys()
              , s = e.model()
              , o = e.options()
              , n = e.properties()
              , a = new _i.Action({
                actionId: "Chart.Series.PriceScale.ToggleInvertPriceScale",
                options: {
                    label: Ol.t(null, void 0, i(37189)),
                    statName: "Invert Scale",
                    checkable: !0,
                    onExecute: ()=>s.invertPriceScale(s.mainSeries().priceScale()),
                    hotkeyGroup: t,
                    hotkeyHash: Ee.Modifiers.Alt + 73
                }
            })
              , c = new _i.Action({
                actionId: "Chart.Series.PriceScale.ToggleAutoScale",
                options: {
                    label: Ol.t(null, void 0, i(224157)),
                    checkable: !0,
                    onExecute: e=>{
                        const t = s.mainSeries().priceScale();
                        s.togglePriceScaleAutoScaleMode(t),
                        e.update({
                            checked: t.isAutoScale()
                        })
                    }
                }
            })
              , u = new _i.Action({
                actionId: "Chart.Scales.ToggleLockPriceToBarRatio",
                options: {
                    label: Ol.t(null, void 0, i(314017)),
                    checkable: !0,
                    statName: "ToggleLockScale",
                    onExecute: ()=>s.togglePriceScaleLockScaleMode(s.mainSeries().priceScale())
                }
            })
              , h = new _i.Action({
                actionId: "Chart.Series.PriceScale.ToggleRegular",
                options: {
                    label: Ol.t(null, {
                        context: "scale_menu"
                    }, i(655300)),
                    checkable: !0,
                    statName: "ToggleRegularScale",
                    onExecute: e=>{
                        const t = s.mainSeries().priceScale();
                        s.setPriceScaleRegularScaleMode(t),
                        e.update({
                            checked: t.isRegular()
                        })
                    }
                }
            })
              , p = new _i.Action({
                actionId: "Chart.Series.PriceScale.TogglePercentage",
                options: {
                    label: Ol.t(null, void 0, i(806919)),
                    checkable: !0,
                    statName: "TogglePercantage",
                    onExecute: ()=>s.togglePriceScalePercentageScaleMode(s.mainSeries().priceScale()),
                    hotkeyGroup: t,
                    hotkeyHash: Ee.Modifiers.Alt + 80
                }
            })
              , m = new _i.Action({
                actionId: "Chart.Series.PriceScale.ToggleIndexedTo100",
                options: {
                    label: Ol.t(null, void 0, i(189999)),
                    checkable: !0,
                    statName: "ToggleIndexedTo100",
                    onExecute: ()=>s.togglePriceScaleIndexedTo100ScaleMode(s.mainSeries().priceScale())
                }
            })
              , g = new _i.Action({
                actionId: "Chart.Series.PriceScale.ToggleLogarithmic",
                options: {
                    label: Ol.t(null, void 0, i(116170)),
                    statName: "ToggleLogScale",
                    checkable: !0,
                    onExecute: ()=>s.togglePriceScaleLogScaleMode(s.mainSeries().priceScale()),
                    hotkeyGroup: t,
                    hotkeyHash: Ee.Modifiers.Alt + 76
                }
            })
              , _ = new _i.Action({
                actionId: "Chart.ChangeTimeZone",
                options: {
                    label: Ol.t(null, void 0, i(320909)),
                    statName: "TimeZone"
                }
            })
              , v = new fi.ActionWithStandardIcon({
                actionId: "Chart.TimeScale.Reset",
                options: {
                    label: Ol.t(null, void 0, i(354170)),
                    iconId: "Chart.Reset",
                    statName: "ResetScale",
                    onExecute: ()=>s.resetTimeScale(),
                    hotkeyGroup: e.hotkeys(),
                    hotkeyHash: Ee.Modifiers.Mod + Ee.Modifiers.Alt + 81
                }
            })
              , S = new _i.Action({
                actionId: "Chart.Dialogs.ShowInsertIndicators",
                options: {
                    label: (0,
                    ul.appendEllipsis)(Ol.t(null, void 0, i(287829))),
                    statName: "InsertIndicator",
                    onExecute: ()=>e.showIndicators(),
                    ...o.indicatorsDialogShortcutEnabled ? {
                        hotkeyGroup: t,
                        hotkeyHash: 191
                    } : void 0
                }
            })
              , f = new _i.Action({
                actionId: "Chart.Dialogs.ShowCompareOrAddSymbol",
                options: {
                    label: (0,
                    ul.appendEllipsis)(Ol.t(null, void 0, i(253942))),
                    statName: "CompareOrAddSymbol",
                    onExecute: ()=>e.toggleCompareOrAdd()
                }
            })
              , b = new fi.ActionWithStandardIcon({
                actionId: "Chart.Dialogs.ShowGeneralSettings",
                options: {
                    label: (0,
                    ul.appendEllipsis)(Ol.t(null, void 0, i(232514))),
                    iconId: "Settings",
                    statName: "ChartProperties",
                    onExecute: ()=>e.showGeneralChartProperties()
                }
            })
              , y = new fi.ActionWithStandardIcon({
                actionId: "Chart.Dialogs.ShowGeneralSettings.SymbolTab",
                options: {
                    label: (0,
                    ul.appendEllipsis)(Ol.t(null, void 0, i(232514))),
                    iconId: "Settings",
                    statName: "MainSeriesProperties",
                    onExecute: ()=>e.showGeneralChartProperties(ot.TabNames.symbol)
                }
            })
              , C = new fi.ActionWithStandardIcon({
                actionId: "Chart.Dialogs.ShowGeneralSettings.ScalesTab",
                options: {
                    label: (0,
                    ul.appendEllipsis)(Ol.t(null, void 0, i(793907))),
                    iconId: "Settings",
                    statName: "ScalesProperties",
                    onExecute: ()=>e.showGeneralChartProperties(ot.TabNames.scales)
                }
            })
              , w = new _i.Action({
                actionId: "Chart.SelectedObject.ToggleLocked",
                options: {
                    label: Ol.t(null, void 0, i(279777)),
                    statName: "ToggleLockSelectedObject",
                    onExecute: ()=>e.toggleLockSelectedObject()
                }
            })
              , T = new fi.ActionWithStandardIcon({
                actionId: "Chart.SelectedObject.Hide",
                options: {
                    label: Ol.t(null, void 0, i(327298)),
                    iconId: "Chart.Hide",
                    statName: "HideSelectedObject",
                    onExecute: ()=>e.hideSelectedObject()
                }
            })
              , P = new pi.PropertyBoundAction({
                actionId: "Chart.PriceScale.ToggleAutoScaleSeriesOnly",
                options: {
                    label: Ol.t(null, void 0, i(243758)),
                    checkable: !0,
                    statName: "ScalePriceChartOnly"
                }
            },{
                property: n.childs().scalesProperties.childs().scaleSeriesOnly,
                undoModel: s,
                undoText: cc
            })
              , x = new ac({
                actionId: "Chart.DrawingToolbar.ToggleVisibility",
                options: {
                    label: Ol.t(null, void 0, i(993864)),
                    statName: "ToggleDrawingToolbar"
                }
            },o.isDrawingToolbarVisible)
              , M = new pi.PropertyBoundAction({
                actionId: "",
                options: {
                    label: Ol.t(null, void 0, i(704035)),
                    checkable: !0,
                    statName: "ToggleStayInDrawingMode"
                }
            },{
                property: qt.properties().childs().stayInDrawingMode,
                undoModel: s,
                undoText: dc
            })
              , I = new pi.PropertyBoundAction({
                actionId: "Chart.Marks.ToggleVisibility",
                options: {
                    label: Ol.t(null, void 0, i(328345)),
                    checkable: !0,
                    statName: "ToggleHideMarksOnBars"
                }
            },{
                property: qt.hideMarksOnBars(),
                undoModel: s,
                undoText: uc,
                callback: e=>qt.hideMarksOnBars().setValue(e.isChecked())
            })
              , A = new pi.PropertyBoundAction({
                actionId: "Chart.PriceScale.Labels.ToggleSeriesLastValueVisibility",
                options: {
                    label: Ol.t(null, void 0, i(410127)),
                    checkable: !0,
                    checked: !1,
                    statName: "ToggleSymbolLastValue"
                }
            },{
                property: n.childs().scalesProperties.childs().showSeriesLastValue,
                undoModel: s,
                undoText: hc
            })
              , L = new pi.PropertyBoundAction({
                actionId: "Chart.PriceScale.Labels.ToggleSymbolNameLabelsVisibility",
                options: {
                    label: Ol.t(null, void 0, i(832390)),
                    checkable: !0,
                    checked: !1,
                    statName: "ToggleSymbolLabels"
                }
            },{
                property: n.childs().scalesProperties.childs().showSymbolLabels,
                undoModel: s,
                undoText: gc
            })
              , E = (0,
            lc.combineProperty)(((e,t)=>e || t), n.childs().scalesProperties.childs().showStudyLastValue.weakReference(), n.childs().scalesProperties.childs().showFundamentalLastValue.weakReference())
              , D = new pi.PropertyBoundAction({
                actionId: "Chart.PriceScale.Labels.ToggleIndicatorsValueLabelsVisibility",
                options: {
                    label: Ol.t(null, void 0, i(454574)),
                    checkable: !0,
                    checked: !1,
                    statName: "ToggleStudiesAndFundamentalsPriceLabels",
                    onDestroy: ()=>{
                        E.destroy()
                    }
                }
            },{
                property: E,
                undoModel: s,
                undoText: null,
                callback: ()=>{
                    const e = !E.value();
                    s.beginUndoMacro(_c),
                    s.setProperty(n.childs().scalesProperties.childs().showStudyLastValue, e, null),
                    s.setProperty(n.childs().scalesProperties.childs().showFundamentalLastValue, e, null),
                    s.endUndoMacro()
                }
            })
              , N = (0,
            lc.combineProperty)(((e,t)=>e || t), n.childs().scalesProperties.childs().showStudyPlotLabels.weakReference(), n.childs().scalesProperties.childs().showFundamentalNameLabel.weakReference())
              , B = new pi.PropertyBoundAction({
                actionId: "Chart.PriceScale.Labels.ToggleIndicatorsNameLabelsVisibility",
                options: {
                    label: Ol.t(null, void 0, i(803061)),
                    checkable: !0,
                    checked: !1,
                    statName: "ToggleStudiesAndFundamentalsNameLabels",
                    onDestroy: ()=>{
                        N.destroy()
                    }
                }
            },{
                property: N,
                undoModel: s,
                undoText: null,
                callback: ()=>{
                    const e = !N.value();
                    s.beginUndoMacro(vc),
                    s.setProperty(n.childs().scalesProperties.childs().showStudyPlotLabels, e, null),
                    s.setProperty(n.childs().scalesProperties.childs().showFundamentalNameLabel, e, null),
                    s.endUndoMacro()
                }
            })
              , R = s.mainSeries().properties().childs().highLowAvgPrice.childs()
              , O = new pi.PropertyBoundAction({
                actionId: "Chart.PriceScale.Labels.ToggleHighLowPriceLabelsVisibility",
                options: {
                    label: Ol.t(null, void 0, i(399479)),
                    checkable: !0,
                    checked: !1,
                    statName: "ToggleHighLowPriceLabels"
                }
            },{
                property: R.highLowPriceLabelsVisible,
                undoModel: s,
                undoText: Cc
            })
              , V = new pi.PropertyBoundAction({
                actionId: "Chart.Lines.ToggleHighLowLinesVisibility",
                options: {
                    label: Ol.t(null, void 0, i(433766)),
                    checkable: !0,
                    checked: !1,
                    statName: "ToggleHighLowPriceLine"
                }
            },{
                property: R.highLowPriceLinesVisible,
                undoModel: s,
                undoText: wc
            })
              , W = new pi.PropertyBoundAction({
                actionId: "Chart.PriceScale.ToggleCountdownToBarCloseVisibility",
                options: {
                    label: Ol.t(null, void 0, i(583140)),
                    checkable: !0,
                    checked: !1,
                    statName: "ToggleCountdown"
                }
            },{
                property: s.mainSeries().properties().childs().showCountdown,
                undoModel: s,
                undoText: Tc
            })
              , F = new pi.PropertyBoundAction({
                actionId: "Chart.PriceScale.ToggleAddOrderPlusButtonVisibility",
                options: {
                    label: Ol.t(null, void 0, i(371566)),
                    checkable: !0,
                    checked: Rr.addPlusButtonProperty.value(),
                    statName: "ToggleAddOrderPlusButton"
                }
            },{
                property: Rr.addPlusButtonProperty,
                undoModel: s,
                undoText: Pc
            })
              , H = new fi.ActionWithStandardIcon({
                actionId: "Chart.Dialogs.ShowSymbolInfo",
                options: {
                    label: (0,
                    ul.appendEllipsis)((0,
                    Fl.isMobile)() ? Ol.t(null, void 0, i(655104)) : Ol.t(null, void 0, i(975594))),
                    iconId: "Chart.SymbolInfo",
                    checkable: !1,
                    statName: "SymbolInfo",
                    onExecute: ()=>{
                        if ((0,
                        Fl.isMobile)())
                            (0,
                            d.enabled)("mobile_app_action_open_details_webview") && o.onDetailsWebviewOpen ? o.onDetailsWebviewOpen() : (0,
                            Hl.showDetailsDialog)(),
                            (0,
                            Ne.trackEvent)("ContextMenuClick", "Mobile", "SymbolInfo");
                        else {
                            const t = e.model().model()
                              , i = t.mainSeries().symbolInfo();
                            if (i) {
                                const e = t.availableUnits()
                                  , s = t.unitConversionEnabled();
                                (0,
                                sc.showSymbolInfoDialog)({
                                    symbolInfo: i,
                                    showUnit: s,
                                    unitDescription: t=>t ? e.description(t) : "",
                                    dateFormatter: t.dateFormatter()
                                })
                            }
                        }
                    }
                }
            })
              , z = new _i.Action({
                actionId: "Chart.PriceScale.MergeAllScalesToLeft",
                options: {
                    label: Ol.t(null, void 0, i(562329)),
                    statName: "MergeAllScalesToLeft",
                    onExecute: ()=>s.mergeAllScales("left")
                }
            })
              , U = new _i.Action({
                actionId: "Chart.PriceScale.MergeAllScalesToRight",
                options: {
                    label: Ol.t(null, void 0, i(755813)),
                    statName: "MergeAllScalesToRight",
                    onExecute: ()=>s.mergeAllScales("right")
                }
            })
              , G = new _i.Action({
                actionId: "Chart.PriceScale.MoveToLeft",
                options: {
                    label: Ol.t(null, void 0, i(26493)),
                    statName: "MoveScaleToLeft",
                    onExecute: ()=>s.mergeAllScales("left")
                }
            })
              , j = new _i.Action({
                actionId: "Chart.PriceScale.MoveToRight",
                options: {
                    label: Ol.t(null, void 0, i(140789)),
                    statName: "MoveScaleToRight",
                    onExecute: ()=>s.mergeAllScales("right")
                }
            })
              , q = new fi.ActionWithStandardIcon({
                actionId: "Chart.Scales.Reset",
                options: {
                    label: Ol.t(null, void 0, i(575246)),
                    iconId: "Chart.Reset",
                    statName: "ResetChart",
                    onExecute: ()=>e.GUIResetScales(),
                    hotkeyGroup: t,
                    hotkeyHash: Ee.Modifiers.Alt + 82
                }
            })
              , X = e.model().model().sessions().properties().childs().graphics.childs().vertlines.childs().sessBreaks.childs().visible
              , K = (0,
            lc.createWVFromProperty)(e.model().mainSeries().isDWMProperty())
              , Y = new _i.Action({
                actionId: "Chart.SessionBreaks.ToggleVisibility",
                options: {
                    label: Ol.t(null, void 0, i(366707)),
                    checkable: !0,
                    checked: X.value(),
                    statName: "ToggleSessionBreaks",
                    disabled: K.value(),
                    onExecute: ()=>{
                        X && s.setProperty(X, !X.value(), xc)
                    }
                    ,
                    onDestroy: ()=>K.destroy()
                }
            });
            K.subscribe((()=>Y.update({
                disabled: K.value()
            })));
            const Z = new pi.PropertyBoundAction({
                actionId: "Chart.Lines.ToggleSeriesPriceLineVisibility",
                options: {
                    label: Ol.t(null, void 0, i(72926)),
                    checkable: !0,
                    statName: "TogglePriceLine"
                }
            },{
                property: s.mainSeries().properties().childs().showPriceLine,
                undoModel: s,
                undoText: Mc
            })
              , $ = new _i.Action({
                actionId: "Chart.Undo",
                options: {
                    label: Ol.t(null, void 0, i(314804)),
                    onExecute: ()=>{
                        (0,
                        Ne.trackEvent)("GUI", "Undo"),
                        s.undoHistory().undo()
                    }
                    ,
                    onDestroy: ()=>{
                        e.model().undoHistory().undoStack().onChange().unsubscribeAll($)
                    }
                    ,
                    disabled: !0,
                    hotkeyGroup: t,
                    hotkeyHash: Ee.Modifiers.Mod + 90,
                    isRepeatAccepted: !0
                }
            });
            e.model().undoHistory().undoStack().onChange().subscribe($, (()=>$.update({
                disabled: e.model().undoHistory().undoStack().isEmpty()
            })));
            const J = new _i.Action({
                actionId: "Chart.Redo",
                options: {
                    label: Ol.t(null, void 0, i(148236)),
                    onExecute: ()=>{
                        (0,
                        Ne.trackEvent)("GUI", "Redo"),
                        e.model().undoHistory().redo()
                    }
                    ,
                    onDestroy: ()=>{
                        e.model().undoHistory().redoStack().onChange().unsubscribeAll(J)
                    }
                    ,
                    disabled: !0,
                    hotkeyGroup: t,
                    hotkeyHash: Ee.Modifiers.Mod + 89,
                    isRepeatAccepted: !0
                }
            });
            e.model().undoHistory().redoStack().onChange().subscribe(J, (()=>J.update({
                disabled: e.model().undoHistory().redoStack().isEmpty()
            })));
            const Q = {
                invertSeriesScale: a,
                autoSeriesScale: c,
                lockSeriesScale: u,
                regularSeriesScale: h,
                percentSeriesScale: p,
                indexedTo100SeriesScale: m,
                logSeriesScale: g,
                applyTimeZone: _,
                symbolSearch: new _i.Action({
                    actionId: "Chart.Dialogs.ShowChangeSymbol",
                    options: {
                        label: (0,
                        ul.appendEllipsis)(r.t(null, void 0, i(885124))),
                        statName: "ChangeSymbol",
                        onExecute: ()=>{
                            (0,
                            Fe.showDialog)({
                                defaultValue: "",
                                trackResultsOptions: {
                                    trackResults: !d.enabled("widget"),
                                    emptySearchType: "empty_result__supercharts"
                                }
                            })
                        }
                    }
                }),
                changeInterval: rc(e),
                timeScaleReset: v,
                insertIndicator: S,
                compareOrAdd: f,
                chartProperties: b,
                mainSeriesPropertiesAction: y,
                scalesProperties: C,
                lineToggleLock: w,
                seriesHide: T,
                studyHide: T,
                lineHide: T,
                scaleSeriesOnly: P,
                drawingToolbarAction: x,
                stayInDrawingModeAction: M,
                hideAllMarks: I,
                showSeriesLastValue: A,
                showSymbolLabelsAction: L,
                showStudyLastValue: D,
                showStudyPlotNamesAction: B,
                showHighLowPriceLabels: O,
                showHighLowPriceLines: V,
                showCountdown: W,
                addPlusButton: F,
                showSymbolInfoDialog: H,
                mergeLeftScalesAction: z,
                mergeRightScalesAction: U,
                moveScaleToLeft: G,
                moveScaleToRight: j,
                chartReset: q,
                sessionBreaks: Y,
                showPriceLine: Z,
                undo: $,
                redo: J
            };
            o.goToDateEnabled && (Q.gotoDate = new _i.Action({
                actionId: "Chart.Dialogs.ShowGoToDate",
                options: {
                    label: (0,
                    ul.appendEllipsis)(Ol.t(null, void 0, i(754280))),
                    statName: "GoToDate",
                    onExecute: ()=>(0,
                    oc.showGoToDateDialog)(e.chartWidgetCollection().activeChartWidget.value()),
                    hotkeyGroup: t,
                    hotkeyHash: Ee.Modifiers.Alt + 71
                }
            })),
            (0,
            d.enabled)("show_object_tree") && (Q.paneObjectTree = new _i.Action({
                actionId: "Chart.ObjectTree.Show",
                options: {
                    label: (0,
                    ul.appendEllipsis)(Ol.t(null, void 0, i(251221))),
                    statName: "ObjectsTree",
                    onExecute: ()=>e.showObjectsTreePanelOrDialog()
                }
            })),
            (0,
            d.enabled)("property_pages") && (Q.format = new fi.ActionWithStandardIcon({
                actionId: "Chart.SelectedObject.ShowSettingsDialog",
                options: {
                    label: (0,
                    ul.appendEllipsis)(Ol.t(null, void 0, i(232514))),
                    iconId: "Settings",
                    statName: "EditSelectedObject",
                    onExecute: ()=>e.showSelectedSourcesProperties()
                }
            })),
            e.readOnly() || (Q.paneRemoveAllStudies = new _i.Action({
                actionId: "Chart.RemoveAllIndicators",
                options: {
                    label: Ol.t(null, void 0, i(699984)),
                    statName: "RemoveAllIndicators",
                    onExecute: ()=>e.removeAllStudies()
                }
            }),
            Q.paneRemoveAllDrawingTools = new _i.Action({
                actionId: "Chart.RemoveAllLineTools",
                options: {
                    label: Ol.t(null, void 0, i(396374)),
                    statName: "RemoveAllDrawingTools",
                    onExecute: ()=>e.removeAllDrawingTools()
                }
            }),
            Q.paneRemoveAllStudiesDrawingTools = new _i.Action({
                actionId: "Chart.RemoveAllIndicatorsAndLineTools",
                options: {
                    label: Ol.t(null, void 0, i(481442)),
                    statName: "RemoveAllIndicatorsAndDrawingTools",
                    onExecute: ()=>e.removeAllStudiesDrawingTools()
                }
            }),
            Q.applyStudiesToAllCharts = new _i.Action({
                actionId: "Chart.ApplyIndicatorsToAllCharts",
                options: {
                    label: Ol.t(null, void 0, i(222437)),
                    statName: "ApplyIndicatorsToAllCharts",
                    onExecute: ()=>e.chartWidgetCollection().applyIndicatorsToAllCharts(e)
                }
            }),
            Q.studyRemove = Q.lineRemove = new fi.ActionWithStandardIcon({
                actionId: "Chart.SelectedObject.Remove",
                options: {
                    label: Ol.t(null, void 0, i(767410)),
                    iconId: "Chart.RemoveSelectedObject",
                    statName: "RemoveSelectedObject",
                    onExecute: ()=>{
                        var t;
                        (null !== (t = e.chartWidgetCollection().activeChartWidget.value()) && void 0 !== t ? t : e).removeSelectedSources()
                    }
                    ,
                    hotkeyGroup: t,
                    hotkeyHash: Ee.isMacKeyboard ? 8 : 46
                }
            })),
            (0,
            l.onWidget)() || (0,
            d.enabled)("text_notes") && (Q.addToTextNotes = function(e) {
                return new _i.Action({
                    actionId: "Note.Create",
                    options: {
                        iconId: "TextNote.Add",
                        icon: Gl.icons.get("TextNote.Add"),
                        label: r.t(null, void 0, i(784513)),
                        statName: "AddToTextNotes",
                        onExecute: ()=>{
                            window.runOrSignIn((()=>{
                                var t;
                                null === (t = window.widgetbar) || void 0 === t || t.setPage("base"),
                                (0,
                                Ul.createSymbolNote)(e.symbolWV().value(), (0,
                                Fl.isMobile)())
                            }
                            ), {
                                source: "Add text note in chart context menu"
                            })
                        }
                        ,
                        hotkeyHash: k.Modifiers.Alt + 78,
                        hotkeyGroup: e.hotkeys()
                    }
                })
            }(e)),
            window.is_authenticated && ((0,
            pl.showThemeSwitcher)() || (0,
            pl.showThemeAction)()) && (Q.applyColorTheme = new _i.Action({
                actionId: "Chart.Theme.Apply",
                options: {
                    name: "apply-color-theme",
                    label: Ol.t(null, void 0, i(453438)),
                    subItems: [new _i.Action({
                        actionId: "Loading",
                        options: {
                            label: Ol.t(null, void 0, i(786726))
                        }
                    })],
                    statName: "ColorTheme"
                }
            })),
            o.showFinancialsEnabled && (Q.showFinancials = new fi.ActionWithStandardIcon({
                actionId: "Chart.Dialogs.ShowInsertFinancials",
                options: {
                    label: (0,
                    ul.appendEllipsis)(Ol.t(null, void 0, i(856135))),
                    iconId: "Chart.Financials",
                    statName: "Financials",
                    onExecute: ()=>{
                        (0,
                        d.enabled)("mobile_app_action_open_financials_webview") ? (0,
                        Vl.openFinancialsWebview)(new URLSearchParams) : (0,
                        Wl.showFinancialsDialog)(),
                        window.matchMedia("screen and (max-width: 430px)").matches && (0,
                        Ne.trackEvent)("ContextMenuClick", "", "Financials"),
                        (0,
                        $i.getTracker)().then((e=>{
                            null == e || e.trackFinancialsDialog(jo.linking.ensuredProSymbol.value(), "contextMenu")
                        }
                        ))
                    }
                }
            })),
            (0,
            d.enabled)("show_source_code") && (Q.viewSourceCode = new _i.Action({
                actionId: "Chart.Indicator.PineSource",
                options: {
                    label: (0,
                    ul.appendEllipsis)(Ol.t(null, void 0, i(787142))),
                    statName: "OpenSelectedObjectSource",
                    onExecute: ()=>{
                        if (!window.TradingView.bottomWidgetBar)
                            return;
                        const [e] = s.selection().dataSources();
                        if (!(0,
                        rt.isStudy)(e))
                            return;
                        const t = e.metaInfo();
                        t && t.scriptIdPart && t.pine && (0,
                        tc.getPineSourceCode)(t.scriptIdPart, t.pine.version).done((e=>{
                            if (!e)
                                return;
                            const {bottomWidgetBar: i} = window.TradingView;
                            if (!i)
                                return;
                            const {lastVersionMaj: s, scriptName: o, scriptTitle: n, version: r, source: a} = e
                              , l = s ? zl.Version.parse(s) : new zl.Version(0,0);
                            i.activateScriptEditorTab({
                                scriptSource: a,
                                scriptName: o,
                                scriptTitle: n,
                                version: r,
                                scriptIdPart: t.scriptIdPart,
                                isOld: !l.isZero() && l.major() !== zl.Version.parse(r).major()
                            })
                        }
                        )).fail(ec.showScriptInfoErrorNoticeDialog)
                    }
                }
            }));
            {
                const e = Q.showPrePostMarketPriceLabel = new pi.PropertyBoundAction({
                    actionId: "Chart.PriceScale.Labels.TogglePrePostMarketLabelsVisibility",
                    options: {
                        label: Ol.t(null, void 0, i(578793)),
                        checkable: !0,
                        checked: !1,
                        statName: "TogglePrePostMarketPriceLabel",
                        onDestroy: ()=>{
                            s.mainSeries().isPrePostMarketPricesAvailableProperty().unsubscribeAll(e)
                        }
                    }
                },{
                    property: n.childs().scalesProperties.childs().showPrePostMarketPriceLabel,
                    undoModel: s,
                    undoText: bc
                });
                s.mainSeries().isPrePostMarketPricesAvailableProperty().subscribe(e, (t=>{
                    e.update({
                        disabled: !t.value()
                    })
                }
                ))
            }
            {
                const e = Q.showPrePostMarketPriceLine = new pi.PropertyBoundAction({
                    actionId: "Chart.Lines.TogglePrePostMarketPriceLineVisibility",
                    options: {
                        label: Ol.t(null, void 0, i(597915)),
                        checkable: !0,
                        checked: !1,
                        statName: "TogglePrePostMarketPriceLine",
                        onDestroy: ()=>{
                            s.mainSeries().isPrePostMarketPricesAvailableProperty().unsubscribeAll(e)
                        }
                    }
                },{
                    property: s.mainSeries().properties().childs().prePostMarket.childs().visible,
                    undoModel: s,
                    undoText: yc
                });
                s.mainSeries().isPrePostMarketPricesAvailableProperty().subscribe(e, (t=>{
                    e.update({
                        disabled: !t.value()
                    })
                }
                ))
            }
            Q.hideAllLineTools = new pi.PropertyBoundAction({
                actionId: "Chart.ToggleVisibility.AllLineTools",
                options: {
                    label: Ol.t(null, void 0, i(616830)),
                    checkable: !0,
                    statName: "ToggleHideMarksOnBars",
                    hotkeyGroup: e.hotkeys(),
                    hotkeyHash: Ee.Modifiers.Mod + Ee.Modifiers.Alt + 72
                }
            },{
                property: qt.hideMarksOnBars(),
                undoModel: s,
                undoText: uc,
                callback: ()=>(0,
                He.toggleHideMode)()
            });
            {
                const r = Q.showSeriesPrevCloseValue = new pi.PropertyBoundAction({
                    actionId: "Chart.PriceScale.Labels.ToggleSymbolPrevCloseValueVisibility",
                    options: {
                        label: Ol.t(null, void 0, i(522071)),
                        checkable: !0,
                        checked: !1,
                        statName: "ToggleSymbolPrevCloseValue",
                        onDestroy: ()=>s.mainSeries().onRestarted().unsubscribeAll(r)
                    }
                },{
                    property: n.childs().scalesProperties.childs().showSeriesPrevCloseValue,
                    undoModel: s,
                    undoText: pc
                });
                s.mainSeries().onRestarted().subscribe(r, (()=>{
                    r.update({
                        disabled: s.mainSeries().isDWM()
                    })
                }
                ));
                const a = Q.showSeriesPrevCloseLine = new pi.PropertyBoundAction({
                    actionId: "Chart.Lines.ToggleSeriesPrevCloseLineVisibility",
                    options: {
                        label: Ol.t(null, void 0, i(879366)),
                        checkable: !0,
                        checked: !1,
                        statName: "ToggleSymbolPrevCloseLine",
                        onDestroy: ()=>s.mainSeries().onRestarted().unsubscribeAll(a)
                    }
                },{
                    property: s.mainSeries().properties().childs().showPrevClosePriceLine,
                    undoModel: s,
                    undoText: mc
                });
                if (s.mainSeries().onRestarted().subscribe(a, (()=>{
                    a.update({
                        disabled: s.mainSeries().isDWM()
                    })
                }
                )),
                Q.showBidAskLabels = new pi.PropertyBoundAction({
                    actionId: "Chart.PriceScale.Labels.ToggleBidAskLabelsVisibility",
                    options: {
                        label: Ol.t(null, void 0, i(398810)),
                        checkable: !0,
                        checked: !1,
                        statName: "ToggleBidAskLabels"
                    }
                },{
                    property: n.childs().scalesProperties.childs().showBidAskLabels,
                    undoModel: s,
                    undoText: Sc
                }),
                Q.showBidAskLines = new pi.PropertyBoundAction({
                    actionId: "Chart.Lines.ToggleBidAskLinesVisibility",
                    options: {
                        label: Ol.t(null, void 0, i(292590)),
                        checkable: !0,
                        checked: !1,
                        statName: "ToggleBidAskLines"
                    }
                },{
                    property: s.mainSeries().properties().childs().bidAsk.childs().visible,
                    undoModel: s,
                    undoText: fc
                }),
                Q.moveChartAction = new _i.Action({
                    actionId: "Chart.MoveChartInLayout",
                    options: {
                        label: Ol.t(null, void 0, i(287849)),
                        subItems: [new _i.Action({
                            actionId: "Chart.MoveChartInLayout.Forward",
                            options: {
                                label: Ol.t(null, void 0, i(797057)),
                                statName: "MoveChartRight",
                                onExecute: ()=>e.chartWidgetCollection().moveActiveChartWithUndo(!1)
                            }
                        }), new _i.Action({
                            actionId: "Chart.MoveChartInLayout.Back",
                            options: {
                                label: Ol.t(null, void 0, i(139403)),
                                statName: "MoveChartLeft",
                                onExecute: ()=>e.chartWidgetCollection().moveActiveChartWithUndo(!0)
                            }
                        })]
                    }
                }),
                Q.showDataWindow = new fi.ActionWithStandardIcon({
                    actionId: "Chart.DataWindow.Show",
                    options: {
                        label: (0,
                        ul.appendEllipsis)(Ol.t(null, void 0, i(748741))),
                        statName: "DataWindow",
                        hotkeyGroup: t,
                        hotkeyHash: Ee.Modifiers.Alt + 68,
                        iconId: "Chart.ShowDataWindow",
                        onExecute: ic.showChartObjectsWidget
                    }
                }),
                o.addToWatchlistEnabled) {
                    const i = {
                        hotkeyGroup: t
                    };
                    Q.addToWatchlist = new Ql(e,i),
                    t.add({
                        desc: "Add symbol to watchlist",
                        hotkey: Ee.Modifiers.Mod + Ee.Modifiers.Alt + 87,
                        handler: ()=>(0,
                        jl.showAddSymbolDialog)([(0,
                        ql.getWatchlistSymbolFromChart)(e)])
                    })
                }
            }
            return Q
        }
        var Ac = i(876610);
        i(443882);
        const Lc = (0,
        n.getLogger)("ChartWidget", {
            color: "#606"
        })
          , Ec = d.enabled("chart_content_overrides_by_defaults")
          , kc = d.enabled("symphony_embed")
          , Dc = new c.TranslatedString("hide {title}",r.t(null, void 0, i(713017)))
          , Nc = new c.TranslatedString("change timezone",r.t(null, void 0, i(920137)))
          , Bc = new c.TranslatedString("unlock {title}",r.t(null, void 0, i(212525)))
          , Rc = new c.TranslatedString("lock {title}",r.t(null, void 0, i(576104)));
        let Oc = null;
        if (location.search.toLowerCase().includes("logcanvassaverestoreleaks")) {
            if (!l.isChrome)
                throw new Error("CanvasRenderingContext2D save/restore leak detection is available for now in Chrome only");
            i.e(15803).then(i.bind(i, 567736)).then((e=>{
                e.enableCanvasRenderingContext2DSaveRestoreLeaksDetection(),
                Oc = e.reportCanvasRenderingContext2DSaveRestoreLeaks
            }
            ))
        }
        const Vc = {
            addToWatchlistEnabled: !0,
            showFinancialsEnabled: !1,
            sourceSelectionEnabled: !0,
            propertyPagesEnabled: !0,
            paneContextMenuEnabled: !0,
            priceScaleContextMenuEnabled: !0,
            currencyConversionEnabled: !1,
            unitConversionEnabled: !1,
            goToDateEnabled: !1,
            marketStatusWidgetEnabled: !0,
            chartWarningWidgetEnabled: !0,
            dataProblemWidgetEnabled: !0,
            paneControlsEnabled: !0,
            isSymbolAvailable: e=>Promise.resolve(!0),
            legendWidgetEnabled: !0,
            chartEventsEnabled: !0,
            newsNotificationsEnabled: !0,
            esdEnabled: !1,
            latestUpdatesEnabled: {
                news: !1,
                minds: !1
            },
            keyFactsTodayEnabled: !0,
            continuousContractSwitchesEnabled: !1,
            futuresContractExpirationEnabled: !1,
            croppedTickMarks: !0,
            countdownEnabled: !0,
            lastPriceAnimationEnabled: !0,
            useKineticScroll: l.CheckMobile.any(),
            indicatorsDialogShortcutEnabled: !0,
            handleScale: {
                mouseWheel: !0,
                pinch: !0,
                axisPressedMouseMove: {
                    time: !0,
                    price: !0
                }
            },
            handleScroll: {
                mouseWheel: !0,
                pressedMouseMove: !0,
                horzTouchDrag: !0,
                vertTouchDrag: !0
            }
        };
        function Wc(e, t, i, s=0) {
            const o = t.mainSeries().syncModel()
              , n = e.mainSeries().syncModel();
            let r = i;
            if (null !== o && null !== n) {
                const t = e.createSyncPoint(o.syncSourceTarget(), n.syncSourceTarget());
                0 !== s && (i = o.projectTime(i, s)),
                r = t.sourceTimeToTargetTime(i)
            }
            return e.timeScale().points().roughIndex(r, n && n.distance.bind(n))
        }
        const Fc = new Set(["Volume@tv-basicstudies", "Compare@tv-basicstudies", "Overlay@tv-basicstudies", "Dividends@tv-basicstudies", "Earnings@tv-basicstudies", "Splits@tv-basicstudies", "BarSetContinuousRollDates@tv-corestudies", "Sessions@tv-basicstudies", "VbPSessionsRough@tv-volumebyprice", "AnchoredVWAP@tv-basicstudies", "RegressionTrend@tv-basicstudies", "VbPAnchored@tv-basicstudies", "VbPFixed@tv-basicstudies", "VbPFixed@tv-volumebyprice"])
          , Hc = (0,
        Le.default)((()=>{
            window.ChartApiInstance.setIsNonCountedStudyFn((e=>Fc.has(e)))
        }
        ));
        class zc {
            constructor(e, t, o) {
                var n;
                this.activePaneWidget = null,
                this._model = null,
                this._mainDiv = null,
                this._parent = null,
                this._elTooltipDiv = null,
                this._paneWidgets = [],
                this._maximizedPaneWidget = null,
                this._timeAxisWidget = null,
                this._paneSeparators = [],
                this._controlBarNavigation = null,
                this._lineToolsSynchronizer = null,
                this._modelCreated = new le.Delegate,
                this._isDestroyed = !1,
                this._customLegendWidgetsFactoryMap = new Map,
                this._backgroundTopTheme = new h.WatchedValue("light"),
                this._backgroundBasedTheme = new h.WatchedValue("light"),
                this._backgroundBottomTheme = new h.WatchedValue("light"),
                this._backgroundTopColorSpawn = null,
                this._backgroundBottomColorSpawn = null,
                this._lhsAxesWidth = 0,
                this._rhsAxesWidth = 0,
                this._lhsPriceAxisWidthChanged = new le.Delegate,
                this._rhsPriceAxisWidthChanged = new le.Delegate,
                this._hotkeysListener = null,
                this._mouseWheelHelper = null,
                this._onWheelBound = null,
                this._justActivated = !1,
                this._inited = !1,
                this._containsData = !1,
                this._initialLoading = !1,
                this._onWidget = !1,
                this._widgetCustomer = void 0,
                this._defInterval = null,
                this._defStyle = null,
                this._defTimeframe = null,
                this._removeMaximizeHotkey = null,
                this._invalidationMask = null,
                this._drawPlanned = !1,
                this._drawRafId = 0,
                this._inLoadingState = !1,
                this._timingsMeter = null,
                this._tagsChanged = new le.Delegate,
                this._redraw = new le.Delegate,
                this._isVisible = new h.WatchedValue(!0),
                this._collapsed = new h.WatchedValue(!1),
                this._dataWindowWidget = null,
                this._resizeHandler = null,
                this._spinner = null,
                this._symbolWV = new h.WatchedValue,
                this._resolutionWV = new h.WatchedValue,
                this._actions = null,
                this._updateThemedColorBound = this._updateThemedColor.bind(this),
                this._disconnected = new le.Delegate,
                this._reconnectBailout = new le.Delegate,
                this._connected = new le.Delegate,
                this._chartWidgetInitialized = new le.Delegate,
                this._aboutToBeDestroyed = new le.Delegate,
                this._saveChartService = null,
                this._objectTreeDialogController = null,
                this._chartPaintedPromise = null,
                this._noExchangeSubscrptionWarning = null,
                this._paneWidgetsSharedState = new Ls,
                this._onZoom = new le.Delegate,
                this._onScroll = new le.Delegate,
                this._availableScreen = null,
                this._hoveredPriceAxes = new Set,
                this._anyAxisHovered = new h.WatchedValue(!1),
                this._linkingGroupIndex = new h.WatchedValue(null),
                this._isHovered = new h.WatchedValue(!1),
                this._activeHint = null,
                this._eventHintDeferredPromise = null,
                this._warningHintDeferredPromise = null,
                this._setSymbolIntervalContentOverrides = {},
                this._ariaPriceDescription = null,
                this._definitionsViewModel = null,
                this._barsButton = null,
                this._updateScalesActions = ()=>{
                    const e = this.actions()
                      , t = this.model().mainSeries()
                      , i = t.priceScale()
                      , s = t.properties()
                      , o = i.isLockScale()
                      , n = 6 === s.childs().style.value();
                    e.percentSeriesScale.update({
                        disabled: o || n,
                        checked: i.isPercentage()
                    }),
                    e.logSeriesScale.update({
                        disabled: o || n,
                        checked: i.isLog()
                    }),
                    e.regularSeriesScale.update({
                        disabled: o || n,
                        checked: i.isRegular()
                    }),
                    e.indexedTo100SeriesScale.update({
                        disabled: o || n,
                        checked: i.isIndexedTo100()
                    }),
                    e.invertSeriesScale.update({
                        checked: i.isInverted()
                    }),
                    e.lockSeriesScale.update({
                        checked: i.isLockScale()
                    }),
                    e.autoSeriesScale.update({
                        checked: i.isAutoScale(),
                        disabled: i.properties().childs().autoScaleDisabled.value()
                    })
                }
                ,
                this._invalidationHandler = e=>{
                    if (!(e instanceof N.InvalidationMask))
                        throw new Error("Invalid mask");
                    null !== this._invalidationMask ? this._invalidationMask.merge(e) : this._invalidationMask = e,
                    this._drawPlanned || (this._drawPlanned = !0,
                    this._options.visible.when((()=>{
                        const e = !document.hidden
                          , t = this.screen && this.screen.isShown();
                        null !== this._timingsMeter && e && !t && this._timingsMeter.startWaitingDraw();
                        const i = (0,
                        s.ensureNotNull)((0,
                        s.ensureNotNull)(this._parent).ownerDocument.defaultView);
                        this._drawRafId = i.requestAnimationFrame(this._invalidationRAFCallback.bind(this))
                    }
                    )))
                }
                ,
                this._onChartSessionIsConnectedChanged = e=>{
                    e ? this._onConnection() : this._onDisconnect()
                }
                ,
                this._subscribeToBanInfo = e=>{
                    var t, i;
                    e ? null === (t = this._spinner) || void 0 === t || t.stop() : null === (i = this._spinner) || void 0 === i || i.spin()
                }
                ,
                this._id = t,
                this._layoutId = o,
                this._options = (0,
                Ue.merge)((0,
                Ue.clone)(Vc), e),
                this._chartWidgetCollection = this._options.chartWidgetCollection,
                this._isActive = new h.WatchedValue(!!this._options.isActive),
                this._options.customLegendWidgetFactories && (this._customLegendWidgetsFactoryMap = this._options.customLegendWidgetFactories),
                this._subscribeToDrawingState(),
                this.withModel(this, (()=>{
                    const e = this.model().model();
                    e.backgroundTopColor().subscribe(this._updateThemedColorBound),
                    e.backgroundColor().subscribe(this._updateThemedColorBound)
                }
                )),
                this._errorRenderer = new Pt(this),
                this._scrollHelper = new st(this),
                this._objectTreeDialogController = ze.ObjectTreeDialogController.getInstance(),
                this._properties = new Go.DefaultProperty({
                    defaultName: "chartproperties",
                    useUserPreferences: this._options.useUserChartPreferences,
                    excludedDefaultsKeys: ["scalesProperties.axisHighlightColor", "scalesProperties.axisLineToolLabelBackgroundColorActive", "scalesProperties.axisLineToolLabelBackgroundColorCommon", "scalesProperties.showPriceScaleCrosshairLabel", "scalesProperties.showTimeScaleCrosshairLabel", "scalesProperties.crosshairLabelBgColorLight", "scalesProperties.crosshairLabelBgColorDark"],
                    excludedTemplateKeys: ["timezone", "tradingProperties", "mainSeriesProperties", "chartEventsSourceProperties", "priceScaleSelectionStrategyName", "paneProperties.horzGridProperties.style", "paneProperties.vertGridProperties.style", "paneProperties.topMargin", "paneProperties.bottomMargin", "volumePaneSize"],
                    themedColors: (0,
                    Go.extractThemedColors)(De.lightTheme.content.chartProperties, De.darkTheme.content.chartProperties)
                }),
                this._startSpinner(this._options.container.value()),
                window.ChartApiInstance.connectionBanInfo().subscribe(this._subscribeToBanInfo, {
                    callWithLast: !0
                }),
                this._chartSession = new Sl.ChartSession(window.ChartApiInstance),
                Hc(),
                this._isMultipleLayout = (0,
                Ye.combine)((e=>(0,
                xe.isMultipleLayout)(e)), this._chartWidgetCollection.layout.weakReference()),
                this._properties.childs().scalesProperties.childs().scaleSeriesOnly.subscribe(null, (()=>{
                    const e = this.model().model();
                    e.recalculateAllPanes((0,
                    as.viewportChangeEvent)()),
                    e.invalidate(N.InvalidationMask.full())
                }
                )),
                this._hotkeys = Be.createGroup({
                    desc: "Chart actions",
                    isDisabled: ()=>!this.isActive().value()
                }),
                (0,
                l.onWidget)() || (this._persistentLogSwitcher = new Ja.FeatureToggleWatchedValue("support_persistent_logs",!1),
                this._persistentLogSwitcher.subscribe((async e=>{
                    var t;
                    if (e) {
                        if ((0,
                        el.getPersistentLogger)())
                            return;
                        (0,
                        el.setPersistentLogger)(new tl);
                        const {initPersistentLogger: e} = await i.e(94882).then(i.bind(i, 286126));
                        (null === (t = this._persistentLogSwitcher) || void 0 === t ? void 0 : t.value()) ? e() : (0,
                        el.setPersistentLogger)(null)
                    } else
                        (0,
                        el.setPersistentLogger)(null)
                }
                ), {
                    callWithLast: !0
                })),
                this._compareDialog = this._chartWidgetCollection.getCompareDialogRenderer(),
                this._options.timeScaleWidget && (this._options.timeScaleWidget.pressedMouseMoveScale = this._options.handleScale.axisPressedMouseMove.time);
                const r = this._options.onCmeWidget;
                r && Lc.logWarn("[ChartWidget] 'onCmeWidget' option is depricated");
                const a = this._options.widgetCustomer
                  , c = this._options.timezone;
                let d = null !== (n = this._options.defSymbol) && void 0 !== n ? n : ""
                  , u = zs.Interval.isValid(this._options.defInterval) ? this._options.defInterval : null;
                const p = this._options.defStyle;
                let m = (0,
                ye.isValidStyle)(p) ? p : null;
                const g = this._options.defSessionId
                  , _ = void 0 !== this._options.defTimeframe ? "string" == typeof this._options.defTimeframe ? {
                    value: this._options.defTimeframe.toUpperCase(),
                    type: "period-back"
                } : {
                    ...this._options.defTimeframe,
                    type: "time-range"
                } : null;
                this._content = this._options.content,
                this._initialLoading = this._options.initialLoading,
                this._containsData = !!this._options.containsData,
                this._onWidget = !!this._options.onWidget,
                this._compareSymbols = this._options.compareSymbols,
                this._defSymbol = d,
                this._defInterval = u,
                this._defTimeframe = _,
                this._defStyle = m,
                this._onWidget && (r ? this._widgetCustomer = "cme" : a && (this._widgetCustomer = a)),
                this._compareDialog = this._chartWidgetCollection.getCompareDialogRenderer();
                const v = this._contentSeriesProperties();
                v && (d = v.symbol,
                u = v.interval),
                void 0 === this._options.useUserChartPreferences && (this._options.useUserChartPreferences = !0);
                const S = "chartproperties.mainSeriesProperties"
                  , f = this._options.useUserChartPreferences ? (0,
                hr.defaults)(S) : (0,
                hr.factoryDefaults)(S)
                  , b = this._properties.childs().mainSeriesProperties;
                b.merge(f),
                b.hasChild("esdBreaksStyle") && b.removeProperty("esdBreaksStyle");
                const y = u || f.interval || "D";
                null !== m && (0,
                ye.isValidStyle)(m) || (m = (0,
                ye.isValidStyle)(f.style) ? f.style : (0,
                ye.getDefaultStyle)(zs.Interval.isRange(y))),
                b.merge({
                    visible: !0,
                    symbol: d || window.DEFAULT_SYMBOL,
                    shortName: "",
                    timeframe: "",
                    interval: y,
                    currencyId: null,
                    unitId: null,
                    style: m,
                    sessionId: g
                }),
                this._symbolWV.setValue(this.getSymbol()),
                this._resolutionWV.setValue(this.getResolution()),
                this._containsData && this._properties.childs().mainSeriesProperties.merge({
                    showCountdown: !1
                }),
                c && (0,
                Ze.timezoneIsAvailable)(c) && this._properties.childs().timezone.setValue(c),
                this._options.container.subscribe((e=>{
                    this._setElement(e)
                }
                ), {
                    callWithLast: !0
                });
                const C = ()=>{
                    this.resize()
                }
                ;
                this._options.width.subscribe(C),
                this._options.height.subscribe(C),
                this._options.visible.subscribe(this._updateTimingsMeterState.bind(this))
            }
            refreshMarks() {
                this.model().barsMarksSources().forEach((e=>e.refreshData()))
            }
            clearMarks(e) {
                this.model().barsMarksSources().forEach((t=>t.clearMarks(e)))
            }
            setTimezone(e) {
                const t = e;
                t && (0,
                Ze.timezoneIsAvailable)(t) ? this.properties().childs().timezone.setValue(t) : console.warn("Incorrect timezone: " + JSON.stringify(t))
            }
            getTimezone() {
                return this.properties().childs().timezone.value()
            }
            destroy() {
                var e, t, i, s, o, n, r, a, l, c, d, u, h, p, m;
                this._unsetActions(),
                null === (e = this._hotkeys) || void 0 === e || e.destroy(),
                null === (t = this._lineToolsSynchronizer) || void 0 === t || t.destroy(),
                null === (i = this._noExchangeSubscrptionWarning) || void 0 === i || i.destroy(),
                window.loginStateChange.unsubscribe(this, this._handleLoginStateChanged),
                null !== this._model && (this._model.model().backgroundTopColor().unsubscribe(this._updateThemedColorBound),
                this._model.model().backgroundColor().unsubscribe(this._updateThemedColorBound),
                this._model.model().crossHairSource().moved().unsubscribe(this, this._updateAriaPriceDescription),
                this._model.destroy()),
                window.ChartApiInstance.connectionBanInfo().unsubscribe(this._subscribeToBanInfo),
                this._ariaPriceDescription = null,
                this._customLegendWidgetsFactoryMap.clear(),
                this._scrollHelper.destroy(),
                this._errorRenderer.destroy(),
                this._chartSession.criticalError().unsubscribe(this, this._onChartSessionCriticalError),
                this._chartSession.isConnected().unsubscribe(this._onChartSessionIsConnectedChanged),
                this._chartSession.destroy(),
                null === (s = this._persistentLogSwitcher) || void 0 === s || s.destroy(),
                this._isDestroyed = !0,
                this._aboutToBeDestroyed.fire(),
                null === (o = this._removeMaximizeHotkey) || void 0 === o || o.call(this),
                this._removeMaximizeHotkey = null,
                0 !== this._drawRafId && (null === (r = null === (n = this._parent) || void 0 === n ? void 0 : n.ownerDocument.defaultView) || void 0 === r || r.cancelAnimationFrame(this._drawRafId)),
                null === (a = this._backgroundTopColorSpawn) || void 0 === a || a.destroy(),
                null === (l = this._backgroundBottomColorSpawn) || void 0 === l || l.destroy(),
                null === (c = this._timingsMeter) || void 0 === c || c.stopCollect(),
                this._timingsMeter = null;
                for (let e = 0; e < this._paneWidgets.length; e++)
                    this._paneWidgets[e].destroy();
                this._paneWidgets.length = 0;
                for (let e = 0; e < this._paneSeparators.length; e++)
                    this._paneSeparators[e].destroy();
                this._paneSeparators.length = 0,
                null === (d = this._hotkeysListener) || void 0 === d || d.destroy(),
                null === (u = this._barsButton) || void 0 === u || u.destroy(),
                null === (h = this._controlBarNavigation) || void 0 === h || h.destroy(),
                this._controlBarNavigation = null,
                this._mainDiv && (this._onWheelBound && this._mainDiv.removeEventListener("wheel", this._onWheelBound),
                this._mainDiv.remove()),
                null === (p = this._timeAxisWidget) || void 0 === p || p.destroy(),
                this._timeAxisWidget = null,
                null === (m = this._definitionsViewModel) || void 0 === m || m.destroy()
            }
            title() {
                return r.t(null, void 0, i(639950))
            }
            emulateCriticalError() {
                this._chartSession.removeSeries("-1")
            }
            chartSession() {
                return this._chartSession
            }
            onDisconnected() {
                return this._disconnected
            }
            onReconnectBailout() {
                return this._reconnectBailout
            }
            onConnected() {
                return this._connected
            }
            chartWidgetInitialized() {
                return this._chartWidgetInitialized
            }
            setBarsButton(e) {
                this._barsButton = e
            }
            setVisibleTimeRange(e, t, i, s) {
                throw new Error("Not implemented")
            }
            chartWidgetCollection() {
                return this._chartWidgetCollection
            }
            isInitialized() {
                return this._inited
            }
            lineToolsSynchronizer() {
                return this._lineToolsSynchronizer
            }
            actions() {
                return null === this._actions ? this._setActions() : this._actions
            }
            defaultSymbol() {
                return this._defSymbol
            }
            requestFullscreen() {
                this.getResizerDetacher().requestFullscreen()
            }
            exitFullscreen() {
                this.getResizerDetacher().exitFullscreen()
            }
            inFullscreen() {
                return this.getResizerDetacher().fullscreen.value()
            }
            modelCreated() {
                return this._modelCreated
            }
            containsStudyByPredicate(e) {
                return !!this._model && this._model.dataSources().some((t=>!!(0,
                rt.isStudy)(t) && e(t.metaInfo())))
            }
            model() {
                return (0,
                s.ensureNotNull)(this._model)
            }
            id() {
                return this._id
            }
            layoutId() {
                return this._chartWidgetCollection.metaInfo.uid.value()
            }
            properties() {
                return this._properties
            }
            readOnly() {
                return Boolean(this._options.readOnly)
            }
            isActive() {
                return this._isActive.readonly()
            }
            isHovered() {
                return this._isHovered.readonly()
            }
            crossHairSyncEnabled() {
                return this._chartWidgetCollection.lock.crosshair.value()
            }
            isVisible() {
                return this._isVisible.value()
            }
            setVisible(e) {
                this._isVisible.setValue(e)
            }
            visible() {
                return this._isVisible.readonly()
            }
            isCollapsed() {
                return this._collapsed.value()
            }
            setCollapsed(e) {
                this._collapsed.setValue(e)
            }
            collapsed() {
                return this._collapsed.readonly()
            }
            isJustClonedChart() {
                return !!(this._options || {}).justCloned
            }
            removeAllDrawingTools() {
                this.model().removeAllDrawingTools()
            }
            removeAllStudies() {
                this.model().removeAllStudies()
            }
            removeAllStudiesDrawingTools() {
                this.model().removeAllStudiesAndDrawingTools()
            }
            removeSelectedSources() {
                this.removeDataSources(this.model().selection().dataSources())
            }
            removeDataSources(e) {
                const t = this.model()
                  , i = e.filter((e=>e !== t.mainSeries() && e !== t.lineBeingCreated() && e.isUserDeletable()));
                if (0 === i.length)
                    return;
                let o = null;
                (0,
                rt.isStudy)(i[0]) && ((0,
                s.assert)(1 === i.length, "Cannot remove several studies (no multi select for studies)"),
                o = i[0]);
                i.find((e=>e.hasAlert().value())) ? (0,
                cl.confirmDatasourceRemoving)().then((e=>{
                    e && t.removeSelectedSources()
                }
                )) : o && o.hasChildren() ? (0,
                Oe.showDeleteStudyTreeConfirm)((()=>{
                    t.removeSelectedSources()
                }
                )) : t.removeSelectedSources()
            }
            getSymbol(e) {
                var t, i, s, o;
                let n;
                return n = this._model ? this._model.mainSeries().properties().childs() : this.properties().childs().mainSeriesProperties.childs(),
                n ? e && n.shortName && n.shortName.value() ? null !== (i = null === (t = n.shortName) || void 0 === t ? void 0 : t.value()) && void 0 !== i ? i : "" : null !== (o = null === (s = n.symbol) || void 0 === s ? void 0 : s.value()) && void 0 !== o ? o : "" : ""
            }
            setSymbol(e) {
                this._model ? (this._symbolWV.setValue(e),
                this._model.setSymbol(this._model.mainSeries(), e)) : (this.properties().childs().mainSeriesProperties.merge({
                    symbol: e
                }),
                this._symbolWV.setValue(e),
                this._setSymbolIntervalContentOverrides.symbol = e)
            }
            setResolution(e) {
                this._model ? (this._resolutionWV.setValue(e),
                this._model.setResolution(this._model.mainSeries(), e)) : (this.properties().childs().mainSeriesProperties.merge({
                    interval: e
                }),
                this._resolutionWV.setValue(e),
                this._setSymbolIntervalContentOverrides.interval = e)
            }
            getResolution() {
                return this._model ? this._model.mainSeries().properties().childs().interval.value() : this.properties().childs().mainSeriesProperties.childs().interval.value()
            }
            symbolWV() {
                return this._symbolWV.readonly()
            }
            resolutionWV() {
                return this._resolutionWV.readonly()
            }
            loadRange(e) {
                if (this._model) {
                    this.screen.show();
                    this._model.loadRange(e) || this.screen.hide()
                }
            }
            async showGeneralChartProperties(e, t) {
                if (!d.enabled("show_chart_property_page"))
                    return Promise.resolve(null);
                const s = await this._showChartProperties(this.model().mainSeries(), e, {
                    doNotCloseOnBgClick: !0,
                    onResetToDefault: async()=>{
                        this.model().restorePreferences();
                        const e = await Promise.all([i.e(6113), i.e(83767)]).then(i.bind(i, 308721))
                          , t = e.getCurrentTheme().name;
                        e.loadTheme(this.chartWidgetCollection(), {
                            themeName: t,
                            standardTheme: !0
                        })
                    }
                    ,
                    shouldReturnFocus: null == t ? void 0 : t.shouldReturnFocus
                });
                if (null === s)
                    return null;
                const o = ()=>{
                    s.hide(),
                    this._chartWidgetCollection.activeChartWidget.unsubscribe(o)
                }
                ;
                return this._chartWidgetCollection.activeChartWidget.subscribe(o),
                s
            }
            showChartPropertiesForSource(e, t, i, s) {
                return d.enabled("property_pages") && e.userEditEnabled() ? e === this.model().model().mainSeries() ? this.showGeneralChartProperties(t) : ((i = i || {}).onResetToDefault = ()=>{
                    ((0,
                    ct.isLineTool)(e) || (0,
                    rt.isStudy)(e)) && this.model().restorePropertiesForSource.bind(this._model, e)
                }
                ,
                this._showChartProperties(e, t, i, s)) : Promise.resolve(null)
            }
            toggleCompareOrAdd() {
                this._compareDialog.visible().value() ? this._compareDialog.hide() : this._compareDialog.show()
            }
            tags() {
                return this._model ? this._model.calculateDefaultTags() : []
            }
            options() {
                return this._options
            }
            ownerDocument() {
                return (0,
                s.ensureNotNull)(this._parent).ownerDocument
            }
            async showChartPropertiesForSources(e) {
                if (!d.enabled("property_pages"))
                    return Promise.resolve(null);
                const {sources: t, title: o, tabName: n, renamable: a} = e
                  , l = (0,
                s.ensureNotNull)(this._model)
                  , c = Je(t.map((e=>e.properties().childs())))
                  , u = Je(t.map((e=>e.properties().childs().intervalsVisibilities)))
                  , [{createPropertyPage: h},{getSelectionStylePropertiesDefinitions: p},{getSelectionIntervalsVisibilitiesPropertiesDefinition: m},{getSelectionCoordinatesPropertyDefinition: g}] = await Promise.all([Promise.all([i.e(44692), i.e(37761), i.e(24379), i.e(96501), i.e(18537)]).then(i.bind(i, 290590)), Promise.all([i.e(44692), i.e(37761), i.e(24379), i.e(96501), i.e(18537)]).then(i.bind(i, 39634)), Promise.all([i.e(44692), i.e(37761), i.e(24379), i.e(96501), i.e(18537)]).then(i.bind(i, 797822)), Promise.all([i.e(44692), i.e(37761), i.e(24379), i.e(96501), i.e(18537)]).then(i.bind(i, 848071))]);
                return async function(e) {
                    const {SourcesPropertiesEditorRenderer: t} = await Promise.all([i.e(3618), i.e(46445), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(65857), i.e(36010), i.e(53953), i.e(2520), i.e(25480), i.e(62564), i.e(29800), i.e(46489), i.e(29296), i.e(58985), i.e(23141), i.e(62234), i.e(95083), i.e(75826), i.e(59258), i.e(82421), i.e(67158), i.e(22106), i.e(74600), i.e(30422), i.e(72197), i.e(16356), i.e(24125), i.e(88015), i.e(98734), i.e(97384), i.e(93523), i.e(3782), i.e(86605), i.e(43362), i.e(49162), i.e(41243), i.e(64797), i.e(22602), i.e(7001), i.e(71329), i.e(51488), i.e(94106), i.e(59470), i.e(75364), i.e(8222), i.e(33828), i.e(80089), i.e(76750), i.e(13752), i.e(32277), i.e(44066), i.e(25983), i.e(77414), i.e(79412), i.e(31085), i.e(42513), i.e(78685), i.e(59434), i.e(82440), i.e(24474), i.e(89255), i.e(89638), i.e(78687), i.e(31600), i.e(48694), i.e(85775), i.e(45619), i.e(38790), i.e(63095), i.e(601), i.e(62319), i.e(79184), i.e(88544), i.e(39782), i.e(71813), i.e(54786), i.e(1833), i.e(32227), i.e(50030), i.e(87473), i.e(5483), i.e(40563), i.e(53722), i.e(18405), i.e(90223), i.e(93498), i.e(65267), i.e(50186), i.e(71457), i.e(35432), i.e(85589), i.e(89178), i.e(13338), i.e(1077), i.e(92597), i.e(46796), i.e(46780)]).then(i.bind(i, 578569))
                      , s = new t(e);
                    return null !== Xe && (Xe.hide(),
                    Xe = s),
                    s.show(),
                    s
                }({
                    sources: t,
                    propertyPages: [h(p(c, l), "style", r.t(null, void 0, i(492516))), h({
                        definitions: [g(t, l)]
                    }, "displacement", r.t(null, void 0, i(970132))), h(m(u, l), "visibility", r.t(null, void 0, i(640091)))],
                    undoModel: l,
                    title: o,
                    activeTabId: n,
                    renamable: a
                })
            }
            getPriceAxisWidthChangedByName(e) {
                return "left" === e ? this._lhsPriceAxisWidthChanged : this._rhsPriceAxisWidthChanged
            }
            getPriceAxisMaxWidthByName(e) {
                return "left" === e ? this._lhsAxesWidth : this._rhsAxesWidth
            }
            timeAxisHeight() {
                return null !== this._timeAxisWidget ? this._timeAxisWidget.size.height : 0
            }
            withModel(e, t) {
                null !== this._model ? t.call(e) : this.modelCreated().subscribe(e, t, !0)
            }
            hasModel() {
                return null !== this._model
            }
            updateActions() {
                const e = this.actions()
                  , t = this.model().dataSources();
                let s = !1
                  , o = !1;
                for (let e = 0, i = t.length; e < i; e++) {
                    const i = t[e];
                    (0,
                    ct.isLineTool)(i) && i.isUserDeletable() && (s = !0),
                    ((0,
                    rt.isStudy)(i) && i.removeByRemoveAllStudies() || (0,
                    rt.isStudyStub)(i)) && (o = !0)
                }
                this.readOnly() || (e.paneRemoveAllStudies && e.paneRemoveAllStudies.update({
                    disabled: !o
                }),
                e.paneRemoveAllDrawingTools && e.paneRemoveAllDrawingTools.update({
                    disabled: !s
                }),
                e.paneRemoveAllStudiesDrawingTools && e.paneRemoveAllStudiesDrawingTools.update({
                    disabled: !o && !s
                }));
                !((0,
                pl.showThemeSwitcher)() || (0,
                pl.showThemeAction)() || window.is_authenticated) || async function(e) {
                    const [t,s] = await Promise.all([Promise.all([i.e(6113), i.e(83767)]).then(i.bind(i, 308721)), Promise.all([i.e(6113), i.e(83767)]).then(i.bind(i, 867432))])
                      , o = async o=>{
                        const n = [];
                        if (window.is_authenticated) {
                            n.length && n.push(new _i.Separator);
                            const t = new _i.Action({
                                actionId: "Chart.Theme.SaveAs",
                                options: {
                                    name: "theme-save-as",
                                    label: (0,
                                    ul.appendEllipsis)(r.t(null, void 0, i(276266))),
                                    onExecute: ()=>s.showThemeSaveDialogAsync(e.model().model().template())
                                }
                            });
                            n.push(t)
                        }
                        o && o.length && window.is_authenticated && (n.length && n.push(new _i.Separator),
                        o.forEach((i=>{
                            const o = new _i.Action({
                                actionId: "Chart.Theme.Apply.Custom",
                                options: {
                                    label: (0,
                                    dl.clean)(t.translateStdThemeName(i)),
                                    checkable: !1,
                                    onExecute: ()=>{
                                        t.loadTheme(e.chartWidgetCollection(), {
                                            themeName: i,
                                            standardTheme: !1
                                        }).then((()=>{
                                            window.saver.saveChartSilently(),
                                            (0,
                                            Ne.trackEvent)("GUI", "Switch to custom theme")
                                        }
                                        ))
                                    }
                                    ,
                                    toolbox: {
                                        type: hl.ToolboxType.Delete,
                                        action: ()=>s.showRemoveThemeDialogAsync(i)
                                    },
                                    showToolboxOnHover: !0
                                }
                            });
                            n.push(o)
                        }
                        )));
                        const a = e.actions();
                        a.applyColorTheme && a.applyColorTheme.update({
                            subItems: n,
                            disabled: 0 === n.length
                        })
                    }
                    ;
                    window.is_authenticated ? t.getThemeNames().then(o) : o()
                }(this);
                const n = []
                  , a = Ze.availableTimezones
                  , l = e=>e.id === this.model().model().properties().childs().timezone.value();
                if (a.forEach((e=>{
                    const t = new _i.Action({
                        actionId: "Chart.ChangeTimeZone",
                        options: {
                            label: e.title,
                            checkable: !0,
                            checked: l(e),
                            statName: "SetTimeZone",
                            onExecute: ()=>{
                                this.model().setProperty(this.model().model().properties().childs().timezone, e.id, Nc)
                            }
                        }
                    });
                    n.push(t)
                }
                )),
                e.applyTimeZone.update({
                    subItems: n
                }),
                e.addToWatchlist || e.addToTextNotes) {
                    const [,t] = (0,
                    Ac.splitSymbolName)(this.symbolWV().value());
                    if (e.addToWatchlist) {
                        const i = e.addToWatchlist;
                        i.request(),
                        i.updateLabel(t)
                    }
                    e.addToTextNotes && e.addToTextNotes.update({
                        label: r.t(null, void 0, i(339873)).format({
                            symbol: t
                        })
                    })
                }
                e.moveChartAction && e.moveChartAction.update({
                    disabled: !this._chartWidgetCollection.activeChartCanBeMoved()
                })
            }
            onRedraw() {
                return this._redraw
            }
            copyLineToOtherCharts() {
                const e = (0,
                s.ensureNotNull)(this._model)
                  , t = e.selection().lineDataSources().filter((e=>e.isSynchronizable()));
                e.model().copyToOtherCharts(t, !0)
            }
            toggleLockSelectedObject() {
                const e = this.model();
                e.selection().lineDataSources().forEach((t=>{
                    const i = t.properties().frozen.value();
                    e.setProperty(t.properties().frozen, !i, (i ? Bc : Rc).format({
                        title: new c.TranslatedString(t.name(),t.title(So.TitleDisplayTarget.StatusLine))
                    }), so.lineToolsDoNotAffectChartInvalidation)
                }
                ))
            }
            hideDataSources(e) {
                if (e.length) {
                    const t = e.map((e=>e.properties().visible))
                      , i = e.map((()=>!1));
                    this.model().setProperties(t, i, Dc.format({
                        title: new c.TranslatedString(e[0].name(),e[0].title(So.TitleDisplayTarget.StatusLine))
                    }))
                }
            }
            hideSelectedObject() {
                this.hideDataSources(this.model().selection().dataSources().filter((e=>!(0,
                li.isAlertLabel)(e))))
            }
            unlinkSelectedLine() {
                const e = (0,
                s.ensureNotNull)(this._model)
                  , t = e.selection().lineDataSources();
                e.unlinkLines(t)
            }
            paneWidgets() {
                return this._paneWidgets
            }
            paneByState(e) {
                for (let t = 0; t < this._paneWidgets.length; t++)
                    if (this._paneWidgets[t].state() === e)
                        return this._paneWidgets[t];
                return null
            }
            paneByCanvas(e) {
                for (let t = 0; t < this._paneWidgets.length; t++)
                    if (this._paneWidgets[t].hasCanvas(e))
                        return this._paneWidgets[t];
                return null
            }
            timeAxisByCanvas(e) {
                var t;
                return (null === (t = this._timeAxisWidget) || void 0 === t ? void 0 : t.hasCanvas(e)) ? this._timeAxisWidget : null
            }
            selectPointMode() {
                return (0,
                s.ensureNotNull)(this._model).model().selectPointMode()
            }
            cancelRequestSelectPoint() {
                const e = (0,
                s.ensureNotNull)(this._model).model();
                e.cancelRequestSelectPoint(),
                e.setReplayStatus(e.isInReplay().value() ? 3 : 0),
                e.clearCurrentPosition()
            }
            requestSelectPoint(e, t) {
                const i = (0,
                s.ensureNotNull)(this._model);
                return e.selectPointMode === qt.SelectPointMode.Replay && i.model().setReplayStatus(1),
                new Promise(((s,o)=>{
                    const n = ()=>!!this.isVisible() || (o("Chartwidget must be visible"),
                    this.cancelRequestSelectPoint(),
                    !1);
                    if (!n())
                        return;
                    (0,
                    qt.resetToCursor)(!0),
                    i.lineBeingCreated() && i.cancelCreatingLine();
                    let r = !1;
                    const a = {};
                    i.model().onPointSelected().subscribe(a, ((e,t)=>{
                        r = !0,
                        this._isVisible.unsubscribe(n),
                        this._hideHint(),
                        s({
                            point: e,
                            pane: t
                        })
                    }
                    ), !0),
                    i.model().requestSelectPoint(e),
                    this.startTrackingMode(),
                    void 0 !== t && this._showEventHint(t),
                    this._isVisible.subscribe(n),
                    this.selectPointMode().subscribe((()=>{
                        setTimeout((()=>{
                            r || (this.selectPointMode().value() === qt.SelectPointMode.None && this._hideHint(),
                            i.model().onPointSelected().unsubscribeAll(a),
                            this._isVisible.unsubscribe(n),
                            o("cancelled"))
                        }
                        ))
                    }
                    ), {
                        once: !0
                    })
                }
                ))
            }
            showReplayOrderConfirmationDialog() {
                return this.model().isInReplay().value() ? new Promise(((e,t)=>{
                    (0,
                    sl.showConfirm)({
                        text: r.t(null, void 0, i(777017)),
                        onConfirm: t=>{
                            e(),
                            t.dialogClose()
                        }
                        ,
                        onClose: t
                    })
                }
                )) : Promise.resolve()
            }
            showSourceProperties(e, t) {
                e === this.model().mainSeries() && (t = ot.TabNames.symbol),
                this.showChartPropertiesForSource(e, t)
            }
            onScroll() {
                return this._onScroll
            }
            onZoom() {
                return this._onZoom
            }
            onTagsChanged() {
                return this._tagsChanged
            }
            onWidget() {
                return this._onWidget
            }
            containsVolume() {
                return this.model().dataSources().some((e=>(0,
                rt.isStudy)(e) && "Volume" === e.metaInfo().shortId))
            }
            containsStudy(e) {
                return this.containsStudyByPredicate((t=>t.id === e || t.fullId === e))
            }
            isSmall() {
                return this._width() < 550 || this._height() < 300
            }
            onCmeWidget() {
                return "cme" === this._widgetCustomer
            }
            widgetCustomer() {
                return this._widgetCustomer
            }
            compareSymbols() {
                return this._compareSymbols
            }
            images(e) {
                window.TradingView.printing = !0;
                const t = this.model().selection().allSources();
                this.model().selectionMacro((e=>e.clearSelection())),
                this.model().model().recalculateAllPanes((0,
                as.globalChangeEvent)());
                const i = (t,i)=>{
                    t.paint(i);
                    const s = {
                        showCollapsedStudies: Boolean(null == e ? void 0 : e.showCollapsedStudies),
                        status: null == e ? void 0 : e.status
                    };
                    return t.getScreenshotData(s)
                }
                  , s = [];
                if (null !== this._maximizedPaneWidget) {
                    const e = this._paneWidgets.indexOf(this._maximizedPaneWidget);
                    s.push(i(this._maximizedPaneWidget, N.InvalidationMask.light().invalidateForPane(e)))
                } else
                    for (let e = 0; e < this._paneWidgets.length; ++e) {
                        const t = this._paneWidgets[e];
                        s.push(i(t, N.InvalidationMask.light().invalidateForPane(e))),
                        e < this._paneWidgets.length - 1 && s.push(this._paneSeparators[e].image())
                    }
                let o;
                this._timeAxisWidget && (this._timeAxisWidget.paint(N.InvalidationLevel.Light),
                o = this._timeAxisWidget.getScreenshotData()),
                window.TradingView.printing = !1,
                this.model().selectionMacro((e=>{
                    t.forEach((t=>{
                        e.addSourceToSelection(t)
                    }
                    ))
                }
                )),
                this.model().model().recalculateAllPanes((0,
                as.globalChangeEvent)()),
                this.model().model().lightUpdate();
                const n = this.mainSeriesQuotesAndMetainfo();
                return {
                    panes: s,
                    timeAxis: o,
                    colors: {
                        text: this.properties().childs().scalesProperties.childs().textColor.value(),
                        bg: this.properties().childs().paneProperties.childs().background.value(),
                        scales: this.properties().childs().scalesProperties.childs().lineColor.value()
                    },
                    meta: n.meta,
                    ohlc: n.ohlc,
                    quotes: n.quotes
                }
            }
            insertStudy(e, t, i, s, o) {
                return this._insertStudyOrReplaceStub(e, t, void 0, i, s, o)
            }
            replaceStubByStudy(e, t, i, s, o, n) {
                return e.updateDescriptor(t),
                this._insertStudyOrReplaceStub(t, i, e, s, o, n)
            }
            addOverlayStudy(e, t, i) {
                const s = this.model();
                return this._options && this._options.isSymbolAvailable ? this._options.isSymbolAvailable(e).then((async o=>{
                    if (!o)
                        return null;
                    await (0,
                    $a.studyMetaInfoRepository)().requestMetaInfo();
                    const n = s.createStudyInserter({
                        type: "java",
                        studyId: "Overlay@tv-basicstudies"
                    }, [])
                      , r = {
                        allowExtendTimeScale: i
                    };
                    if (d.enabled("use_overrides_for_overlay")) {
                        const e = (0,
                        hr.factoryDefaults)("study_Overlay@tv-basicstudies.style");
                        r.style = e
                    }
                    return n.setPropertiesState(r),
                    n.setForceOverlay(t),
                    n.insert((()=>Promise.resolve({
                        inputs: {
                            symbol: e
                        },
                        parentSources: []
                    })))
                }
                )) : Promise.resolve(null)
            }
            addCompareStudy(e) {
                const t = this.model();
                return this._options && this._options.isSymbolAvailable ? this._options.isSymbolAvailable(e).then((async i=>i ? (await (0,
                $a.studyMetaInfoRepository)().requestMetaInfo(),
                t.createStudyInserter({
                    type: "java",
                    studyId: "Compare@tv-basicstudies"
                }, []).insert((()=>Promise.resolve({
                    inputs: {
                        symbol: e
                    },
                    parentSources: []
                })))) : null)) : Promise.resolve(null)
            }
            showIndicators(e, t) {
                if (window.studyMarket)
                    return window.studyMarket.visible().value() ? void window.studyMarket.hide() : (window.studyMarket.show(e, t),
                    window.studyMarket)
            }
            setSaveChartService(e) {
                this._saveChartService = e,
                null !== this._lineToolsSynchronizer && this._lineToolsSynchronizer.setSaveChartService(e)
            }
            getSaveChartService() {
                return this._saveChartService
            }
            mainSeriesQuotesAndMetainfo() {
                let e, t, i;
                const s = this._model && this._model.mainSeries();
                if (s) {
                    const o = e=>null == e ? "" : s.formatter().format(e, {
                        signNegative: !0,
                        useRtlFormat: !1
                    })
                      , n = e=>null == e ? "" : e + "";
                    e = {
                        resolution: s.interval(),
                        symbol: s.symbol(),
                        values: s.legendValuesProvider().getValues(null)
                    };
                    const r = s.symbolInfo();
                    r && (e.symbol = r.full_name,
                    e.description = r.description,
                    e.exchange = r.exchange);
                    const a = s.bars().last();
                    null !== a && (t = a.value.slice(1, 5).map(o));
                    const l = s.quotes();
                    l && (i = {
                        change: o(l.change),
                        changePercent: n(l.change_percent),
                        last: o(l.last_price)
                    })
                }
                return {
                    meta: e,
                    ohlc: t,
                    quotes: i
                }
            }
            isMultipleLayout() {
                return this._isMultipleLayout
            }
            updateCrossHairPositionIfNeeded() {
                if (this._model) {
                    const e = qt.tool.value();
                    this._model.model().setCurrentTool(e);
                    const t = (0,
                    Mt.lastMouseOrTouchEventInfo)();
                    if (t.isTouch) {
                        const e = this._maximizedPaneWidget || this._paneWidgets[0];
                        if (e.hasState() && (!t.stylus && (this._isLineToolModeExceptBrush() || (0,
                        qt.toolIsMeasure)(qt.tool.value())) || this.selectPointMode().value() !== qt.SelectPointMode.None)) {
                            const t = .5 * this._model.model().timeScale().width()
                              , i = .5 * e.state().defaultPriceScale().height();
                            e.setCursorPosition(t, i)
                        }
                        const i = this._model.model().crossHairSource();
                        i.updateAllViews((0,
                        as.sourceChangeEvent)(i.id()))
                    }
                }
            }
            trackingModePaneWidget() {
                if (!(0,
                Mt.lastMouseOrTouchEventInfo)().isTouch)
                    return null;
                for (const e of this.paneWidgets())
                    if (e.trackingModeEnabled())
                        return e;
                return null
            }
            startTrackingMode() {
                if ((0,
                Mt.lastMouseOrTouchEventInfo)().isTouch) {
                    this.exitTrackingMode(),
                    this.updateCrossHairPositionIfNeeded();
                    const e = this._maximizedPaneWidget || this._paneWidgets[0]
                      , t = this.model().model().crossHairSource().currentPoint();
                    e.startTrackingMode(t, t)
                }
            }
            exitTrackingMode() {
                (0,
                Mt.lastMouseOrTouchEventInfo)().isTouch && this.paneWidgets().some((e=>e.trackingModeEnabled())) && (this.paneWidgets().forEach((e=>e.exitTrackingMode())),
                this.model().model().clearCurrentPosition())
            }
            onToolChanged() {
                const e = this.model().model();
                e.lineBeingCreated() && !e.lineBeingCreateFromExternal() && this._cancelCreatingLine(),
                this.selectPointMode().value() !== qt.SelectPointMode.None && this.cancelRequestSelectPoint(),
                this.exitTrackingMode()
            }
            setInLoadingState(e) {
                this._inLoadingState = e
            }
            paint(e) {
                const t = null != e ? e : N.InvalidationMask.full();
                t.validationActions().forEach((e=>e())),
                this._paneWidgets.forEach(((e,i)=>{
                    null !== this._maximizedPaneWidget && this._maximizedPaneWidget !== e || e.paint(t.invalidateForPane(i))
                }
                )),
                this._timeAxisWidget && this._timeAxisWidget.paint(t.invalidateForTimeScale()),
                null == Oc || Oc(),
                this._redraw.fire()
            }
            GUIResetScales() {
                (0,
                Ne.trackEvent)("GUI", "Reset Scales"),
                null !== this._model && this._model.resetScales()
            }
            applyOverrides(e) {
                const t = {};
                for (const [i,s] of Object.entries(e))
                    i.startsWith("mainSeriesProperties.priceAxisProperties") || (t[i] = s);
                if ((0,
                hr.applyPropertiesOverrides)(this.properties(), void 0, !1, t, void 0),
                this._model) {
                    (0,
                    hr.applyPropertiesOverrides)(this._model.model().properties(), void 0, !1, t),
                    (0,
                    hr.applyPropertiesOverrides)(this._model.mainSeries().properties(), void 0, !1, t, "mainSeriesProperties"),
                    this._model.model().sessions().applyOverrides(t);
                    const e = this._model.model().watermarkSource();
                    null !== e && e.applyOverrides(t)
                }
            }
            showFundamentals(e) {
                this.showIndicators(e ? [e] : void 0, "financials")
            }
            toggleMaximizePane(e) {
                var t;
                if (!(this._paneWidgets.length < 2)) {
                    this._maximizedPaneWidget ? (this._maximizedPaneWidget.state().maximized().setValue(!1),
                    this._maximizedPaneWidget = null,
                    this._paneSeparators.forEach((e=>e.show()))) : (this._maximizedPaneWidget = e,
                    this._maximizedPaneWidget.state().maximized().setValue(!0),
                    this._paneSeparators.forEach((e=>e.hide())));
                    for (let e = this._paneWidgets.length; e--; )
                        this._paneWidgets[e].updateControls(),
                        this._paneWidgets[e].updatePriceAxisWidgetsStates();
                    this._errorRenderer.updatePaneWidgets(),
                    null === (t = this._timeAxisWidget) || void 0 === t || t.updatePriceAxisStubs(),
                    this._adjustSize(),
                    this.updateCrossHairPositionIfNeeded()
                }
            }
            maximizedPaneWidget() {
                return this._maximizedPaneWidget
            }
            isMaximizedPane() {
                return null !== this._maximizedPaneWidget
            }
            setActive(e) {
                (0,
                Mt.lastMouseOrTouchEventInfo)().isTouch && (e && this.selectPointMode().value() !== qt.SelectPointMode.None ? this.startTrackingMode() : this.exitTrackingMode());
                for (const e of this._paneWidgets)
                    e.update();
                e || this.model().selectionMacro((e=>{
                    e.clearSelection()
                }
                )),
                this._isActive.setValue(e)
            }
            justActivated() {
                return this._justActivated
            }
            unsetActivePaneWidget() {
                this.activePaneWidget = null
            }
            setActivePaneWidget(e) {
                this.activePaneWidget = e
            }
            onPaneWidgetDestroyed(e) {
                this.activePaneWidget === e && (this.activePaneWidget = null)
            }
            getResizerDetacher() {
                return this._options
            }
            toggleFullscreen() {
                const e = this.getResizerDetacher();
                e.fullscreenable.value() && (e.fullscreen.value() ? e.exitFullscreen() : e.requestFullscreen())
            }
            generalPropertiesDefinitions() {
                return this._getChartPropertyDefinitionsViewModel().then((e=>e.propertyPages()))
            }
            propertiesDefinitionsForSource(e) {
                return (0,
                ct.isLineTool)(e) || (0,
                rt.isStudy)(e) || (0,
                ct.isStudyLineTool)(e) ? e.getPropertyDefinitionsViewModel().then((e=>null === e ? null : e.propertyPages())).catch((e=>(Lc.logWarn(e),
                null))) : Promise.resolve(null)
            }
            backgroundTopTheme() {
                return this._backgroundTopTheme.readonly()
            }
            backgroundBasedTheme() {
                return this._backgroundBasedTheme.readonly()
            }
            backgroundBottomTheme() {
                return this._backgroundBottomTheme.readonly()
            }
            state(e, t, i, s) {
                if (this._model) {
                    const o = this._model.state(e, t, i, s);
                    return o.chartId = this.id(),
                    o
                }
                return this._content
            }
            lineToolsAndGroupsDTO() {
                return (0,
                s.ensureNotNull)(this._lineToolsSynchronizer).prepareDTO()
            }
            resetLineToolsInvalidated(e, t, i) {
                (0,
                s.ensureNotNull)(this._lineToolsSynchronizer).resetInvalidated(e, t, i)
            }
            applyLineToolUpdateNotification(e, t) {
                (0,
                s.ensureNotNull)(this._lineToolsSynchronizer).applyLineToolUpdateNotification(e, t)
            }
            reloadAllLineTools() {
                (0,
                s.ensureNotNull)(this._lineToolsSynchronizer).reloadAllLineTools()
            }
            startApplyingLineToolUpdateNotification() {
                var e;
                null === (e = this._lineToolsSynchronizer) || void 0 === e || e.startApplyingLineToolUpdateNotification()
            }
            endApplyingLineToolUpdateNotification() {
                var e;
                null === (e = this._lineToolsSynchronizer) || void 0 === e || e.endApplyingLineToolUpdateNotification()
            }
            applyAlertIdByExternalSource(e, t) {
                var i;
                null === (i = this._lineToolsSynchronizer) || void 0 === i || i.applyAlertIdByExternalSource(e, t)
            }
            deleteAlertByExternalSource(e, t) {
                var i;
                null === (i = this._lineToolsSynchronizer) || void 0 === i || i.deleteAlertByExternalSource(e)
            }
            shouldBeSavedEvenIfHidden() {
                return this._model ? this.model().model().shouldBeSavedEvenIfHidden() : !!this._options.content.shouldBeSavedEvenIfHidden
            }
            getTimeScale() {
                return this._timeAxisWidget
            }
            showObjectsTreePanelOrDialog() {
                let e = !1;
                const t = window.widgetbar;
                if (t && t.isVisible()) {
                    const i = (0,
                    s.ensureNotNull)(t.setPage("object_tree"))
                      , o = (0,
                    s.ensureNotNull)(i.widget("object_tree"));
                    (0,
                    s.ensureDefined)(o.properties).setValue({
                        selectedPage: "object_tree"
                    }),
                    e = "object_tree" === i.name
                }
                e || this.showObjectsTreeDialog()
            }
            showObjectsTreeDialog() {
                var e;
                null === (e = this._objectTreeDialogController) || void 0 === e || e.show()
            }
            addCustomWidgetToLegend(e, t) {
                this._customLegendWidgetsFactoryMap.set(e, t);
                for (const i of this.paneWidgets())
                    i.addCustomWidgetToLegend(e, t)
            }
            applyIndicatorsToAllChartsAvailable() {
                if (!this.chartWidgetCollection().applyIndicatorsToAllChartsAvailable())
                    return !1;
                for (const e of this.model().model().panes()) {
                    if (e.sourcesByGroup().all().some((e=>(0,
                    rt.isStudy)(e) && !(0,
                    lt.isLollipopDataSource)(e))))
                        return !0
                }
                return !1
            }
            widget() {
                return (0,
                s.ensureNotNull)(this._mainDiv)
            }
            restoreState(e, t, o) {
                this._adjustSize();
                const n = (0,
                s.ensureNotNull)(this._model)
                  , r = n.restoreState(this._content, t, o)
                  , a = n.mainSeries().properties().childs();
                this._symbolWV.setValue(a.symbol.value()),
                this._resolutionWV.setValue(a.interval.value()),
                r && r.lines_limit_exceeded && !this.readOnly() && Promise.all([i.e(68234), i.e(61135), i.e(91797), i.e(59355), i.e(42810), i.e(96645), i.e(10417), i.e(86021), i.e(25977), i.e(81459), i.e(46086), i.e(90609)]).then(i.bind(i, 316800)).then((({showLinetoolsLimitExceededDialog: e})=>{
                    e(this)
                }
                ))
            }
            addCompareAsOverlay(e, t, i) {
                const o = this.model();
                return (0,
                s.ensureDefined)(this._options.isSymbolAvailable)(e).then((async s=>{
                    if (!s)
                        return null;
                    await (0,
                    $a.studyMetaInfoRepository)().requestMetaInfo();
                    const n = o.createStudyInserter({
                        type: "java",
                        studyId: "Overlay@tv-basicstudies"
                    }, []);
                    return n.setForceOverlay(!0),
                    n.setPreferredPriceScale("as-series"),
                    !0 !== i && n.setTargetPriceScaleMode({
                        percentage: !0
                    }),
                    void 0 !== t && n.setPropertiesState({
                        allowExtendTimeScale: t
                    }),
                    n.insert((async()=>({
                        inputs: {
                            symbol: e
                        },
                        parentSources: []
                    })))
                }
                ))
            }
            scrollHelper() {
                return this._scrollHelper
            }
            resize() {
                const e = this._height() + "px"
                  , t = this._width() + "px"
                  , i = (0,
                s.ensureNotNull)(this._mainDiv);
                i.style.height = e,
                i.style.width = t,
                this._elMainTable.style.height = e,
                this._elMainTable.style.width = t,
                this._resizeHandler && this._mainDiv && this._resizeHandler()
            }
            chartPainted() {
                return this._drawPlanned ? (null === this._chartPaintedPromise && (this._chartPaintedPromise = (0,
                Ve.createDeferredPromise)()),
                this._chartPaintedPromise.promise) : Promise.resolve()
            }
            setDataWindowWidget(e) {
                this._dataWindowWidget = e
            }
            removeDataWindowWidget() {
                this._dataWindowWidget = null
            }
            showSelectedSourcesProperties(e) {
                const t = (0,
                s.ensureNotNull)(this._model).selection().dataSources();
                if (1 === t.length)
                    this.showSourceProperties(t[0], e);
                else {
                    const i = t.filter(ct.isLineTool);
                    i.length > 0 && this.showChartPropertiesForSources({
                        sources: i,
                        tabName: e
                    })
                }
            }
            setTimingsMeter(e) {
                this._timingsMeter = e,
                this._updateTimingsMeterState()
            }
            onAboutToBeDestroyed() {
                return this._aboutToBeDestroyed
            }
            executeActionById(e) {
                if ("takeScreenshot" === e)
                    return console.warn('Action "takeScreenshot" is deprecated. Use method "takeScreenshot" instead'),
                    void this._chartWidgetCollection.takeScreenshot();
                const t = this.actions()[e];
                t ? t.execute() : console.warn("Unknown action id: " + e)
            }
            getCheckableActionState(e) {
                const t = this.actions()[e];
                if (t) {
                    if (t.isCheckable())
                        return t.isChecked();
                    console.warn("Action " + e + " has no state")
                } else
                    console.warn("Unknown action id: " + e);
                return null
            }
            connect() {
                this._chartSession.isConnected().subscribe(this._onChartSessionIsConnectedChanged),
                this._chartSession.criticalError().subscribe(this, this._onChartSessionCriticalError),
                this._chartSession.connect(this._onData.bind(this))
            }
            finishInitWithoutConnect() {
                this._chartSession.disable(),
                this._init(),
                this._chartWidgetInitialized.fire()
            }
            reconnect() {
                this._chartSession.disconnect(),
                this._chartSession.connect()
            }
            update() {
                if (this.hasModel()) {
                    for (const e of this._paneWidgets)
                        e.update();
                    this._timeAxisWidget && this._timeAxisWidget.update()
                }
            }
            setPriceAxisHovered(e, t) {
                t ? this._hoveredPriceAxes.add(e) : this._hoveredPriceAxes.delete(e),
                this._anyAxisHovered.setValue(this._hoveredPriceAxes.size > 0)
            }
            anyPriceAxisHovered() {
                return this._anyAxisHovered.readonly()
            }
            linkingGroupIndex() {
                return this._linkingGroupIndex
            }
            offsetInDocument(e) {
                const t = this._paneWidgets.find((t=>t.state() === e));
                if (void 0 === t)
                    return {
                        left: NaN,
                        top: NaN
                    };
                const i = t.getElement().getBoundingClientRect();
                return {
                    left: Math.round(i.left + document.body.scrollLeft),
                    top: Math.round(i.top + document.body.scrollTop)
                }
            }
            showHint(e, ...t) {
                0 === e ? this._showEventHint(...t) : 1 === e && this._showWarningHint(...t)
            }
            hotkeys() {
                return this._hotkeys
            }
            loadContent(e, t) {
                this.screen.show();
                const i = this.model();
                this.isMaximizedPane() && this.toggleMaximizePane(null);
                const s = i.model().dataSources()
                  , o = i.mainSeries()
                  , n = i.crossHairSource();
                n.clearMeasure();
                for (let e = 0; e < s.length; e++) {
                    const t = s[e];
                    t !== o && t !== n && i.model().removeSource(t, !0)
                }
                let r, a;
                i.model().disconnect(),
                this.activePaneWidget = null,
                o.purgeSymbolInfo(),
                e.loading = !0,
                this._content = e,
                this._setSymbolIntervalContentOverrides = {},
                this._initialLoading = t;
                const l = this._contentSeriesProperties();
                if (l && (r = l,
                a = e.chartProperties.priceScaleSelectionStrategyName),
                !r)
                    throw Error("An error occured while determining main series ion the chart");
                this._properties.childs().mainSeriesProperties.mergeAndFire({
                    visible: !0,
                    symbol: r.symbol,
                    timeframe: "",
                    interval: r.interval || "D",
                    style: r.style
                }),
                void 0 !== a && this._properties.childs().priceScaleSelectionStrategyName.setValue(a),
                this._init(),
                i.undoHistory().clearStack()
            }
            resetDrawingState() {
                var e, t, i;
                (0,
                qt.resetToCursor)(!0);
                const o = (0,
                s.ensureNotNull)(null !== (t = null === (e = this._model) || void 0 === e ? void 0 : e.crossHairSource().pane) && void 0 !== t ? t : null);
                (0,
                s.ensureNotNull)(this.paneByState(o)).cancelCreatingLineTool(),
                null === (i = this._model) || void 0 === i || i.selectionMacro((e=>{
                    e.clearSelection()
                }
                ))
            }
            _clearSelectionHotkey() {
                return {
                    desc: "Cancel selection",
                    hotkey: 27,
                    handler: ()=>{
                        var e, t, i, s, o;
                        if (this._checkIsTradedGroupSelected() && (null === (e = (0,
                        Br.tradingService)()) || void 0 === e || e.clearTradedContextLinking()),
                        this.selectPointMode().value() !== qt.SelectPointMode.None)
                            return this.selectPointMode().value() === qt.SelectPointMode.Replay && this._chartWidgetCollection.getAll().forEach((e=>{
                                e !== this && e.selectPointMode().value() === qt.SelectPointMode.Replay && e.cancelRequestSelectPoint()
                            }
                            )),
                            void this.cancelRequestSelectPoint();
                        null === (t = this._model) || void 0 === t || t.selectionMacro((e=>{
                            this._cancelCreatingLine(),
                            e.clearSelection()
                        }
                        ));
                        const n = null === (i = this._model) || void 0 === i ? void 0 : i.model().customSourceMovingHitTestData();
                        n && n.cancelMoveHandler && n.cancelMoveHandler() && (n.cancelled = !0,
                        null === (s = this._model) || void 0 === s || s.model().setMovingCustomSource(null, null),
                        null === (o = this._model) || void 0 === o || o.model().lightUpdate())
                    }
                    ,
                    isDisabled: ()=>{
                        const e = this._model;
                        if (!e)
                            return !0;
                        const t = 0 === e.selection().allSources().length
                          , i = null === e.crossHairSource().measurePane().value()
                          , s = this.selectPointMode().value() === qt.SelectPointMode.None;
                        return t && i && s
                    }
                }
            }
            _insertStudyOrReplaceStub(e, t, i, s, o, n) {
                {
                    const o = this.model().model().chartApi().canCreateStudy({
                        id: "java" === e.type ? e.studyId : "",
                        child: t.length > 0,
                        fundamental: null == s ? void 0 : s.isFundamental
                    });
                    if (!o.success)
                        return i && this.model().model().removeSource(i, !0),
                        (0,
                        Js.showStudiesLimitGoProDialog)(this.model().model(), o),
                        Promise.resolve(null)
                }
                const r = "java" === e.type;
                return new Promise((async a=>{
                    if (0 === t.length)
                        return null == n || n(),
                        r && await (0,
                        $a.studyMetaInfoRepository)().requestMetaInfo(),
                        void a(this._insertOrReplaceStubByStudyImpl(e, t, i, s, o));
                    window.runOrSignIn((async()=>{
                        null == n || n(),
                        r && await (0,
                        $a.studyMetaInfoRepository)().requestMetaInfo(),
                        a(this._insertOrReplaceStubByStudyImpl(e, t, i, s, o))
                    }
                    ), {
                        source: "study on study"
                    })
                }
                )).catch((()=>null))
            }
            _insertOrReplaceStubByStudyImpl(e, t, o, n, a) {
                const l = (0,
                s.ensureNotNull)(this._model).createStudyInserter(e, t, n);
                l.setForceOverlay("java" === e.type && "Volume@tv-basicstudies" === e.studyId && d.enabled("volume_force_overlay"));
                const c = l.insert(((e,i,s)=>new Promise(((o,n)=>{
                    this.selectPointMode().value() !== qt.SelectPointMode.None && this.cancelRequestSelectPoint(),
                    a ? o(a(e, i, s)) : (0,
                    rt.isSymbolicStudy)(s) ? ((0,
                    Ne.trackEvent)("GUI", "Confirmation dialogs", "Symbol confirmation dialog"),
                    qe(this, e, s, o, n, "symbol")) : (0,
                    rt.hasConfirmInputs)(i) ? ((0,
                    Ne.trackEvent)("GUI", "Confirmation dialogs", "Inputs confirmation dialog"),
                    qe(this, e, s, o, n)) : o({
                        inputs: {},
                        parentSources: t
                    })
                }
                ))), void 0, o);
                return c.then((()=>{
                    (0,
                    qt.hideAllIndicators)().value() && (0,
                    He.toggleHideMode)()
                }
                )).catch((e=>{
                    o || (e === bl.InsertionErrorCode.StudyCannotBeChild && (0,
                    il.showNoticeDialog)({
                        type: "modal",
                        title: r.t(null, void 0, i(621064)),
                        content: r.t(null, void 0, i(359519))
                    }),
                    e === bl.InsertionErrorCode.CannotCompilePub && (0,
                    il.showNoticeDialog)({
                        type: "modal",
                        title: r.t(null, void 0, i(621064)),
                        content: r.t(null, void 0, i(418260))
                    }),
                    e === bl.InsertionErrorCode.CannotGetMetainfo && (0,
                    il.showNoticeDialog)({
                        type: "modal",
                        title: r.t(null, void 0, i(621064)),
                        content: r.t(null, void 0, i(504509))
                    }))
                }
                )),
                c
            }
            async _showChartProperties(e, t, i, s) {
                if (!this._model)
                    return null;
                t && ((0,
                ke.setValue)("properties_dialog.active_tab.chart", t),
                i.tabName = t);
                const o = await ht(e, this._model, i, this._options.chartWidgetCollection, s);
                return (null == o ? void 0 : o.visible().value()) ? o : null
            }
            _createLineToolsSynchronizerIfNeeded() {
                var e;
                {
                    const t = {
                        readOnlyMode: this.readOnly(),
                        migrateSyncedLineTools: this === this._options.chartWidgetCollection.getAll()[0]
                    }
                      , i = Rl;
                    this._lineToolsSynchronizer = new i({
                        layoutId: this.layoutId(),
                        chartId: this._id,
                        clientId: this._chartWidgetCollection.clientId
                    },this.model().model(),t),
                    null !== this._saveChartService && this._lineToolsSynchronizer.setSaveChartService(this._saveChartService),
                    this._lineToolsSynchronizer.invalidateAll(),
                    null === (e = this._model) || void 0 === e || e.model().setLineToolsSynchronizer(this._lineToolsSynchronizer)
                }
            }
            _updateThemedColor() {
                const e = this.model().model()
                  , t = e.backgroundColorAtYPercentFromTop(.5);
                let i = e.backgroundTopColor().value()
                  , s = e.backgroundColor().value();
                const o = (0,
                Re.isColorDark)(t)
                  , n = (0,
                Re.isColorDark)(i)
                  , r = (0,
                Re.isColorDark)(s);
                this.widget().classList.toggle("chart-widget--themed-dark", o),
                this.widget().classList.toggle("chart-widget--themed-light", !o),
                this.widget().classList.toggle("chart-widget__top--themed-dark", n),
                this.widget().classList.toggle("chart-widget__top--themed-light", !n),
                this.widget().classList.toggle("chart-widget__bottom--themed-dark", r),
                this.widget().classList.toggle("chart-widget__bottom--themed-light", !r),
                this._backgroundTopTheme.setValue(n ? "dark" : "light"),
                this._backgroundBasedTheme.setValue(o ? "dark" : "light"),
                this._backgroundBottomTheme.setValue(r ? "dark" : "light"),
                i === s && (0,
                Ce.isStdThemedDefaultValue)("chartProperties.paneProperties.background", i, this._backgroundBasedTheme.value()) && (i = null,
                s = null);
                for (const e of this._paneWidgets)
                    e.updateThemedColors({
                        topColor: i,
                        bottomColor: s
                    })
            }
            _isLineToolModeExceptBrush() {
                const e = qt.tool.value();
                return (0,
                U.isLineToolName)(e) && !(0,
                U.isLineDrawnWithPressedButton)(e) && this.selectPointMode().value() === qt.SelectPointMode.None
            }
            _cancelCreatingLine() {
                const e = (0,
                s.ensureNotNull)(this._model).model()
                  , t = e.lineBeingCreated();
                if (null !== t) {
                    const i = (0,
                    s.ensureNotNull)(e.paneForSource(t));
                    (0,
                    s.ensureNotNull)(this.paneByState(i)).cancelCreatingLineTool(),
                    t.toolname === qt.tool.value() && (0,
                    qt.resetToCursor)()
                }
                const i = e.crossHairSource().measurePane().value();
                if (null !== i) {
                    (0,
                    s.ensureNotNull)(this.paneByState(i)).cancelMeasuring()
                }
            }
            _adjustSize(e) {
                var t;
                let i = 0;
                const s = null === this._model ? null : this._model.model().priceScaleSlotsCount()
                  , o = new Uint32Array(null === s ? 0 : s.left)
                  , n = new Uint32Array(null === s ? 0 : s.right)
                  , r = (0,
                xt.getCanvasDevicePixelRatio)(document.body)
                  , a = (e,t)=>e + t
                  , l = (e,t)=>{
                    t.forEach(((t,i)=>{
                        e[i] = Math.max(e[i], t)
                    }
                    ))
                }
                  , c = this._width()
                  , d = this._height()
                  , u = this._paneSeparators.length
                  , h = this.isMaximizedPane() ? 0 : Wt.height() * u
                  , p = null !== this._timeAxisWidget ? this._timeAxisWidget.optimalHeight() : 0;
                let m = d - p >= 61 ? p : 0;
                m % 2 && (m += 1);
                const g = Math.max(1, Math.floor((d - h - m) / this._paneWidgets.length));
                let _ = 0
                  , v = null;
                for (const e of this._paneWidgets)
                    if (!this._maximizedPaneWidget || this._maximizedPaneWidget === e) {
                        e.leftPriceAxisesContainer().updateCurrencyLabels();
                        const t = e.leftPriceAxisesContainer().optimalWidths();
                        e.rightPriceAxisesContainer().updateCurrencyLabels();
                        const s = e.rightPriceAxisesContainer().optimalWidths();
                        l(o, t),
                        l(n, s),
                        this._maximizedPaneWidget !== e && e.state().collapsed().value() ? _ += Math.min(g, e.collapsedHeight()) : (i += e.stretchFactor(),
                        v = e)
                    }
                let S = o.reduce(a, 0)
                  , f = n.reduce(a, 0)
                  , b = Math.max(c - S - f, 0);
                if (b <= 102) {
                    S = 0,
                    f = 0,
                    b = c;
                    for (let e = 0; e < o.length; e++)
                        o[e] = 0;
                    for (let e = 0; e < n.length; e++)
                        n[e] = 0
                }
                for (const e of this._paneSeparators)
                    e.adjustSize();
                const y = h + _ + m
                  , C = d < y ? 0 : d - y
                  , w = C / i;
                let T = 0
                  , P = !1;
                const x = null === (t = this._model) || void 0 === t ? void 0 : t.model();
                for (let e = 0; e < this._paneWidgets.length; ++e) {
                    const t = this._paneWidgets[e];
                    void 0 !== x && t.setState(x.panes()[e]);
                    let i = 0;
                    if (this.isMaximizedPane())
                        i = this._maximizedPaneWidget === t ? C : 0;
                    else if (t.state().collapsed().value())
                        i = Math.min(g, t.collapsedHeight());
                    else {
                        const e = t === v ? Math.ceil((C - T) * r) / r : Math.round(t.stretchFactor() * w * r) / r;
                        i = Math.max(e, 2),
                        T += i
                    }
                    t.setPriceAxisSizes("left", i, o),
                    t.setPriceAxisSizes("right", i, n),
                    P = P || i !== t.height(),
                    t.setSize((0,
                    Ae.size)({
                        width: b,
                        height: i
                    })),
                    x && t.state() && x.setPaneHeight(t.state(), i)
                }
                null !== this._timeAxisWidget && this._timeAxisWidget.setSizes((0,
                Ae.size)({
                    width: b,
                    height: m
                }), o, n),
                x && x.setWidth(b, e),
                this._controlBarNavigation && this._controlBarNavigation.updatePosition(),
                this._lhsAxesWidth !== S && (this._lhsAxesWidth = S,
                this._lhsPriceAxisWidthChanged.fire(S)),
                this._rhsAxesWidth !== f && (this._rhsAxesWidth = f,
                this._rhsPriceAxisWidthChanged.fire(f)),
                P && Me.emit("panes_height_changed")
            }
            _makePaneWidgetsAndSeparators() {
                const e = this.model().model().panes()
                  , t = e.length
                  , i = this._paneWidgets.length;
                for (let e = t; e < i; e++) {
                    (0,
                    s.ensureDefined)(this._paneWidgets.pop()).destroy();
                    const e = this._paneSeparators.pop();
                    e && e.destroy()
                }
                const o = this._options.containsData;
                for (let s = i; s < t; s++) {
                    const t = {
                        contextMenuEnabled: this._options.paneContextMenuEnabled,
                        currencyConversionEnabled: this._options.currencyConversionEnabled,
                        unitConversionEnabled: this._options.unitConversionEnabled,
                        handleScale: this._options.handleScale,
                        handleScroll: this._options.handleScroll,
                        priceScaleContextMenuEnabled: this._options.priceScaleContextMenuEnabled,
                        legendWidgetEnabled: this._options.legendWidgetEnabled,
                        sourceStatusesWidgetEnabled: !o,
                        sourceStatusesWidget: this._options.sourceStatusesWidget,
                        marketStatusWidgetEnabled: this._options.marketStatusWidgetEnabled && !o,
                        chartWarningWidgetEnabled: this._options.chartWarningWidgetEnabled && !o,
                        chartWarningWidget: this._options.chartWarningWidget,
                        dataProblemWidgetEnabled: this._options.dataProblemWidgetEnabled && !o,
                        legendWidget: this._options.legendWidget,
                        propertyPagesEnabled: this._options.propertyPagesEnabled,
                        sourceSelectionEnabled: this._options.sourceSelectionEnabled,
                        controlsEnabled: this._options.paneControlsEnabled,
                        croppedTickMarks: this._options.croppedTickMarks,
                        countdownEnabled: this._options.countdownEnabled,
                        customLegendWidgetFactories: new Map(this._customLegendWidgetsFactoryMap),
                        useKineticScroll: this._options.useKineticScroll,
                        pineSourceStatusEnabled: !this.readOnly()
                    };
                    void 0 !== this._options.paneContextMenu && (t.contextMenu = this._options.paneContextMenu),
                    void 0 !== this._options.priceScaleContextMenu && (t.priceScaleContextMenu = this._options.priceScaleContextMenu);
                    const i = new As(this,e[s],t,this._paneWidgetsSharedState);
                    if (this._paneWidgets.push(i),
                    s > 0) {
                        const e = new Wt(this,s - 1,s);
                        this._paneSeparators.push(e),
                        this._timeAxisWidget ? this._elMainTable.insertBefore(e.getElement(), this._timeAxisWidget.getElement()) : this._elMainTable.appendChild(e.getElement())
                    }
                    this._timeAxisWidget ? this._elMainTable.insertBefore(i.getElement(), this._timeAxisWidget.getElement()) : this._elMainTable.appendChild(i.getElement())
                }
                for (let i = 0; i < t; i++) {
                    const t = e[i]
                      , s = this._paneWidgets[i];
                    s.hasState() && s.state() === t ? s.updatePriceAxisWidgetsStates() : s.setState(t)
                }
                for (let e = t; e--; )
                    this._paneWidgets[e].updateControls();
                this._errorRenderer.updatePaneWidgets(),
                this._updateThemedColor()
            }
            _width() {
                return this._options.width.value()
            }
            _height() {
                return this._options.height.value()
            }
            _update(e, t) {
                var i, s;
                const o = e ? e.fullInvalidation() : N.InvalidationLevel.Full
                  , n = !!e && e.isVisibleTimeRangeLockedOnResize();
                if (null !== this._timingsMeter && this._timingsMeter.startDraw(o),
                o === N.InvalidationLevel.Full && (this._model ? this._updateGui(n) : this._adjustSize(n)),
                o > N.InvalidationLevel.Cursor && (null === (i = this._timeAxisWidget) || void 0 === i || i.update(),
                this._paneWidgets.forEach((e=>{
                    e.updatePriceAxisWidgets()
                }
                )),
                this._applyTimeScaleInvalidations(e, t),
                (null === (s = this._invalidationMask) || void 0 === s ? void 0 : s.fullInvalidation()) === N.InvalidationLevel.Full && (this._invalidationMask.merge(e),
                this._adjustSize(this._invalidationMask.isVisibleTimeRangeLockedOnResize()),
                this._applyTimeScaleInvalidations(this._invalidationMask, t),
                e = this._invalidationMask,
                this._invalidationMask = null)),
                this.paint(e),
                this._dataWindowWidget) {
                    const t = e.maxPaneInvalidation();
                    t === N.InvalidationLevel.Full ? this._dataWindowWidget.fullUpdate() : t > N.InvalidationLevel.None && this._dataWindowWidget.update()
                }
                for (let t = 0; t < this._paneWidgets.length; t++)
                    this._paneWidgets[t].updateStatusWidget(e.invalidateForPane(t));
                null !== this._timingsMeter && this._timingsMeter.stopDraw(),
                e && e.panesOrderInvalidated() && Me.emit("panes_order_changed")
            }
            _initMaximizeHotkey(e) {
                const t = e=>{
                    if (e.defaultPrevented)
                        return;
                    (0,
                    Ee.modifiersFromEvent)(e) === Ee.Modifiers.Alt && e.stopPropagation()
                }
                  , i = e=>{
                    if (e.defaultPrevented)
                        return;
                    (0,
                    Ee.modifiersFromEvent)(e) === Ee.Modifiers.Alt && (e.preventDefault(),
                    e.stopPropagation(),
                    this.toggleFullscreen())
                }
                ;
                return e.addEventListener("mousedown", t, !0),
                e.addEventListener("click", i, !0),
                ()=>{
                    e.removeEventListener("mousedown", t, !0),
                    e.removeEventListener("click", i, !0)
                }
            }
            _onMousewheel(e) {
                if (!this.model().model().zoomEnabled() || null === this._mouseWheelHelper)
                    return;
                if (!(0,
                l.onWidget)() && !kc && parent && parent !== window && parent.IS_DEMO_PAGE)
                    return;
                if (null === this._model)
                    return;
                if (this.model().timeScale().isEmpty())
                    return;
                const t = this._mouseWheelHelper.processWheel(e)
                  , i = t.deltaX
                  , o = -t.deltaY;
                if (0 !== i && this._options.handleScroll.mouseWheel || 0 !== o && this._options.handleScale.mouseWheel) {
                    if (e.cancelable && e.preventDefault(),
                    0 !== o && this._options.handleScale.mouseWheel) {
                        const t = Math.sign(o) * Math.min(1, Math.abs(o))
                          , i = (0,
                        s.ensureNotNull)(this._mainDiv).getBoundingClientRect()
                          , n = e.clientX - this._lhsAxesWidth - i.left;
                        if (!Number.isFinite(n) || !Number.isFinite(t))
                            return void Lc.logWarn("Incorrect mouse wheel processing: scrollPosition: " + n + ", zoomScale: " + t);
                        const r = new Gt.EnvironmentState(e).mod();
                        this.model().model().zoomTime(n, t, !!r || void 0),
                        this._onZoom.fire(r)
                    }
                    0 !== i && this._options.handleScroll.mouseWheel && this.model().scrollChart(-80 * i)
                }
            }
            _beginRequestActive() {
                const e = this._chartWidgetCollection.activeChartWidget.value() !== this;
                if (this._chartWidgetCollection.activeChartWidget.setValue(this),
                e) {
                    this._chartWidgetCollection.ariaDescribeChart(this._chartWidgetCollection.activeChartWidget.value());
                    const e = (0,
                    Mt.lastMouseOrTouchEventInfo)();
                    e.isTouch && !e.stylus && this._isLineToolModeExceptBrush() && this.updateCrossHairPositionIfNeeded(),
                    this._justActivated = !0
                }
            }
            _endRequestActive() {
                this._justActivated && setTimeout((()=>this._justActivated = !1), 0)
            }
            _requestActive() {
                this._beginRequestActive(),
                this._endRequestActive()
            }
            _createSessions(e) {
                const t = this.showGeneralChartProperties.bind(this, ot.TabNames.events);
                e.createSessions(t)
            }
            _createPrePostMarket(e) {
                {
                    const t = this.showGeneralChartProperties.bind(this, ot.TabNames.scales);
                    e.createPrePostMarket(t)
                }
            }
            _createVolumeIfNeeded() {
                const e = d.enabled("create_volume_indicator_by_default") && this._options.addVolume
                  , t = !this._content
                  , i = d.enabled("create_volume_indicator_by_default_once");
                this._content && this._content.loading;
                if (e && t) {
                    const e = ()=>{
                        setTimeout((async()=>{
                            const e = this.model().model()
                              , t = e.mainSeries().symbolInfo();
                            if (!t)
                                return;
                            const i = (0,
                            ye.hasVolume)(t);
                            if (!this.containsVolume() && i) {
                                const t = (0,
                                hr.factoryDefaults)("chartproperties.volumePaneSize");
                                await (0,
                                $a.studyMetaInfoRepository)().requestMetaInfo();
                                const i = e.createStudyInserter({
                                    type: "java",
                                    studyId: "Volume@tv-basicstudies"
                                });
                                i.setForceOverlay(d.enabled("volume_force_overlay")),
                                i.setPaneSize(t),
                                d.enabled("hide_volume_ma") && i.setPropertiesState({
                                    styles: {
                                        vol_ma: {
                                            display: 0
                                        }
                                    }
                                }),
                                i.insert()
                            } else if (!i && this.containsVolume()) {
                                const t = this.model().dataSources().filter((e=>(0,
                                rt.isStudy)(e) && "Volume" === e.metaInfo().shortId))[0];
                                e.removeSource(t)
                            }
                        }
                        ))
                    }
                    ;
                    this.model().mainSeries().dataEvents().symbolResolved().subscribe(this, e, i)
                }
            }
            onModelTagsChanged() {
                this._tagsChanged.fire()
            }
            _initBackgroundColor() {
                null === this._backgroundTopColorSpawn && (this._backgroundTopColorSpawn = this.model().model().backgroundTopColor().spawn(),
                this._backgroundTopColorSpawn.subscribe(this._onBackgroundColorChanged.bind(this))),
                null === this._backgroundBottomColorSpawn && (this._backgroundBottomColorSpawn = this.model().model().backgroundColor().spawn(),
                this._backgroundBottomColorSpawn.subscribe(this._onBackgroundColorChanged.bind(this)))
            }
            _updateGui(e) {
                this._model && (this._makeTimeAxisWidget(),
                this._makePaneWidgetsAndSeparators(),
                this._elMainTable.style.userSelect = "none",
                this._adjustSize(e))
            }
            _onChartStyleChanged() {
                (0,
                Ne.trackEvent)("Chart", `Chart Style ${this.model().mainSeries().getStyleShortName().toUpperCase()}`)
            }
            _addPerfMark(e) {
                (0,
                wl.addPerfMark)(`ChartWidget.${this._id}.${e}`)
            }
            _setElement(e) {
                if (!e)
                    return;
                if (this._mainDiv) {
                    this._mainDiv.remove();
                    const e = document.createRange();
                    e.selectNodeContents((0,
                    s.ensureNotNull)(this._parent)),
                    e.deleteContents()
                }
                this._controlBarNavigation && (this._controlBarNavigation.destroy(),
                this._controlBarNavigation = null),
                null !== this._removeMaximizeHotkey && this._removeMaximizeHotkey(),
                this._removeMaximizeHotkey = this._initMaximizeHotkey(e);
                const t = e.ownerDocument
                  , o = t.createElement("div");
                o.classList.add("chart-container-border"),
                e.insertBefore(o, e.firstChild),
                this._parent = o;
                const n = t.createElement("div");
                if (n.classList.add("chart-widget"),
                this._mainDiv = n,
                this._elTooltipDiv = t.createElement("div"),
                this._elTooltipDiv.className = "tooltip-wrapper",
                this._mainDiv.appendChild(this._elTooltipDiv),
                this._elMainTable = t.createElement("div"),
                this._elMainTable.className = "chart-markup-table",
                this._mainDiv.appendChild(this._elMainTable),
                n.setAttribute("role", "region"),
                n.setAttribute("aria-label", r.t(null, {
                    replace: {
                        index: this.id()
                    }
                }, i(556275))),
                this._hotkeysListener && this._hotkeysListener.destroy(),
                this._errorRenderer.setContainer(this._parent),
                this._hotkeysListener = new et.ChartHotkeysListener(this,this._mainDiv),
                (this._options.controlBarEnabled || d.enabled("control_bar")) && this._createControlBar(),
                this._options.handleScale.mouseWheel || this._options.handleScroll.mouseWheel) {
                    this._mouseWheelHelper = new Nt;
                    const e = this._onMousewheel.bind(this);
                    this._onWheelBound = e,
                    this._mainDiv.addEventListener("wheel", e, {
                        passive: !1
                    })
                }
                this._mainDiv.addEventListener("mouseenter", (()=>this._isHovered.setValue(!0))),
                this._mainDiv.addEventListener("mouseleave", (()=>this._isHovered.setValue(!1))),
                this.resize(),
                this._justActivated = !1,
                this.withModel(this, (()=>{
                    o.appendChild(n),
                    n.addEventListener("mousedown", this._beginRequestActive.bind(this)),
                    n.addEventListener("mouseup", this._endRequestActive.bind(this)),
                    n.addEventListener("touchstart", this._beginRequestActive.bind(this)),
                    n.addEventListener("touchmove", this._endRequestActive.bind(this)),
                    n.addEventListener("touchend", this._endRequestActive.bind(this)),
                    n.addEventListener("click", this._requestActive.bind(this))
                }
                )),
                this._inited && (null !== this._timeAxisWidget && (this._timeAxisWidget.destroy(),
                this._timeAxisWidget = null),
                this._paneWidgets.forEach((e=>{
                    e.destroy()
                }
                )),
                this._paneWidgets.length = 0,
                this._paneSeparators.forEach((e=>{
                    e.destroy()
                }
                )),
                this._paneSeparators.length = 0,
                this._update(N.InvalidationMask.full(), performance.now()))
            }
            _init() {
                this.hasModel() && this.model().mainSeries().clearData(),
                this._initColors(),
                this._makeDefaultGui();
                this._makeDefaultModel(),
                (()=>{
                    this._checkObsoleteTimezone(),
                    this._chartSession && this._chartSession.connected() && this.model().model().restart(),
                    this._content && (this._initColors(),
                    this._updateGui(),
                    this.update()),
                    this._resizeHandler = ()=>{
                        this._invalidationHandler(N.InvalidationMask.full())
                    }
                    ,
                    this._resizeHandler(),
                    (0,
                    s.ensureNotNull)(this._parent).appendChild((0,
                    s.ensureNotNull)(this._mainDiv)),
                    this._spinner && (this._spinner.stop(),
                    this._spinner = null),
                    this._activateSymbolSearchHotkeys(),
                    this.model().timeScale().onScroll().subscribe(this, (()=>this._onScroll.fire())),
                    this._inited = !0
                }
                )()
            }
            _makeDefaultModel() {
                var e, t;
                let i;
                if (this._content && this._content.timeScale.points) {
                    const e = this._content.timeScale.points.items[0];
                    i = {
                        startDate: e
                    }
                }
                const o = ()=>{
                    var e, t;
                    const s = {
                        readOnly: this.readOnly(),
                        isSnapshot: !!this._containsData,
                        ...(0,
                        We.pickFields)(this._options, ["timeScale", "crossHair", "chartEventsEnabled", "newsNotificationsEnabled", "esdEnabled", "latestUpdatesEnabled", "keyFactsTodayEnabled", "continuousContractSwitchesEnabled", "futuresContractExpirationEnabled", "countdownEnabled", "lastPriceAnimationEnabled", "currencyConversionEnabled", "unitConversionEnabled", "watermarkEnabled", "shiftVisibleRangeOnNewBar", "hideIdeas", "onWidget"])
                    }
                      , o = function(e, t, i, s, o, n, r, a, l, c, d) {
                        const u = new Za(e,t,i,s,o,n,r,a,l,c,d);
                        return u.model().fullUpdate(),
                        u
                    }(this._chartSession, this._invalidationHandler, this.properties(), i, this, this._options.undoHistory, this._options.barsMarksContainersFactory, s, this._collapsed, this._linkingGroupIndex, null !== (t = null === (e = this._saveChartService) || void 0 === e ? void 0 : e.autoSaveEnabled()) && void 0 !== t ? t : new h.WatchedValue(!0));
                    return this._createSessions(o.model()),
                    this._createPrePostMarket(o.model()),
                    o
                }
                ;
                d.enabled("lean_chart_load") ? this._model = this._model || o() : this._model = o(),
                this._model.model().setChartSaveTime(1e3 * this._chartWidgetCollection.metaInfo.lastModified.value()),
                this._createVolumeIfNeeded();
                if (this._content) {
                    let i = this._setSymbolIntervalContentOverrides;
                    Ec && this._initialLoading && (i = {
                        ...i,
                        symbol: this._defSymbol,
                        interval: null !== (e = this._defInterval) && void 0 !== e ? e : void 0,
                        style: null !== (t = this._defStyle) && void 0 !== t ? t : void 0
                    },
                    this._defInterval && zs.Interval.isRange(this._defInterval) && (i.style = 11)),
                    this.restoreState(this._content, this._containsData, i),
                    this._setSymbolIntervalContentOverrides = {},
                    Ec && this._defSymbol && this.model().model().recalculatePriceRangeOnce()
                }
                this._setActions(),
                this._createLineToolsSynchronizerIfNeeded(),
                (()=>{
                    const e = (0,
                    s.ensureNotNull)(this._model);
                    e.onTagsChanged().subscribe(this, (()=>this.onModelTagsChanged())),
                    this._initBackgroundColor(),
                    this._updateGui(),
                    this._modelCreated.fire(e),
                    this._tagsChanged.fire();
                    const t = e.mainSeries()
                      , i = t.properties().childs();
                    this._defTimeframe && t.setDefaultTimeframe(this._defTimeframe),
                    t.dataEvents().symbolNotPermitted().subscribe(null, (e=>t.setSymbolParams({
                        symbol: e
                    }))),
                    this._symbolWV.setValue(i.symbol.value()),
                    i.symbol.subscribe(this, (e=>this._symbolWV.setValue(e.value()))),
                    this._resolutionWV.setValue(i.interval.value()),
                    i.interval.subscribe(this, (e=>this._resolutionWV.setValue(e.value()))),
                    window.loginStateChange.subscribe(this, this._handleLoginStateChanged),
                    this._handleLoginStateChanged(),
                    t.dataEvents().symbolResolved().subscribe(this, (e=>{
                        const i = e.pro_name
                          , s = e.pro_perm;
                        i && this._options.isSymbolAvailable && this._options.isSymbolAvailable(i, s).then((e=>{
                            e || t.setSymbolParams({
                                symbol: window.DEFAULT_SYMBOL
                            })
                        }
                        ))
                    }
                    )),
                    void 0 !== this._options.requestFallbackSymbol && t.dataEvents().symbolGroupNotPermitted().subscribe(this, (e=>{
                        (0,
                        s.ensureDefined)(this._options.requestFallbackSymbol)(i.symbol.value(), {
                            type: "group_not_permitted",
                            symbolGroup: e
                        }).then((e=>{
                            e && t.setSymbolParams({
                                symbol: e
                            })
                        }
                        ))
                    }
                    )),
                    (0,
                    s.ensureDefined)(t.onInReplayStateChanged).bind(t)().subscribe(this.screen, this.screen.show),
                    i.style.unsubscribe(this, this._onChartStyleChanged),
                    i.style.subscribe(this, this._onChartStyleChanged),
                    t.dataEvents().completed().subscribe(this, (()=>this._addPerfMark("SeriesCompleted")), !0),
                    t.dataEvents().barReceived().subscribe(this, (()=>this._addPerfMark("SeriesFirstDataReceived")), !0);
                    const o = this._options;
                    t.dataEvents().chartTypeNotPermitted().subscribe(null, (()=>{
                        t.setSymbolParams({
                            interval: "D"
                        }),
                        o.muteSessionErrors || ((0,
                        K.trackGoProFeature)("kagiRenko"),
                        (0,
                        Zn.reloginOrGoPro)({
                            feature: "kagiRenko"
                        }))
                    }
                    )),
                    t.dataEvents().intradaySpreadNotPermitted().subscribe(null, (()=>{
                        t.setSymbolParams({
                            interval: "D"
                        }),
                        o.muteSessionErrors || (0,
                        Zn.reloginOrGoPro)({
                            feature: "intradaySpread"
                        })
                    }
                    )),
                    t.dataEvents().customIntervalNotPermitted().subscribe(null, (i=>{
                        const s = e.model().defaultResolutions()
                          , n = s.find((e=>(0,
                        rs.compareResolutions)(e, i) >= 0))
                          , r = null != n ? n : s[s.length - 1];
                        t.setSymbolParams({
                            interval: r
                        }),
                        o.muteSessionErrors || (0,
                        Zn.reloginOrGoPro)({
                            feature: "customIntervals"
                        })
                    }
                    )),
                    t.dataEvents().secondsIntervalNotPermitted().subscribe(null, (()=>{
                        t.setSymbolParams({
                            interval: "1"
                        }),
                        o.muteSessionErrors || (0,
                        Zn.reloginOrGoPro)({
                            feature: "secondsIntervals",
                            forceUpgradeBtn: !0
                        })
                    }
                    )),
                    t.dataEvents().ticksIntervalNotPermitted().subscribe(null, (()=>{
                        t.setSymbolParams({
                            interval: "1"
                        }),
                        o.muteSessionErrors || (0,
                        Zn.reloginOrGoPro)({
                            feature: "tickIntervals",
                            forceUpgradeBtn: !0,
                            isTrialAvailable: !1
                        })
                    }
                    )),
                    t.dataEvents().intradayExchangeNotPermitted().subscribe(null, (()=>{
                        if (t.setSymbolParams({
                            interval: "D"
                        }),
                        !o.muteSessionErrors) {
                            let e = (0,
                            s.ensureNotNull)(t.symbolInfo()).listed_exchange;
                            (0,
                            Qa.getExchanges)().forEach((t=>{
                                t.value === e && (e = t.name)
                            }
                            )),
                            (0,
                            Zn.reloginOrGoPro)({
                                feature: "intradayExchange"
                            })
                        }
                    }
                    )),
                    t.requestingStyleIsNotSupported.subscribe(null, (()=>{
                        const i = t.interval()
                          , s = e.model().defaultResolutions()
                          , o = (0,
                        ye.getLastUsedSingleValueBasedStyle)()
                          , n = (0,
                        rs.getResolutionByChartStyle)(o, i, s);
                        t.setChartStyleWithIntervalIfNeeded(o, n)
                    }
                    )),
                    t.requestingStyleSupportRecovered.subscribe(null, (i=>{
                        const s = t.interval()
                          , o = e.model().defaultResolutions()
                          , n = (0,
                        rs.getResolutionByChartStyle)(i, s, o);
                        t.setChartStyleWithIntervalIfNeeded(i, n)
                    }
                    ))
                }
                )()
            }
            _addHotkeys() {
                if (this._hotkeys.add({
                    desc: "Maximize",
                    hotkey: Ee.Modifiers.Alt + 13,
                    handler: ()=>this.toggleFullscreen(),
                    isDisabled: ()=>!this.getResizerDetacher().fullscreenable.value()
                }),
                this._hotkeys.add(this._clearSelectionHotkey()),
                this._options.indicatorsDialogShortcutEnabled && this._hotkeys.add({
                    desc: "Show insert indicator dialog",
                    hotkey: 111,
                    handler: ()=>this.showIndicators()
                }),
                !this.readOnly()) {
                    this._hotkeys.add({
                        desc: "Remove selected source",
                        hotkey: Ee.isMacKeyboard ? 46 : 8,
                        handler: ()=>this.removeSelectedSources()
                    });
                    {
                        const e = (e,t)=>{
                            this.activePaneWidget && ("drawRightThere" === t.action ? this.activePaneWidget.drawRightThere(e) : qt.tool.setValue(e))
                        }
                          , t = (t,i)=>()=>e(t, i);
                        Object.entries(gl.lineToolsSelectHotkeys).map((([e,i])=>({
                            desc: i.description,
                            hotkey: i.hash,
                            handler: t(e, i)
                        }))).forEach((e=>this._hotkeys.add(e)))
                    }
                }
                this.withModel(null, (()=>{
                    const e = ()=>this._hotkeys.promote();
                    this.model().onSelectedSourceChanged().subscribe(null, e),
                    this.model().crossHairSource().measurePane().subscribe((t=>{
                        null !== t && e()
                    }
                    ))
                }
                ))
            }
            _startSpinner(e) {
                this._spinner || e && (this._spinner = (new Ke.Spinner).spin(e))
            }
            _handleLoginStateChanged() {
                d.enabled("popup_hints") && window.user && window.user.is_pro ? this._noExchangeSubscrptionWarning = new ll(this) : null !== this._noExchangeSubscrptionWarning && (this._noExchangeSubscrptionWarning.destroy(),
                this._noExchangeSubscrptionWarning = null)
            }
            _checkObsoleteTimezone() {
                const e = this.properties().childs().timezone.value();
                (0,
                Ze.timezoneIsAvailable)(e) || this.properties().childs().timezone.setValue({
                    UTC: "Etc/UTC",
                    EST: "America/New_York",
                    CST: "America/Chicago",
                    PST: "America/Los_Angeles"
                }[e] || "exchange")
            }
            _initColors() {
                const e = this.properties().childs()
                  , t = e.scalesProperties.childs();
                t.lineColor.listeners().subscribe(this, this._updateAndPaint),
                t.textColor.listeners().subscribe(this, this._updateAndPaint),
                e.paneProperties.childs().separatorColor.listeners().subscribe(this, this._setPaneSeparatorLineColor)
            }
            _setPaneSeparatorLineColor() {
                this._paneSeparators.forEach((e=>e.update())),
                this._updateAndPaint()
            }
            _updateAndPaint() {
                this.update(),
                this.paint()
            }
            _makeDefaultGui() {
                this._makeLoadingScreen(),
                this.onWidget() && this._makeAvailableOnTVPopup(),
                this.hasModel() && (this._makeTimeAxisWidget(),
                this._makePaneWidgetsAndSeparators(),
                this._updateScalesActions()),
                this._adjustSize(),
                (0,
                Qe.disableSelection)(this._elMainTable),
                this._updateAndPaint()
            }
            _makeLoadingScreen() {
                if (d.enabled("lean_chart_load")) {
                    if (this.screen)
                        return;
                    this.screen = new kt(this,(0,
                    s.ensureNotNull)(this._parent))
                } else
                    this.screen = new kt(this,(0,
                    s.ensureNotNull)(this._mainDiv))
            }
            _makeAvailableOnTVPopup() {
                this._availableScreen || (this._availableScreen = new vl(this))
            }
            _activateSymbolSearchHotkeys() {
                this.readOnly() || this._options.hideSymbolSearch || (0,
                Fe.activateKeyPressHandler)()
            }
            _makeTimeAxisWidget() {
                if (this._timeAxisWidget)
                    return void this._timeAxisWidget.updatePriceAxisStubs();
                const e = this.model();
                this._timeAxisWidget = new Rs(this,this._options.timeScaleWidget,this._titlesProvider.bind(this),this._menuItemsProvider.bind(this),this._backgroundBasedTheme.spawnOwnership()),
                this._elMainTable.appendChild(this._timeAxisWidget.getElement()),
                this._timeAxisWidget.updatePriceAxisStubs(),
                this._timeAxisWidget.onLabelHovered().subscribe(this, ((t,i)=>{
                    const o = this._maximizedPaneWidget ? this._maximizedPaneWidget.state() : e.paneForSource(e.mainSeries())
                      , n = (0,
                    s.ensureNotNull)(this.paneByState((0,
                    s.ensureNotNull)(o))).highlightedPriceAxis()
                      , r = n.value();
                    (i || r.owner === t.owner) && (n.setValue({
                        owner: t.owner,
                        axis: i ? t.axis : null
                    }),
                    this.model().model().lightUpdate())
                }
                ))
            }
            _updateAriaPriceDescription(e) {}
            _titlesProvider(e, t) {
                const i = this.model()
                  , o = (0,
                s.ensureNotNull)(this._maximizedPaneWidget ? this._maximizedPaneWidget.state() : i.paneForSource(i.mainSeries()))
                  , n = "right" === e ? o.rightPriceScales() : o.leftPriceScales();
                if (n.length < t + 1)
                    return [];
                let r = n[t].orderedSources().filter((e=>e === i.mainSeries() || (0,
                rt.isStudy)(e)));
                return r.reverse(),
                r = (0,
                Te.moveToHead)(r, i.mainSeries()),
                r.map((e=>e.title(So.TitleDisplayTarget.StatusLine, !0, void 0, !1)))
            }
            _menuItemsProvider(e, t) {
                const i = this.model()
                  , o = (0,
                s.ensureNotNull)(this._maximizedPaneWidget ? this._maximizedPaneWidget.state() : i.paneForSource(i.mainSeries()))
                  , n = "right" === e ? o.visibleRightPriceScales() : o.visibleLeftPriceScales();
                if (n.length < t + 1)
                    return [];
                const r = n[t]
                  , a = i.model().panes().indexOf(o)
                  , l = this._paneWidgets[a]
                  , c = "right" === e ? l.rightPriceAxisesContainer() : l.leftPriceAxisesContainer();
                return (0,
                s.ensureNotNull)(c.findAxisWidgetForScale(r)).getContextMenuActions()
            }
            _invalidationRAFCallback(e) {
                if (this._drawPlanned = !1,
                this._drawRafId = 0,
                !this._inLoadingState) {
                    if (this._invalidationMask) {
                        const t = this._invalidationMask;
                        this._invalidationMask = null,
                        this._update(t, e);
                        for (const i of t.timeScaleInvalidations())
                            if (0 === i.type && !i.value.finished(e)) {
                                this.model().model().setTimeScaleAnimation(i.value, i.rightOffsetPx);
                                break
                            }
                    }
                    null !== this._chartPaintedPromise && (this._chartPaintedPromise.resolve(),
                    this._chartPaintedPromise = null)
                }
            }
            _applyTimeScaleInvalidations(e, t) {
                for (const i of e.timeScaleInvalidations())
                    this._applyTimeScaleInvalidation(i, t)
            }
            _applyTimeScaleInvalidation(e, t) {
                var i, s, o;
                const n = null === (i = this._model) || void 0 === i ? void 0 : i.timeScale();
                if (n && 0 === e.type) {
                    const i = e.value.getStartPosition() - e.value.getPosition(t)
                      , r = e.rightOffsetPx + i
                      , a = n.width() - r
                      , l = n.indexToCoordinate(n.baseIndex());
                    n.startScroll(l),
                    n.scrollTo(a),
                    n.endScroll(),
                    n.requestHistoryPointsIfNeeded(),
                    e.value.finished(t) && (null === (o = (s = e.value).onFinish) || void 0 === o || o.call(s, !0))
                }
            }
            _onChartSessionCriticalError(e, t) {
                this._disconnected.fire(!0)
            }
            _onData(e) {
                if ("reconnect_bailout" === e.method)
                    this._reconnectBailout.fire();
                else
                    this.model().model().onData(e)
            }
            _onConnection() {
                this._requestMetadataAndProcessModel(),
                this.hasModel() && (this.model().model().restart(),
                this.model().model().fullUpdate(),
                this._connected.fire())
            }
            _onDisconnect() {
                this.hasModel() && this.model().model().disconnect(),
                this._model && this._model.model().fullUpdate(),
                this._disconnected.fire()
            }
            async _requestMetadataAndProcessModel() {
                this._inited || (await (0,
                ct.initAllLineToolsFromContent)(this._content),
                this._init(),
                this._chartWidgetInitialized.fire(),
                Lc.logDebug("initialized"))
            }
            async _requestMetadata() {
                this._addPerfMark("RequestMetadataStart"),
                Lc.logInfo("RequestMetadataStart"),
                await (0,
                $a.studyMetaInfoRepository)().requestMetaInfo(),
                this._addPerfMark("RequestMetadataEnd"),
                Lc.logInfo("RequestMetadataEnd, already initialized: " + Boolean(this._inited))
            }
            async _createControlBar() {
                const e = await Promise.all([i.e(65073), i.e(46445), i.e(93703), i.e(75816), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(2520), i.e(25480), i.e(62564), i.e(46489), i.e(58985), i.e(75826), i.e(74600), i.e(88015), i.e(86605), i.e(41243), i.e(7001), i.e(71329), i.e(51488), i.e(59470), i.e(75364), i.e(79753), i.e(77183), i.e(58357), i.e(80269), i.e(32227), i.e(50030), i.e(18405), i.e(98422), i.e(5093)]).then(i.bind(i, 956394));
                this._controlBarNavigation = new e.ControlBarNavigation(this,(0,
                s.ensureNotNull)(this._mainDiv),this._options.controlBar),
                this._model && this._adjustSize()
            }
            _subscribeToDrawingState() {
                if (this.readOnly())
                    return;
                (0,
                qt.init)();
                const e = (e,t)=>{
                    const i = this._model;
                    if (null === i)
                        return;
                    const s = i.model();
                    e.model !== s && (this._lineToolsSynchronizer ? this._lineToolsSynchronizer.executeSyncedAction((()=>t(s, i))) : t(s, i))
                }
                ;
                qt.createdLineTool.subscribe(null, (t=>{
                    e(t, ((e,i)=>{
                        const o = (0,
                        s.ensureNotNull)(e.paneForSource(e.mainSeries()));
                        let n, r = null;
                        if (void 0 === t.pointPositionPercents) {
                            if (r = Wc(e, t.model, t.point.timeStamp),
                            null === r)
                                return;
                            n = t.point.price
                        } else {
                            const i = t.pointPositionPercents.x * e.timeScale().width()
                              , s = e.mainSeries().priceScale()
                              , o = t.pointPositionPercents.y * s.height()
                              , a = e.mainSeries().firstValue();
                            if (null === a)
                                return;
                            r = e.timeScale().coordinateToIndex(i),
                            n = s.coordinateToPrice(o, a)
                        }
                        const a = {
                            index: (0,
                            s.ensureNotNull)(r),
                            price: n
                        }
                          , l = i.createLineTool({
                            pane: o,
                            point: a,
                            linetool: t.linetool,
                            properties: t.properties,
                            linkKey: t.linkKey,
                            ownerSource: e.mainSeries(),
                            disableSynchronization: !0,
                            id: t.id,
                            sharingMode: t.sharingMode
                        });
                        null !== l && !Boolean(this.model().lineBeingCreated()) && t.finalState && l.restoreExternalPoints(t.finalState, {
                            indexesChanged: !0,
                            pricesChanged: !0
                        })
                    }
                    ))
                }
                )),
                qt.continuedLineTool.subscribe(null, (t=>{
                    e(t, ((e,i)=>{
                        var s;
                        const o = Wc(e, t.model, t.point.timeStamp);
                        if (null === o)
                            return;
                        const n = {
                            index: o,
                            price: t.point.price
                        }
                          , r = e.lineBeingCreated();
                        if (null === r)
                            return;
                        i.continueExternalLine(n, null !== (s = t.envState) && void 0 !== s ? s : void 0, !!t.finalState) && t.finalState && r.restoreExternalPoints(t.finalState, {
                            indexesChanged: !0,
                            pricesChanged: !0
                        })
                    }
                    ))
                }
                )),
                qt.cancelledLineTool.subscribe(null, (t=>{
                    e(t, ((e,t)=>{
                        e.cancelCreatingLine()
                    }
                    ))
                }
                )),
                qt.beenSetLineToolLastPoint.subscribe(null, (t=>{
                    e(t, ((e,i)=>{
                        const s = e.lineBeingCreated();
                        if (null === s || s.linkKey().value() !== t.linkKey)
                            return;
                        const o = Wc(e, t.model, t.point.timeStamp);
                        if (null === o)
                            return;
                        const n = {
                            index: o,
                            price: t.point.price
                        };
                        s.setLastPoint(n),
                        s.updateAllViews((0,
                        as.sourceChangeEvent)(s.id())),
                        e.lightUpdate()
                    }
                    ))
                }
                )),
                qt.startedMovingLineTool.subscribe(null, (t=>{
                    e(t, ((e,i)=>{
                        var s;
                        const o = t.linkKeys.map(ct.lineToolByLinkKey.bind(null, e)).filter(Ue.notNull);
                        if (o.length) {
                            const i = Wc(e, t.model, t.point.timeStamp);
                            if (null === i)
                                return;
                            const n = {
                                index: i,
                                price: t.point.price
                            }
                              , r = null !== (s = t.activeItem) && void 0 !== s ? s : null
                              , a = o[0].pointToScreenPoint(n);
                            a && e.startMovingSources(o, {
                                logical: n,
                                screen: a
                            }, r, t.pointPositionPercents, null === t.envState ? void 0 : t.envState, !0)
                        }
                    }
                    ))
                }
                )),
                qt.movedLineTool.subscribe(null, (t=>{
                    e(t, ((e,i)=>{
                        var s;
                        const o = e.sourcesBeingMoved().filter(ct.isLineTool).filter((e=>(e=>t.linkKeys.some((t=>e.linkKey().value() === t)))(e)));
                        if (!o.length)
                            return;
                        const n = Wc(e, t.model, t.point.timeStamp);
                        if (null === n)
                            return;
                        const r = {
                            index: n,
                            price: t.point.price
                        }
                          , a = o[0].pointToScreenPoint(r);
                        a && e.moveSources({
                            logical: r,
                            screen: a
                        }, t.pointPositionPercents, null !== (s = t.envState) && void 0 !== s ? s : void 0, !0)
                    }
                    ))
                }
                )),
                qt.finishedMovingLineTool.subscribe(null, (t=>{
                    e(t, ((e,i)=>{
                        const s = e.sourcesBeingMoved().filter(ct.isLineTool);
                        if (0 === s.length)
                            return;
                        s.forEach((i=>{
                            const s = (e=>{
                                for (let i = 0; i < t.linkKeys.length; i++)
                                    if (t.linkKeys[i] === e.linkKey().value())
                                        return {
                                            state: t.finalStates[i],
                                            changes: t.changes[i]
                                        };
                                return null
                            }
                            )(i);
                            e.endMovingSources(null !== s, !0),
                            null !== s && (i.restoreExternalPoints(s.state, s.changes),
                            s.state.pointPositionPercents && i.restorePositionPercents(s.state.pointPositionPercents))
                        }
                        ))
                    }
                    ))
                }
                )),
                qt.startedChangingLineTool.subscribe(null, (t=>{
                    e(t, ((e,i)=>{
                        var s;
                        const o = (0,
                        ct.lineToolByLinkKey)(e, t.linkKey);
                        if (null !== o) {
                            const i = o.getPoint(t.pointIndex)
                              , n = i ? i.index : Wc(e, t.model, t.point.timeStamp);
                            if (null === n)
                                return;
                            if (o.isActualSymbol() && o.isActualCurrency() && o.isActualUnit()) {
                                const i = {
                                    index: n,
                                    price: t.point.price
                                };
                                e.startChangingLinetool(o, i, t.pointIndex, null !== (s = t.envState) && void 0 !== s ? s : void 0, !0)
                            }
                        }
                    }
                    ))
                }
                )),
                qt.changedLineTool.subscribe(null, (t=>{
                    e(t, ((e,i)=>{
                        const o = e.lineBeingEdited();
                        if (null === o || o.linkKey().value() !== t.linkKey)
                            return;
                        let n = null;
                        if (n = t.changes.indexesChanged ? Wc(e, t.model, t.point.timeStamp) : (0,
                        s.ensureNotNull)(e.linePointBeingChanged()).index,
                        null !== n && o.isActualSymbol() && o.isActualCurrency() && o.isActualUnit()) {
                            const i = {
                                index: n,
                                price: t.point.price
                            };
                            e.changeLinePoint(i, void 0, !0)
                        }
                    }
                    ))
                }
                )),
                qt.finishedChangingLineTool.subscribe(null, (t=>{
                    e(t, ((e,i)=>{
                        const s = (0,
                        ct.lineToolByLinkKey)(e, t.linkKey);
                        null !== s && s.isActualSymbol() && s.isActualCurrency() && s.isActualUnit() && null !== e.lineBeingEdited() && e.endChangingLinetool(!!t.finalState, !0),
                        null !== s && t.finalState && s.restoreExternalPoints(t.finalState, t.changes)
                    }
                    ))
                }
                )),
                qt.removedLineTool.subscribe(null, (t=>{
                    e(t, ((e,i)=>{
                        const {withUndo: s, unlink: o, linkKey: n} = t
                          , r = (0,
                        ct.lineToolByLinkKey)(e, n);
                        null !== r && (o && r.detachAlert(),
                        s ? i.removeSource(r, !1) : (e.lineToolsGroupModel().removeLineTools([r]),
                        e.removeSource(r)))
                    }
                    ))
                }
                )),
                qt.finishedLineTool.subscribe(null, (t=>{
                    e(t, ((e,i)=>{
                        const s = (0,
                        ct.lineToolByLinkKey)(e, t.linkKey);
                        null !== s && (0,
                        U.isLineToolFinishRequiredWhenCreatedByApi)(s.toolname) && s.finish()
                    }
                    ))
                }
                )),
                qt.changedLineStyle.subscribe(null, (t=>{
                    e(t, ((e,i)=>{
                        const s = (0,
                        ct.lineToolByLinkKey)(e, t.linkKey);
                        null !== s && (s.restoreExternalState(t.state),
                        s.propertiesChanged(!0),
                        t.alertId && s.syncAlert(t.alertId))
                    }
                    ))
                }
                )),
                qt.restoredLineToolState.subscribe(null, (t=>{
                    e(t, ((e,i)=>{
                        const s = (0,
                        ct.lineToolByLinkKey)(e, t.linkKey);
                        if (null !== s) {
                            const i = {
                                ...t.state
                            };
                            i.indexes = t.state.points.map((i=>({
                                index: Wc(e, t.model, i.time_t),
                                price: i.price
                            }))),
                            e.restoreLineToolState(s, i, !1)
                        }
                    }
                    ))
                }
                )),
                qt.restoredLineTool.subscribe(null, (t=>{
                    e(t, ((e,i)=>{
                        e.restoreSource(t.state.restorePane, t.state.paneIndex, t.state.paneState, t.state.sourceState, null)
                    }
                    ))
                }
                )),
                qt.copiedLineTool.subscribe(null, (t=>{
                    e(t, ((e,i)=>{
                        const o = (0,
                        s.ensureNotNull)(e.paneForSource(e.mainSeries()));
                        let n;
                        const r = {
                            ...t.state,
                            intervalsVisibilities: (0,
                            ur.mergeIntervalVisibilitiesDefaults)(t.state.intervalsVisibilities)
                        }
                          , a = (0,
                        ct.createLineToolProperties)(t.linetool, r, e)
                          , l = e.dataSourceForId(t.id);
                        if (l) {
                            if (!(0,
                            ct.isLineTool)(l))
                                return void Lc.logError(`Error sync creating line tool. Object with id ${t.id} is already in use and it is not a line tool`);
                            if (l.toolname !== t.linetool)
                                return void Lc.logError(`Error sync creating line tool. Object with id ${t.id} is already in use and its type differs: ${l.toolname} and ${t.linetool}`)
                        }
                        if (l && (l.linkKey().setValue(t.linkKey),
                        l.share(t.sharingMode)),
                        t.pointPositionPercents) {
                            const e = {
                                index: 0,
                                price: 0
                            };
                            if (n = null != l ? l : i.createLineTool({
                                pane: o,
                                point: e,
                                linetool: t.linetool,
                                properties: a,
                                linkKey: t.linkKey,
                                disableSynchronization: !0,
                                id: t.id
                            }),
                            null === n)
                                return;
                            n.restorePositionPercents((0,
                            s.ensureDefined)(t.pointPositionPercents))
                        } else {
                            const r = i=>({
                                index: (0,
                                s.ensureNotNull)(Wc(e, t.model, i.timeStamp)),
                                price: i.price
                            })
                              , c = t.points.map(r)
                              , d = t.pointsForCreating.map(r)
                              , u = c[0];
                            if (l)
                                n = l;
                            else if (t.withUndo)
                                n = i.createLineTool({
                                    pane: o,
                                    point: u,
                                    linetool: t.linetool,
                                    properties: a,
                                    linkKey: t.linkKey,
                                    sharingMode: t.sharingMode,
                                    disableSynchronization: !0,
                                    id: t.id
                                });
                            else {
                                const e = new vo({
                                    model: i.model(),
                                    pane: o,
                                    lineTool: t.linetool,
                                    ownerSource: (0,
                                    s.ensureNotNull)(o.mainDataSource()),
                                    drawOnAllChartsMode: t.sharingMode,
                                    id: t.id
                                });
                                e.redo(),
                                e.startCreatingLine(u, a, t.linkKey || null, t.sharingMode, !0),
                                n = (0,
                                s.ensureNotNull)(e.line())
                            }
                            if (null === n)
                                return;
                            const h = (e,s)=>{
                                t.withUndo ? i.continueCreatingLine(e, new Gt.EnvironmentState(void 0,!0), s, !0) : i.model().continueCreatingLine(e, new Gt.EnvironmentState(void 0,!0), s, !0)
                            }
                              , p = (0,
                            U.isLineToolFinishRequiredWhenCreatedByApi)(t.linetool);
                            if (e.lineBeingCreated())
                                if (d.length > 1)
                                    for (let e = 1; e < d.length; e++)
                                        h(d[e], e < d.length - 1 && !p),
                                        e === d.length - 1 && p && (n.finish(),
                                        h(d[e], !0));
                                else
                                    p && (n.finish(),
                                    h(d[0], !0))
                        }
                        n.properties().interval.setValue(t.state.interval),
                        n.restoreExternalState(t.state),
                        n.restoreData && n.restoreData(t),
                        n.setZorder(t.zOrder),
                        n.propertiesChanged(!0),
                        t.finalState && (n.calcIsActualSymbol(),
                        n.restoreExternalPoints(t.finalState, {
                            pricesChanged: !0,
                            indexesChanged: !0,
                            overrideCalculatedState: !0
                        })),
                        t.alertId && n.syncAlert(t.alertId)
                    }
                    ))
                }
                ))
            }
            _setFirstRequestNumbarsUsingTimeframeAndInterval(e) {
                const t = function(e) {
                    var t, i, s, o, n, r, a, l, c, d, u, h, p;
                    const m = null !== (t = e.numberExtraBars) && void 0 !== t ? t : 0
                      , g = e.barSpacing || 6
                      , _ = Math.ceil(e.width / g) + m;
                    if (e.timeFrame) {
                        if (!e.interval)
                            return {
                                barCount: _
                            };
                        const t = zs.Interval.parse(e.interval);
                        if ("string" == typeof e.timeFrame) {
                            if ("ALL" === e.timeFrame)
                                return {
                                    barCount: _
                                };
                            let l = e.timeFrame;
                            "YTD" === e.timeFrame && (l = `${Math.floor(((new Date).valueOf() - new Date((new Date).getFullYear(),0,0).valueOf()) / 1e3 / 60 / 60 / 24)}D`);
                            const c = zs.Interval.parse(l)
                              , d = Date.now().valueOf()
                              , u = d - c.inMilliseconds();
                            return {
                                barCount: (0,
                                fl.getPeriodsBetweenDates)(null !== (s = null === (i = e.symbolInfo) || void 0 === i ? void 0 : i.session) && void 0 !== s ? s : "24x7", null !== (n = null === (o = e.symbolInfo) || void 0 === o ? void 0 : o.session_holidays) && void 0 !== n ? n : "", null !== (a = null === (r = e.symbolInfo) || void 0 === r ? void 0 : r.corrections) && void 0 !== a ? a : "", t.letter(), t.multiplier(), u, d) + m,
                                message: `based on period of ${l}`,
                                shouldAdjustBarSpacing: !0
                            }
                        }
                        if ("time-range" === e.timeFrame.type)
                            return {
                                barCount: (0,
                                fl.getPeriodsBetweenDates)(null !== (c = null === (l = e.symbolInfo) || void 0 === l ? void 0 : l.session) && void 0 !== c ? c : "24x7", null !== (u = null === (d = e.symbolInfo) || void 0 === d ? void 0 : d.session_holidays) && void 0 !== u ? u : "", null !== (p = null === (h = e.symbolInfo) || void 0 === h ? void 0 : h.corrections) && void 0 !== p ? p : "", t.letter(), t.multiplier(), 1e3 * e.timeFrame.from, 1e3 * e.timeFrame.to) + m,
                                message: `based on time range: ${e.timeFrame.from} ... ${e.timeFrame.to}`,
                                shouldAdjustBarSpacing: !0
                            }
                    }
                    return {
                        barCount: _
                    }
                }({
                    width: e.timeScale().width(),
                    barSpacing: e.timeScale().barSpacing(),
                    timeFrame: this.options().defTimeframe,
                    interval: this.options().defInterval
                });
                if (d.enabled("charting_library_debug_mode") && console.log(`${(new Date).toISOString()} Setting initial data request count to ${t.barCount} bars${t.message ? ` (${t.message})` : ""}`),
                e.mainSeries().seriesSource().setInitialRequestOptions({
                    count: t.barCount
                }),
                t.shouldAdjustBarSpacing && "number" == typeof t.barCount && t.barCount > 0) {
                    const i = Math.ceil(e.timeScale().width() / t.barCount);
                    e.timeScale().setBarSpacing(i)
                }
            }
            _createEventHint() {
                if (null === this._eventHintDeferredPromise) {
                    const e = (0,
                    Ve.createDeferredPromise)();
                    this._eventHintDeferredPromise = e,
                    Promise.all([i.e(62093), i.e(32690), i.e(32227), i.e(26166)]).then(i.bind(i, 410837)).then((t=>{
                        e.resolve(new t.ChartEventHintRenderer(this._chartWidgetCollection.getContainer()))
                    }
                    ))
                }
                return this._eventHintDeferredPromise.promise
            }
            async _createWarningHint() {
                if (null === this._warningHintDeferredPromise) {
                    const e = (0,
                    Ve.createDeferredPromise)();
                    this._warningHintDeferredPromise = e,
                    Promise.all([i.e(29328), i.e(44524), i.e(3062), i.e(2190), i.e(32227), i.e(83129)]).then(i.bind(i, 629981)).then((t=>{
                        e.resolve(new t.ChartWarningHintRenderer(this))
                    }
                    ))
                }
                return this._warningHintDeferredPromise.promise
            }
            _showEventHint(e) {
                d.enabled("popup_hints") && (null !== this._activeHint && 0 === this._activeHint.type ? this._activeHint.show(e) : (this._hideHint(),
                this._createEventHint().then((t=>{
                    this._activeHint = t,
                    void 0 !== e && this._activeHint.show(e)
                }
                ))))
            }
            _showWarningHint(e) {
                d.enabled("popup_hints") && (null !== this._activeHint && 1 === this._activeHint.type ? this._activeHint.show(e) : (this._hideHint(),
                this._createWarningHint().then((t=>{
                    if (null !== t) {
                        if (this._activeHint = t,
                        void 0 === e)
                            return;
                        this._activeHint.show(e)
                    }
                }
                ))))
            }
            _hideHint() {
                null !== this._activeHint && this._activeHint.hide()
            }
            _checkIsTradedGroupSelected() {
                const e = this.model()
                  , t = e.model();
                return e.selection().customSources().some((e=>{
                    var i;
                    return null === (i = t.customSourceName(e)) || void 0 === i ? void 0 : i.startsWith(ml.tradedGroupPlaceOrderPrefix)
                }
                ))
            }
            _setActions() {
                return this._unsetActions(),
                this._addHotkeys(),
                this._actions = Ic(this),
                this.withModel(null, (()=>{
                    const e = this.model().mainSeries()
                      , t = e.properties();
                    t.childs().priceAxisProperties.subscribe(this, this._updateScalesActions),
                    e.priceScaleAboutToBeChanged().subscribe(this, (()=>{
                        t.childs().priceAxisProperties.unsubscribeAll(this)
                    }
                    )),
                    e.priceScaleChanged().subscribe(this, (()=>{
                        t.childs().priceAxisProperties.subscribe(this, this._updateScalesActions),
                        this._updateScalesActions()
                    }
                    ))
                }
                )),
                this._updateScalesActions(),
                this._actions
            }
            _unsetActions() {
                this._actions && (Object.values(this._actions).forEach((e=>{
                    e.destroy()
                }
                )),
                this._actions = null)
            }
            _updateTimingsMeterState() {
                const e = this._options.visible.value();
                null !== this._timingsMeter && (e ? this._timingsMeter.startCollect() : this._timingsMeter.stopCollect())
            }
            _onBackgroundColorChanged() {
                for (let e = 0; e < this._paneWidgets.length; e++)
                    this._paneWidgets[e].setCursorForTool();
                this.update(),
                this.model().model().fullUpdate()
            }
            _contentSeriesProperties() {
                var e;
                if (this._content)
                    for (let t = this._content.panes.length; t-- > 0; ) {
                        const i = this._content.panes[t].sources;
                        for (let t = i.length; t-- > 0; ) {
                            const s = i[t];
                            if ((0,
                            fn.isMainSeriesState)(s))
                                return null !== (e = s.state) && void 0 !== e ? e : null
                        }
                    }
                return null
            }
            async _getChartPropertyDefinitionsViewModel() {
                if (null === this._definitionsViewModel) {
                    const e = await Promise.all([i.e(73580), i.e(24379), i.e(28093), i.e(83596)]).then(i.bind(i, 250077));
                    if (this._isDestroyed)
                        throw new Error("Chart widget already destroyed");
                    await new Promise((e=>this.withModel(null, e))),
                    null === this._definitionsViewModel && (this._definitionsViewModel = new e.ChartPropertyDefinitionsViewModel(this.model(),this.properties(),this._options))
                }
                return this._definitionsViewModel
            }
        }
        var Uc = i(851063)
          , Gc = i(387964);
        const jc = new c.TranslatedString("change chart layout to {title}",r.t(null, void 0, i(768846)));
        class qc extends m.UndoCommand {
            constructor(e, t) {
                super(jc.format({
                    title: xe.layouts[t].title
                })),
                this._chartWidgetCollection = e,
                this._newLayoutType = t,
                this._oldLayoutType = e.layout.value()
            }
            redo() {
                this._chartWidgetCollection.setLayout(this._newLayoutType)
            }
            undo() {
                this._chartWidgetCollection.setLayout(this._oldLayoutType)
            }
        }
        const Xc = new c.TranslatedString("apply toolbars theme",r.t(null, void 0, i(686708)));
        class Kc extends m.UndoCommand {
            constructor(e, t, i=!0) {
                super(Xc),
                this._prevThemeName = e,
                this._themeName = t,
                this._syncState = i
            }
            undo() {
                (0,
                Ce.isStdThemeName)(this._prevThemeName) && ((0,
                mt.setTheme)(this._prevThemeName),
                this._syncState && (0,
                Ce.syncTheme)())
            }
            redo() {
                (0,
                Ce.isStdThemeName)(this._themeName.toLowerCase()) && ((0,
                mt.setTheme)(this._themeName.toLowerCase()),
                this._syncState && (0,
                Ce.syncTheme)())
            }
        }
        var Yc = i(203918)
          , Zc = i(566238)
          , $c = i(263844);
        i(99647);
        const Jc = !l.CheckMobile.any()
          , Qc = (0,
        n.getLogger)("ChartWidgetCollectionBase")
          , ed = new c.TranslatedString("apply indicators to entire layout",r.t(null, void 0, i(870507)))
          , td = new c.TranslatedString("sync time",r.t(null, void 0, i(591677)))
          , id = new c.TranslatedString("resize layout",r.t(null, void 0, i(847418)))
          , sd = new c.TranslatedString("reset layout sizes",r.t(null, void 0, i(385366)))
          , od = new c.TranslatedString("apply chart theme",r.t(null, void 0, i(368231)))
          , nd = new c.TranslatedString("symbol lock",r.t(null, void 0, i(253278)))
          , rd = new c.TranslatedString("interval lock",r.t(null, void 0, i(456558)))
          , ad = new c.TranslatedString("date range lock",r.t(null, void 0, i(658850)))
          , ld = new c.TranslatedString("track time",r.t(null, void 0, i(946807)))
          , cd = new c.TranslatedString("change series style",r.t(null, void 0, i(549965)))
          , dd = r.t(null, void 0, i(328298))
          , ud = r.t(null, void 0, i(978972))
          , hd = r.t(null, void 0, i(410615))
          , pd = r.t(null, void 0, i(981518))
          , md = r.t(null, void 0, i(740947))
          , gd = r.t(null, void 0, i(955801))
          , _d = r.t(null, void 0, i(176651))
          , vd = r.t(null, void 0, i(868054))
          , Sd = r.t(null, void 0, i(294656));
        function fd(e, t) {
            const i = t.model().model().studyTemplate();
            e.undoHistory.beginUndoMacro(ed);
            for (let s = 0; s < e.chartWidgetsDefs.length; s++) {
                const o = e.chartWidgetsDefs[s].chartWidget;
                o !== t && (o.hasModel() && o.model().applyStudyTemplate(i, ""))
            }
            e.undoHistory.endUndoMacro()
        }
        async function bd(e, t, i, o, n) {
            e.undoHistory.beginUndoMacro(n);
            for (let r = 0; r < e.chartWidgetsDefs.length; r++) {
                const a = e.chartWidgetsDefs[r].chartWidget;
                if (a !== t && a && a.hasModel()) {
                    const t = a.model();
                    let r;
                    if (o.isOnMainPane)
                        r = (0,
                        s.ensureNotNull)(t.model().paneForSource(a.model().model().mainSeries()));
                    else {
                        const i = new g(t.model(),o.paneIndex);
                        e.undoHistory.pushUndoCommand(i);
                        const n = (0,
                        s.ensureDefined)(i.createdPaneId());
                        r = (0,
                        s.ensureDefined)(t.model().panes().find((e=>e.id() === n)))
                    }
                    const l = await t.pasteSourceFromClip(r, i, !0);
                    if (l && 1 === l.length) {
                        const e = l[0];
                        if (o.asCompare) {
                            const i = (0,
                            s.ensureNotNull)(t.mainSeries().priceScale());
                            t.moveToScale(e, (0,
                            s.ensureDefined)(r), i, n),
                            t.setPriceScaleMode({
                                percentage: !0
                            }, i, null)
                        }
                    }
                    t.model().lightUpdate()
                }
            }
            e.undoHistory.endUndoMacro()
        }
        function yd(e) {
            let t = 1;
            for (; e.has("" + t); )
                t++;
            return "" + t
        }
        function Cd(e) {
            const t = new Map
              , i = e.chartsCountToSave()
              , s = new Set;
            for (let o = 0; o < i; o++)
                if (o < e.chartWidgetsDefs.length) {
                    const i = e.chartWidgetsDefs[o].chartWidget
                      , n = i.id()
                      , r = i.lineToolsAndGroupsDTO();
                    t.set(n, r),
                    s.add(n)
                } else {
                    const i = e.savedChartWidgetOptions[o - e.chartWidgetsDefs.length].content;
                    i.chartId || (i.chartId = yd(s));
                    const n = new Map;
                    n.set(0, q(i)),
                    t.set(i.chartId, n),
                    s.add(i.chartId)
                }
            return t
        }
        function wd(e, t) {
            const i = this.innerState()
              , {withData: s, skipLineToolsFromOtherSymbols: o, wipeSensitiveData: n, skipLineTools: r} = t;
            if (e < i.chartWidgetsDefs.length) {
                const t = i.chartWidgetsDefs[e].chartWidget;
                return e < i.actualLayoutCount() || t.shouldBeSavedEvenIfHidden() ? t.state(s, o, n, r) : null
            }
            return function(e, t=!1) {
                return t ? G(e) : e
            }(i.savedChartWidgetOptions[e - i.chartWidgetsDefs.length].content, r)
        }
        function Td(e) {
            return e.savedChartWidgetOptions.map((e=>(0,
            s.ensureDefined)(e.content.chartId)))
        }
        function Pd(e, t, i) {
            const s = e.chartsCountToSave();
            i.forEach((i=>{
                const s = (o = i.chartId,
                null !== (r = null === (n = e.chartWidgetsDefs.find((e=>e.chartWidget.id() === o))) || void 0 === n ? void 0 : n.chartWidget) && void 0 !== r ? r : null);
                var o, n, r;
                null == s || s.resetLineToolsInvalidated(t, i.savedDto, i.sharingMode)
            }
            ));
            for (let t = e.chartWidgetsDefs.length; t < s; t++) {
                const i = G(e.savedChartWidgetOptions[t - e.chartWidgetsDefs.length].content);
                e.savedChartWidgetOptions[t - e.chartWidgetsDefs.length].content = i
            }
        }
        function xd(e, t, i, s) {
            const o = e.map((e=>e.chartWidget)).filter((e=>e.hasModel())).filter((e=>e.id() === t || 0 !== s));
            try {
                o.forEach((e=>e.startApplyingLineToolUpdateNotification())),
                o.forEach((e=>e.applyLineToolUpdateNotification(i, s)))
            } finally {
                o.forEach((e=>e.endApplyingLineToolUpdateNotification()))
            }
        }
        function Md(e) {
            return e instanceof Error ? e.message : null
        }
        function Id(e) {
            return new M({
                copyRequested: (t,i)=>{
                    e.activeChartWidget.value().model().clipboardCopy(t, i).catch((e=>{
                        var t;
                        const i = null !== (t = Md(e)) && void 0 !== t ? t : dd.format({
                            keystroke: (0,
                            k.humanReadableHash)(k.Modifiers.Mod + 67)
                        });
                        (0,
                        E.showChartWarningNotification)("copy", {
                            title: ud,
                            text: i
                        })
                    }
                    ))
                }
                ,
                cutRequested: (t,i)=>{
                    e.activeChartWidget.value().model().clipboardCut(t, i).catch((e=>{
                        var t;
                        const i = null !== (t = Md(e)) && void 0 !== t ? t : dd.format({
                            keystroke: (0,
                            k.humanReadableHash)(k.Modifiers.Mod + 88)
                        });
                        (0,
                        E.showChartWarningNotification)("cut", {
                            title: hd,
                            text: i
                        })
                    }
                    ))
                }
                ,
                pasteRequested: (t,i)=>{
                    (i ? i.model().undoModel() : e.activeChartWidget.value().model()).clipboardPaste(t, i).catch((e=>{
                        var t;
                        const i = null !== (t = Md(e)) && void 0 !== t ? t : dd.format({
                            keystroke: (0,
                            k.humanReadableHash)(k.Modifiers.Mod + 86)
                        });
                        (0,
                        E.showChartWarningNotification)("paste", {
                            title: pd,
                            text: i
                        })
                    }
                    ))
                }
            })
        }
        function Ad(e, t) {
            (0,
            X.setBroker)(t)
        }
        function Ld(e) {
            const t = {};
            return e.chartWidgetsDefs.map((e=>e.chartWidget)).forEach((e=>t[e.id()] = function(e) {
                var t, i, o, n, r;
                const a = {};
                if (!e.hasModel()) {
                    const n = e.options().content;
                    if (!n)
                        return a;
                    const r = (0,
                    s.ensureNotNull)(n.panes.reduce(((e,t)=>{
                        var i;
                        return null !== (i = null != e ? e : t.sources.find((e=>"MainSeries" === e.type))) && void 0 !== i ? i : null
                    }
                    ), null));
                    return a.resolution = null === (t = r.state) || void 0 === t ? void 0 : t.interval,
                    a.symbol = null === (i = r.state) || void 0 === i ? void 0 : i.symbol,
                    a.short_name = null === (o = r.state) || void 0 === o ? void 0 : o.shortName,
                    a
                }
                const l = e.model().mainSeries()
                  , c = l.properties().childs()
                  , d = l.symbolInfo();
                a.resolution = c.interval.value(),
                a.symbol_type = null !== d && d.type || "",
                a.exchange = null !== d && d.exchange || "",
                a.listed_exchange = null !== d && d.listed_exchange || "";
                const u = null !== (n = null == d ? void 0 : d.legs) && void 0 !== n ? n : [];
                if (null !== d && l.isSpread()) {
                    const e = u[0];
                    let t = d.base_name[0];
                    t = t.split(":")[1],
                    a.symbol = e,
                    a.short_name = t,
                    a.expression = d.full_name
                } else
                    a.symbol = null !== d && d.ticker || c.symbol.value(),
                    a.short_name = c.shortName.value();
                const h = null !== (r = null == d ? void 0 : d.base_name) && void 0 !== r ? r : [];
                return a.legs = u.map(((e,t)=>({
                    symbol: e,
                    pro_symbol: h[t]
                }))),
                a
            }(e))),
            t
        }
        function Ed(e, t) {
            if (ge(e, t.widgetOptions)) {
                const i = new ve(e,!e.readOnly());
                i.beforeUnhibernating().subscribe(e, (()=>{
                    !function(e) {
                        e.chartWidgetsDefs.map((e=>e.chartWidget)).forEach((e=>e.reloadAllLineTools()))
                    }(t)
                }
                )),
                t.setChartStorageNotificationSubscription(i)
            }
        }
        async function kd(e, t) {
            if (t.widgetOptions.newsNotificationsEnabled) {
                return new ((await i.e(56370).then(i.bind(i, 595321))).ChartWidgetCollectionNewsNotifier)(e)
            }
            return null
        }
        function Dd(e, t) {
            const i = {
                snapshotUrl: e
            };
            return i.asyncSave = !window.TVD,
            L(t, i).then((e=>((0,
            Me.emit)("onScreenshotReady", e),
            e)))
        }
        function Nd(e, t) {
            const i = {
                snapshotUrl: e
            };
            i.asyncSave = !window.TVD;
            const s = (0,
            ie.isOnMobileAppPage)("any");
            return (s ? L : A)(t, i).then((e=>((0,
            Me.emit)("onScreenshotReady", e),
            s || (0,
            Me.emit)("onServerScreenshotCopiedToClipboard"),
            e)))
        }
        function Bd(e) {
            return function(e) {
                return I().then((t=>t.downloadClientScreenshot(e)))
            }(e)
        }
        function Rd(e) {
            return function(e) {
                return I().then((t=>t.copyToClipboardClientScreenshot(e)))
            }(e).then((()=>{
                (0,
                Me.emit)("onClientScreenshotCopiedToClipboard")
            }
            ))
        }
        const Od = {
            s: 0,
            "2h": 0,
            "2v": 1,
            "2-1": 1,
            "3s": 0,
            "3h": 0,
            "3v": 2,
            4: 1,
            6: 1,
            8: 1,
            "1-2": 1,
            "3r": 1,
            "4h": 0,
            "4v": 3,
            "4s": 0,
            "4s-l": 0,
            "5h": 0,
            "5v": 0,
            "6h": 0,
            "6v": 0,
            "7h": 0,
            "8h": 0,
            "8v": 0,
            "1-3": 1,
            "2-2": 3,
            "2-2-l": 0,
            "2-3": 2,
            "3-2": 3,
            "1-4": 1,
            "2-4": 2,
            "5s": 0,
            "6c": 4,
            "8c": 6,
            "9s": 6,
            "9h": 0,
            "9v": 0,
            "10h": 0,
            "10v": 0,
            "10c5": 1,
            "12c6": 1,
            "12c4": 3,
            "14c7": 1,
            "16c8": 1,
            "16c4": 3
        };
        function Vd(e, t, i, s) {
            let o = 0;
            const n = (0,
            Yc.createWVFromGetterAndSubscriptions)((()=>++o), [i, s]);
            return (0,
            Ye.combine)((t=>{
                var i;
                return null !== (i = e()[Od[t]]) && void 0 !== i ? i : null
            }
            ), t.weakReference(), n.ownership())
        }
        function Wd(e, t, i, s) {
            var o;
            const n = Math.max(1, window.devicePixelRatio || 1)
              , r = e.getAll();
            let a;
            {
                const s = t || "TradingView.com"
                  , n = {
                    timezone: null !== (o = e.activeChartWidget.value().model().model().timezoneExceptExchange().value()) && void 0 !== o ? o : "exchange",
                    dateFormat: "MMM dd, yyyy"
                }
                  , r = new fe.DateTimeWithTzFormatter(n).format(window.ChartApiInstance.serverTime() / 1e3)
                  , l = e.metaInfo.username.value()
                  , c = !l || e.readOnly() || i ? gd : md
                  , d = [c.split(/{date}/)[0].format({
                    userName: l,
                    customer: s
                }).trim(), r]
                  , u = [c.format({
                    userName: l,
                    customer: s,
                    date: r
                }).trim()];
                a = "phone-vertical" === Se.mediaState.device ? d : u
            }
            const l = e.maximizedChartWidget().value();
            if (s && s.onlyActiveChart || l)
                return {
                    layout: "s",
                    hidpiRatio: n,
                    theme: (0,
                    Ce.getCurrentTheme)().name,
                    charts: [e.activeChartWidget.value().images(s)],
                    publishedBy: a
                };
            const c = []
              , d = xe.layouts[e.layout.value()].count
              , u = {
                showCollapsedStudies: (s = s || {}).showCollapsedStudies,
                status: s.status
            };
            for (let e = 0; e < r.length && e < d; e++)
                c.push(r[e].images(u));
            return {
                layout: e.layout.value(),
                hidpiRatio: n,
                theme: (0,
                Ce.getCurrentTheme)().name,
                charts: c,
                publishedBy: a
            }
        }
        function Fd(e, t, i, s) {
            const o = s || {}
              , n = {
                hideResolution: Boolean(o.hideResolution)
            };
            return (0,
            l.isSymphonyEmbed)() || (o.showHeaderPublishedBy = !0),
            (0,
            we.clientSnapshot)(Wd(e, t, i, {
                showCollapsedStudies: !1,
                status: n
            }), o)
        }
        function Hd(e) {
            var t, i, s, o, n, r;
            const a = (null !== (t = e.options.edge) && void 0 !== t ? t : 0) + (null !== (i = e.options.border) && void 0 !== i ? i : 0)
              , l = null !== (o = null === (s = e.bottomToolbar.value()) || void 0 === s ? void 0 : s.offsetHeight) && void 0 !== o ? o : 0
              , c = null !== (r = null === (n = e.replayContainer) || void 0 === n ? void 0 : n.offsetHeight) && void 0 !== r ? r : 0;
            return {
                width: e.widthWV.value() - 2 * a,
                height: e.heightWV.value() - l - c - a,
                top: 0,
                left: a
            }
        }
        function zd(e) {
            return `chart-widget-collection-border-${e}`
        }
        function Ud(e, t) {
            const i = (0,
            Uc.layoutInitialSizingState)(e.layoutTemplate.value().expression)
              , s = e.layoutTemplate.value().layoutType
              , o = t=>t ? e.allLayoutSizesState.set(s, t) : e.allLayoutSizesState.delete(s);
            if (t)
                return e.sizingState.setValue(i),
                void o(i);
            e.undoHistory.beginUndoMacro(sd),
            e.undoHistory.pushUndoCommand(new v(e.sizingState,e.sizingState.value(),i,sd)),
            e.undoHistory.pushUndoCommand(new _(o,e.allLayoutSizesState.get(e.layoutTemplate.value().layoutType),i,sd)),
            e.undoHistory.endUndoMacro()
        }
        function Gd(e, t) {
            Ud(e, t)
        }
        class jd {
            constructor(e, t, i) {
                this._onShiftPressed = e=>{
                    const t = this._state.currentLayoutResizeAction.value();
                    t && this._applyMouseMove(t.delta, e)
                }
                ,
                this._state = e,
                this._splitterElement = t,
                this._splitter = i,
                (0,
                et.shiftPressed)().subscribe(this._onShiftPressed)
            }
            destroy() {
                (0,
                et.shiftPressed)().unsubscribe(this._onShiftPressed)
            }
            mouseDownEvent(e) {
                this._mouseDownOrTouchStartEvent(e)
            }
            touchStartEvent(e) {
                this._mouseDownOrTouchStartEvent(e)
            }
            pressedMouseMoveEvent(e) {
                this._pressedMouseOrTouchMoveEvent(e)
            }
            touchMoveEvent(e) {
                this._pressedMouseOrTouchMoveEvent(e)
            }
            mouseUpEvent(e) {
                this._mouseUpOrTouchEndEvent(e)
            }
            touchEndEvent(e) {
                this._mouseUpOrTouchEndEvent(e)
            }
            mouseEnterEvent(e) {
                this._highlightSplitters(e.shiftKey)
            }
            mouseLeaveEvent(e) {
                const t = zd(this._splitter.className);
                Array.from(this._state.parent.getElementsByClassName(t)).forEach((e=>e.classList.remove($c.hovered)))
            }
            mouseDoubleClickEvent(e) {
                Ud(this._state)
            }
            _highlightSplitters(e) {
                const t = zd(this._splitter.className);
                Array.from(this._state.parent.getElementsByClassName(t)).forEach((e=>e.classList.remove($c.hovered)));
                (e ? Array.from(this._state.parent.getElementsByClassName(t)) : [this._splitterElement]).forEach((e=>e.classList.add($c.hovered)))
            }
            _mouseDownOrTouchStartEvent(e) {
                const t = new o.Point(e.localX + this._splitterElement.offsetLeft,e.localY + this._splitterElement.offsetTop)
                  , i = (0,
                Gc.deepCopy)(this._state.sizingState.value());
                this._state.currentLayoutResizeAction.setValue({
                    point: t,
                    splitter: this._splitter,
                    initialState: i,
                    alignedState: this._state.layoutTemplate.value().syncSublayoutsBySplitter(this._splitter, (0,
                    Gc.deepCopy)(i)),
                    shiftState: e.shiftKey,
                    delta: 0
                }),
                this._splitterElement.classList.add($c["i-active"]),
                this._highlightSplitters(e.shiftKey)
            }
            _pressedMouseOrTouchMoveEvent(e) {
                const t = this._state.currentLayoutResizeAction.value();
                if (!t)
                    return;
                t.shiftState !== e.shiftKey && (this._highlightSplitters(e.shiftKey),
                t.shiftState = e.shiftKey);
                const i = new o.Point(e.localX + this._splitterElement.offsetLeft,e.localY + this._splitterElement.offsetTop);
                t.delta = "v" === t.splitter.orientation ? i.y - t.point.y : i.x - t.point.x,
                this._applyMouseMove(t.delta, e.shiftKey)
            }
            _mouseUpOrTouchEndEvent(e) {
                const t = this._state.currentLayoutResizeAction.value();
                if (t && (this._splitterElement.classList.remove($c["i-active"]),
                this._state.currentLayoutResizeAction.setValue(null),
                t.currentState)) {
                    this._state.undoHistory.beginUndoMacro(id),
                    this._state.undoHistory.pushUndoCommand(new v(this._state.sizingState,t.initialState,t.currentState,id));
                    const e = this._state.layoutTemplate.value().layoutType;
                    this._state.undoHistory.pushUndoCommand(new _((t=>t ? this._state.allLayoutSizesState.set(e, t) : this._state.allLayoutSizesState.delete(e)),this._state.allLayoutSizesState.get(this._state.layoutTemplate.value().layoutType),this._state.sizingState.value(),sd)),
                    this._state.undoHistory.endUndoMacro(),
                    this._state.layoutSizesChanged.setValue(!0)
                }
            }
            _applyMouseMove(e, t) {
                var i;
                const o = (0,
                s.ensureNotNull)(this._state.currentLayoutResizeAction.value())
                  , n = t ? o.alignedState : o.initialState
                  , r = null !== (i = this._state.options.padding) && void 0 !== i ? i : 2
                  , a = Hd(this._state);
                o.currentState = this._state.layoutTemplate.value().resizeApplier(a, r, e, o.splitter, (0,
                Gc.deepCopy)(n), t),
                this._state.sizingState.setValue(o.currentState)
            }
        }
        function qd(e, t, i, s, o) {
            var n, r;
            const a = null !== (n = e.options.padding) && void 0 !== n ? n : 2
              , l = null !== (r = e.options.border) && void 0 !== r ? r : 0;
            o = null != o ? o : e.layoutTemplate.value();
            const c = Hd(e)
              , d = o.sizer(c, i, s, a + l, Jc ? e.sizingState.value() : void 0);
            d.width = Math.max(Math.round(d.width), 0),
            d.height = Math.max(Math.round(d.height), 0),
            d.top = Math.round(d.top),
            d.left = Math.round(d.left),
            t.metrics = d;
            const u = t.container.value();
            if (u) {
                u.style.width = d.width + "px",
                u.style.height = d.height + "px",
                u.style.top = d.top + "px",
                u.style.left = d.left + "px";
                const e = 1 === s;
                u.classList.toggle("single-visible", e);
                const t = Math.round(c.width)
                  , i = 0 === d.top && 0 === d.left
                  , o = 0 === d.top && d.left + d.width === t
                  , n = 0 === d.top && d.width === t;
                u.classList.toggle("top-left-chart", !e && !n && i),
                u.classList.toggle("top-right-chart", !e && !n && o),
                u.classList.toggle("top-full-width-chart", e || n)
            }
            t.width.setValue(d.width),
            t.height.setValue(d.height)
        }
        function Xd(e) {
            var t, i, s;
            let o;
            const n = e.layoutTemplate.value()
              , r = e.maximizedChartDef.value();
            if (o = r ? [r] : e.chartWidgetsDefs.slice(0, n.count).filter((e=>!e.hiddenInLayout.value())),
            o.forEach(((t,i)=>qd(e, t, i, o.length))),
            Jc && !e.maximizedChartDef.value()) {
                const o = Hd(e)
                  , r = null !== (t = e.options.padding) && void 0 !== t ? t : 2
                  , a = null !== (i = e.options.border) && void 0 !== i ? i : 0
                  , l = n.splitters(o, r + a, e.sizingState.value())
                  , c = null !== (s = e.splitters.value()) && void 0 !== s ? s : [];
                c.forEach(((e,t)=>{
                    t >= l.length && (e.splitterElement.remove(),
                    e.mouseHandler.destroy(),
                    e.mouseListener.destroy())
                }
                ));
                const d = l.map(((t,i)=>{
                    const s = i < c.length ? c[i].splitterElement : document.createElement("div");
                    let o, n;
                    i < c.length ? (o = c[i].mouseListener,
                    n = c[i].mouseHandler) : (o = new jd(e,s,t),
                    n = new Ot.MouseEventHandler(s,o));
                    const r = t.metrics
                      , a = s.classList.contains($c.hovered)
                      , l = s.classList.contains($c["i-active"]);
                    return s.className = "",
                    s.classList.add($c.chartsSplitter),
                    s.classList.add(zd(t.className)),
                    a && s.classList.add($c.hovered),
                    l && s.classList.add($c["i-active"]),
                    s.style.left = r.left + "px",
                    s.style.top = r.top + "px",
                    s.style.width = r.width + "px",
                    s.style.height = r.height + "px",
                    s.setAttribute("aria-hidden", "true"),
                    "v" === t.orientation ? s.style.cursor = "ns-resize" : s.style.cursor = "ew-resize",
                    e.parent.insertBefore(s, e.bottomToolbar.value()),
                    {
                        splitter: t,
                        splitterElement: s,
                        mouseHandler: n,
                        mouseListener: o
                    }
                }
                ));
                e.splitters.setValue(d)
            }
        }
        function Kd(e, t, i) {
            const s = e.chartWidgetsDefs.slice(0, e.layoutTemplate.value().count).map(((t,i,s)=>({
                def: t,
                metrics: e.layoutTemplate.value().sizer({
                    top: 0,
                    left: 0,
                    width: 256,
                    height: 256
                }, i, s.length, 0)
            }))).sort(((e,t)=>e.metrics.top - t.metrics.top || e.metrics.left - t.metrics.left)).map((e=>e.def));
            if (s.length < 2)
                return null;
            let o = s.indexOf(t);
            return -1 === o ? null : (o = (o + (i ? s.length - 1 : 1)) % s.length,
            s[o])
        }
        function Yd(e, t) {
            return e.chartWidgetsDefs.some((e=>{
                var i;
                return (null === (i = e.chartWidget) || void 0 === i ? void 0 : i.id()) === t
            }
            ))
        }
        function Zd(e) {
            let t = 1;
            for (; e("" + t); )
                t++;
            return "" + t
        }
        function $d(e, t, i) {
            const s = [];
            if (null == i ? void 0 : i.publishedChartsEnabled) {
                const t = new z.PublishedChartsTimeline(e,(e=>function(e) {
                    (0,
                    ee.openPublicationViewPopup)(e)
                }(e)));
                s.push(t)
            }
            return s
        }
        function Jd(e, t, i) {
            var o, n;
            const {toastsFactory: r, chartWidgetsDefs: a, customLegendWidgetsFactoriesMap: c} = e;
            let d = {
                chartWidgetCollection: t,
                isActive: 0 === a.length,
                barsMarksContainersFactory: t=>$d(t, 0, e.options),
                undoHistory: e.undoHistory,
                readOnly: e.readOnly,
                initialLoading: e.initialLoading,
                getToasts: r ? ()=>r.getChartToasts() : void 0,
                ...null != i ? i : {}
            };
            void 0 !== c && (d.customLegendWidgetFactories = new Map(c));
            const u = document.createElement("div");
            u.classList.add("chart-container"),
            u.style.position = "absolute",
            u.style.overflow = "hidden",
            e.parent.insertBefore(u, e.bottomToolbar.value()),
            l.isEdge && (u.style.touchAction = "none",
            u.style.msTouchAction = "none"),
            d.className && u.classList.add(d.className);
            const p = {
                alive: new h.WatchedValue(!0),
                container: new h.WatchedValue(u),
                width: new h.WatchedValue,
                height: new h.WatchedValue,
                collapsed: new h.WatchedValue(!1),
                hiddenInLayout: new h.WatchedValue(!1),
                visible: new h.WatchedValue,
                rdState: new Ie.ResizerDetacherState,
                requestFullscreen: ()=>{
                    e.globalDetachable.value() && (e.setMaximized(p),
                    e.activeChartWidget.setValue((0,
                    s.ensureNotNull)(p.chartWidget)))
                }
                ,
                exitFullscreen: ()=>{
                    e.activeChartWidget.value() === p.chartWidget && e.setMaximized(null)
                }
                ,
                detachable: e.globalDetachable,
                fullscreenable: e.globalDetachable,
                fullscreen: new h.WatchedValue,
                chartWidget: null
            };
            p.rdState.pushOwner(p),
            a.push(p);
            const m = ()=>{
                p.visible.setValue(!p.hiddenInLayout.value() && e.options.resizerBridge.visible.value())
            }
            ;
            p.hiddenInLayout.subscribe((()=>{
                (0,
                s.ensureNotNull)(p.chartWidget).setVisible(!p.hiddenInLayout.value()),
                m()
            }
            )),
            p.collapsed.subscribe((()=>(0,
            s.ensureNotNull)(p.chartWidget).setCollapsed(p.collapsed.value()))),
            e.options.resizerBridge.visible.subscribe(m),
            m(),
            function(e, t) {
                let i = 0
                  , s = 0;
                const o = t.layoutTemplate.value();
                for (let n = 0; n < o.count; n++)
                    t.chartWidgetsDefs[n] === e && (s = i),
                    i++;
                qd(t, e, s, i, o)
            }(p, e),
            d = {
                ...d,
                ...p.rdState.bridge()
            };
            const g = d.content ? (0,
            s.ensureDefined)(d.content.chartId) : Zd((t=>Yd(e, t)))
              , _ = p.chartWidget = new zc(d,g,t.metaInfo.uid.value());
            e.saveChartService && _.setSaveChartService(e.saveChartService),
            e.readOnly || (p.timingsMeter = new H(String(a.length - 1)),
            _.setTimingsMeter(p.timingsMeter)),
            d.containsData ? _.finishInitWithoutConnect() : _.connect(),
            _.withModel(null, (()=>{
                const t = _.model().model();
                e.customSources.forEach(((e,i)=>{
                    t.addCustomSource(i, e.factory, e.layer)
                }
                ))
            }
            )),
            e.updateWatchedValue(),
            e.updateActivityView();
            const v = null !== (n = null === (o = null == d ? void 0 : d.content) || void 0 === o ? void 0 : o.linkingGroup) && void 0 !== n ? n : null;
            _.linkingGroupIndex().setValue(v),
            _.linkingGroupIndex().subscribe(e.updateLinkingGroupCharts);
            const S = Ru(e, v).value();
            return S.length > 0 && (e.symbolLock.value() && _.setSymbol(S[0].symbolWV().value()),
            e.intervalLock.value() && _.setResolution(S[0].resolutionWV().value())),
            e.updateLinkingGroupCharts(),
            e.chartWidgetCreatedDelegate.fire(_),
            p
        }
        function Qd(e, t, i, s) {
            let o, n = e.savedChartWidgetOptions.shift();
            if (void 0 !== n) {
                const t = e.activeChartWidget.value();
                t && t.lineToolsSynchronizer() && (o = t.lineToolsAndGroupsDTO())
            } else
                n = function(e) {
                    const t = e.activeChartWidget.value();
                    if (t) {
                        const i = t.state();
                        return i.chartId = Zd((t=>Yd(e, t))),
                        i.shouldBeSavedEvenIfHidden = !1,
                        i.panes.forEach((e=>{
                            e.sources.forEach((e=>{
                                "alertId"in e && (e.alertId = void 0)
                            }
                            ))
                        }
                        )),
                        {
                            content: i
                        }
                    }
                }(e);
            const r = {
                ...e.widgetOptions,
                ...n,
                ...0 === i || e.symbolLock.value() ? void 0 : {
                    defSymbol: null
                }
            }
              , a = Jd(e, t, r)
              , {chartWidget: l} = a;
            return l.modelCreated().subscribe(null, (()=>{
                s ? s() : e.checkAllPendingModelsAlreadyCreated(),
                e.dateRangeLock.value() && l === e.activeChartWidget.value() && e.subscribeToCompletedEventForDateRangeSync(l, !0);
                const t = l.lineToolsSynchronizer();
                void 0 !== o && t && [...o.entries()].map((([e,i])=>{
                    0 !== e && t.applyDTO(i, e).then((()=>{
                        t.invalidateAll()
                    }
                    ))
                }
                ));
                const i = e.chartWidgetsDefs.filter((e=>e.chartWidget.hasModel())).map((e=>e.chartWidget.model()));
                e.chartModels.setValue(i)
            }
            ), !0),
            a
        }
        function eu(e) {
            e.hiddenInLayout.setValue(!0);
            const t = e.container.value();
            t.parentNode && t.parentNode.removeChild(t),
            e.fullscreen.setValue(!1)
        }
        function tu(e, t, i) {
            const o = (0,
            s.ensureNotNull)(e.chartWidget);
            o.onZoom().unsubscribeAll(i),
            o.onScroll().unsubscribeAll(i),
            o.withModel(null, (()=>{
                const e = o.lineToolsSynchronizer();
                null !== e && (e.hasChanges().unsubscribe(t.recalcHasChanges),
                t.recalcHasChanges())
            }
            ))
        }
        function iu(e, t) {
            e.chartWidgetsDefs.forEach((i=>{
                tu(i, e, t)
            }
            ))
        }
        function su(e, t) {
            const i = e.actualLayoutCount();
            for (let s = i; s < e.chartWidgetsDefs.length; s++)
                tu(e.chartWidgetsDefs[s], e, t);
            e.chartWidgetsDefs.splice(i, e.chartWidgetsDefs.length - i)
        }
        function ou(e, t) {
            e.chartWidgetsDefs.forEach((i=>{
                const o = (0,
                s.ensureNotNull)(i.chartWidget);
                o.onZoom().subscribe(t, (t=>e.onZoom.fire(t))),
                o.onScroll().subscribe(t, (()=>e.onScroll.fire())),
                o.withModel(null, (()=>{
                    const t = o.lineToolsSynchronizer();
                    null !== t && (t.hasChanges().subscribe(e.recalcHasChanges),
                    e.recalcHasChanges())
                }
                ))
            }
            ))
        }
        const nu = ["2-3", "5h", "6h", "7h", "8h"]
          , ru = ["10c5", "12c6", "12c4", "14c7", "16c8", "16c4"];
        async function au(e) {
            var t, i;
            const o = this.innerState();
            (0,
            D.getInitData)().is_mobile_new && (nu.includes(e) && !(0,
            d.enabled)("mobile_app_supports_new_layout_types") || ru.includes(e) && !(0,
            d.enabled)("mobile_app_supports_new_layout_types_2")) && (e = "s");
            {
                let e = !1;
                if (o.saveChartService && (e = Boolean(o.saveChartService.autoSaveEnabled().value())),
                e)
                    try {
                        const e = o.chartWidgetsDefs.map((e=>{
                            var t, i, s;
                            return null !== (s = null === (i = null === (t = e.chartWidget) || void 0 === t ? void 0 : t.lineToolsSynchronizer()) || void 0 === i ? void 0 : i.flushPendingSavings()) && void 0 !== s ? s : null
                        }
                        )).filter(Ue.notNull);
                        e.length && await Promise.all(e)
                    } catch (e) {
                        Qc.logError(`Error flushing line tools: ${e}`)
                    }
            }
            (e = o.checkProFeature(e))in xe.layouts || (e = "s"),
            iu(o, this);
            const n = o.layoutType
              , r = xe.layouts[e].count;
            (0,
            Me.emit)("layout_about_to_be_changed", e),
            (null !== (t = o.splitters.value()) && void 0 !== t ? t : []).forEach(((e,t)=>{
                e.splitterElement.remove(),
                e.mouseHandler.destroy()
            }
            )),
            o.splitters.setValue([]);
            const a = xe.layouts[e];
            o.layoutTemplate.setValue(a);
            const l = null !== (i = o.allLayoutSizesState.get(a.layoutType)) && void 0 !== i ? i : (0,
            Uc.layoutInitialSizingState)(a.expression);
            o.allLayoutSizesState.set(a.layoutType, l),
            o.sizingState.setValue(l);
            const c = o.maximizedChartDef.value();
            if (o.isPhoneSize.value() && o.viewMode.value() === p.CollectionViewMode.ForceFullscreen)
                if (c) {
                    const e = o.chartWidgetsDefs.indexOf(c);
                    (e < 0 || e >= r) && o.maximizedChartDef.setValue(o.chartWidgetsDefs[0])
                } else
                    o.maximizedChartDef.setValue(o.chartWidgetsDefs[0]);
            else
                n !== e && o.maximizedChartDef.value() && o.maximizedChartDef.setValue(null);
            c && o.activeChartWidget.setValue((0,
            s.ensureNotNull)(c.chartWidget));
            for (let e = 0; e < r || e < o.chartWidgetsDefs.length; e++) {
                let t, i = o.chartWidgetsDefs[e];
                const n = e >= r;
                if (t = o.maximizedChartDef.value() ? o.maximizedChartDef.value() === i : e < r,
                t) {
                    if (i) {
                        if (o.parent.insertBefore(i.container.value(), o.bottomToolbar.value()),
                        i.hiddenInLayout.setValue(!1),
                        o.loadingContent) {
                            const e = o.savedChartWidgetOptions.shift();
                            e && (o.setLoadingContent(!0),
                            (0,
                            s.ensureNotNull)(i.chartWidget).loadContent(e.content, o.initialLoading),
                            o.setLoadingContent(!1))
                        }
                    } else
                        Qd(o, this, e, void 0),
                        i = o.chartWidgetsDefs[e];
                    i.container.value().classList.toggle("multiple", r > 1),
                    i.fullscreen.setValue(o.maximizedChartDef.value() === i),
                    i.collapsed.setValue(n)
                } else
                    i ? (eu(i),
                    i.collapsed.setValue(n)) : o.isPhoneSize.value() && o.viewMode.value() === p.CollectionViewMode.ForceFullscreen && (Qd(o, this, e, void 0),
                    eu(o.chartWidgetsDefs[e]),
                    o.chartWidgetsDefs[e].collapsed.setValue(n))
            }
            o.sizingState.setValue(l),
            Xd(o),
            o.layoutWV.setValue(e),
            o.setLayoutType(e),
            o.updateWatchedValue(),
            function(e) {
                const t = e.layoutTemplate.value().count;
                e.inlineChartsCount.setValue(t),
                e.globalDetachable.setValue(t > 1)
            }(o),
            o.checkAllPendingModelsAlreadyCreated(),
            ou(o, this),
            o.initialLoading || o.updateViewMode(),
            o.inlineChartsCount.value() < 1 && r > 0 && o.chartWidgetsDefs[r - 1].rdState.bridge().attach()
        }
        function lu(e, t, i, s, o) {
            const n = e.actualLayoutCount();
            return e.chartWidgetsDefs.slice(0, n).filter((e=>e.rdState.bridge().visible.value())).map((e=>e.chartWidget)).filter((t=>t.id() !== i && (!!t.hasModel() && (t.selectPointMode().value() === qt.SelectPointMode.Replay && "AllCharts" === J.replayModeProperty.value() || (s || e.crosshairLockRaw))))).forEach((e=>e.model().model().setExternalPosition(t, o))),
            !0
        }
        function cu(e, t, i, s, o) {
            if (lu(e, t, i, s, o)) {
                const i = e.crossHairSyncBroadcast;
                if (i) {
                    const e = {
                        type: "crosshair",
                        payload: {
                            point: t,
                            envState: o,
                            sourceUniqueId: i.uniqueId
                        }
                    };
                    i.channel.postMessage(e)
                }
            }
        }
        function du(e) {
            const t = new BroadcastChannel("ChartWidgetsCollection");
            return t.onmessage = t=>{
                const i = t.data
                  , s = e();
                if (s.crossHairSyncBroadcast && "crosshair" === i.type)
                    s.crossHairSyncBroadcast.uniqueId !== i.payload.sourceUniqueId && lu(s, i.payload.point, null, !1, i.payload.envState)
            }
            ,
            {
                channel: t,
                uniqueId: (0,
                Pe.randomHashN)(6)
            }
        }
        function uu(e) {
            var t;
            null === (t = e.crossHairSyncBroadcast) || void 0 === t || t.channel.close()
        }
        function hu(e, t, i) {
            if (!e.combinedTrackTimeLock.value() || e.dateRangeLock.value())
                return;
            const s = e.layoutTemplate.value().count;
            e.undoHistory.beginUndoMacro(td),
            e.chartWidgetsDefs.slice(0, s).filter((e=>e.chartWidget.hasModel() && e.chartWidget.model().model() !== i)).forEach((e=>{
                const i = e.chartWidget.model().model()
                  , s = i.mainSeries().syncModel();
                s && i.syncTimeWithModel(s.syncSourceTarget(), t)
            }
            )),
            e.undoHistory.endUndoMacro(),
            (0,
            Me.emit)("sync_time", t)
        }
        function pu(e) {
            return Promise.all(e.map((e=>{
                const t = e.model().mainSeries();
                return t.symbolResolvingActive().value() ? u(t.dataEvents().symbolResolved()).promise : t.symbolInfo()
            }
            )))
        }
        function mu(e) {
            return e.chartWidgetsDefs.every((e=>e.chartWidget.hasModel())) ? Promise.resolve(e.chartWidgetsDefs.map((e=>e.chartWidget))) : Promise.all(e.chartWidgetsDefs.map((e=>e.chartWidget.hasModel() || u(e.chartWidget.modelCreated()).promise))).then((()=>mu(e)))
        }
        function gu(e, t) {
            var i, o, n;
            if ("s" === t || e.widgetOptions.containsData || e.readOnly || (0,
            Y.enabled)("MULTIPLE_CHARTS") && (0,
            s.ensure)(null === (i = (0,
            Y.getConfig)("MULTIPLE_CHARTS")) || void 0 === i ? void 0 : i.limit) >= xe.layouts[t].count)
                return t;
            let r = "s";
            {
                let i = 1;
                const s = null !== (n = null === (o = (0,
                Y.getConfig)("MULTIPLE_CHARTS")) || void 0 === o ? void 0 : o.limit) && void 0 !== n ? n : 0;
                for (const e of Object.keys(xe.layouts)) {
                    const t = xe.layouts[e].count;
                    t <= s && t > i && (r = e,
                    i = t)
                }
                mu(e).then(pu).then((()=>{
                    (0,
                    K.trackGoProFeature)("multipleCharts"),
                    (0,
                    Z.createGoProDialog)({
                        feature: "multipleCharts",
                        customParams: xe.layouts[t].count
                    })
                }
                ))
            }
            return r
        }
        async function _u(e, t, i) {
            if (i = gu(e, i),
            e.layoutWV.value() === i)
                return !1;
            {
                let t = !1;
                if (e.saveChartService && (t = Boolean(e.saveChartService.autoSaveEnabled().value())),
                t) {
                    const t = e.chartWidgetsDefs.map((e=>{
                        var t, i, s;
                        return null !== (s = null === (i = null === (t = e.chartWidget) || void 0 === t ? void 0 : t.lineToolsSynchronizer()) || void 0 === i ? void 0 : i.flushPendingSavings()) && void 0 !== s ? s : null
                    }
                    )).filter(Ue.notNull);
                    if (t.length)
                        try {
                            await Promise.all(t)
                        } catch (e) {
                            Qc.logError(`Error flushing line tools: ${e}`)
                        }
                }
            }
            return e.undoHistory.pushUndoCommand(new qc(t,i)),
            !0
        }
        async function vu(e, t, i) {
            const {theme: s, onlyActiveChart: o, restoreNonThemeDefaults: n, themeName: r, standardTheme: a, syncState: l=!0, noUndo: c} = i
              , d = (0,
            Ce.getCurrentTheme)().name;
            let u;
            o ? u = [e.activeChartWidget.value()] : (iu(e, t),
            await Promise.all(e.savedChartWidgetOptions.map(((e,t)=>t)).map((i=>new Promise((s=>{
                eu(Qd(e, t, i, s))
            }
            ))))),
            u = e.chartWidgetsDefs.map((e=>e.chartWidget)),
            ou(e, t)),
            c ? (a && new Kc(d,r,l).redo(),
            u.forEach((e=>{
                e.model().model().restoreTheme(s, n, c)
            }
            ))) : (e.undoHistory.beginUndoMacro(od),
            a && e.undoHistory.pushUndoCommand(new Kc(d,r,l)),
            u.forEach((e=>{
                e.model().model().restoreTheme(s, n)
            }
            )),
            e.undoHistory.endUndoMacro()),
            await Promise.all(u.map((e=>e.model().model().colorStudiesPropertiesReady())))
        }
        function Su(e, t) {
            e.symbolLock.setValue(t)
        }
        function fu(e, t) {
            const {internalSymbolLock: i, activeChartWidget: s, undoHistory: o, dateRangeLock: n, loadingContent: r, linkingGroupsCharts: l, chartWidgetsDefs: c} = e;
            if (t !== i.value())
                if (r)
                    i.setValue(t);
                else {
                    if (e.undoHistory.beginUndoMacro(nd),
                    t) {
                        const t = s.value()
                          , i = c.map((e=>e.chartWidget));
                        l.forEach(((s,o)=>{
                            const r = t.linkingGroupIndex().value() === o ? t : i.find((e=>e.linkingGroupIndex().value() === o));
                            if (void 0 !== r) {
                                (0,
                                a.muteLinkingGroup)(o, !0);
                                for (const t of s.value())
                                    t !== r && t.symbolWV().value() !== r.symbolWV().value() && (t.setSymbol(r.symbolWV().value()),
                                    n.value() && e.subscribeToCompletedEventForDateRangeSync(t, !0));
                                (0,
                                a.muteLinkingGroup)(o, !1)
                            }
                        }
                        ))
                    }
                    o.setWatchedValue(i, t, nd),
                    o.endUndoMacro()
                }
        }
        function bu(e, t) {
            e.intervalLock.setValue(t)
        }
        function yu(e, t) {
            const {internalIntervalLock: i, activeChartWidget: s, undoHistory: o, dateRangeLock: n, loadingContent: r, chartWidgetsDefs: l, linkingGroupsCharts: c} = e;
            if (t !== i.value())
                if (r)
                    i.setValue(t);
                else {
                    if (o.beginUndoMacro(rd),
                    t && t) {
                        const t = s.value()
                          , i = l.map((e=>e.chartWidget));
                        c.forEach(((s,o)=>{
                            const r = t.linkingGroupIndex().value() === o ? t : i.find((e=>e.linkingGroupIndex().value() === o));
                            if (void 0 !== r) {
                                (0,
                                a.muteLinkingGroup)(o, !0);
                                for (const t of s.value())
                                    t !== r && t.resolutionWV().value() !== r.resolutionWV().value() && (t.setResolution(r.resolutionWV().value()),
                                    n.value() && e.subscribeToCompletedEventForDateRangeSync(t, !0));
                                (0,
                                a.muteLinkingGroup)(o, !1)
                            }
                        }
                        ))
                    }
                    o.setWatchedValue(i, t, rd),
                    o.endUndoMacro()
                }
        }
        function Cu(e, t) {
            const i = e.activeChartWidget.value();
            if (i && i.hasModel()) {
                const s = i.model();
                t ? (e.subscribeToEventsForDateRangeSync(s),
                e.syncChartsDateRangesWithActiveChartRange()) : e.unsubscribeFromEventsForDateRangeSync(s)
            }
            e.dateRangeLock.setValue(t)
        }
        function wu(e, t) {
            const {internalDateRangeLock: i, undoHistory: s, loadingContent: o} = e;
            o ? i.setValue(t) : s.setWatchedValue(i, t, ad)
        }
        function Tu(e, t) {
            e.trackTimeLock.setValue(t)
        }
        function Pu(e, t) {
            const {internalTrackTimeLock: i, undoHistory: s, loadingContent: o} = e;
            o ? i.setValue(t) : s.setWatchedValue(i, t, ld)
        }
        async function xu(e, t) {
            const i = e.chartWidgetsDefs.map((e=>e.chartWidget));
            return Mu(e, t, void 0, void 0, i)
        }
        async function Mu(e, t, i, s, o) {
            const n = null != s ? s : e.activeChartWidget.value();
            void 0 === i && (i = n.linkingGroupIndex().value());
            {
                const i = (o = null != o ? o : e.symbolLock.value() ? e.chartWidgetsDefs.map((e=>e.chartWidget)) : [n]).filter((e=>e.model().isInReplay().value()));
                if (i.length) {
                    if (!(await Promise.all(i.map((e=>e.model().canChangeSymbol(t))))).some(Boolean))
                        return !1
                }
            }
            for (const e of o)
                (e.hasModel() ? e.model().mainSeries().symbolSameAsResolved(t) : e.symbolWV().value() === t) || void 0 !== i && e.linkingGroupIndex().value() !== i || e.setSymbol(t);
            return !0
        }
        async function Iu(e, t=this.activeChartWidget.value()) {
            if (!t)
                return !1;
            {
                if (zs.Interval.isTicks(t.resolutionWV().value()) && (4 === e || 7 === e || 5 === e || 6 === e))
                    return t.showHint(1, {
                        text: Sd.format({
                            chartStyle: (0,
                            ye.getTranslatedChartStyleName)(e)
                        }),
                        solutionId: Q.solutionIds.WHY_RENKO_NOT_WORK,
                        solutionText: r.t(null, void 0, i(744955))
                    }),
                    !1;
                let s = !1;
                const o = Lu(this.innerState());
                for (const t of o) {
                    const i = t.model().model();
                    if (i.isInReplay().value() && !i.mainSeries().isStyleSupported(e)) {
                        s = !0;
                        break
                    }
                }
                const n = this.innerState().flags;
                return !s || n.isConfirmationAboutReplayLocked ? (Au(t, e),
                !0) : new Promise((i=>{
                    (0,
                    sl.showConfirm)({
                        text: _d,
                        onConfirm: s=>{
                            n.isConfirmationAboutReplayLocked = !0,
                            Au(t, e),
                            n.isConfirmationAboutReplayLocked = !1,
                            s.dialogClose(),
                            i(!0)
                        }
                        ,
                        onClose: ()=>i(!1),
                        onCancel: e=>{
                            e.dialogClose(),
                            i(!1)
                        }
                    })
                }
                ))
            }
        }
        function Au(e, t) {
            const i = e.model()
              , s = i.mainSeries().properties().childs().style;
            i.setChartStyleProperty(s, t, cd)
        }
        function Lu(e) {
            return (e.intervalLock.value() ? e.chartWidgetsDefs.map((e=>e.chartWidget)) : [e.activeChartWidget.value()]).filter((e=>e.hasModel()))
        }
        async function Eu(e, t, s, o) {
            if (e.flags.loadingChart || e.flags.setTimeFrameActive || e.flags.setNewResolution)
                return !1;
            {
                const n = zs.Interval.isTicks(t)
                  , a = Lu(e);
                if (n)
                    for (const e of a) {
                        const t = e.model().model().mainSeries().style();
                        if (4 === t || 7 === t || 5 === t || 6 === t)
                            return e.showHint(1, {
                                text: Sd.format({
                                    chartStyle: (0,
                                    ye.getTranslatedChartStyleName)(t)
                                }),
                                solutionId: Q.solutionIds.WHY_RENKO_NOT_WORK,
                                solutionText: r.t(null, void 0, i(744955))
                            }),
                            !1
                    }
                let l = ""
                  , c = !1;
                const d = zs.Interval.isRange(t);
                if (d || n)
                    for (const e of a) {
                        const t = e.model().model();
                        if (t.isInReplay().value()) {
                            if (d && 11 !== t.mainSeries().style()) {
                                c = !0,
                                l = _d;
                                break
                            }
                            n && (c = !0,
                            l = vd)
                        }
                    }
                const u = a.filter((e=>e.model().isInReplay().value()));
                if (u.length) {
                    if (!(await Promise.all(u.map((e=>e.model().canChangeResolution(t))))).every(Boolean))
                        return !1
                }
                return !c || e.flags.isConfirmationAboutReplayLocked ? (ku(e, t, s, o),
                !0) : new Promise((i=>{
                    (0,
                    sl.showConfirm)({
                        text: l,
                        onConfirm: n=>{
                            e.flags.isConfirmationAboutReplayLocked = !0,
                            ku(e, t, s, o),
                            e.flags.isConfirmationAboutReplayLocked = !1,
                            n.dialogClose(),
                            i(!0)
                        }
                        ,
                        onClose: ()=>i(!1),
                        onCancel: e=>{
                            e.dialogClose(),
                            i(!1)
                        }
                    })
                }
                ))
            }
        }
        function ku(e, t, i, s) {
            if ((0,
            rs.setLastUsedResolution)(t),
            e.flags.setNewResolution = !0,
            s = null != s ? s : e.activeChartWidget.value(),
            void 0 === i && (i = s.linkingGroupIndex().value()),
            e.intervalLock.value())
                for (const s of e.chartWidgetsDefs) {
                    const e = s.chartWidget;
                    e.resolutionWV().value() === t || void 0 !== i && e.linkingGroupIndex().value() !== i || e.setResolution(t)
                }
            else
                s.setResolution(t);
            e.flags.setNewResolution = !1
        }
        function Du(e) {
            const t = new h.WatchedValue(null)
              , i = ()=>{
                t.setValue(e.value().linkingGroupIndex().value())
            }
            ;
            e.value() && i();
            const s = e.spawn();
            let o;
            return s.subscribe((e=>{
                null == o || o.destroy(),
                o = e.linkingGroupIndex().spawn(),
                o.subscribe(i),
                i()
            }
            )),
            t.spawn((()=>{
                s.destroy(),
                null == o || o.destroy()
            }
            ))
        }
        function Nu(e) {
            const t = new Set(e.map((e=>e.chartWidget.linkingGroupIndex().value())));
            return Array.from(t).sort(((e,t)=>(null != e ? e : -1) - (null != t ? t : -1)))
        }
        function Bu(e) {
            const t = new Zc.WatchedObject(Nu(e.chartWidgetsDefs))
              , i = ()=>{
                t.setValue(Nu(e.chartWidgetsDefs))
            }
            ;
            e.chartWidgetsDefs.forEach((e=>e.chartWidget.linkingGroupIndex().subscribe(i)));
            const s = e=>{
                e.linkingGroupIndex().subscribe(i),
                i()
            }
            ;
            return e.chartWidgetCreatedDelegate.subscribe(null, s),
            t.spawn((()=>{
                e.chartWidgetsDefs.forEach((e=>e.chartWidget.linkingGroupIndex().unsubscribe(i))),
                e.chartWidgetCreatedDelegate.unsubscribe(null, s)
            }
            ))
        }
        function Ru(e, t) {
            let i = e.linkingGroupsCharts.get(t);
            return void 0 === i && (i = new Zc.WatchedObject([],Te.compareTwoCollectionsByIds),
            e.linkingGroupsCharts.set(t, i)),
            i
        }
        function Ou(e) {
            var t;
            const i = new Map;
            for (const t of e.chartWidgetsDefs) {
                const e = t.chartWidget.linkingGroupIndex().value();
                let s = i.get(e);
                void 0 === s && (s = [],
                i.set(e, s)),
                s.push(t.chartWidget)
            }
            for (const s of (0,
            Te.join)(new Set(e.linkingGroupsCharts.keys()), new Set(i.keys())))
                Ru(e, s).setValue(null !== (t = i.get(s)) && void 0 !== t ? t : [])
        }
        function Vu(e) {
            if (e) {
                const e = function() {
                    var e, t, i, o;
                    const n = null !== (t = null === (e = (0,
                    Y.getConfig)("BACKEND_CONNECTIONS")) || void 0 === e ? void 0 : e.limit) && void 0 !== t ? t : 0
                      , r = (0,
                    s.ensureDefined)(window.pro)
                      , a = r.getProductsByType(r.PRODUCT_TYPES.pro_plan);
                    for (const e of a)
                        if ((null !== (o = null === (i = (0,
                        Y.getConfig)("BACKEND_CONNECTIONS", (0,
                        s.ensureDefined)(e.id))) || void 0 === i ? void 0 : i.limit) && void 0 !== o ? o : 0) > n)
                            return {
                                connectionCount: n,
                                moreConnectionsPlanAvailable: !0
                            };
                    return {
                        connectionCount: n,
                        moreConnectionsPlanAvailable: !1
                    }
                }()
                  , t = [{
                    text: r.t(null, void 0, i(906186)),
                    action: $.PredefinedAction.Close,
                    variant: "secondary",
                    color: "gray",
                    compactMode: !0,
                    onClick: ()=>window.ChartApiInstance.connect()
                }];
                e.moreConnectionsPlanAvailable && t.push({
                    action: $.PredefinedAction.OpenGopro,
                    text: r.t(null, void 0, i(987780)),
                    compactMode: !0
                }),
                (0,
                Z.createGoProDialog)({
                    feature: "connectionsLimit",
                    actionButtonsLayout: $.ActionButtonsLayout.Row,
                    actions: t,
                    customParams: e
                })
            }
        }
        function Wu(e, t) {
            let i = [];
            const s = {}
              , o = ()=>{
                i.forEach((e=>e.unsubscribe(a))),
                i = t.filter((e=>e.chartWidget.hasModel())).map((e=>e.chartWidget.selectPointMode())),
                i.forEach((e=>e.subscribe(a))),
                t.forEach((e=>{
                    e.chartWidget.hasModel() || e.chartWidget.withModel(s, (()=>{
                        o(),
                        a()
                    }
                    ))
                }
                ))
            }
            ;
            o();
            const n = ()=>i.some((e=>e.value() === qt.SelectPointMode.Replay)) && "AllCharts" === J.replayModeProperty.value()
              , r = new h.WatchedValue(n())
              , a = ()=>r.setValue(n())
              , l = ()=>{
                o(),
                a()
            }
            ;
            e.subscribe(l),
            J.replayModeProperty.subscribe(r, a);
            return r.spawn((()=>{
                J.replayModeProperty.unsubscribe(r, a),
                e.unsubscribe(l),
                i.forEach((e=>e.subscribe(a)))
            }
            ))
        }
        function Fu(e, t, i) {
            return (0,
            Ye.combine)(((e,t)=>e || t), t.weakReference(), Wu(e, i).ownership())
        }
        function Hu(e, t, i) {
            const s = t.id();
            if (e.chartWidgetIdToCompletedCallbackMap.has(s))
                return;
            const o = ()=>{
                e.chartWidgetIdToCompletedCallbackMap.has(s) && (e.chartWidgetIdToCompletedCallbackMap.delete(s),
                Ku(e, i ? t : void 0))
            }
            ;
            t.model().mainSeries().dataEvents().completed().subscribe(null, o, !0),
            e.chartWidgetIdToCompletedCallbackMap.set(s, {
                cw: t,
                callback: o
            })
        }
        function zu(e) {
            Ku(e)
        }
        const Uu = new Map;
        function Gu(e) {
            var t;
            const i = null !== (t = Uu.get(e.id())) && void 0 !== t ? t : {};
            return Uu.set(e.id(), i),
            i
        }
        function ju(e, t) {
            t.timeScale().visibleBarsStrictRangeChanged().subscribe(Gu(t), zu.bind(null, e))
        }
        function qu(e, t) {
            t.timeScale().visibleBarsStrictRangeChanged().unsubscribeAll(Gu(t)),
            e.chartWidgetIdToCompletedCallbackMap.forEach((e=>{
                const t = e.cw
                  , i = e.callback;
                t.model().mainSeries().dataEvents().completed().unsubscribe(null, i)
            }
            )),
            e.chartWidgetIdToCompletedCallbackMap.clear()
        }
        function Xu(e, t, i) {
            e.model().model().gotoTimeRange(t, i),
            (0,
            Me.emit)("sync_date_range", t, i)
        }
        function Ku(e, t) {
            if (!e.dateRangeLock.value() || null !== e.currentLayoutResizeAction.value())
                return;
            const i = e.activeChartWidget.value()
              , o = i.model().mainSeries();
            if (!(0,
            ye.isTimeBasedStyle)(o.style()))
                return;
            const n = i.model().timeScale()
              , r = n.visibleBarsStrictRange();
            if (null === r)
                return;
            const a = (0,
            s.ensureNotNull)(n.points().range().value());
            let l = n.indexToTimePoint(r.firstBar());
            null === l && o.endOfData() && (l = n.indexToTimePoint(a.firstIndex));
            let c = n.indexToTimePoint(r.lastBar());
            if (null === c && (c = n.indexToTimePoint(a.lastIndex)),
            null === l || null === c)
                return void Hu(e, i, !1);
            e.chartWidgetIdToCompletedCallbackMap.delete(i.id());
            let d = 1e3 * l
              , u = 1e3 * c;
            if (o.isDWM()) {
                const e = new Date(d)
                  , t = new Date(u);
                (0,
                be.set_hms)(e, 0, 0, 0, 0),
                (0,
                be.set_hms)(t, 0, 0, 0, 0),
                d = e.getTime(),
                u = t.getTime()
            }
            for (let s = 0; s < e.chartWidgetsDefs.length; s++) {
                const o = e.chartWidgetsDefs[s].chartWidget;
                o.hasModel() && o !== i && (void 0 === t || o === t) && (0,
                ye.isTimeBasedStyle)(o.model().mainSeries().style()) && setTimeout(Xu.bind(null, o, d, u))
            }
        }
        function Yu(e) {
            const {addOnlyActiveChart: t, ...i} = e
              , s = this.innerState();
            let o = t ? this.getAll().indexOf(this.activeChartWidget.value()) : 0;
            const n = t ? o + 1 : s.chartsCountToSave()
              , r = [];
            let a;
            for (; o < n; o++) {
                const e = wd.call(this, o, i);
                if (e) {
                    let t = e;
                    {
                        const e = e=>/^study_?.*$/gim.test(e.type);
                        t = {
                            ...t,
                            panes: t.panes.map((t=>({
                                ...t,
                                sources: t.sources.map((t=>{
                                    if (e(t)) {
                                        const {metaInfo: e, metaInfo: {fullId: i, pine: s}, ...o} = t;
                                        a || (a = {});
                                        const n = `${i}${s ? `[v.${s.version}]` : ""}`;
                                        return a[n] || (a[n] = e),
                                        {
                                            ...o,
                                            metaInfo: n
                                        }
                                    }
                                    return t
                                }
                                ))
                            })))
                        }
                    }
                    r.push(t)
                }
            }
            const l = t ? void 0 : Array.from(s.allLayoutSizesState.entries()).reduce(((e,[t,i])=>(e[t] = i,
            e)), {});
            return {
                name: this.metaInfo.name.value(),
                layout: t ? "s" : s.layoutType,
                charts: r,
                symbolLock: Zu(s.symbolLock),
                intervalLock: Zu(s.intervalLock),
                trackTimeLock: Zu(s.trackTimeLock),
                dateRangeLock: Zu(s.dateRangeLock),
                crosshairLock: Zu(s.crosshairLock),
                layoutsSizes: l,
                studyMetaInfoMap: a
            }
        }
        function Zu(e) {
            return e.value() ? 1 : 0
        }
        function $u(e) {
            Fs.StudyMetaInfo.mergeDefaultsOverrides(e),
            (0,
            $a.studyMetaInfoRepository)().isReady() && Fs.StudyMetaInfo.overrideDefaults((0,
            $a.studyMetaInfoRepository)().getInternalMetaInfoArray())
        }
    }
    ,
    475268: (e,t,i)=>{
        "use strict";
        const {clone: s} = i(124829);
        var o = i(650151).assert
          , n = i(442657).layouts
          , r = i(405338).createUndoHistory
          , a = i(419283)
          , l = i(799786)
          , c = i(470316)
          , d = i(251954)
          , u = i(953297)
          , h = i(566238).WatchedObject
          , p = i(978296).WatchedValue
          , m = i(338619).getLogger("Chart.ChartWidgetCollection")
          , g = i(228609).preventDefaultForContextMenu
          , _ = i(540519)
          , v = i(161590).GeneralChartPropertiesRenderer
          , S = i(834698).CompareDialogRenderer
          , f = i(314802).isOnMobileAppPage
          , b = i(942634).Delegate;
        const {isSupportedLayout: y, tryGuessingTheMostSuitableLayout: C} = i(442657);
        var w = i(26829).CollectionViewMode
          , T = i(850775).mediaState
          , P = i(778660).SwapChartsUndoCommand
          , x = i(489935).ToastsFactory
          , M = i(271868).reconnectChartApi
          , I = i(516284).marketStatusText;
        const A = i(79342).randomHash;
        var L = i(238874)
          , E = L.applyIndicatorsToAllChartsImpl
          , k = L.applyIndicatorToAllChartsImpl
          , D = L.lineToolsAndGroupsDTOsImpl
          , N = L.resetLineToolsInvalidatedImpl
          , B = L.applyLineToolUpdateNotificationImpl
          , R = L.createClipboardHandler
          , O = L.chartsSymbolsImpl
          , V = L.updateLayoutImpl
          , W = L.computeContentBoxImpl
          , F = L.getVisuallyAdjacentDefImpl
          , H = L.setLayoutImpl
          , z = L.removeChartWidgetSubscriptionsImpl
          , U = L.generateNewChartId
          , G = L.syncCrosshairImpl
          , j = L.createBroadcastChannel
          , q = L.destroyBroadcastChannel
          , X = L.syncScrollImpl
          , K = L.allInitialModelsCreated
          , Y = L.allInitialSymbolsResolved
          , Z = L.applyThemeImpl
          , $ = L.handleDateRangeLockChange
          , J = L.handleInternalDateRangeLockChange
          , Q = L.handleTrackTimeLockChange
          , ee = L.handleInternalTrackTimeLockChange
          , te = L.handleIntervalLockChange
          , ie = L.handleInternalIntervalLockChange
          , se = L.handleSymbolLockChange
          , oe = L.handleInternalSymbolLockChange
          , ne = L.handleConnectionLimitReachedChanged
          , re = L.createLeftBottomChartWidgetWV
          , ae = L.subscribeToEventsForDateRangeSync
          , le = L.unsubscribeFromEventsForDateRangeSync
          , ce = L.syncChartsDateRangesWithActiveChartRange
          , de = L.subscribeToCompletedEventForDateRangeUpdate
          , ue = L.resetLayoutSizesImpl
          , he = L.unloadUnusedChartsImpl
          , pe = L.applyStudiesOverrides
          , me = new Map
          , ge = L.setBrokerImpl
          , _e = {
            saveChartEnabled: !0,
            takeScreenshotEnabled: !0,
            publishedChartsEnabled: !0
        };
        e.exports = function(e) {
            var t = this
              , ve = Object.assign({}, _e, e)
              , Se = new p
              , fe = ve.readOnly || !1
              , be = !1
              , ye = A()
              , Ce = []
              , we = 0
              , Te = new p
              , Pe = new p
              , xe = new p
              , Me = "s"
              , Ie = new p(null)
              , Ae = new Map
              , Le = new p([])
              , Ee = new p;
            Ee.setValue(w.ForceFullscreen);
            var ke = [];
            const De = {
                isConfirmationAboutReplayLocked: !1,
                loadingChart: !1,
                setTimeFrameActive: !1,
                setNewResolution: !1
            };
            var Ne = !1
              , Be = !1
              , Re = new p(!1)
              , Oe = new p(null)
              , Ve = new p(!1)
              , We = new p(!1);
            We.subscribe((e=>se(At(), e)));
            var Fe = new p(We.value());
            Fe.subscribe((e=>oe(At(), e)));
            var He = new p(!1);
            He.subscribe((e=>te(At(), e)));
            var ze = new p(He.value());
            ze.subscribe((e=>ie(At(), e)));
            var Ue = new p(Me)
              , Ge = new p(!1);
            Ge.subscribe((e=>Q(At(), e)));
            var je = L.combinedTrackTimeLock(Ue, Ge, Ce);
            Ge.subscribe((e=>Q(At(), e)));
            var qe = new p(je.value());
            qe.subscribe((e=>ee(At(), e)));
            var Xe = new p(!1);
            Xe.subscribe((e=>$(At(), e))),
            Ie.subscribe(oi);
            var Ke = new p(Xe.value());
            Ke.subscribe((e=>J(At(), e)));
            var Ye = new p(TVSettings.getBool("chart.syncCrosshair", !0))
              , Ze = l.createGroup({
                desc: "Layout"
            })
              , $e = null
              , Je = null
              , Qe = null
              , et = null
              , tt = null;
            if (window.TVD) {
                var it = window.TVD.crosshairSyncEnabled;
                it ? (it.value() && (et = j(At)),
                tt = it.subscribe((e=>{
                    e ? et = j(At) : (q(At()),
                    et = null)
                }
                ))) : et = j(At)
            }
            var st = Ye.value();
            Ye.subscribe((function(e) {
                st = e = !!e,
                TVSettings.setValue("chart.syncCrosshair", e);
                for (var t = 0; t < Ce.length; ++t) {
                    var i = Ce[t].chartWidget;
                    i.hasModel() && i.model().model().lightUpdate()
                }
            }
            ));
            var ot = ve.resizerBridge.width
              , nt = ve.resizerBridge.height
              , rt = new p(null)
              , at = new p(null);
            rt.subscribe((e=>{
                at.setValue(null === e ? null : e.chartWidget)
            }
            ));
            var lt = ve.widgetOptions || {}
              , ct = ve.metaInfo || {}
              , dt = {
                id: new p(ct.id || null),
                name: new p(ct.name),
                description: new p(ct.description),
                username: new p(ct.username),
                uid: new p(ct.uid),
                lastModified: new p(ct.lastModified)
            }
              , ut = r();
            ut.onChange().subscribe(null, (function(e) {
                d.emit("undo_redo_state_changed", e)
            }
            ));
            var ht = ve.resizerBridge.container.value();
            ht.addEventListener("contextmenu", g);
            var pt, mt = new b, gt = new b, _t = new b, vt = new p(!1), St = new p(null), ft = null, bt = null;
            ve.seriesControlBarEnabled && (pt = "0px",
            St.setValue(document.createElement("div")),
            St.value().style.left = pt,
            St.value().style.right = pt,
            St.value().style.bottom = pt,
            St.value().classList.add("chart-toolbar", "chart-controls-bar"),
            St.value().setAttribute("data-is-chart-toolbar-component", "true"),
            ht.appendChild(St.value()),
            Promise.all([i.e(77586), i.e(93703), i.e(49481), i.e(53953), i.e(2520), i.e(46489), i.e(75826), i.e(59258), i.e(74600), i.e(72197), i.e(97384), i.e(43362), i.e(49325), i.e(7001), i.e(17175), i.e(84353), i.e(18777), i.e(36448), i.e(98155), i.e(52388), i.e(32227), i.e(50698), i.e(47260)]).then(i.bind(i, 442389)).then((({BottomToolbarRenderer: e})=>{
                var i = ve.resizerBridge
                  , s = [i.container.spawn(), i.width.spawn(), i.height.spawn()]
                  , o = i.container.value()
                  , n = function() {
                    var e = o.getBoundingClientRect()
                      , t = W(At());
                    return t.top = e.top + t.top,
                    t.left = e.left + t.left,
                    t
                }
                  , r = new b
                  , a = function() {
                    r.fire()
                };
                s.forEach((function(e) {
                    e.subscribe(a)
                }
                ));
                var l = function() {
                    s.forEach((function(e) {
                        e.destroy()
                    }
                    )),
                    r.destroy(),
                    window.ChartApiInstance.connectionsLimitReached().unsubscribe(ne)
                };
                ft = new e(St.value(),r,n,t,ChartApiInstance,lt,ve.seriesControlBar),
                bt = function() {
                    null !== ft && (ft.destroy(),
                    ft = null,
                    St.value().remove(),
                    St.setValue(null)),
                    l()
                }
            }
            )));
            var yt = new v(t)
              , Ct = new S(t)
              , wt = null;
            function Tt() {
                vt.setValue(Ce.some((e=>{
                    const t = e.chartWidget.lineToolsSynchronizer();
                    return null !== t && t.hasChanges().value()
                }
                )))
            }
            function Pt(e) {
                return L.checkProFeatureImpl(At(), e)
            }
            wt = new x(ve.resizerBridge,(function() {
                return St.value() ? St.offsetHeight : 0
            }
            )),
            window.ChartApiInstance.connectionsLimitReached().subscribe(ne, {
                callWithLast: !0
            }),
            Oe.subscribe((()=>kt()));
            const xt = new Map
              , Mt = ()=>L.updateLinkingGroupCharts(At())
              , It = new h([]);
            function At() {
                return {
                    undoHistory: ut,
                    chartWidgetsDefs: Ce,
                    chartsCountToSave: Lt,
                    actualLayoutCount: Et,
                    savedChartWidgetOptions: ke,
                    activeChartWidget: Se,
                    options: ve,
                    parent: ht,
                    toastsFactory: wt,
                    crosshairLockRaw: st,
                    crossHairSyncBroadcast: et,
                    setChartStorageNotificationSubscription: e=>{
                        Je = e
                    }
                    ,
                    maximizedChartDef: rt,
                    setMaximized: Ht,
                    layoutTemplate: xe,
                    widthWV: ot,
                    heightWV: nt,
                    checkProFeature: Pt,
                    lineToolsSynchronizerHasChanges: vt,
                    recalcHasChanges: Tt,
                    onZoom: gt,
                    onScroll: _t,
                    layoutType: Me,
                    layoutWV: Ue,
                    setLayoutType: e=>{
                        Me = e
                    }
                    ,
                    isPhoneSize: Re,
                    viewMode: Ee,
                    updateViewMode: Ut,
                    loadingContent: Ne,
                    setLoadingContent: e=>{
                        Ne = e
                    }
                    ,
                    initialLoading: Be,
                    inlineChartsCount: Pe,
                    updateWatchedValue: Gt,
                    checkAllPendingModelsAlreadyCreated: zt,
                    readOnly: fe,
                    symbolLock: We,
                    internalSymbolLock: Fe,
                    intervalLock: He,
                    internalIntervalLock: ze,
                    dateRangeLock: Ke,
                    internalDateRangeLock: Ke,
                    trackTimeLock: Ge,
                    internalTrackTimeLock: qe,
                    crosshairLock: Ye,
                    customLegendWidgetsFactoriesMap: pi,
                    globalDetachable: Te,
                    saveChartService: $e,
                    customSources: ui,
                    updateActivityView: jt,
                    chartWidgetCreatedDelegate: mt,
                    sizingState: Oe,
                    currentLayoutResizeAction: Ie,
                    allLayoutSizesState: Ae,
                    splitters: Le,
                    widgetOptions: lt,
                    bottomToolbar: St,
                    replayContainer: hi,
                    layoutSizesChanged: Ve,
                    subscribeToCompletedEventForDateRangeSync: (e,t)=>de(At(), e, t),
                    subscribeToEventsForDateRangeSync: e=>ae(At(), e),
                    unsubscribeFromEventsForDateRangeSync: e=>le(At(), e),
                    syncChartsDateRangesWithActiveChartRange: e=>ce(At(), e),
                    combinedTrackTimeLock: je,
                    chartWidgetIdToCompletedCallbackMap: me,
                    flags: De,
                    linkingGroupsCharts: xt,
                    chartModels: It,
                    updateLinkingGroupCharts: Mt
                }
            }
            function Lt() {
                return Ce.length + ke.length
            }
            function Et() {
                return n[Me].count
            }
            function kt() {
                V(At())
            }
            ot.subscribe(kt),
            nt.subscribe(kt),
            this.updateLayout = kt;
            const Dt = L.activeLinkingGroupWV(Se)
              , Nt = L.allLinkingGroupsWV(At());
            var Bt;
            Re.setValue(!1);
            var Rt = ["phone", "phone-vertical"];
            function Ot(e, t) {
                ve.mobileForceChartMaximizeEnabled && (!Rt.includes(T.device) || t && Rt.includes(t) ? Rt.includes(T.device) || t && !Rt.includes(t) || Re.setValue(!1) : Re.setValue(!0))
            }
            function Vt() {
                if (window.is_authenticated) {
                    var e = u.enabled("app_phone");
                    !u.enabled("app_tablet") && (e || Re.value()) ? Ee.value() === w.ForceFullscreen && (Bt = rt.value(),
                    Se.value().requestFullscreen()) : Bt || (Ht(null),
                    Ut())
                }
            }
            function Wt(e) {
                return e.rdState.owner.value() !== e
            }
            function Ft(e) {
                return H.call(t, e)
            }
            function Ht(e) {
                rt.value() !== e && (rt.setValue(e),
                Ft(Me))
            }
            function zt() {
                Ce.every((e=>e.chartWidget.hasModel())) && (Gt(),
                d.emit("layout_changed"))
            }
            function Ut() {
                "s" === Me || rt.value() ? Ee.setValue(w.ForceFullscreen) : Ee.setValue(w.Multichart)
            }
            function Gt() {
                var e = Math.min(xe.value().count, Ce.length) - 1;
                if (e < 0)
                    Se.deleteValue();
                else {
                    var t = we;
                    t < 0 && (t = 0),
                    t > e && (t = e),
                    Se.setValue(Ce[t].chartWidget)
                }
            }
            function jt() {
                for (var e = Ce.length; e--; ) {
                    var t = e === we;
                    Ce[e].container.value().classList.toggle("active", t),
                    Ce[e].container.value().classList.toggle("inactive", !t)
                }
            }
            function qt(e) {
                0
            }
            function Xt(e, t) {
                return F(At(), e, t)
            }
            function Kt(e) {
                var t = Xt(Ce[we], e);
                qt(t ? t.chartWidget : Se.value()),
                t && (Se.setValue(t.chartWidget),
                rt.value() && Ft(Me))
            }
            const Yt = new b;
            function Zt(e, t) {
                var i = Ce.findIndex((function(t) {
                    return t.chartWidget === e
                }
                ))
                  , s = Ce.findIndex((function(e) {
                    return e.chartWidget === t
                }
                ));
                if (-1 === i || -1 === s)
                    throw new Error("chart is not in the layout");
                var o = Ce[i]
                  , n = Ce[s];
                Ce[i] = n,
                Ce[s] = o,
                we === i ? we = s : we === s && (we = i),
                kt(),
                Yt.fire()
            }
            var $t = new b
              , Jt = new p
              , Qt = new p([])
              , ei = null;
            function ti(e) {
                var t = e.mainSeries().properties();
                t.style.subscribe(null, ii),
                ii(t.style),
                e.model().onSelectedSourceChanged().subscribe(null, si),
                Xe.value() && (ae(At(), e),
                ce(At())),
                si(e.selection().allSources())
            }
            function ii(e) {
                Jt.setValue(e.value())
            }
            function si() {
                var e = ei.model();
                Qt.setValue(e.selection().allSources())
            }
            function oi(e) {
                Xe.value() && null === e && ce(At())
            }
            Se.subscribe((function(e) {
                if (e) {
                    for (var t, i = Ce.length; i--; )
                        if (Ce[i].chartWidget === e) {
                            t = i;
                            break
                        }
                    if (!isFinite(t))
                        throw new Error("Cannot make detached ChartWidget active");
                    if (we !== t) {
                        rt.value() && (Wt(Ce[t]) || rt.setValue(Ce[t])),
                        we = t,
                        jt();
                        for (i = Ce.length; i--; )
                            Ce[i].chartWidget !== e && Ce[i].chartWidget.setActive(!1);
                        wi(),
                        e.setActive(!0),
                        a.activePointSelectionMode.setValue(e.selectPointMode().value())
                    }
                    !function(e) {
                        if (ei !== e) {
                            if (ei && (ei.modelCreated().unsubscribe(null, ti),
                            ei.hasModel())) {
                                var t = ei.model();
                                Xe.value() && le(At(), t),
                                t.mainSeries().properties().style.unsubscribe(null, ii),
                                t.model().onSelectedSourceChanged().unsubscribe(null, si),
                                ei = null
                            }
                            e && (ei = e,
                            e.hasModel() ? ti(e.model()) : e.modelCreated().subscribe(null, ti))
                        }
                    }(e)
                }
            }
            ), {
                callWithLast: !0
            });
            var ni = new b;
            function ri() {
                ve.resizerBridge.requestFullscreen()
            }
            function ai() {
                ve.resizerBridge.exitFullscreen()
            }
            function li() {
                return ve.resizerBridge.fullscreenable
            }
            function ci() {
                return ve.resizerBridge.fullscreen
            }
            function di(e) {
                if (0 !== Ce.length) {
                    for (var t = Ce.length; t--; )
                        Ce[t].chartWidget.setActive(!1);
                    Ce[we].chartWidget.setActive(e)
                }
            }
            fe || (Ze.add({
                desc: "Switch active chart",
                hotkey: u.enabled("accessible_keyboard_shortcuts") ? c.Modifiers.Shift + 39 : 9,
                handler: function() {
                    Kt(!1)
                }
            }),
            Ze.add({
                desc: "Switch active chart",
                hotkey: u.enabled("accessible_keyboard_shortcuts") ? c.Modifiers.Shift + 37 : c.Modifiers.Shift + 9,
                handler: function() {
                    Kt(!0)
                }
            })),
            Ze.add({
                desc: "Fullscreen mode",
                hotkey: c.Modifiers.Shift + 70,
                isDisabled: u.enabled("widget") || !li().value(),
                handler: function() {
                    ci().value() ? ai() : ri()
                }
            }),
            ve.takeScreenshotEnabled && (Ze.add({
                desc: "Screenshot server",
                hotkey: c.Modifiers.Alt + 83,
                handler: L.takeServerScreenshot.bind(this, ve.snapshotUrl, t)
            }),
            f("any") || (Ze.add({
                desc: "Download client screenshot",
                hotkey: c.Modifiers.Mod + c.Modifiers.Alt + 83,
                handler: L.downloadScreenshot.bind(this, t)
            }),
            Ze.add({
                desc: "Copy client screenshot",
                hotkey: c.Modifiers.Mod + c.Modifiers.Shift + 83,
                handler: L.copyScreenshotToClipboard.bind(this, t)
            }))),
            ve.saveChartEnabled && Ze.add({
                desc: "Save Chart Layout",
                hotkey: c.Modifiers.Mod + 83,
                handler: function() {
                    $t.fire()
                }
            });
            var ui = new Map
              , hi = null
              , pi = new Map;
            const mi = R(At());
            ve.globalEvents && mi.listen();
            const gi = We.spawn()
              , _i = He.spawn()
              , vi = Xe.spawn()
              , Si = Ge.spawn()
              , fi = Ye.spawn()
              , bi = ()=>Ce.map((e=>e.chartWidget))
              , yi = re(bi, Ue.readonly(), Yt, mt);
            function Ci(e, t) {
                if (Ne = !0,
                Be = Boolean(t),
                ke.splice(0),
                e) {
                    if (e.charts || (e = {
                        layout: "s",
                        charts: [e]
                    }),
                    e.layoutsSizes)
                        for (const t of Object.keys(e.layoutsSizes))
                            Ae.set(t, e.layoutsSizes[t]);
                    var i = new Set;
                    e.charts.forEach((function(e) {
                        e.chartId && i.add(e.chartId)
                    }
                    )),
                    e.charts.forEach((function(e) {
                        if (!e.chartId) {
                            var t = U((function(e) {
                                return i.has(e)
                            }
                            ));
                            i.add(t),
                            e.chartId = t
                        }
                    }
                    ));
                    let t = e.layout;
                    if (!y(t)) {
                        const e = C(t);
                        m.logError(`Loading unsupported layout ${t}. Force migration to ${e}`),
                        t = e
                    }
                    Me = Pt(t || "s");
                    for (const t of e.charts)
                        e.studyMetaInfoMap && t.panes.forEach((t=>{
                            t.sources.forEach((t=>{
                                "string" == typeof t.metaInfo && (t.metaInfo = s(e.studyMetaInfoMap[t.metaInfo]))
                            }
                            ))
                        }
                        )),
                        ke.push({
                            content: t
                        });
                    void 0 !== e.symbolLock && We.setValue(Boolean(e.symbolLock)),
                    void 0 !== e.intervalLock && He.setValue(Boolean(e.intervalLock)),
                    void 0 !== e.trackTimeLock && Ge.setValue(Boolean(e.trackTimeLock)),
                    void 0 !== e.dateRangeLock && Xe.setValue(Boolean(e.dateRangeLock)),
                    void 0 !== e.crosshairLock && Ye.setValue(Boolean(e.crosshairLock))
                }
                Ft(Me),
                "s" === Me || ve.mobileForceChartMaximizeEnabled || Ee.setValue(w.Multichart),
                a.init(),
                a.tool.subscribe(Ti),
                a.tool.subscribe(wi),
                Ne = !1,
                Be = !1
            }
            function wi() {
                var e = Se.value();
                Ce.forEach((function(t) {
                    t.chartWidget !== e && t.chartWidget.updateCrossHairPositionIfNeeded()
                }
                )),
                e && e.updateCrossHairPositionIfNeeded()
            }
            function Ti() {
                Ce.forEach((function(e) {
                    e.chartWidget.onToolChanged()
                }
                ))
            }
            Object.assign(this, {
                innerState: At,
                getAll: bi,
                maximizedChartWidget: ()=>at.readonly(),
                leftBottomChartWidget: ()=>yi,
                activeLinkingGroup: ()=>Dt,
                allLinkingGroups: ()=>Nt,
                linkingGroupsCharts: e=>L.getLinkingGroupCharts(At(), e).readonly(),
                destroy: function() {
                    if (ni.fire(),
                    di(!1),
                    null !== bt && (bt(),
                    bt = null),
                    z(At()),
                    gi.destroy(),
                    _i.destroy(),
                    Si.destroy(),
                    vi.destroy(),
                    je.destroy(),
                    fi.destroy(),
                    Ie.unsubscribe(oi),
                    Ce.forEach((function(e) {
                        void 0 !== e.timingsMeter && e.timingsMeter.destroy(),
                        e.chartWidget.linkingGroupIndex().unsubscribe(Mt),
                        e.chartWidget.destroy()
                    }
                    )),
                    ve.resizerBridge.remove(),
                    Le.value().forEach((e=>{
                        e.mouseHandler.destroy(),
                        e.mouseListener.destroy()
                    }
                    )),
                    window.removeEventListener("resize", kt),
                    T.off("changeDevice", Ot),
                    ve.mobileForceChartMaximizeEnabled && !ve.handleMaximizedChartOnResizeDisabled && T.off("changeDevice", Vt),
                    a.tool.unsubscribe(wi),
                    a.tool.unsubscribe(Ti),
                    ht.remove(),
                    ui.clear(),
                    pi.clear(),
                    Ze.destroy(),
                    Je && Je.destroy(),
                    mi && mi.destroy(),
                    Qe && Qe.destroy(),
                    Dt.destroy(),
                    Nt.destroy(),
                    window.TVD) {
                        const e = window.TVD.crosshairSyncEnabled;
                        e && e.unsubscribe(tt),
                        q(At())
                    }
                    yi.destroy(),
                    be = !0
                },
                onAboutToBeDestroyed: ni,
                layout: Ue.readonly(),
                setLayout: Ft,
                activeChartWidget: Se,
                viewMode: Ee,
                activeChartStyle: Jt.readonly(),
                setChartStyleToWidget: L.setChartStyleToWidget.bind(this),
                selectedSources: Qt.readonly(),
                metaInfo: dt,
                state: function(e, i, s, o, n) {
                    return L.stateImpl.call(t, {
                        withData: e,
                        skipLineToolsFromOtherSymbols: i,
                        wipeSensitiveData: s,
                        skipLineTools: o,
                        addOnlyActiveChart: n
                    })
                },
                lineToolsAndGroupsDTOs: function() {
                    return D(At())
                },
                resetLineToolsInvalidated: function(e, t) {
                    return N(At(), e, t)
                },
                applyLineToolUpdateNotification: B.bind(null, Ce),
                readOnly: function() {
                    return fe
                },
                onZoom: function() {
                    return gt
                },
                onScroll: function() {
                    return _t
                },
                resizerBridge: function() {
                    return ve.resizerBridge
                },
                lock: {
                    symbol: gi,
                    interval: _i,
                    dateRange: vi,
                    crosshair: fi,
                    trackTime: Si
                },
                setSymbol: (e,t,i)=>L.setSymbol(At(), e, t, i),
                setSymbolAll: e=>L.setSymbolAll(At(), e),
                setResolution: (e,t,i)=>L.setResolution(At(), e, t, i),
                setTimeFrame: function(e) {
                    De.loadingChart || De.setTimeFrameActive || (De.setTimeFrameActive = !0,
                    He.value() ? Ce.forEach((function(t) {
                        t.chartWidget.loadRange(e)
                    }
                    )) : Se.value().loadRange(e),
                    De.setTimeFrameActive = !1)
                },
                updateLayout: kt,
                setChartLayoutWithUndo: function(e) {
                    return L.setChartLayoutWithUndoImpl(At(), this, e)
                },
                images: L.getSnapshot.bind(this, this, ve.widgetOptions.customerReadableName, lt.onWidget),
                clientSnapshot: L.getClientSnapshot.bind(this, this, ve.widgetOptions.customerReadableName, lt.onWidget),
                tags: function() {
                    for (var e = [], t = 0; t < Ce.length && t < xe.value().count; t++)
                        e = e.concat(Ce[t].chartWidget.tags());
                    return e = (e = Array.from(new Set(e))).map((function(e) {
                        return e.toLowerCase().replace(/\W+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "")
                    }
                    ))
                },
                syncCrosshair: (e,t,i,s)=>G(At(), e, t, i, s),
                syncScroll: function(e, t) {
                    return X(At(), e, t)
                },
                clearChartMetaInfo: function() {
                    dt.id.setValue(null),
                    dt.uid.setValue(void 0),
                    dt.name.setValue(void 0)
                },
                takeScreenshot: L.takeScreenshot.bind(this, ve.snapshotUrl, this),
                takeServerScreenshot: L.takeServerScreenshot.bind(this, ve.snapshotUrl, this),
                loadContent: Ci,
                purgeUnusedWidgets: function() {
                    for (var e = n[Me].count; e < Ce.length; e++)
                        Ce[e].chartWidget.destroy();
                    Ce.splice(n[Me].count)
                },
                applyOverrides: function(e) {
                    for (var t = 0; t < Ce.length; t++)
                        Ce[t].chartWidget.applyOverrides(e)
                },
                applyStudiesOverrides: pe,
                switchChart: Kt,
                startFullscreen: ri,
                exitFullscreen: ai,
                fullscreen: ci,
                fullscreenable: li,
                chartWidgetCreated: function() {
                    return mt
                },
                saveKeysPressed: function() {
                    return $t
                },
                getContainer: function() {
                    return ht
                },
                onWidget: lt.onWidget,
                applyTheme: function(e) {
                    return Z(At(), t, e)
                },
                applyIndicatorsToAllCharts: function(e) {
                    E(At(), e)
                },
                applyIndicatorsToAllChartsAvailable: function() {
                    return !fe && Et() > 1
                },
                applyIndicatorToAllCharts: async function(e, t, i, s) {
                    await k(At(), e, t, i, s)
                },
                setActive: di,
                inlineChartsCount: Pe.readonly(),
                revertToInline: function() {
                    if (!Re.value() || Ee.value() !== w.ForceFullscreen) {
                        Ht(null);
                        for (var e = 0; e < Ce.length; e++)
                            Ce[e].rdState.bridge().attach()
                    }
                },
                chartMarketStatuses: function() {
                    return Ce.map((function(e) {
                        var t = e.chartWidget.hasModel() ? e.chartWidget.model().mainSeries().marketStatusModel() : null;
                        return null !== t ? I(t.status()) : "-"
                    }
                    ))
                },
                chartSeriesStatuses: function() {
                    return Ce.map((function(e) {
                        var t = e.chartWidget.hasModel() ? e.chartWidget.model().mainSeries().status() : null;
                        return (null === t ? "" : _.SERIES_STATUS_TEXT[t]) + " (" + t + ")"
                    }
                    ))
                },
                undoHistory: ut,
                lineToolsSynchronizerHasChanges: vt,
                applyPreferencesToAllCharts: function(e) {
                    var t = e.model().preferences();
                    Ce.forEach((function(i) {
                        i.chartWidget._model !== e && i.chartWidget._model.applyPreferences(t)
                    }
                    ))
                },
                getToasts: function() {
                    return wt.getChartToasts()
                },
                addCustomSource: function(e, t, i) {
                    o(!ui.has(e), "Cannot create the same custom source multiple times"),
                    ui.set(e, {
                        factory: t,
                        layer: i
                    });
                    for (var s = 0; s < Ce.length; ++s) {
                        var n = Ce[s].chartWidget;
                        n.hasModel() && n.model().model().addCustomSource(e, t, i)
                    }
                },
                removeCustomSource: function(e) {
                    o(ui.has(e), "Cannot remove not created custom source"),
                    ui.delete(e);
                    for (var t = 0; t < Ce.length; ++t) {
                        var i = Ce[t].chartWidget;
                        i.hasModel() && i.model().model().removeCustomSource(e)
                    }
                },
                addCustomWidgetToLegend: function(e, t) {
                    o(!pi.has(e), "Cannot create the same custom widget in legend multiple times"),
                    pi.set(e, t);
                    for (var i = 0; i < Ce.length; ++i)
                        Ce[i].chartWidget.addCustomWidgetToLegend(e, t)
                },
                addReplayWidget: function(e) {
                    o(null === hi, "Cannot create replay container multiple times"),
                    (hi = document.createElement("div")).style.position = "absolute",
                    hi.style["min-height"] = "51px",
                    hi.style.overflow = "hidden",
                    hi.style.left = "0px",
                    hi.style.right = "0px";
                    var t = null === St.value() ? 0 : St.value().offsetHeight;
                    hi.style.bottom = `${t}px`,
                    hi.setAttribute("data-is-chart-toolbar-component", "true"),
                    ht.prepend(hi),
                    e(hi, (()=>kt())),
                    kt()
                },
                destroyReplayWidget: function() {
                    o(null !== hi, "Cannot remove replay container, container is not created"),
                    hi.remove(),
                    hi = null,
                    kt()
                },
                setViewMode: function(e) {
                    Ee.setValue(e)
                },
                moveActiveChartWithUndo: function(e) {
                    var t = Ce[we]
                      , i = Xt(t, e);
                    i && ut.pushUndoCommand(new P(Zt,t.chartWidget,i.chartWidget))
                },
                activeChartCanBeMoved: function() {
                    return !(fe || Pe.value() < 2 || Wt(Ce[we]))
                },
                generalPropertiesDefinitions: function() {
                    return Se.value().generalPropertiesDefinitions()
                },
                reconnectChartApi: function(e) {
                    M(e)
                },
                setBroker: function(e) {
                    ge(At(), e)
                },
                setSaveChartService: function(e) {
                    $e = e;
                    for (var t = 0; t < Ce.length; ++t) {
                        Ce[t].chartWidget.setSaveChartService(e)
                    }
                },
                getCompareDialogRenderer: function() {
                    return Ct
                },
                getChartPropertiesDialogRenderer: function() {
                    return yt
                },
                clipboard: mi,
                chartsSymbols: function() {
                    return O(At())
                },
                resetLayoutSizes: ue.bind(null, At()),
                unloadUnusedCharts: he.bind(null, At()),
                layoutSizesChanged: ()=>Ve,
                clientId: ye,
                ariaDescribeChart: qt,
                chartModels: ()=>It.readonly()
            }),
            L.createChartStorageSubscriptionsIfRequired(this, At()),
            Ci(ve.content, !0),
            L.createChartWidgetCollectionNewsNotifier(this, At()).then((e=>{
                be || (Qe = e)
            }
            )),
            Ue.subscribe((function() {
                jt()
            }
            )),
            Ue.hook = function(e) {
                return e === this.value() ? e : Pt(e)
            }
            ,
            fe && (Ue.writeLock = !0),
            window.addEventListener("resize", kt),
            ve.mobileForceChartMaximizeEnabled && (T.on("changeDevice", Ot),
            ve.handleMaximizedChartOnResizeDisabled || T.on("changeDevice", Vt),
            Ot(),
            Vt());
            var Pi = 0;
            function xi() {
                0 === --Pi && d.emitOnce("onChartReady")
            }
            Ce.forEach((function(e) {
                if (e) {
                    Pi++;
                    var t = e.chartWidget;
                    t.withModel(null, (function() {
                        ve.metaInfo && t.model().model().setChartSaveTime(1e3 * ve.metaInfo.lastModified);
                        var e = t.model().mainSeries();
                        if (e.bars().size() > 0 || e.isFailed())
                            xi();
                        else {
                            var i = e.dataEvents()
                              , s = function() {
                                xi(),
                                i.barReceived().unsubscribe(null, s),
                                i.completed().unsubscribe(null, s),
                                i.error().unsubscribe(null, s),
                                i.unsupportedResolutionRequested().unsubscribe(null, s)
                            };
                            i.barReceived().subscribe(null, s),
                            i.completed().subscribe(null, s),
                            i.error().subscribe(null, s),
                            i.unsupportedResolutionRequested().subscribe(null, s)
                        }
                    }
                    ))
                }
            }
            )),
            K(At()).then(Y).then((function() {
                window.saver && window.is_authenticated && ve.widgetOptions.justCloned && window.saver.saveChartSilently()
            }
            )).catch(m.logError.bind(m))
        }
    }
    ,
    558150: (e,t,i)=>{
        "use strict";
        i.d(t, {
            clientSnapshot: ()=>I,
            widgetClientSnapshot: ()=>L
        });
        var s, o, n = i(327714), r = i(650151), a = i(86441), l = i(724377), c = i(61499), d = i(828473), u = i(631088), h = i(511275), p = i(694852), m = i(308721), g = i(287489), _ = (i(953297),
        i(776351));
        const v = Boolean(null === (o = null === (s = window.initData) || void 0 === s ? void 0 : s.logo) || void 0 === o ? void 0 : o.no_powered_by);
        function S(e, t=null, i=null) {
            let s = {};
            if ("number" == typeof e)
                return {
                    relativePositions: {
                        [e]: {
                            l: t,
                            t: i
                        }
                    },
                    nextElementLeft: e,
                    nextElementTop: e
                };
            const [o,...n] = e;
            if ("v" === o) {
                let e = null;
                for (const o of n) {
                    const n = S(o, t, i);
                    s = {
                        ...s,
                        ...n.relativePositions
                    },
                    i = n.nextElementTop,
                    e = n.nextElementLeft
                }
                t = e
            }
            if ("h" === o) {
                let e = null;
                for (const o of n) {
                    const n = S(o, t, i);
                    s = {
                        ...s,
                        ...n.relativePositions
                    },
                    t = n.nextElementLeft,
                    e = n.nextElementTop
                }
                i = e
            }
            return {
                relativePositions: s,
                nextElementTop: i,
                nextElementLeft: t
            }
        }
        const f = function(e) {
            const t = {};
            for (const i of Object.keys(e)) {
                const s = S(e[i]).relativePositions;
                t[i] = s
            }
            return t
        }(g);
        function b(e, t, i, s) {
            let o = Math.round(10 * s)
              , n = Math.round(10 * s);
            const r = i[e];
            if (null !== r.l) {
                const e = b(r.l, t, i, s);
                o = e.x + e.width + Math.round(5 * s)
            }
            if (null !== r.t) {
                const e = b(r.t, t, i, s);
                n = e.y + e.height + Math.round(5 * s)
            }
            const a = t[e];
            return {
                x: o,
                y: n,
                width: a.width,
                height: a.height
            }
        }
        function y(e, t, i) {
            var s;
            const o = (new DOMParser).parseFromString(_, "image/svg+xml");
            null === (s = null == o ? void 0 : o.firstElementChild) || void 0 === s || s.setAttribute("color", i);
            const n = URL.createObjectURL(new Blob([(new XMLSerializer).serializeToString(o)],{
                type: "image/svg+xml"
            }));
            return new Promise((i=>{
                const s = new Image;
                s.width = e,
                s.height = t,
                s.onload = ()=>{
                    i({
                        image: s,
                        width: e,
                        height: t
                    })
                }
                ,
                s.src = n
            }
            ))
        }
        function C(e, t, i, s, o) {
            e.save(),
            e.drawImage(s.image, t, i, s.width, s.height),
            e.textBaseline = "bottom";
            const n = (t + s.width) / o + 3
              , r = (i + s.height) / o;
            (0,
            u.drawScaled)(e, o, o, (()=>{
                e.fillText("TradingView", n, r)
            }
            )),
            e.restore()
        }
        function w(e, t, i, s) {
            return (0,
            u.drawScaled)(e, s, s, (()=>{
                e.fillText(i, t.x / s, t.y / s)
            }
            )),
            e.measureText(i).width * s
        }
        function T(e, t, i, s, o, n) {
            const r = o.map((e=>e.text)).join("");
            let l = i.x;
            const c = function(e, t, i, s) {
                if (e.measureText(t).width * s <= i)
                    return {
                        text: t,
                        elided: !1
                    };
                const o = e.measureText("...").width * s
                  , n = [];
                for (let e = 0; e < t.length; ++e)
                    n.push(e);
                const r = (0,
                d.upperbound)(n, i, ((n,r)=>e.measureText(t.slice(0, r + 1)).width * s + o > i));
                return {
                    text: (t = t.slice(0, r)).trim(),
                    elided: !0
                }
            }(e, r, s - l, t);
            if (c.elided && !n)
                return null;
            const u = [];
            let h = 0;
            for (const e of o) {
                if (h + e.text.length > c.text.length)
                    break;
                u.push(e.text),
                h += e.text.length
            }
            const p = u.join("").trim().length;
            h = 0;
            for (const s of o) {
                if (h + s.text.length > p)
                    break;
                s.color && (e.save(),
                e.fillStyle = s.color),
                l += w(e, new a.Point(l,i.y), s.text, t),
                s.color && e.restore(),
                h += s.text.length
            }
            return c.elided && (l += w(e, new a.Point(l,i.y), "...", t)),
            l
        }
        function P(e) {
            return e.map((e=>({
                ...e,
                title: ""
            })))
        }
        function x(e, t) {
            const i = [{
                text: e.trim()
            }];
            for (const e of t)
                e.visible && ("" !== i[i.length - 1].text && i.push({
                    text: "  "
                }),
                e.title && i.push({
                    text: e.title
                }),
                i.push({
                    text: e.value,
                    color: e.color
                }));
            return i
        }
        class M {
            constructor(e, t) {
                this._logoTextColor = null,
                this._snapshotData = e,
                t = t || {},
                this._options = {
                    backgroundColor: m.themes[e.theme].getThemedColor("color-bg-primary"),
                    borderColor: m.themes[e.theme].getThemedColor("color-border"),
                    font: h.CHART_FONT_FAMILY,
                    fontSize: 12,
                    legendMode: "vertical",
                    hideResolution: !1,
                    hideStudiesFromLegend: !1,
                    showHeaderPublishedBy: !1,
                    showHeaderMainSymbol: !1,
                    ...t
                };
                const i = f[e.layout]
                  , s = e.charts.map((e=>function(e) {
                    const t = e.panes[0]
                      , i = t.canvas.width + t.leftAxis.canvas.width + t.rightAxis.canvas.width;
                    let s = 0;
                    for (const t of e.panes)
                        s += t.canvas.height;
                    return void 0 !== e.timeAxis && 0 !== e.timeAxis.contentHeight && (s += e.timeAxis.canvas.height),
                    (0,
                    n.size)({
                        width: i,
                        height: s
                    })
                }(e)));
                if (this._pixelRatio = e.hidpiRatio,
                this._chartsGeometry = e.charts.map(((e,t)=>b(t, s, i, this._pixelRatio))),
                !v) {
                    let i = e.theme;
                    void 0 !== t.backgroundColor && (i = "black" === (0,
                    l.rgbToBlackWhiteString)((0,
                    l.parseRgb)(t.backgroundColor), 150) ? c.StdTheme.Dark : c.StdTheme.Light),
                    this._logoTextColor = m.themes[i].getThemedColor("color-text-primary")
                }
                this._headerDefaultTextColor = m.themes[e.theme].getThemedColor("color-text-primary")
            }
            async getImage() {
                const e = this._pixelRatio;
                let t = 0
                  , i = 0
                  , s = 0;
                const o = this._headerItems();
                if (o.length > 0) {
                    s = Math.ceil(1.4 * this._options.fontSize * e) * o.length
                }
                i += s;
                let r = 0
                  , l = 0;
                for (const e of this._chartsGeometry)
                    r = Math.max(r, e.x + e.width),
                    l = Math.max(l, e.y + e.height);
                const c = i;
                t += r,
                i += l,
                t += Math.round(10 * e);
                const d = v ? Math.round(10 * e) : Math.round(35 * e)
                  , m = i;
                i += d;
                const g = (0,
                u.createDisconnectedCanvas)(document, (0,
                n.size)({
                    width: t,
                    height: i
                }), 1)
                  , _ = (0,
                u.getContext2D)(g);
                _.font = (0,
                p.makeFont)(this._options.fontSize, this._options.font),
                _.textBaseline = "top",
                _.fillStyle = this._options.backgroundColor,
                _.fillRect(0, 0, t, i),
                o.length > 0 && this._drawHeader(_, o, t, new a.Point(Math.round(10 * e),Math.round(10 * e)));
                for (let e = 0; e < this._snapshotData.charts.length; ++e) {
                    const t = this._snapshotData.charts[e]
                      , i = this._chartsGeometry[e];
                    this._drawChart(t, i, _, new a.Point(0,c))
                }
                if (null !== this._logoTextColor) {
                    const t = await y(Math.round(20 * e), Math.round(15 * e), this._logoTextColor);
                    _.fillStyle = this._logoTextColor,
                    _.font = (0,
                    p.makeFont)(13, h.CHART_FONT_FAMILY);
                    const i = m + Math.round(d / 2 - t.height / 2);
                    C(_, Math.round(10 * e), i, t, e)
                }
                return g
            }
            _drawChart(e, t, i, s) {
                i.save(),
                i.translate(t.x + s.x, t.y + s.y);
                let o = 0;
                for (const t of e.panes) {
                    let s = 0;
                    const n = t.leftAxis.canvas.width + Math.round(8 * this._pixelRatio)
                      , r = o
                      , l = o + Math.round(10 * this._pixelRatio);
                    t.leftAxis.contentWidth > 0 && t.leftAxis.contentHeight > 0 && (i.drawImage(t.leftAxis.canvas, s, o),
                    s += t.leftAxis.canvas.width),
                    i.drawImage(t.canvas, s, o),
                    s += t.canvas.width,
                    t.rightAxis.contentWidth > 0 && t.rightAxis.contentHeight > 0 && i.drawImage(t.rightAxis.canvas, s, o),
                    "pane" === t.type && (i.fillStyle = e.colors.text,
                    this._drawLegend(t, i, new a.Point(n,l), r)),
                    o += t.canvas.height
                }
                if (void 0 !== e.timeAxis && 0 !== e.timeAxis.contentHeight) {
                    let t = 0;
                    e.timeAxis.lhsStub.contentWidth > 0 && e.timeAxis.lhsStub.contentHeight > 0 && (i.drawImage(e.timeAxis.lhsStub.canvas, t, o),
                    t += e.timeAxis.lhsStub.canvas.width),
                    i.drawImage(e.timeAxis.canvas, t, o),
                    t += e.timeAxis.canvas.width,
                    e.timeAxis.rhsStub.contentWidth > 0 && e.timeAxis.rhsStub.contentHeight > 0 && i.drawImage(e.timeAxis.rhsStub.canvas, t, o)
                }
                i.strokeStyle = this._options.borderColor,
                i.strokeRect(0, 0, t.width, t.height),
                i.restore()
            }
            _headerItems() {
                var e, t, i, s;
                const o = [];
                if (this._options.showHeaderPublishedBy && this._snapshotData.publishedBy)
                    for (const e of this._snapshotData.publishedBy)
                        o.push([{
                            text: e
                        }]);
                if (this._options.showHeaderMainSymbol) {
                    const n = this._snapshotData.charts[0]
                      , r = `${null === (e = n.meta) || void 0 === e ? void 0 : e.symbol}, ${null === (t = n.meta) || void 0 === t ? void 0 : t.resolution}`;
                    o.push(x(r, null !== (s = null === (i = n.meta) || void 0 === i ? void 0 : i.values) && void 0 !== s ? s : []))
                }
                return o
            }
            _drawHeader(e, t, i, s) {
                e.save(),
                e.fillStyle = this._headerDefaultTextColor;
                const o = Math.ceil(1.4 * this._options.fontSize * this._pixelRatio);
                t.forEach(((t,n)=>{
                    T(e, this._pixelRatio, new a.Point(s.x,s.y + o * n), i, t, !0)
                }
                )),
                e.restore()
            }
            _drawLegend(e, t, i, s) {
                let o = !0;
                const n = Math.ceil(1.4 * this._options.fontSize * this._pixelRatio);
                let l = i.x
                  , c = i.y;
                if (e.mainSeriesText && c + n < s + e.canvas.height) {
                    const i = T(t, this._pixelRatio, new a.Point(l,c), e.contentWidth * this._pixelRatio, x(e.mainSeriesText, e.mainSeriesValues), !0);
                    "horizontal" !== this._options.legendMode ? c += n : (l = (0,
                    r.ensureNotNull)(i) + 1.4 * this._options.fontSize * this._pixelRatio,
                    o = !1)
                }
                for (let r = 0; r < e.studies.length; ++r)
                    if (c + n < s + e.canvas.height) {
                        const s = e.studies[r]
                          , d = e.studiesValues[r];
                        let u = null;
                        for (; null === u; )
                            u = T(t, this._pixelRatio, new a.Point(l,c), e.contentWidth * this._pixelRatio, this._options.hideStudiesFromLegend ? [] : x(s, P(d)), o),
                            "horizontal" !== this._options.legendMode ? c += n : null === u ? (o = !0,
                            l = i.x,
                            c += n) : (l = u + 1.4 * this._options.fontSize * this._pixelRatio,
                            o = !1)
                    }
            }
        }
        async function I(e, t) {
            return new M(e,t).getImage()
        }
        class A {
            constructor(e, t) {
                if (this._logoTextColor = null,
                this._widgetSnapshot = e,
                t = t || {},
                this._options = {
                    backgroundColor: m.themes[e.theme].getThemedColor("color-bg-primary"),
                    borderColor: m.themes[e.theme].getThemedColor("color-border"),
                    font: h.CHART_FONT_FAMILY,
                    fontSize: 12,
                    showHeaderPublishedBy: !0,
                    ...t
                },
                this._pixelRatio = e.hidpiRatio,
                !v) {
                    let i = e.theme;
                    void 0 !== t.backgroundColor && (i = "black" === (0,
                    l.rgbToBlackWhiteString)((0,
                    l.parseRgb)(t.backgroundColor), 150) ? c.StdTheme.Dark : c.StdTheme.Light),
                    this._logoTextColor = m.themes[i].getThemedColor("color-text-primary")
                }
                this._headerDefaultTextColor = m.themes[e.theme].getThemedColor("color-text-primary")
            }
            async getImage() {
                const e = this._pixelRatio
                  , t = Math.round(10 * e);
                let i = 0
                  , s = 0
                  , o = 0;
                const r = this._headerItems();
                if (r.length > 0) {
                    o = Math.ceil(1.4 * this._options.fontSize * e) * r.length
                }
                s += o;
                const l = s
                  , c = this._widgetSnapshot.canvas.width
                  , d = this._widgetSnapshot.canvas.height;
                i += c + 2 * t,
                s += d + t;
                const m = Math.round(35 * e)
                  , g = s;
                s += m;
                const _ = (0,
                u.createDisconnectedCanvas)(document, (0,
                n.size)({
                    width: i,
                    height: s
                }), 1)
                  , v = (0,
                u.getContext2D)(_);
                if (v.font = (0,
                p.makeFont)(this._options.fontSize, this._options.font),
                v.textBaseline = "top",
                v.fillStyle = this._options.backgroundColor,
                v.fillRect(0, 0, i, s),
                r.length > 0 && this._drawHeader(v, r, i, new a.Point(t,t)),
                v.drawImage(this._widgetSnapshot.canvas, t, t + l),
                v.strokeStyle = this._options.borderColor,
                v.strokeRect(t, t + l, c, d),
                null !== this._logoTextColor) {
                    const i = await y(Math.round(20 * e), Math.round(15 * e), this._logoTextColor);
                    v.fillStyle = this._logoTextColor,
                    v.font = (0,
                    p.makeFont)(13, h.CHART_FONT_FAMILY);
                    C(v, t, g + Math.round(m / 2 - i.height / 2), i, e)
                }
                return _
            }
            _headerItems() {
                const e = [];
                if (this._options.showHeaderPublishedBy && this._widgetSnapshot.publishedBy)
                    for (const t of this._widgetSnapshot.publishedBy)
                        e.push([{
                            text: t
                        }]);
                return e
            }
            _drawHeader(e, t, i, s) {
                e.save(),
                e.fillStyle = this._headerDefaultTextColor;
                const o = Math.ceil(1.4 * this._options.fontSize * this._pixelRatio);
                t.forEach(((t,n)=>{
                    T(e, this._pixelRatio, new a.Point(s.x,s.y + o * n), i, t, !0)
                }
                )),
                e.restore()
            }
        }
        async function L(e, t) {
            return new A(e,t).getImage()
        }
    }
    ,
    621452: (e,t,i)=>{
        "use strict";
        i.r(t),
        i.d(t, {
            ContextMenuManager: ()=>s
        });
        var s, o = i(828473), n = i(691371), r = i(224743);
        !function(e) {
            let t = null
              , s = null;
            const a = []
              , l = {
                createAction: e=>new n.Action({
                    actionId: "Chart.CustomActionId",
                    options: e
                }),
                createAsyncAction: e=>new n.Action({
                    actionId: "Chart.CustomActionId",
                    options: {},
                    optionsLoader: e
                }),
                createSeparator: ()=>new n.Separator
            };
            async function c(e, n={}, r={
                menuName: ""
            }, c) {
                null !== t && (e = await t(e, l, r));
                let u = null;
                const h = ()=>{
                    const e = (0,
                    o.indexOf)(a, (e=>e.renderer === u));
                    -1 !== e && a.splice(e, 1),
                    void 0 !== c && c()
                }
                ;
                let p = !1;
                if (null !== s && (u = await s(e, r, h)),
                u)
                    p = !0,
                    d();
                else {
                    const t = await Promise.all([i.e(19966), i.e(53953), i.e(29800), i.e(46489), i.e(23141), i.e(75826), i.e(7001), i.e(71329), i.e(44066), i.e(5463), i.e(1198), i.e(32227), i.e(90656), i.e(91584)]).then(i.bind(i, 977957));
                    u = new t.ContextMenuRenderer(e,n,h,d)
                }
                return a.push({
                    renderer: u,
                    isExternal: p
                }),
                u
            }
            function d() {
                (0,
                r.globalCloseMenu)(),
                a.forEach((e=>{
                    e.isExternal && e.renderer.isShown() && e.renderer.hide()
                }
                ))
            }
            e.createMenu = c,
            e.showMenu = function(e, t, i={}, s, o) {
                return c(e, i, s, o).then((e=>e.show(t)))
            }
            ,
            e.setCustomRendererFactory = function(e) {
                s = e
            }
            ,
            e.setCustomItemsProcessor = function(e) {
                t = e
            }
            ,
            e.hideAll = d,
            e.getShown = function() {
                for (let e = 0; e < a.length; e++)
                    if (a[e].renderer.isShown())
                        return a[e].renderer;
                return null
            }
        }(s || (s = {}))
    }
    ,
    33052: (e,t,i)=>{
        "use strict";
        var s;
        i.d(t, {
            TabNames: ()=>s
        }),
        function(e) {
            e.background = "Background",
            e.coordinates = "Coordinates",
            e.drawings = "Drawings",
            e.events = "Events",
            e.eventsAndAlerts = "Events & Alerts",
            e.inputs = "Inputs",
            e.properties = "Properties",
            e.scales = "Scales",
            e.legend = "Legend",
            e.sourceCode = "Source Code",
            e.style = "Style",
            e.symbol = "Symbol",
            e.timezoneSessions = "Timezone/Sessions",
            e.trading = "Trading",
            e.visibility = "Visibility",
            e.text = "Text"
        }(s || (s = {}))
    }
    ,
    109436: (e,t,i)=>{
        "use strict";
        i.d(t, {
            getPriceAxisNameInfo: ()=>r
        });
        const s = ["Z", "Y", "X", "W", "V", "U", "T", "S"]
          , o = ["A", "B", "C", "D", "E", "F", "G", "H"];
        class n {
            constructor(e) {
                this.label = e
            }
            equals(e) {
                return null !== e && this.label === e.label
            }
        }
        function r(e, t) {
            const i = "left" === e ? s : o;
            return new n(t < i.length ? i[t] : "")
        }
    }
    ,
    689010: (e,t,i)=>{
        "use strict";
        i.d(t, {
            KineticAnimation: ()=>r
        });
        var s = i(650151);
        function o(e, t) {
            return e.position - t.position
        }
        function n(e, t, i) {
            const s = (e.position - t.position) / (e.time - t.time);
            return Math.sign(s) * Math.min(Math.abs(s), i)
        }
        class r {
            constructor(e, t, i, s) {
                this._position1 = null,
                this._position2 = null,
                this._position3 = null,
                this._position4 = null,
                this._animationStartPosition = null,
                this._durationMsecs = 0,
                this._speedPxPerMsec = 0,
                this._minSpeed = e,
                this._maxSpeed = t,
                this._dumpingCoeff = i,
                this._minMove = s
            }
            addPosition(e, t) {
                if (null !== this._position1) {
                    if (this._position1.time === t)
                        return void (this._position1.position = e);
                    if (Math.abs(this._position1.position - e) < this._minMove)
                        return
                }
                this._position4 = this._position3,
                this._position3 = this._position2,
                this._position2 = this._position1,
                this._position1 = {
                    time: t,
                    position: e
                }
            }
            start(e, t) {
                if (null === this._position1 || null === this._position2)
                    return;
                if (t - this._position1.time > 50)
                    return;
                let i = 0;
                const s = n(this._position1, this._position2, this._maxSpeed)
                  , r = o(this._position1, this._position2)
                  , a = [s]
                  , l = [r];
                if (i += r,
                null !== this._position3) {
                    const e = n(this._position2, this._position3, this._maxSpeed);
                    if (Math.sign(e) === Math.sign(s)) {
                        const t = o(this._position2, this._position3);
                        if (a.push(e),
                        l.push(t),
                        i += t,
                        null !== this._position4) {
                            const e = n(this._position3, this._position4, this._maxSpeed);
                            if (Math.sign(e) === Math.sign(s)) {
                                const t = o(this._position3, this._position4);
                                a.push(e),
                                l.push(t),
                                i += t
                            }
                        }
                    }
                }
                let c = 0;
                for (let e = 0; e < a.length; ++e)
                    c += l[e] / i * a[e];
                Math.abs(c) < this._minSpeed || (this._animationStartPosition = {
                    position: e,
                    time: t
                },
                this._speedPxPerMsec = c,
                this._durationMsecs = function(e, t) {
                    const i = Math.log(t);
                    return Math.log(1 * i / -e) / i
                }(Math.abs(c), this._dumpingCoeff))
            }
            getStartPosition() {
                return (0,
                s.ensureNotNull)(this._animationStartPosition).position
            }
            getPosition(e) {
                const t = (0,
                s.ensureNotNull)(this._animationStartPosition)
                  , i = e - t.time;
                return t.position + this._speedPxPerMsec * (Math.pow(this._dumpingCoeff, i) - 1) / Math.log(this._dumpingCoeff)
            }
            finished(e) {
                return null === this._animationStartPosition || this._progressDuration(e) === this._durationMsecs
            }
            _progressDuration(e) {
                const t = e - (0,
                s.ensureNotNull)(this._animationStartPosition).time;
                return Math.min(t, this._durationMsecs)
            }
        }
    }
    ,
    189436: (e,t,i)=>{
        "use strict";
        i.d(t, {
            icons: ()=>o
        });
        var s = i(266621);
        const o = [{
            icon: "🔶",
            label: s.t(null, void 0, i(132407))
        }, {
            icon: "🍀",
            label: s.t(null, void 0, i(820079))
        }, {
            icon: "💧",
            label: s.t(null, void 0, i(69608))
        }, {
            icon: "❤️",
            label: s.t(null, void 0, i(857618))
        }, {
            icon: "💩",
            label: s.t(null, void 0, i(842344))
        }]
    }
    ,
    851063: (e,t,i)=>{
        "use strict";
        i.d(t, {
            createLayout: ()=>a,
            layoutInitialSizingState: ()=>c
        });
        var s = i(569708)
          , o = i(154834)
          , n = i(650151);
        function r(e, t, i) {
            const s = new Set;
            if ("number" == typeof e)
                return s.add(e),
                {
                    indices: s,
                    smallestIndex: e,
                    sizer: e=>e,
                    splitters: ()=>[],
                    resizeApplier: (e,t,i,s,o)=>o,
                    syncSublayoutsBySplitter: (e,t)=>t
                };
            const a = e[0]
              , l = e.slice(1).map((e=>r(e, t)));
            let c = 1 / 0;
            for (const e of l)
                for (const t of Array.from(e.indices))
                    t < c && (c = t),
                    s.add(t);
            const d = (e,t,i,s,o,n,r,a)=>{
                const l = "h" === r ? e.width : e.height;
                let c, d, u;
                if (a) {
                    const e = t * i + s * l;
                    c = Math.round(e),
                    d = t === n - 1 ? l - c : Math.round(e + o * l) - c
                } else {
                    const e = (l - (n - 1) * i) / n
                      , s = t * (e + i);
                    c = Math.round(s),
                    d = Math.round(s + e) - c
                }
                return u = "h" === r ? {
                    top: e.top,
                    left: e.left + c,
                    height: e.height,
                    width: d
                } : {
                    top: e.top + c,
                    left: e.left,
                    height: d,
                    width: e.width
                },
                u
            }
              , u = (e,t,i,s,o,n,r)=>{
                if ("number" == typeof i)
                    return [];
                const a = i[0]
                  , l = i.slice(1);
                return l.reduce(((i,c,h)=>{
                    var p;
                    const m = null == r ? void 0 : r[h]
                      , g = null !== (p = null == m ? void 0 : m.percent) && void 0 !== p ? p : 1 / l.length
                      , _ = d(e, h, t, i.sumOfCoeffsBefore, g, l.length, a, r)
                      , v = i.sumOfCoeffsBefore + g;
                    if (h < l.length - 1) {
                        const e = `${n}-${s}-${h}-${a}`;
                        let t;
                        t = "v" === a ? {
                            left: _.left,
                            top: _.top + _.height - 6 + 1,
                            width: _.width,
                            height: 12
                        } : {
                            left: _.left + _.width - 6 + 1,
                            top: _.top,
                            width: 12,
                            height: _.height
                        };
                        const r = {
                            level: s,
                            orientation: a,
                            indexes: [...o, h],
                            metrics: t,
                            className: e
                        };
                        i.splitters.push(r)
                    }
                    return Array.isArray(c) ? {
                        splitters: i.splitters.concat(u(_, t, c, s + 1, [...o, h], n, null == m ? void 0 : m.substate)),
                        sumOfCoeffsBefore: v
                    } : {
                        splitters: i.splitters,
                        sumOfCoeffsBefore: v
                    }
                }
                ), {
                    splitters: [],
                    sumOfCoeffsBefore: 0
                }).splitters
            }
            ;
            function h(e, t, i, s, o, r, l, c) {
                if ("number" == typeof s)
                    return r;
                const u = s.slice(1)
                  , p = [0];
                for (let e = 0; e < u.length; e++)
                    p.push(p[p.length - 1] + r[e].percent);
                if (l < o.level)
                    return u.map(((s,m)=>{
                        var g;
                        const _ = null == r ? void 0 : r[m];
                        if ("number" == typeof s)
                            return _;
                        if (!c && m !== o.indexes[l])
                            return _;
                        const v = null !== (g = null == _ ? void 0 : _.percent) && void 0 !== g ? g : 1 / u.length
                          , S = d(e, m, t, p[m], v, u.length, a, r);
                        return {
                            percent: _.percent,
                            substate: h(S, t, i, s, o, (0,
                            n.ensureDefined)(_.substate), l + 1, c)
                        }
                    }
                    ));
                {
                    const t = s[0];
                    if (t !== o.orientation || r.length < 2)
                        return r;
                    const n = Math.min(o.indexes[l], r.length - 2)
                      , a = "v" === t ? e.height : e.width
                      , c = i / a
                      , d = r[n].percent + r[n + 1].percent;
                    return r[n].percent += c,
                    r[n].percent = Math.min(d - .05, Math.max(.05, r[n].percent)),
                    r[n + 1].percent -= c,
                    r[n + 1].percent = Math.min(d - .05, Math.max(.05, r[n + 1].percent)),
                    r
                }
            }
            function p(e, t) {
                if (1 === e.length)
                    return t;
                {
                    const i = (0,
                    n.ensureDefined)(t[e[0]].substate);
                    return p(e.slice(1), i)
                }
            }
            function m(e, t, i, s, r) {
                if ("number" == typeof e)
                    return i;
                const a = e.slice(1);
                if (r < t.level)
                    return a.map(((e,o)=>{
                        const a = null == i ? void 0 : i[o];
                        return "number" == typeof e ? a : {
                            percent: a.percent,
                            substate: m(e, t, (0,
                            n.ensureDefined)(a.substate), s, r + 1)
                        }
                    }
                    ));
                {
                    const e = t.indexes[r];
                    if (s.length < i.length) {
                        const e = (0,
                        o.default)(s)
                          , t = e[e.length - 1].percent
                          , n = i.length - e.length
                          , r = t / (n + 1);
                        e[e.length - 1].percent = r;
                        for (let t = 0; t < n; t++)
                            e.push({
                                percent: r
                            });
                        s = e
                    } else if (s.length > i.length) {
                        const t = (0,
                        o.default)(s);
                        if (e >= i.length - 1) {
                            const e = s.length - i.length;
                            for (let i = 0; i < e; i++)
                                t[e].percent += t[i].percent;
                            t.splice(0, e)
                        } else {
                            for (let e = i.length; e < s.length; e++)
                                t[i.length - 1].percent += t[e].percent;
                            t.splice(i.length)
                        }
                        s = t
                    }
                    return i.forEach(((e,t)=>e.percent = s[t].percent)),
                    i
                }
            }
            return {
                indices: s,
                smallestIndex: c,
                sizer: (e,t,i,s,o)=>{
                    let n, r, c, u = 0, h = 0, p = 0;
                    for (let e = 0; e < l.length; e++) {
                        const s = l[e];
                        s.smallestIndex >= i || (s.indices.has(t) && (n = s,
                        c = null == o ? void 0 : o[e].substate,
                        o && (p = o[e].percent),
                        r = u),
                        u++,
                        o && 0 === p && (h += o[e].percent))
                    }
                    const m = d(e, r, s, h, p, u, a, o);
                    return n.sizer(m, t, i, s, c)
                }
                ,
                splitters: (t,i,s)=>u(t, i, e, 0, [], "", s),
                resizeApplier: (t,i,s,o,n,r)=>h(t, i, s, e, o, n, 0, r),
                syncSublayoutsBySplitter: function(t, i) {
                    const s = p(t.indexes, i);
                    return m(e, t, i, s, 0)
                }
            }
        }
        function a(e, t, i) {
            const s = r(e, t);
            return {
                title: i,
                count: s.indices.size,
                sizer: s.sizer,
                splitters: s.splitters,
                resizeApplier: s.resizeApplier,
                syncSublayoutsBySplitter: s.syncSublayoutsBySplitter,
                expression: e,
                layoutType: t
            }
        }
        function l(e) {
            return e.map((t=>{
                if ((0,
                s.default)(t))
                    return {
                        percent: 1 / e.length
                    };
                {
                    const i = t.slice(1);
                    return {
                        percent: 1 / e.length,
                        substate: l(i)
                    }
                }
            }
            ))
        }
        function c(e) {
            return l(e.slice(1))
        }
    }
    ,
    442657: (e,t,i)=>{
        "use strict";
        i.r(t),
        i.d(t, {
            isMultipleLayout: ()=>c,
            isSingleLayout: ()=>l,
            isSupportedLayout: ()=>d,
            layouts: ()=>a,
            tryGuessingTheMostSuitableLayout: ()=>u
        });
        var s = i(287489)
          , o = i(851063);
        const n = {
            s: {
                title: "1 chart",
                count: 1,
                layoutType: "s",
                sizer: (e,t)=>{
                    if (0 !== t)
                        throw new RangeError("invalid index");
                    return e
                }
                ,
                splitters: ()=>[],
                resizeApplier: (e,t,i,s,o)=>o,
                syncSublayoutsBySplitter: (e,t)=>t,
                expression: ["h", 0]
            }
        };
        let r;
        r = {
            "2h": (0,
            o.createLayout)(s["2h"], "2h", "2-up horizontal"),
            "2v": (0,
            o.createLayout)(s["2v"], "2v", "2-up vertical"),
            "2-1": (0,
            o.createLayout)(s["2-1"], "2-1", "2 at top and 1 at bottom"),
            "1-2": (0,
            o.createLayout)(s["1-2"], "1-2", "1 at top and 2 at bottom"),
            "3s": (0,
            o.createLayout)(s["3s"], "3s", "3-up stacked"),
            "3r": (0,
            o.createLayout)(s["3r"], "3r", "3-up stacked left"),
            "3h": (0,
            o.createLayout)(s["3h"], "3h", "3-up horizontal"),
            "3v": (0,
            o.createLayout)(s["3v"], "3v", "3-up vertical"),
            4: (0,
            o.createLayout)(s[4], "4", "4-up"),
            "4h": (0,
            o.createLayout)(s["4h"], "4h", "4-up horizontal"),
            "4v": (0,
            o.createLayout)(s["4v"], "4v", "4-up vertical"),
            "4s": (0,
            o.createLayout)(s["4s"], "4s", "4-up stacked"),
            "4s-l": (0,
            o.createLayout)(s["4s-l"], "4s-l", "4-up stacked left"),
            "5h": (0,
            o.createLayout)(s["5h"], "5h", "5-up horizontal"),
            "5v": (0,
            o.createLayout)(s["5v"], "5v", "5-up vertical"),
            "6h": (0,
            o.createLayout)(s["6h"], "6h", "6-up horizontal"),
            "6v": (0,
            o.createLayout)(s["6v"], "6v", "6-up vertical"),
            "7h": (0,
            o.createLayout)(s["7h"], "7h", "7-up horizontal"),
            "8h": (0,
            o.createLayout)(s["8h"], "8h", "8-up horizontal"),
            "8v": (0,
            o.createLayout)(s["8v"], "8v", "8-up vertical"),
            "2-2": (0,
            o.createLayout)(s["2-2"], "2-2", "2 at top and 2 at bottom"),
            "2-2-l": (0,
            o.createLayout)(s["2-2-l"], "2-2-l", "2 at left and 2 at right"),
            "2-3": (0,
            o.createLayout)(s["2-3"], "2-3", "2 at top and 3 at bottom"),
            "3-2": (0,
            o.createLayout)(s["3-2"], "3-2", "3 at top and 2 at bottom"),
            "1-3": (0,
            o.createLayout)(s["1-3"], "1-3", "1 at top and 3 at bottom"),
            "1-4": (0,
            o.createLayout)(s["1-4"], "1-4", "1 at top and 4 at bottom"),
            "2-4": (0,
            o.createLayout)(s["2-4"], "2-4", "2 at top and 4 at bottom"),
            "5s": (0,
            o.createLayout)(s["5s"], "5s", "5-up stacked"),
            6: (0,
            o.createLayout)(s[6], "6", "6-up"),
            "6c": (0,
            o.createLayout)(s["6c"], "6c", "6-up in two columns"),
            8: (0,
            o.createLayout)(s[8], "8", "8-up"),
            "8c": (0,
            o.createLayout)(s["8c"], "8c", "8-up in two columns"),
            "9s": (0,
            o.createLayout)(s["9s"], "9s", "3x3 square"),
            "9h": (0,
            o.createLayout)(s["9h"], "9h", "9-up horizontal"),
            "9v": (0,
            o.createLayout)(s["9v"], "9v", "9-up vertical"),
            "10h": (0,
            o.createLayout)(s["10h"], "10h", "10-up horizontal"),
            "10v": (0,
            o.createLayout)(s["10v"], "10v", "10-up vertical"),
            "10c5": (0,
            o.createLayout)(s["10c5"], "10c5", "2-up in 5 columns"),
            "12c6": (0,
            o.createLayout)(s["12c6"], "12c6", "2-up in 6 columns"),
            "12c4": (0,
            o.createLayout)(s["12c4"], "12c4", "3-up in 4 columns"),
            "14c7": (0,
            o.createLayout)(s["14c7"], "14c7", "2-up in 7 columns"),
            "16c8": (0,
            o.createLayout)(s["16c8"], "16c8", "2-up in 8 columns"),
            "16c4": (0,
            o.createLayout)(s["16c4"], "16c4", "4-up in 4 columns")
        };
        const a = {
            ...n,
            ...r
        };
        function l(e) {
            return "s" === e
        }
        function c(e) {
            return !l(e)
        }
        function d(e) {
            return l(e) || r.hasOwnProperty(e)
        }
        function u(e) {
            const t = /(\d)-(\d)/.exec(e);
            let i = 1;
            for (i = 3 === (null == t ? void 0 : t.length) ? parseInt(t[1]) + parseInt(t[2]) : parseInt(e); i > 1; ) {
                const e = Object.keys(r).find((e=>r[e].count === i));
                if (e)
                    return e;
                i--
            }
            return "s"
        }
    }
    ,
    390675: (e,t,i)=>{
        "use strict";
        i.d(t, {
            lineToolsSelectHotkeys: ()=>o
        });
        i(466281);
        var s = i(470316);
        const o = {
            LineToolFibRetracement: {
                hash: s.Modifiers.Alt + 70,
                action: "setTool",
                description: "Draw Fib Retracement"
            },
            LineToolHorzLine: {
                hash: s.Modifiers.Alt + 72,
                action: "drawRightThere",
                description: "Draw Horizontal Line here"
            },
            LineToolHorzRay: {
                hash: s.Modifiers.Alt + 74,
                action: "drawRightThere",
                description: "Draw Horizontal Ray here"
            },
            LineToolRectangle: {
                hash: s.Modifiers.Alt + s.Modifiers.Shift + 82,
                action: "setTool",
                description: "Draw Rectangle"
            },
            LineToolTrendLine: {
                hash: s.Modifiers.Alt + 84,
                action: "setTool",
                description: "Draw Trend Line"
            },
            LineToolVertLine: {
                hash: s.Modifiers.Alt + 86,
                action: "drawRightThere",
                description: "Draw Vertical Line here"
            },
            LineToolCrossLine: {
                hash: s.Modifiers.Alt + 67,
                action: "drawRightThere",
                description: "Draw Cross Line here"
            }
        }
    }
    ,
    235853: (e,t,i)=>{
        "use strict";
        i.d(t, {
            actualBehavior: ()=>a,
            availableValues: ()=>r,
            navigationButtonsVisibilityKey: ()=>o,
            property: ()=>n,
            restoreNavigationButtonsVisibilitySettingsValue: ()=>l
        });
        var s = i(154241);
        const o = "NavigationButtons.visibility"
          , {property: n, availableValues: r, actualBehavior: a, restoreDefaultValue: l} = (0,
        s.createVisibilityController)(o)
    }
    ,
    836861: (e,t,i)=>{
        "use strict";
        i.d(t, {
            actualBehavior: ()=>a,
            availableValues: ()=>r,
            property: ()=>n,
            restorePaneButtonsVisibilitySettingsValue: ()=>l
        });
        var s = i(154241)
          , o = i(235853);
        const {property: n, availableValues: r, actualBehavior: a, restoreDefaultValue: l} = (0,
        s.createVisibilityController)("PaneButtons.visibility", o.navigationButtonsVisibilityKey)
    }
    ,
    15144: (e,t,i)=>{
        "use strict";
        i.d(t, {
            performanceTestMode: ()=>r
        });
        var s = i(125226)
          , o = i(638456)
          , n = i(314802);
        const r = navigator.userAgent.toLowerCase().indexOf("chrome") > -1 && -1 === navigator.userAgent.toLowerCase().indexOf("edge") && !o.CheckMobile.any() && !(0,
        n.isOnMobileAppPage)("any") && !window.TVD && !(0,
        o.onWidget)() && (0,
        s.isFeatureEnabled)("performance_test_mode") && !window.matchMedia("(prefers-reduced-motion)").matches
    }
    ,
    845520: (e,t,i)=>{
        "use strict";
        function s(e) {
            var t, i, s, o, n, r, a, l;
            const c = null === (i = null === (t = window.widgetbar) || void 0 === t ? void 0 : t.tradingPanelAccessor) || void 0 === i ? void 0 : i.tradingPanel
              , d = !(null === (o = null === (s = window.widgetbar) || void 0 === s ? void 0 : s.layout) || void 0 === o ? void 0 : o.canOpen());
            (null == c ? void 0 : c.isOpened) && d && c.close();
            const u = null === (n = window.widgetbar) || void 0 === n ? void 0 : n.setPage("pine_logs");
            null === (l = null === (a = null === (r = window.widgetbar) || void 0 === r ? void 0 : r.layout) || void 0 === a ? void 0 : a.widgetBar) || void 0 === l || l.saveToTVSettings();
            const h = null == u ? void 0 : u.widget("pine_logs")
              , p = null == h ? void 0 : h.widgetObject;
            e ? null == p || p.onSelectStudyFromChart(e) : null == p || p.onOpenFromEditor()
        }
        function o() {
            var e, t, i, s, o;
            null === (t = null === (e = window.widgetbar) || void 0 === e ? void 0 : e.layout) || void 0 === t || t.setMinimizedState(!0),
            null === (o = null === (s = null === (i = window.widgetbar) || void 0 === i ? void 0 : i.layout) || void 0 === s ? void 0 : s.widgetBar) || void 0 === o || o.saveToTVSettings()
        }
        i.d(t, {
            closeRightPanel: ()=>o,
            openPineLogsInRightPanel: ()=>s
        })
    }
    ,
    956250: (e,t,i)=>{
        "use strict";
        i.d(t, {
            COMPLETED_STATUSES: ()=>n,
            findUpdatedActiveStudy: ()=>a,
            getOnlyVisibleStudies: ()=>l,
            isUserStudyWithLogs: ()=>r
        });
        var s = i(971417)
          , o = i(757402);
        const n = new Set([o.StudyStatusType.Error, o.StudyStatusType.Completed]);
        function r(e) {
            if (null == e ? void 0 : e.metaInfo) {
                const t = null == e ? void 0 : e.metaInfo()
                  , i = t.graphics.logs
                  , o = (0,
                s.extractPineId)(t.id)
                  , n = t.pine;
                return Boolean(n && o && (0,
                s.isCustomPineId)(o) && i)
            }
            return !1
        }
        function a(e, t) {
            return e.find((e=>e.instanceId() !== t.instanceId() && e.id() === t.id()))
        }
        function l(e) {
            return e.filter((e=>null == e ? void 0 : e.isVisible()))
        }
    }
    ,
    716761: (e,t,i)=>{
        "use strict";
        i.d(t, {
            isCustomStudy: ()=>o
        });
        const s = {
            LinearRegression: !0,
            PivotPointsHighLow: !0,
            VbPSessions: !0,
            VbPSessionsRoughDetailed: !0,
            VbPPeriodic: !0,
            VbPAutoAnchored: !0,
            ZigZag: !0,
            TPOPeriodic: !0,
            TPOSessions: !0,
            VbPFixed: !0,
            PivotPointsStandard: !0,
            VbPVisible: !0,
            VbPAnchored: !0
        };
        function o(e) {
            return e in s
        }
    }
    ,
    598631: (e,t,i)=>{
        "use strict";
        i.d(t, {
            MetaInfoHelper: ()=>h
        });
        var s = i(650151)
          , o = i(637761)
          , n = i(748947)
          , r = i(124829)
          , a = i(338619)
          , l = i(218049);
        function c(e) {
            return !e.groupId && !e.isHidden && e.id !== l.RangeDependentStudyInputNames.FirstBar && e.id !== l.RangeDependentStudyInputNames.LastBar
        }
        var d = i(716761);
        const u = (0,
        a.getLogger)("Platform.GUI.PropertyDialog.Indicators.MetaInfo");
        class h {
            constructor(e) {
                this._metaInfo = e
            }
            hasUserEditableInputs() {
                return this._metaInfo.inputs.some(c)
            }
            getUserEditableInputs() {
                return this._metaInfo.inputs.filter(c)
            }
            hasUserEditableProperties() {
                return o.StudyMetaInfo.isScriptStrategy(this._metaInfo)
            }
            hasUserEditableStyles() {
                const e = this._metaInfo;
                return e.plots.length > 0 || void 0 !== e.bands || void 0 !== e.filledAreas || (0,
                d.isCustomStudy)(e.shortId) || o.StudyMetaInfo.isScriptStrategy(this._metaInfo) || Object.values(e.graphics).some((e=>void 0 !== e))
            }
            getUserEditablePlots() {
                const e = new Set
                  , t = this._metaInfo;
                return t.plots.filter((i=>{
                    if ((0,
                    n.isColorerPlot)(i) || (0,
                    n.isTextColorerPlot)(i) || (0,
                    n.isDataOffsetPlot)(i) || (0,
                    n.isOhlcColorerPlot)(i) || (0,
                    n.isAlertConditionPlot)(i) || (0,
                    n.isDataPlot)(i))
                        return !1;
                    if ((0,
                    n.isOhlcPlot)(i)) {
                        const o = i.target;
                        if (e.has(o))
                            return !1;
                        e.add(o);
                        const n = (0,
                        s.ensureDefined)(t.ohlcPlots);
                        return !(0,
                        s.ensureDefined)(n[o]).isHidden
                    }
                    {
                        const e = t.styles ? t.styles[i.id] : void 0;
                        return void 0 === e || !e.isHidden
                    }
                }
                ))
            }
            hasUserEditableOptions() {
                return this.hasUserEditableInputs() || this.hasUserEditableProperties() || this.hasUserEditableStyles()
            }
            getStrategyProperties() {
                const e = this._metaInfo
                  , t = e.inputs.filter(m)
                  , i = {
                    ...p
                };
                for (const s of t) {
                    const t = s.internalID;
                    i[t] = s,
                    p.hasOwnProperty(t) || u.logWarn(`Unknown strategy input internal id ${t} in ${e.fullId}`)
                }
                return (0,
                r.clone)(i)
            }
        }
        const p = {
            currency: void 0,
            backtest_fill_limits_assumption: void 0,
            calc_on_every_tick: void 0,
            calc_on_order_fills: void 0,
            commission_value: void 0,
            commission_type: void 0,
            initial_capital: void 0,
            pyramiding: void 0,
            slippage: void 0,
            default_qty_type: void 0,
            default_qty_value: void 0,
            margin_long: void 0,
            margin_short: void 0,
            use_bar_magnifier: void 0,
            process_orders_on_close: void 0,
            fill_orders_on_standard_ohlc: void 0
        };
        function m(e) {
            return "strategy_props" === e.groupId
        }
    }
    ,
    418638: (e,t,i)=>{
        "use strict";
        i.d(t, {
            showAboutTheStudyHandler: ()=>d
        });
        var s = i(605244);
        const o = /^STD;Fund_(.*?)(?:_(?:fy|fq|fh|ttm))?$/;
        var n = i(637761)
          , r = i(453995)
          , a = i(613122)
          , l = i(137685)
          , c = i(296842);
        async function d(e) {
            const t = e.metaInfo();
            if (!t)
                return null;
            const {scriptIdPart: d, id: u, pine: h} = t;
            if ((0,
            c.isFundamentalStudyMetaInfo)(t)) {
                const e = function(e) {
                    const t = e.match(o);
                    return t ? t[1] : t
                }(d);
                if (e) {
                    const {default: t} = await i.e(54875).then(i.t.bind(i, 384898, 19));
                    if (e in t)
                        return ()=>(0,
                        s.showSupportDialog)({
                            solutionId: t[e]
                        })
                }
            } else if (!h || n.StudyMetaInfo.hasStdSuffix(d)) {
                const {default: e} = await i.e(95937).then(i.t.bind(i, 676006, 19));
                if (d in e || u in e)
                    return ()=>(0,
                    s.showSupportDialog)({
                        solutionId: e[d] || e[u]
                    })
            } else if (n.StudyMetaInfo.hasPubSuffix(d))
                return async()=>{
                    try {
                        const {chartImageUrl: e} = await (0,
                        r.requestScriptInfo)(d);
                        (0,
                        a.openPublicationViewPopup)({
                            uid: e,
                            type: a.PublicationType.Script
                        })
                    } catch (e) {
                        (0,
                        l.showScriptInfoErrorNoticeDialog)()
                    }
                }
                ;
            return null
        }
    }
    ,
    137685: (e,t,i)=>{
        "use strict";
        i.d(t, {
            showScriptInfoErrorNoticeDialog: ()=>n
        });
        var s = i(444372)
          , o = i(927094);
        function n() {
            (0,
            o.showNoticeDialog)({
                type: "modal",
                title: s.t(null, void 0, i(782374)),
                content: s.t(null, void 0, i(444028))
            })
        }
    }
    ,
    152463: (e,t,i)=>{
        "use strict";
        i.d(t, {
            showStudiesLimitGoProDialog: ()=>d
        });
        var s = i(444372)
          , o = i(405117)
          , n = i(590508)
          , r = i(640146)
          , a = i(434396)
          , l = i(287741);
        const c = s.t(null, void 0, i(515462));
        function d(e, t) {
            const i = "pro_premium_expert" === window.user.pro_plan;
            switch (t.reason) {
            case "child":
                (0,
                n.createGoProDialog)({
                    feature: "studyOnStudy",
                    actions: i ? [{
                        text: c,
                        action: r.PredefinedAction.Close
                    }] : void 0
                });
                break;
            case "fundamental":
                const t = e.allStudies().filter(a.isFundamentalStudy).map((e=>e.title(l.TitleDisplayTarget.StatusLine)));
                (0,
                n.createGoProDialog)({
                    feature: "fundamentalsOnChart",
                    actions: i ? [{
                        text: c,
                        action: r.PredefinedAction.Close
                    }] : void 0,
                    customParams: t
                });
                break;
            default:
                (0,
                o.trackGoProFeature)("studyLimit");
                const s = e.listUserStudies({
                    dontCountVolume: !0,
                    dontCountOverlay: !0,
                    dontCountCompare: !0
                });
                (0,
                n.createGoProDialog)({
                    feature: "studyLimit",
                    customParams: s,
                    actions: i ? [{
                        text: c,
                        action: r.PredefinedAction.Close
                    }] : void 0
                })
            }
        }
    }
    ,
    875678: (e,t,i)=>{
        "use strict";
        i.d(t, {
            restoreShowMarketOpenStatusProperty: ()=>l,
            showMarketOpenStatusProperty: ()=>a
        });
        var s = i(998418)
          , o = i(62802);
        const n = "Chart.ShowMarketOpenStatus";
        function r() {
            return o.getBool(n, true)
        }
        const a = (0,
        s.createPrimitiveProperty)(r());
        function l() {
            a.setValue(true),
            o.remove(n)
        }
        o.onSync.subscribe(null, (()=>a.setValue(r()))),
        a.subscribe(null, (()=>o.setValue(n, a.value())))
    }
    ,
    516284: (e,t,i)=>{
        "use strict";
        i.d(t, {
            marketStatusText: ()=>o
        });
        var s = i(807975);
        function o(e) {
            const t = e.value();
            if (null !== t) {
                const e = s.titleMap.get(t);
                if (void 0 !== e)
                    return e
            }
            return ""
        }
    }
    ,
    807975: (e,t,i)=>{
        "use strict";
        i.d(t, {
            actionMap: ()=>J,
            classNameMap: ()=>U,
            countdownFnMap: ()=>$,
            iconMap: ()=>z,
            marketStatusDescription: ()=>X,
            titleColorMap: ()=>q,
            titleMap: ()=>j,
            tooltipMap: ()=>G
        });
        var s = i(166770)
          , o = i(444372)
          , n = i(553218)
          , r = i(732140)
          , a = i(262998)
          , l = i(725230)
          , c = i(315507)
          , d = i(643401)
          , u = i(85290)
          , h = i(212462)
          , p = i(792263)
          , m = i(24165)
          , g = i(421672)
          , _ = i(792845)
          , v = i(109494)
          , S = i(858994);
        const f = o.t(null, void 0, i(241410))
          , b = o.t(null, void 0, i(236018))
          , y = o.t(null, void 0, i(673897))
          , C = o.t(null, void 0, i(762464))
          , w = o.t(null, void 0, i(987845))
          , T = o.t(null, void 0, i(753357))
          , P = o.t(null, void 0, i(765420))
          , x = o.t(null, void 0, i(23302))
          , M = o.t(null, void 0, i(452176))
          , I = o.t(null, void 0, i(741392))
          , A = o.t(null, void 0, i(59938))
          , L = o.t(null, void 0, i(451320))
          , E = o.t(null, void 0, i(283187))
          , k = o.t(null, void 0, i(605371))
          , D = o.t(null, void 0, i(18643))
          , N = o.t(null, void 0, i(681509))
          , B = o.t(null, void 0, i(758470))
          , R = new Map([["market", new Map([["small", r], ["medium", a], ["large", a]])], ["pre_market", new Map([["small", u], ["medium", h], ["large", h]])], ["post_market", new Map([["small", c], ["medium", d], ["large", d]])], ["out_of_session", new Map([["small", n], ["medium", n], ["large", n]])], ["holiday", new Map([["small", l], ["medium", l], ["large", l]])]])
          , O = new Map([["market", S.marketStatusOpen], ["pre_market", S.marketStatusPre], ["post_market", S.marketStatusPost], ["out_of_session", S.marketStatusClose], ["holiday", S.marketStatusHoliday]])
          , V = new Map([["market", f], ["pre_market", b], ["post_market", y], ["out_of_session", C], ["holiday", w]])
          , W = new Map([["market", f], ["pre_market", b], ["post_market", y], ["out_of_session", C], ["holiday", w]])
          , F = new Map([["market", s.colorsPalette["color-market-open"]], ["pre_market", s.colorsPalette["color-pre-market"]], ["post_market", s.colorsPalette["color-post-market"]], ["out_of_session", s.colorsPalette["color-market-closed"]], ["holiday", s.colorsPalette["color-market-holiday"]]])
          , H = new Map([["market", T], ["pre_market", P], ["post_market", x], ["out_of_session", M], ["holiday", I]]);
        R.set("delisted", new Map([["small", p], ["medium", m], ["large", g]])),
        R.set("expired", new Map([["small", _], ["medium", v], ["large", v]])),
        O.set("delisted", S.marketStatusDelisted),
        O.set("expired", S.marketStatusExpired),
        V.set("delisted", o.t(null, void 0, i(254602))),
        V.set("expired", o.t(null, void 0, i(260657))),
        W.set("delisted", o.t(null, void 0, i(331683))),
        W.set("expired", o.t(null, void 0, i(260657))),
        F.set("delisted", s.colorsPalette["color-delisted-symbol"]),
        F.set("expired", s.colorsPalette["color-market-expired"]),
        H.set("delisted", "This is no longer publicly trading so no new data will be added. But you can explore the historicals here."),
        H.set("expired", o.t(null, void 0, i(639301)));
        const z = R
          , U = O
          , G = V
          , j = W
          , q = F
          , X = H;
        function K(e) {
            return o.t(null, {
                plural: "{number} minutes",
                count: e
            }, i(532547)).format({
                number: e.toString()
            })
        }
        function Y(e) {
            return o.t(null, {
                plural: "{number} hours",
                count: e
            }, i(844646)).format({
                number: e.toString()
            })
        }
        function Z(e) {
            const t = Math.floor(e / 86400)
              , s = Math.floor((e - 86400 * t) / 3600)
              , n = Math.floor((e - 86400 * t - 3600 * s) / 60);
            return 0 === t && 0 === s && 0 === n ? A : t > 0 ? L.format({
                days: (r = t,
                o.t(null, {
                    plural: "{number} days",
                    count: r
                }, i(839501)).format({
                    number: r.toString()
                })),
                hours: Y(s)
            }) : s > 0 ? E.format({
                hours: Y(s),
                minutes: K(n)
            }) : K(n);
            var r
        }
        const $ = {
            market: e=>("post_market" === e.status ? N : D).format({
                remainingTime: Z(e.remainingSeconds)
            }),
            pre_market: e=>k.format({
                remainingTime: Z(e.remainingSeconds)
            }),
            post_market: e=>D.format({
                remainingTime: Z(e.remainingSeconds)
            }),
            out_of_session: e=>("pre_market" === e.status ? B : k).format({
                remainingTime: Z(e.remainingSeconds)
            }),
            holiday: e=>("pre_market" === e.status ? B : k).format({
                remainingTime: Z(e.remainingSeconds)
            }),
            delisted: e=>"",
            expired: e=>""
        }
          , J = new Map([["market", null], ["pre_market", null], ["post_market", null], ["out_of_session", null], ["holiday", null], ["delisted", null]])
    }
    ,
    826312: (e,t,i)=>{
        "use strict";
        i.d(t, {
            canShowSpreadActions: ()=>o,
            globalKeypressMatches: ()=>n
        });
        var s = i(374271);
        i(953297);
        function o() {
            let e = !1;
            return e = "cme" !== window.TradingView.widgetCustomer && "bovespa" !== window.TradingView.widgetCustomer,
            e
        }
        function n(e) {
            if (e.ctrlKey)
                return !1;
            if (e.metaKey)
                return !1;
            if (!e.charCode)
                return !1;
            if (!e.which || e.which <= 32)
                return !1;
            const t = e.target;
            return (!t || !/^(input|textarea)$/i.test(t.tagName) && "listbox" !== t.getAttribute("role")) && !(0,
            s.isOpenedModals)()
        }
    }
    ,
    506672: (e,t,i)=>{
        "use strict";
        function s() {
            return Promise.all([i.e(9685), i.e(46445), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(53953), i.e(2520), i.e(25480), i.e(62564), i.e(46489), i.e(58985), i.e(77476), i.e(75826), i.e(59258), i.e(82421), i.e(67158), i.e(74600), i.e(72197), i.e(24125), i.e(88015), i.e(98734), i.e(97384), i.e(93523), i.e(3782), i.e(86605), i.e(49162), i.e(41243), i.e(7001), i.e(71329), i.e(51488), i.e(94106), i.e(59470), i.e(75364), i.e(17762), i.e(79412), i.e(42513), i.e(78685), i.e(59434), i.e(10393), i.e(32227), i.e(50030), i.e(87473), i.e(5483), i.e(21041), i.e(83912), i.e(85572), i.e(18405), i.e(93498), i.e(65267), i.e(38506), i.e(50186), i.e(45378), i.e(21754)]).then(i.bind(i, 788048))
        }
        i.d(t, {
            loadNewSymbolSearch: ()=>s
        })
    }
    ,
    489935: (e,t,i)=>{
        "use strict";
        i.d(t, {
            ToastsFactory: ()=>s
        });
        class s {
            constructor(e, t) {
                this._chartToastsPromise = null,
                this._resizerBridge = e,
                this._bottomToolbarOffsetHeightProvider = t
            }
            async getChartToasts() {
                return null !== this._chartToastsPromise || (this._chartToastsPromise = async function() {
                    return Promise.all([Promise.all([i.e(45800), i.e(44524), i.e(89407), i.e(7546), i.e(32227), i.e(66875), i.e(53088)]).then(i.bind(i, 969154)), Promise.all([i.e(89407), i.e(32227), i.e(66875), i.e(94291)]).then(i.bind(i, 13830))]).then((e=>[e[0].ChartToasts, e[1].globalToasts]))
                }().then((e=>{
                    const t = e[0]
                      , i = e[1];
                    return new t(this._resizerBridge,this._resizerBridge.container.value(),i,this._bottomToolbarOffsetHeightProvider())
                }
                ))),
                this._chartToastsPromise
            }
        }
    }
    ,
    683833: (e,t,i)=>{
        "use strict";
        i.d(t, {
            createTradeContext: ()=>o
        });
        var s = i(650151);
        async function o(e, t) {
            let i = NaN
              , o = NaN
              , n = "";
            const r = e.proSymbol()
              , a = (e.symbolInfo() || {
                name: null
            }).name || r
              , l = e.priceScale();
            if (t) {
                const s = e.firstValue();
                i = null !== s ? l.coordinateToPrice(t, s) : null,
                n = null !== i ? e.formatter().format(i) : ""
            }
            const c = e.bars().last();
            null !== c && (o = (0,
            s.ensure)(c.value[TradingView.CLOSE_PLOT]));
            return {
                symbol: r,
                displaySymbol: a,
                value: i,
                formattedValue: n,
                last: o,
                symbolInfoTradable: !!(e.symbolInfo() || {
                    is_tradable: !1
                }).is_tradable
            }
        }
    }
    ,
    597655: (e,t,i)=>{
        "use strict";
        i.d(t, {
            isBrokerHidden: ()=>p,
            isMobileTradingAvailable: ()=>u,
            isMobileTradingAvailableInApp: ()=>h,
            isSmallScreen: ()=>m
        });
        var s = i(638456)
          , o = i(125226)
          , n = i(314802)
          , r = i(953297);
        const a = (0,
        o.isFeatureEnabled)("mobile_trading_ios") && s.CheckMobile.iOS() && (0,
        n.isOnMobileAppPage)("old")
          , l = (0,
        o.isFeatureEnabled)("mobile_trading_android") && s.CheckMobile.Android() && (0,
        n.isOnMobileAppPage)("new")
          , c = (0,
        o.isFeatureEnabled)("mobile_trading_web") && s.CheckMobile.any() && !s.CheckMobile.isIPad() && m() && !(0,
        n.isOnMobileAppPage)("any")
          , d = r.enabled("mobile_trading") && (a || l || c);
        function u() {
            return d
        }
        function h() {
            return a || l
        }
        function p(e) {
            return a ? (0,
            o.isFeatureEnabled)(`hide_${e}_on_ios`) : l ? (0,
            o.isFeatureEnabled)(`hide_${e}_on_android`) : !!c && (0,
            o.isFeatureEnabled)(`hide_${e}_on_mobile_web`)
        }
        function m() {
            return window.matchMedia("screen and (orientation: portrait) and (max-width: 567px)").matches || window.matchMedia("screen and (orientation: landscape) and (max-height: 567px)").matches
        }
    }
    ,
    745402: (e,t,i)=>{
        "use strict";
        i.d(t, {
            tradedGroupBaseNamePrefix: ()=>s,
            tradedGroupPlaceOrderPrefix: ()=>o
        });
        const s = "tradedGroup:"
          , o = `${s}PlaceOrder`
    }
    ,
    955931: (e,t,i)=>{
        "use strict";
        function s(e) {
            return e.hasModel() ? e.model().mainSeries().proSymbol() : e.symbolWV().value()
        }
        i.d(t, {
            getWatchlistSymbolFromChart: ()=>s
        })
    }
    ,
    676962: (e,t,i)=>{
        "use strict";
        i.r(t),
        i.d(t, {
            addSymbolDialogHasOpenedKey: ()=>r,
            showAddSymbolDialog: ()=>a
        });
        var s = i(586450)
          , o = i(305514)
          , n = i(251954);
        const r = "addSymbolDialogHasOpenedKey";
        function a(e) {
            (0,
            s.runOrSigninWithFeature)((()=>{
                (0,
                o.showWatchListsDialog)({
                    addSymbols: e,
                    onOpen: l
                })
            }
            ), {
                feature: "watchList",
                source: "add symbol to watchlist"
            })
        }
        function l() {
            n.emit(r)
        }
    }
    ,
    344158: (e,t,i)=>{
        "use strict";
        i.d(t, {
            addPlusButtonProperty: ()=>h,
            restoreAddPlusButtonSettingsValue: ()=>p,
            showPlusButtonOnCursor: ()=>d
        });
        var s = i(799786)
          , o = (i(953297),
        i(62802))
          , n = i(998418)
          , r = i(978296);
        const a = "add_plus_button";
        function l() {
            const e = s.keyboardPressedKeysState.value();
            return void 0 !== e && (Boolean(e.modifiers & s.Modifiers.Alt && e.modifiers & s.Modifiers.Mod) && (void 0 === e.code || e.altOrOptionCode() || e.controlOrMetaCode()))
        }
        const c = new r.WatchedValue(l());
        s.keyboardPressedKeysState.subscribe((()=>c.setValue(l())));
        const d = c.readonly();
        function u() {
            return o.getBool(a, !0)
        }
        const h = (0,
        n.createPrimitiveProperty)(u());
        function p() {
            h.setValue(!0),
            o.remove(a)
        }
        o.onSync.subscribe(null, (()=>h.setValue(u()))),
        h.subscribe(null, (()=>{
            o.setValue(a, h.value())
        }
        ))
    }
    ,
    995152: (e,t,i)=>{
        "use strict";
        i.d(t, {
            getAlertColorLineByTheme: ()=>y,
            getSettingsProperty: ()=>f,
            restoreSettingsProperty: ()=>b
        });
        var s = i(650151)
          , o = i(154834)
          , n = i(650279)
          , r = i(998034)
          , a = i(166770)
          , l = i(62802)
          , c = i(61499)
          , d = i(658843)
          , u = i(262624)
          , h = i(211183);
        const p = "alertLabels";
        let m;
        const g = {
            visible: !0,
            showOnlyActive: !0,
            line: {
                color: "",
                visible: !0
            }
        }
          , _ = new Map([[c.StdTheme.Light, {
            line: {
                color: (0,
                a.getHexColorByName)("color-cold-gray-900")
            }
        }], [c.StdTheme.Dark, {
            line: {
                color: (0,
                a.getHexColorByName)("color-cold-gray-200")
            }
        }]]);
        function v() {
            let e = (0,
            l.getJSON)(p, null);
            if (null === e) {
                const t = (0,
                h.defaults)("chartproperties");
                t && t.alertsProperties && t.alertsProperties.labels && (e = t.alertsProperties.labels)
            }
            null === e && (e = (0,
            o.default)(g));
            const t = (0,
            u.extractAllPropertiesKeys)(g)
              , i = (0,
            u.extractAllPropertiesKeys)(e);
            if (!(0,
            n.default)(t, i)) {
                const i = (0,
                u.extractState)(e, t);
                e = (0,
                r.default)((0,
                o.default)(g), i)
            }
            return e
        }
        function S() {
            m && (0,
            l.setJSON)(p, m.state())
        }
        function f() {
            return m || (m = new d.Property(v()),
            m.listeners().subscribe(null, S),
            l.onSync.subscribe(null, (()=>{
                m.mergeAndFire(v())
            }
            )),
            m)
        }
        function b() {
            m && m.mergeAndFire(g)
        }
        function y(e) {
            const t = e.dark().value() ? c.StdTheme.Dark : c.StdTheme.Light;
            return (0,
            s.ensureDefined)(_.get(t)).line.color
        }
    }
    ,
    938614: (e,t,i)=>{
        "use strict";
        i.d(t, {
            ALERT_LABEL_WIDTH: ()=>ae,
            AlertLabel: ()=>ue,
            isAlertLabel: ()=>le
        });
        var s, o = i(650151), n = i(166770), r = i(411667), a = i(472512), l = i(903424), c = i(343272), d = i(658843), u = i(95370), h = i(378975), p = i(975179), m = i(169532), g = i(345848), _ = i(995152), v = i(86441), S = i(444372), f = i(982949), b = i(509078), y = i(112377), C = i(230844), w = i(922182), T = i(666574), P = i(665798), x = i(286436), M = i(961970);
        !function(e) {
            e[e.ConnectorOffsetFromIcon = 28] = "ConnectorOffsetFromIcon",
            e[e.ConnectorCircleRadius = 4] = "ConnectorCircleRadius",
            e[e.IconWidth = 21] = "IconWidth"
        }(s || (s = {}));
        class I extends M.BitmapCoordinatesPaneRenderer {
            constructor(e) {
                super(),
                this._data = e
            }
            hitTest(e, t) {
                const i = (0,
                x.interactionTolerance)().line;
                for (let s = 0; s < this._data.levels.length; s++) {
                    const o = this._data.levels[s]
                      , [n,r] = this._calculateLeftRight(this._data, o, t.mediaSize.width, 1)
                      , a = Math.min(n, r)
                      , l = Math.max(n, r);
                    if (Math.abs(o.y - e.y) <= i && e.x >= a && e.x <= l)
                        return new b.HitTestResult(b.HitTarget.MovePoint,{
                            activeItem: s,
                            hideCrosshairLinesOnHover: !0,
                            areaName: b.AreaName.Line
                        })
                }
                const o = this._data.levels.map((e=>e.y))
                  , n = Math.min(...o)
                  , r = Math.max(...o)
                  , a = this._data.isLeft ? Math.round(s.ConnectorOffsetFromIcon + s.IconWidth) : Math.round(t.mediaSize.width - (s.ConnectorOffsetFromIcon + s.IconWidth));
                if (Math.abs(a - e.x) < i && e.y >= n && e.y <= r) {
                    const t = o.reduce(((t,i,s)=>{
                        const o = Math.abs(t.level - e.y);
                        return Math.abs(i - e.y) < o ? {
                            index: s,
                            level: i
                        } : t
                    }
                    ), {
                        index: 0,
                        level: o[0]
                    });
                    return new b.HitTestResult(b.HitTarget.MovePoint,{
                        activeItem: t.index,
                        hideCrosshairLinesOnHover: !0,
                        areaName: b.AreaName.Line
                    })
                }
                return null
            }
            _drawImpl(e) {
                const t = e.context;
                if (t.lineWidth = Math.max(1, Math.floor(e.verticalPixelRatio)),
                t.strokeStyle = this._data.color,
                (0,
                P.setLineStyle)(t, T.LINESTYLE_DASHED),
                this._data.levels.forEach((i=>{
                    const s = Math.round(i.y * e.verticalPixelRatio)
                      , [o,n] = this._calculateLeftRight(this._data, i, e.bitmapSize.width, e.horizontalPixelRatio);
                    (0,
                    P.drawHorizontalLine)(t, s, o, n)
                }
                )),
                this._data.levels.length > 1) {
                    const i = this._data.isLeft ? Math.round((s.ConnectorOffsetFromIcon + s.IconWidth) * e.horizontalPixelRatio) + .5 : Math.round(e.bitmapSize.width - (s.ConnectorOffsetFromIcon + s.IconWidth) * e.horizontalPixelRatio) + .5
                      , o = this._data.levels.map((e=>e.y))
                      , n = Math.min(...o)
                      , r = Math.max(...o);
                    t.beginPath(),
                    t.moveTo(i, n * e.verticalPixelRatio),
                    t.lineTo(i, r * e.verticalPixelRatio),
                    t.stroke();
                    const a = Math.round(s.ConnectorCircleRadius * e.horizontalPixelRatio);
                    (0,
                    P.setLineStyle)(t, T.LINESTYLE_SOLID),
                    t.fillStyle = this._data.connectorsBackColor,
                    [n, r].forEach((s=>{
                        const o = Math.round(s * e.verticalPixelRatio);
                        t.beginPath(),
                        t.arc(i, o, a, 0, 2 * Math.PI, !0),
                        t.fill(),
                        t.stroke()
                    }
                    ))
                }
            }
            _calculateLeftRight(e, t, i, o) {
                const n = 1 === e.levels.length ? 0 : Math.floor(s.ConnectorCircleRadius * o);
                let r, a;
                return this._data.isLeft ? (a = 0,
                r = "full" === t.mode ? i : "toConnector" === t.mode ? Math.round((s.ConnectorOffsetFromIcon + s.IconWidth - n) * o) : Math.round(this._data.distanceToTooltip * o)) : (r = "full" === t.mode ? 0 : "toConnector" === t.mode ? Math.round(i - (s.ConnectorOffsetFromIcon + s.IconWidth - n) * o) : Math.round(i - this._data.distanceToTooltip * o),
                a = i),
                [r, a]
            }
        }
        var A = i(934026)
          , L = i(631088)
          , E = i(511275)
          , k = i(694852)
          , D = i(5486)
          , N = i(828473)
          , B = i(547777);
        const R = (0,
        k.makeFont)(12, E.CHART_FONT_FAMILY)
          , O = new Path2D("M5 3.06574L10.9014 7L5 10.9343V3.06574ZM6 9.06574L9.09861 7L6 4.93426V9.06574ZM7 13C10.3137 13 13 10.3137 13 7C13 3.68629 10.3137 1 7 1C3.68629 1 1 3.68629 1 7C1 10.3137 3.68629 13 7 13ZM7 14C10.866 14 14 10.866 14 7C14 3.13401 10.866 0 7 0C3.13401 0 0 3.13401 0 7C0 10.866 3.13401 14 7 14Z")
          , V = " • ";
        class W extends M.BitmapCoordinatesPaneRenderer {
            constructor() {
                super(),
                this._data = null,
                this._lastPaintTextWidth = null,
                this._lastPaintPaneWidth = null,
                this._widthCache = new D.TextWidthCache
            }
            setData(e) {
                this._data = e
            }
            hitTest(e) {
                const t = this._data;
                if (null === this._lastPaintTextWidth || !t || null === this._lastPaintPaneWidth)
                    return null;
                const i = this._lastPaintTextWidth + 16 + 26
                  , s = this._calculatePoint(t, i, this._lastPaintPaneWidth);
                {
                    const o = new v.Point(s.x - 26 + i,s.y - 9.5)
                      , n = o.add(new v.Point(26,19));
                    if ((0,
                    A.pointInBox)(e, (0,
                    v.box)(o, n)))
                        return new b.HitTestResult(b.HitTarget.Custom,{
                            activeItem: t.lineIndex,
                            hideCrosshairLinesOnHover: !0,
                            areaName: b.AreaName.Button,
                            clickHandler: t.buttonAction,
                            tapHandler: t.buttonAction
                        })
                }
                {
                    const o = new v.Point(s.x,s.y - 9.5)
                      , n = o.add(new v.Point(i,19));
                    if ((0,
                    A.pointInBox)(e, (0,
                    v.box)(o, n)))
                        return new b.HitTestResult(b.HitTarget.MovePoint,{
                            activeItem: t.lineIndex,
                            hideCrosshairLinesOnHover: !0,
                            areaName: b.AreaName.Tooltip
                        })
                }
                return null
            }
            _drawImpl(e) {
                const t = this._data;
                if (!t)
                    return;
                const i = e.context;
                this._lastPaintPaneWidth = e.mediaSize.width,
                i.font = R;
                const s = t.text
                  , n = t.additionalText;
                let r = !1
                  , a = null;
                n && (this._lastPaintTextWidth = this._widthCache.measureText(i, s + V + n),
                a = this._tooltipSizes(e),
                r = a.contentWidth <= a.maxWidth);
                let l = s;
                if (!r && (this._lastPaintTextWidth = this._widthCache.measureText(i, l),
                a = this._tooltipSizes(e),
                a.contentWidth > a.maxWidth)) {
                    l = function(e, t, i) {
                        const s = (0,
                        N.lowerboundExt)((t=>e.substring(0, t)), t, ((t,s)=>i(t === e ? e : (0,
                        B.appendEllipsis)(t)) < s), 0, e.length);
                        return s === e.length ? e : (0,
                        B.appendEllipsis)(e.substring(0, s))
                    }(l, a.maxWidth - 16 - 26, (e=>this._widthCache.measureText(i, e)))
                }
                const c = (0,
                o.ensureNotNull)(a).maxWidth
                  , d = Math.round(c * e.horizontalPixelRatio)
                  , u = Math.round(19 * e.verticalPixelRatio)
                  , h = this._calculatePoint(t, c, this._lastPaintPaneWidth);
                this._drawBorderAround(t, e, h, d, u, (e=>e.fill())),
                this._drawButton(t, e, h, d, u),
                this._drawText(t, e, h, l),
                r && this._drawAdditionalText(t, e, h),
                this._drawBorderAround(t, e, h, d, u, (e=>e.stroke()))
            }
            _drawButton(e, t, i, s, o) {
                const n = t.context;
                i = i.add(new v.Point(s / t.horizontalPixelRatio,0));
                {
                    const s = Math.round((i.x - 26) * t.horizontalPixelRatio) + .5
                      , r = Math.round(i.y * t.verticalPixelRatio - .5 * o) + .5;
                    n.fillStyle = e.buttonBackColor,
                    n.fillRect(s, r, 26 * t.horizontalPixelRatio, o),
                    n.strokeStyle = e.buttonBorderColor,
                    n.lineWidth = Math.max(1, Math.floor(t.verticalPixelRatio)),
                    n.beginPath(),
                    n.moveTo(s, r),
                    n.lineTo(s, r + o),
                    n.stroke()
                }
                0 === e.buttonType ? this._drawCloseButton(e, t, i) : 1 === e.buttonType && this._drawRestartButton(e, t, i)
            }
            _drawCloseButton(e, t, i) {
                const s = t.context;
                s.strokeStyle = e.lineColor,
                s.beginPath();
                const o = Math.round((i.x - 13 - 4 + .5) * t.horizontalPixelRatio)
                  , n = Math.round((i.y - 4 + .5) * t.verticalPixelRatio)
                  , r = Math.round(8 * t.horizontalPixelRatio)
                  , a = Math.round(8 * t.verticalPixelRatio);
                s.moveTo(o, n),
                s.lineTo(o + r, n + a),
                s.moveTo(o, n + a),
                s.lineTo(o + r, n),
                s.stroke()
            }
            _drawRestartButton(e, t, i) {
                const s = t.context
                  , n = Math.round((i.x - 26 + 6 + .5) * t.horizontalPixelRatio)
                  , r = Math.round((i.y - 7 + .5) * t.verticalPixelRatio);
                s.save(),
                s.translate(n, r),
                s.scale(t.horizontalPixelRatio, t.verticalPixelRatio),
                s.fillStyle = (0,
                o.ensureDefined)(e.restartIconColor),
                s.fill(O, "evenodd"),
                s.restore()
            }
            _tooltipSizes(e) {
                const t = (0,
                o.ensureNotNull)(this._lastPaintTextWidth) + 16 + 26
                  , i = Math.max(20, .9 * (e.mediaSize.width - 80));
                return {
                    contentWidth: t,
                    maxWidth: Math.min(t, i)
                }
            }
            _drawText(e, t, i, s) {
                const o = t.context
                  , n = Math.round((i.x + 8) * t.horizontalPixelRatio)
                  , r = Math.round((i.y + 5) * t.verticalPixelRatio);
                o.save(),
                o.translate(n, r),
                (0,
                L.drawScaled)(o, t.horizontalPixelRatio, t.verticalPixelRatio, (()=>{
                    o.fillStyle = e.textColor,
                    o.fillText(s, 0, 0)
                }
                )),
                o.restore()
            }
            _drawAdditionalText(e, t, i) {
                const s = t.context
                  , n = Math.round(this._widthCache.measureText(s, e.text) * t.horizontalPixelRatio)
                  , r = Math.round(this._widthCache.measureText(s, V) * t.horizontalPixelRatio)
                  , a = Math.round((i.x + 8) * t.horizontalPixelRatio) + n
                  , l = Math.round((i.y + 5) * t.verticalPixelRatio);
                s.save(),
                s.fillStyle = (0,
                o.ensureDefined)(e.additionalTextColor),
                s.translate(a, l),
                (0,
                L.drawScaled)(s, t.horizontalPixelRatio, t.verticalPixelRatio, (()=>{
                    s.fillStyle = (0,
                    o.ensureDefined)(e.textColor),
                    s.fillText(V, 0, 0)
                }
                )),
                s.translate(r, 0),
                (0,
                L.drawScaled)(s, t.horizontalPixelRatio, t.verticalPixelRatio, (()=>{
                    s.fillStyle = (0,
                    o.ensureDefined)(e.additionalTextColor),
                    s.fillText((0,
                    o.ensureDefined)(e.additionalText), 0, 0)
                }
                )),
                s.restore()
            }
            _drawBorderAround(e, t, i, s, o, n) {
                const r = t.context
                  , a = Math.round(i.x * t.horizontalPixelRatio) + .5
                  , l = Math.round(i.y * t.verticalPixelRatio - o / 2) + .5;
                r.strokeStyle = e.lineColor,
                r.lineWidth = Math.max(1, Math.floor(t.verticalPixelRatio));
                const c = Math.round(4 * t.horizontalPixelRatio);
                r.fillStyle = e.backColor,
                r.beginPath(),
                (0,
                P.drawRoundRect)(r, a, l, s, o, c),
                n(r)
            }
            _calculatePoint(e, t, i) {
                const s = e.point;
                if (e.center) {
                    const o = Math.max(0, .5 * (i - t));
                    return e.isLeft ? o < s.x ? s : new v.Point(o,s.y) : o + t < s.x ? new v.Point(o,s.y) : new v.Point(s.x - t,s.y)
                }
                return e.isLeft ? s : s.subtract(new v.Point(t,0))
            }
        }
        var F;
        !function(e) {
            e[e.SelectionPointOffset = 35] = "SelectionPointOffset",
            e[e.NoLineModeOffsetSingleLine = 47] = "NoLineModeOffsetSingleLine",
            e[e.NoLineModeOffsetMultipleLines = 62] = "NoLineModeOffsetMultipleLines"
        }(F || (F = {}));
        const H = " — "
          , z = S.t(null, {
            context: "alert_status"
        }, i(730829))
          , U = z + H + S.t(null, {
            context: "alert_status"
        }, i(261129))
          , G = z + H + S.t(null, {
            context: "alert_status"
        }, i(401732))
          , j = z + H + S.t(null, {
            context: "alert_status"
        }, i(660963))
          , q = new Map([[r.AlertStopReason.Auto, G], [r.AlertStopReason.Manual, U], [r.AlertStopReason.Expired, j]]);
        function X(e) {
            return void 0 !== e ? q.get(e) : void 0
        }
        function K(e, t) {
            switch (e) {
            case r.AlertStopReason.Auto:
                return t.inActiveTextTriggeredColor;
            case r.AlertStopReason.Manual:
                return t.inActiveTextManualColor;
            case r.AlertStopReason.Expired:
                return t.inActiveTextExpiredColor;
            default:
                return
            }
        }
        class Y {
            constructor(e, t) {
                this._invalidated = !0,
                this._compositeRenderer = new f.CompositeRenderer,
                this._tooltipRenderer = new W,
                this._alertLabel = e,
                this._model = t
            }
            update() {
                this._invalidated = !0
            }
            invalidate() {
                this._model.lightUpdate()
            }
            renderer() {
                return this._invalidated && (this._updateImpl(),
                this._invalidated = !1),
                this._compositeRenderer
            }
            _updateImpl() {
                var e, t;
                this._compositeRenderer.clear();
                const i = this._alertLabel
                  , s = i.alert()
                  , n = s.condition();
                if (null === n)
                    return;
                const r = (0,
                o.ensureNotNull)(this._model.paneForSource(i))
                  , a = (0,
                o.ensureNotNull)(r.mainDataSource()).firstValue();
                if (null === a || !i.canDrawLabelForAlert())
                    return;
                const l = (0,
                o.ensureNotNull)(i.priceScale())
                  , c = e=>l.priceToCoordinate(e, a)
                  , d = [];
                if ("channel" === n.type) {
                    const e = c(n.upper)
                      , t = c(n.lower);
                    d.push(e),
                    d.push(t)
                } else
                    d.push(c(n.price));
                const u = i.isSelected()
                  , h = i.isHovered()
                  , p = this._model.lastHittestData()
                  , m = this._model.lastSelectedHittestData();
                let g = 0;
                h && (g = null !== (e = null == p ? void 0 : p.activeItem) && void 0 !== e ? e : 0),
                u && (g = null !== (t = null == m ? void 0 : m.activeItem) && void 0 !== t ? t : 0);
                const _ = this._alertLabel.colors()
                  , S = i.labelLineColor()
                  , f = d.map(((e,t)=>({
                    y: e,
                    mode: i.drawHorzLine() ? "full" : t === g && 1 === d.length ? "toTooltip" : "toConnector"
                })))
                  , T = r.leftPriceScales().includes(l)
                  , P = 1 === d.length ? F.NoLineModeOffsetSingleLine : F.NoLineModeOffsetMultipleLines
                  , x = {
                    distanceToTooltip: P,
                    levels: f,
                    color: S,
                    connectorsBackColor: _.connectorBackColor,
                    iconBackgroundWithCorners: u || h,
                    iconColor: _.iconColor,
                    isLeft: T
                };
                if ((i.drawHorzLine() || u || h) && this._compositeRenderer.append(new I(x)),
                u) {
                    const e = r.height()
                      , t = d.map((t=>this._model.backgroundColorAtYPercentFromTop(t / e)))
                      , i = T ? F.SelectionPointOffset : r.width() - F.SelectionPointOffset
                      , s = {
                        points: d.map((e=>new v.Point(i,e))),
                        hittestResult: b.HitTarget.MovePoint,
                        bgColors: t,
                        visible: !0,
                        barSpacing: this._model.timeScale().barSpacing()
                    };
                    this._compositeRenderer.append(new y.SelectionRenderer(s))
                }
                if ((u || h) && !this._alertLabel.isMoving()) {
                    const e = h && (null == p ? void 0 : p.areaName) === b.AreaName.Button
                      , t = T ? P : r.width() - P
                      , o = s.name() || (i.isMoving() ? s.defaultDescription() : s.description())
                      , n = this._alertLabel.isInactive() ? _.inActiveTextBaseColor : S
                      , a = async()=>{
                        const e = this._alertLabel.alert().id().value()
                          , t = this._alertLabel.alert().isNew();
                        e && !t && (await (0,
                        C.getAlertsActionCreators)()).deleteAlert(e, {
                            confirmation: (0,
                            w.selectedRemoveConfirmation)([s]),
                            analytics: {
                                actionLabel: "Alert label source",
                                actionSource: "Chart",
                                event: "restart"
                            }
                        }).execute()
                    }
                      , l = async()=>{
                        const e = this._alertLabel.alert().id().value()
                          , t = this._alertLabel.alert().isNew();
                        e && !t && (await (0,
                        C.getAlertsActionCreators)()).restartAlert(e, {
                            analytics: {
                                actionLabel: "Alert label source",
                                actionSource: "Chart",
                                event: "restart"
                            }
                        }).execute()
                    }
                      , c = i.stopReason()
                      , u = void 0 !== c
                      , m = {
                        isLeft: T,
                        point: new v.Point(t,d[g]),
                        lineIndex: g,
                        center: i.drawHorzLine(),
                        text: o,
                        textColor: n,
                        additionalText: X(c),
                        additionalTextColor: K(c, _),
                        lineColor: S,
                        backColor: _.connectorBackColor,
                        buttonType: u ? 1 : 0,
                        buttonBorderColor: _.tooltipButtonBorderColor,
                        buttonBackColor: e ? _.tooltipButtonBorderColorHovered : _.connectorBackColor,
                        buttonAction: u ? l : a,
                        restartIconColor: u ? _.restartIconColor : void 0,
                        themeName: this._model.dark().value() ? "dark" : "light"
                    };
                    this._tooltipRenderer.setData(m),
                    this._compositeRenderer.append(this._tooltipRenderer)
                }
            }
        }
        var Z = i(432059)
          , $ = i(347808);
        class J {
            constructor(e) {
                this._renderers = null != e ? e : []
            }
            clear() {
                this._renderers = []
            }
            add(e) {
                this._renderers.push(e)
            }
            draw(e, t, i, s, o) {
                for (const n of this._renderers)
                    n.draw(e, t, i, s, o)
            }
            lastDrawnBodyBox() {
                let e = null;
                for (const t of this._renderers)
                    if (t.lastDrawnBodyBox) {
                        const i = t.lastDrawnBodyBox();
                        if (null !== i) {
                            if (null === e) {
                                e = i;
                                continue
                            }
                            e = (0,
                            v.box)((0,
                            v.point)(Math.min(e.min.x, i.min.x), Math.min(e.min.y, i.min.y)), (0,
                            v.point)(Math.max(e.max.x, i.max.x), Math.max(e.max.y, i.max.y)))
                        }
                    }
                return e
            }
            hitTest(e, t, i) {
                var s, o;
                let n = null;
                for (let r = this._renderers.length - 1; r >= 0; r -= 1) {
                    const a = null === (o = (s = this._renderers[r]).hitTest) || void 0 === o ? void 0 : o.call(s, e, t, i);
                    null != a && (null === n || a.target() > n.target()) && (n = a)
                }
                return n
            }
            topBottomTotalHeight(e) {
                const t = {
                    top: 0,
                    bottom: 0,
                    total: 0
                };
                for (const i of this._renderers) {
                    const s = i.topBottomTotalHeight(e);
                    t.top = Math.max(t.top, s.top),
                    t.bottom = Math.max(t.bottom, s.bottom),
                    t.top = t.top + t.bottom
                }
                return t
            }
            setData(e, t) {
                for (const i of this._renderers)
                    i.setData(e, t)
            }
        }
        var Q = i(968720);
        const ee = new Path2D("M6.21 5.27 1.68 1.06A1 1 0 0 0 0 1.79v8.42a1 1 0 0 0 1.68.73l4.53-4.2a1 1 0 0 0 0-1.47Z");
        class te {
            constructor() {
                this._data = null,
                this._commonData = null,
                this._bodyBox = null
            }
            setData(e, t) {
                this._data = e,
                this._commonData = t
            }
            lastDrawnBodyBox() {
                return this._bodyBox
            }
            draw(e, t, i, s, o) {
                var n;
                const r = this._data
                  , a = this._commonData;
                if (!r || !a)
                    return;
                const l = "right" === o
                  , {horizontalPixelRatio: c, verticalPixelRatio: d, bitmapSize: u, mediaSize: h} = t
                  , {borderSize: p} = i
                  , m = l ? u.width : Math.max(1, Math.floor(p * c));
                e.save(),
                e.fillStyle = null !== (n = r.backgroung) && void 0 !== n ? n : a.background,
                e.translate(m, Math.round((a.coordinate - 6.5 + 1) * d)),
                (0,
                L.drawScaled)(e, l ? -c : c, d, (()=>{
                    e.fill(ee)
                }
                )),
                e.restore();
                {
                    const e = l ? h.width - 7 : 0;
                    this._bodyBox = (0,
                    v.box)((0,
                    v.point)(e, a.coordinate - 6.5), (0,
                    v.point)(e + 7, a.coordinate + 6.5))
                }
            }
            topBottomTotalHeight(e) {
                return {
                    top: 0,
                    bottom: 0,
                    total: 0
                }
            }
            hitTest(e, t, i) {
                return this._data ? (0,
                Q.hittestByData)(this._data, e) : null
            }
        }
        var ie;
        !function(e) {
            e[e.IconMinWidth = 23] = "IconMinWidth"
        }(ie || (ie = {}));
        class se extends $.PriceAxisView {
            constructor(e, t) {
                super(),
                this._collapsedAxisRenderer = new te,
                this._lastDrawnAxisBox = null,
                this._lastDrawnPaneBox = null,
                this._alertLabel = e,
                this._levelIndex = t,
                this._collapsedAxisRenderer.setData(this._axisRendererData, this._commonRendererData)
            }
            renderer() {
                return this._updateRendererDataIfNeeded(),
                this._rendererImpl()
            }
            ignoreAlignment() {
                return !0
            }
            _updateRendererData(e, t, i) {
                var s, o, n, r, a, l;
                if (e.visible = !1,
                t.visible = !1,
                !this._alertLabel.labelVisible())
                    return;
                const c = this._alertLabel.priceScale();
                if (!c)
                    return;
                const d = c.mainSource()
                  , u = null !== d ? d.firstValue() : null;
                if (c.isEmpty() || null === u)
                    return;
                const h = this._alertLabel.priceOfLevel(this._levelIndex);
                if (null === h)
                    return;
                const p = this._alertLabel.colors()
                  , m = this._alertLabel.labelLineColor();
                i.background = (0,
                Z.resetTransparency)(m),
                i.textColor = p.iconColor,
                i.coordinate = c.priceToCoordinate(h, u);
                const g = this._alertLabel.animation();
                if (null !== g) {
                    const e = g.data(performance.now());
                    i.globalAlpha = e.alpha
                } else
                    i.globalAlpha = void 0;
                e.text = c.formatPrice(h, u);
                const _ = null !== (n = null === (o = (s = this._rendererImpl()).lastDrawnBodyBox) || void 0 === o ? void 0 : o.call(s)) && void 0 !== n ? n : this._lastDrawnAxisBox;
                this._lastDrawnAxisBox = null != _ ? _ : this._lastDrawnAxisBox,
                this._lastDrawnAxisBox && (e.hitTestData = {
                    hoverModelFromAxis: !0,
                    itemBox: this._lastDrawnAxisBox,
                    activeItem: this._levelIndex
                });
                const v = null !== (l = null === (a = (r = this._paneRenderer).lastDrawnBodyBox) || void 0 === a ? void 0 : a.call(r)) && void 0 !== l ? l : this._lastDrawnPaneBox;
                this._lastDrawnPaneBox = null != v ? v : this._lastDrawnPaneBox,
                this._lastDrawnPaneBox && (t.hitTestData = {
                    hoverModelFromAxis: !0,
                    itemBox: this._lastDrawnPaneBox,
                    activeItem: this._levelIndex
                }),
                t.hitTarget = b.HitTarget.MovePoint,
                e.hitTarget = b.HitTarget.Regular,
                t.labelIcon = 1,
                t.labelIconMinWidth = ie.IconMinWidth,
                t.visible = !0,
                e.visible = !0
            }
            _rendererImpl() {
                return null === this._alertLabel.animation() ? this._alertLabel.isHovered() || this._alertLabel.isSelected() ? this._axisRenderer : this._collapsedAxisRenderer : new J([this._collapsedAxisRenderer, this._axisRenderer])
            }
        }
        var oe = i(930203);
        const ne = c.sortSourcesPreOrdered.AlertLabel
          , re = c.sortSourcesPreOrdered.AlertLabelInactive
          , ae = 5;
        function le(e) {
            return e instanceof ue
        }
        const ce = {
            newAlertColor: (0,
            n.getHexColorByName)("color-cold-gray-450"),
            inActiveAlertColor: (0,
            n.getHexColorByName)("color-cold-gray-600"),
            inActiveTextBaseColor: (0,
            n.getHexColorByName)("color-cold-gray-450"),
            inActiveTextManualColor: (0,
            n.getHexColorByName)("color-cold-gray-450"),
            inActiveTextTriggeredColor: (0,
            n.getHexColorByName)("color-tan-orange-500"),
            inActiveTextExpiredColor: (0,
            n.getHexColorByName)("color-ripe-red-500"),
            connectorBackColor: (0,
            n.getHexColorByName)("color-cold-gray-900"),
            iconColor: (0,
            n.getHexColorByName)("color-cold-gray-900"),
            restartIconColor: (0,
            n.getHexColorByName)("color-cold-gray-200"),
            tooltipButtonBorderColor: (0,
            n.getHexColorByName)("color-cold-gray-800"),
            tooltipButtonBorderColorHovered: (0,
            n.getHexColorByName)("color-cold-gray-800")
        }
          , de = {
            newAlertColor: (0,
            n.getHexColorByName)("color-cold-gray-450"),
            inActiveAlertColor: (0,
            n.getHexColorByName)("color-cold-gray-300"),
            inActiveTextBaseColor: (0,
            n.getHexColorByName)("color-cold-gray-550"),
            inActiveTextManualColor: (0,
            n.getHexColorByName)("color-cold-gray-550"),
            inActiveTextTriggeredColor: (0,
            n.getHexColorByName)("color-tan-orange-500"),
            inActiveTextExpiredColor: (0,
            n.getHexColorByName)("color-ripe-red-500"),
            connectorBackColor: (0,
            n.getHexColorByName)("color-white"),
            iconColor: (0,
            n.getHexColorByName)("color-white"),
            restartIconColor: (0,
            n.getHexColorByName)("color-cold-gray-900"),
            tooltipButtonBorderColor: (0,
            n.getHexColorByName)("color-cold-gray-100"),
            tooltipButtonBorderColorHovered: (0,
            n.getHexColorByName)("color-cold-gray-100")
        };
        class ue extends l.DataSource {
            constructor(e, t, i, s) {
                super(),
                this._priceAxisViews = [],
                this._paneLabelsPaneViews = [],
                this._propertyMock = new d.Property,
                this._startMovingPoint = null,
                this._currentMovingPoint = null,
                this._animation = null,
                this._onConditionChanged = ()=>{
                    const e = this.alert().condition()
                      , t = e ? "channel" === e.type ? 2 : 1 : 0;
                    if (this._priceAxisViews.length !== t) {
                        for (let e = this._priceAxisViews.length; e < t; e++) {
                            const t = new se(this,e);
                            this._priceAxisViews.push(t),
                            this._paneLabelsPaneViews.push(new u.PanePriceAxisView(t,this,this._model))
                        }
                        this._priceAxisViews = this._priceAxisViews.slice(0, t),
                        this._paneLabelsPaneViews = this._paneLabelsPaneViews.slice(0, t)
                    }
                    this._model.lightUpdate()
                }
                ,
                this._propertyMock.addProperty("visible", !0),
                this._model = e,
                this._alert = t,
                this._alertOwnerSource = i,
                this._paneView = new Y(this,e),
                this._invokeAlertEditor = s,
                this._resetUserEditEnabled(),
                this._hasAlert.setValue(!0),
                this._alertSeriesId = (0,
                o.ensureNotNull)(t.seriesId()),
                this._alertId = t.id().spawn(),
                this._alertId.subscribe(this._resetUserEditEnabled.bind(this)),
                t.onConditionChanged().subscribe(this, this._onConditionChanged),
                this._onConditionChanged(),
                this._isBeingEdited = t.isBeingEdited().spawn(),
                this._isBeingEdited.subscribe(this._resetUserEditEnabled.bind(this)),
                this._selected = t.selected().spawn(),
                this._selected.subscribe(this._onAlertSelectedChanged.bind(this)),
                this._selected.value() && this.canDrawLabelForAlert() && this._selectAlertLabel(),
                this._localFireTime = t.localFireTime().spawn(),
                this._localFireTime.subscribe(this._onAlertFireTimeChanged.bind(this), {
                    callWithLast: !0
                }),
                (0,
                _.getSettingsProperty)().subscribe(this, (()=>e.updateSource(this))),
                this._active = t.active().spawn(),
                this._active.subscribe((()=>e.updateSource(this)))
            }
            destroy() {
                this._alertId.destroy(),
                this._isBeingEdited.destroy(),
                this._localFireTime.destroy(),
                this._active.destroy(),
                this._selected.destroy(),
                (0,
                _.getSettingsProperty)().unsubscribeAll(this),
                this._alert.onConditionChanged().unsubscribeAll(this),
                super.destroy()
            }
            model() {
                return this._model
            }
            zorder() {
                return this.isInactive() ? re : ne
            }
            colors() {
                return {
                    ...this._themedColors(),
                    lineColor: this.labelLineColor()
                }
            }
            alertOwnerSource() {
                return this._alertOwnerSource
            }
            alertSeriesId() {
                return this._alertSeriesId
            }
            alignCrossHairToMovePoint() {
                return !0
            }
            name() {
                return "AlertLabel"
            }
            isSpeciallyZOrderedSource() {
                return !0
            }
            stop() {
                this._alert.id().unsubscribe(this._resetUserEditEnabled),
                this._alert.isBeingEdited().unsubscribe(this._resetUserEditEnabled),
                this._alert.selected().unsubscribe(this._onAlertSelectedChanged)
            }
            alert() {
                return this._alert
            }
            isMoving() {
                return null !== this._startMovingPoint
            }
            isHovered() {
                return this === this._model.hoveredSource()
            }
            isSelected() {
                return this._model.selection().isSelected(this)
            }
            alertId() {
                return this.alert().id().value()
            }
            getAlert() {
                return Promise.resolve(this._alert)
            }
            getAlertSync() {
                return this._alert
            }
            priceOfLevel(e) {
                const t = this.alert().condition();
                return t ? "channel" === t.type ? [t.upper, t.lower][e] : t.price : null
            }
            convertYCoordinateToPriceForMoving(e, t) {
                const i = this.priceScale();
                if (!t || !i || i.isEmpty())
                    return null;
                const s = t.firstValue();
                return null === s ? null : i.coordinateToPrice(e, s)
            }
            isSynchronizable() {
                return !1
            }
            state() {
                const e = this.alert().condition()
                  , t = [];
                return null !== e && ("channel" === e.type ? (t.push({
                    price: e.upper
                }),
                t.push({
                    price: e.lower
                })) : t.push({
                    price: e.price
                })),
                {
                    id: this._id,
                    type: "AlertLabel",
                    zorder: this.zorder(),
                    points: t
                }
            }
            restorePoints(e) {}
            createServerPoints() {}
            properties() {
                return this._propertyMock
            }
            paneViews() {
                return window.TradingView.printing || !this.labelVisible() ? null : [this._paneView]
            }
            topPaneViews() {
                const e = performance.now();
                return null !== this._animation && this._continueOrFinishAnimation(e),
                !window.TradingView.printing && this.labelVisible() && this._animationActive(e) ? (this.updateAllViews((0,
                m.sourceChangeEvent)(this.id())),
                this._paneLabelsPaneViews) : null
            }
            dataWindowView() {
                return null
            }
            priceAxisViews(e, t) {
                return this.labelVisible() && this.priceScale() === t && !this._animationActive() && this.canDrawLabelForAlert() ? this._priceAxisViews : []
            }
            topPriceAxisViews(e, t) {
                const i = performance.now();
                return null !== this._animation && this._continueOrFinishAnimation(i),
                this.priceScale() === t && this._animationActive(i) && this.canDrawLabelForAlert() ? (this.updateAllViews((0,
                m.sourceChangeEvent)(this.id())),
                this._priceAxisViews) : []
            }
            updateAllViews(e) {
                this._paneView.update(),
                this._priceAxisViews.forEach((t=>t.update(e))),
                this._paneLabelsPaneViews.forEach((t=>t.update(e)))
            }
            pointsCount() {
                return 0
            }
            title() {
                return this.alert().title()
            }
            movable() {
                return !this._alert.isBeingEdited().value() && !this._alert.isNew()
            }
            startMoving(e, t, i, s) {
                this._userEditEnabled = !1,
                this._startMovingPoint = e,
                this.alert().startEditing()
            }
            move(e, t, i, s) {
                if (!e.logical || null === t)
                    return;
                const n = e.logical.price
                  , r = this.alert()
                  , a = (0,
                o.ensureNotNull)(r.condition());
                if (this._currentMovingPoint = {
                    ...e
                },
                "channel" === a.type) {
                    let {upper: e, lower: i} = a;
                    const s = this._alertOwnerSource.base() || 100;
                    0 === t ? (0,
                    o.ensureDefined)(this._currentMovingPoint.logical).price = e = Math.max(n, i + 1 / s) : 1 === t && ((0,
                    o.ensureDefined)(this._currentMovingPoint.logical).price = i = Math.min(n, e - 1 / s)),
                    r.setCondition({
                        ...a,
                        lower: i,
                        upper: e
                    })
                } else
                    r.setCondition({
                        type: "price",
                        price: n
                    })
            }
            endMoving() {
                const e = this._startMovingPoint
                  , t = this._currentMovingPoint;
                if (this._userEditEnabled = !0,
                this._startMovingPoint = null,
                this._currentMovingPoint = null,
                !e || !t || e === t)
                    return;
                (0,
                g.trackEvent)("chart_alert", "edit", "move"),
                this._invokeAlertEditor({
                    dataSourceHub: this._model,
                    alert: this.alert(),
                    type: "edit_alert",
                    onEditCancel: ()=>{
                        setTimeout((async()=>{
                            if (this.isInactive()) {
                                const e = this.alert().id().value();
                                void 0 !== e && (await (0,
                                C.getAlertsActionCreators)()).restartAlert(e, {
                                    analytics: {
                                        actionLabel: "Alert label source",
                                        actionSource: "Chart",
                                        event: "restart"
                                    }
                                }).execute()
                            } else
                                this.alert().abortEditing();
                            this._model.lightUpdate()
                        }
                        ), 0)
                    }
                    ,
                    silent: !0,
                    actionSource: "alert_label_move",
                    onAborted: ()=>this.alert().abortEditing()
                })
            }
            currentMovingPoint() {
                return this._currentMovingPoint
            }
            showInObjectTree() {
                return !1
            }
            isRemovedByStudyTemplates() {
                return !1
            }
            isUserDeletable() {
                return !1
            }
            doesMovingAffectsUndo() {
                return !1
            }
            drawHorzLine() {
                return this.labelLineVisible()
            }
            canDrawLabelForAlert() {
                const e = this.alert()
                  , t = this._model.mainSeries()
                  , i = t && t.properties().childs()
                  , s = i && i.style && i.style.value()
                  , o = (0,
                p.isRangeBasedStyle)(s) ? s : null
                  , n = e.crossInterval() || h.Interval.isEqual(e.resolution(), t.interval())
                  , r = e.rangeBasedStyle() === o;
                return e.isPrice() && n && r
            }
            labelVisible() {
                const e = this._alertOwnerSource.symbolSource();
                if (e && (e.isConvertedToOtherCurrency() || e.isConvertedToOtherUnit()))
                    return !1;
                if (this._model.isInReplay().value())
                    return !1;
                if (!this.isInactive())
                    return (0,
                    _.getSettingsProperty)().childs().visible.value();
                const t = this.stopReason();
                return void 0 !== t && (t === r.AlertStopReason.Created || this._animationActive() || !this.showOnlyActive())
            }
            labelLineColor() {
                const e = (0,
                _.getSettingsProperty)().childs().line.childs().color.value()
                  , t = e || (0,
                _.getAlertColorLineByTheme)(this.model());
                if (null !== this._animation)
                    return (0,
                    o.ensureDefined)(t);
                const i = this._themedColors();
                return this._alert.isNew() ? (0,
                o.ensureDefined)(i.newAlertColor) : this._alert.active().value() || this._alert.stopReason() === r.AlertStopReason.Created ? t : (0,
                o.ensureDefined)(i.inActiveAlertColor)
            }
            labelLineVisible() {
                return (0,
                _.getSettingsProperty)().childs().line.childs().visible.value()
            }
            showOnlyActive() {
                return (0,
                _.getSettingsProperty)().childs().showOnlyActive.value()
            }
            stopReason() {
                return this.isInactive() ? this._alert.stopReason() : void 0
            }
            animation() {
                return this._animation
            }
            isInactive() {
                return !this._alert.active().value() && !this._alert.isNew()
            }
            _themedColors() {
                return this._model.dark().value() ? ce : de
            }
            _resetUserEditEnabled() {
                const e = this._alert;
                this._userEditEnabled = !(e.isBeingEdited().value() || e.isNew() || !e.isPrice() || null === e.condition())
            }
            _onAlertSelectedChanged(e) {
                this.canDrawLabelForAlert() && (e ? this._selectAlertLabel() : this._unselectAlertLabel())
            }
            _selectAlertLabel() {
                this._model.selectionMacro((e=>{
                    e.selection().isSelected(this) || (e.clearSelection(),
                    e.addSourceToSelection(this))
                }
                ))
            }
            _unselectAlertLabel() {
                this._model.selectionMacro((e=>{
                    e.selection().isSelected(this) && e.removeSourceFromSelection(this)
                }
                ))
            }
            _onAlertFireTimeChanged(e) {
                var t, i;
                null !== e && (this._animation = (t = e,
                i = this.isHovered() || this.isSelected() ? 1 : 0,
                {
                    finished: e=>e - t >= 2400,
                    data: e=>{
                        const s = Math.min(e - t, 2400) % 1200
                          , o = s % 600
                          , n = Math.round(s / 1200)
                          , r = (0,
                        oe.easingFunc.linear)(o / 600);
                        return {
                            alpha: 0 === n == (0 === i) ? r : 1 - r
                        }
                    }
                }),
                this._model.updateSource(this))
            }
            _continueOrFinishAnimation(e) {
                (0,
                o.ensureNotNull)(this._animation).finished(e) ? (this._animation = null,
                this._model.updateSource(this)) : this._model.invalidate(a.InvalidationMask.cursor())
            }
            _animationActive(e=performance.now()) {
                return null !== this._animation && !this._animation.finished(e)
            }
        }
    }
    ,
    436207: (e,t,i)=>{
        "use strict";
        i.d(t, {
            AppliedTimeFrame: ()=>o
        });
        var s = i(566238);
        class o {
            constructor(e) {
                this._appliedTimeFrame = new s.WatchedObject(null),
                this._appliedTimeFrameInfo = null,
                this._appliedTimeFrameChangedBound = this._appliedTimeFrameChanged.bind(this),
                this._model = e,
                e.mainSeries().dataEvents().seriesTimeFrame().subscribe(this, this._onSeriesTimeFrame),
                this._appliedTimeFrame.subscribe(this._appliedTimeFrameChangedBound)
            }
            destroy() {
                this._appliedTimeFrame.unsubscribe(this._appliedTimeFrameChangedBound),
                this._model.timeScale().logicalRangeChanged().unsubscribeAll(this),
                this._model.mainSeries().dataEvents().seriesTimeFrame().unsubscribeAll(this)
            }
            appliedTimeFrame() {
                return this._appliedTimeFrame
            }
            _appliedTimeFrameChanged() {
                this._model.timeScale().logicalRangeChanged().unsubscribe(this, this._invalidateAppliedTimeFrame)
            }
            _onSeriesTimeFrame(e, t, i, s) {
                if (s) {
                    const e = this._model.timeScale();
                    this._appliedTimeFrameInfo = {
                        logicalRange: e.logicalRange(),
                        baseIndex: e.baseIndex()
                    },
                    e.logicalRangeChanged().subscribe(this, this._invalidateAppliedTimeFrame)
                }
            }
            _invalidateAppliedTimeFrame() {
                if (null === this._appliedTimeFrameInfo)
                    return;
                const e = this._model.timeScale()
                  , t = e.logicalRange()
                  , i = e.baseIndex()
                  , s = this._appliedTimeFrameInfo.logicalRange
                  , o = this._appliedTimeFrameInfo.baseIndex;
                (null === t || null === s || Math.abs(i - t.left() - (o - s.left())) >= .01 || Math.abs(i - t.right() - (o - s.right())) >= .01) && this._appliedTimeFrame.setValue(null)
            }
        }
    }
    ,
    496416: (e,t,i)=>{
        "use strict";
        i.d(t, {
            defaultsPreferencesByWhiteList: ()=>k,
            preferencesByWhiteList: ()=>E
        });
        var s = i(124829)
          , o = i(779732)
          , n = i(725356)
          , r = i(338619)
          , a = i(675490)
          , l = i(707311)
          , c = i(45003)
          , d = i(201871)
          , u = i(166770);
        const h = {
            visible: !1,
            lineStyle: i(666574).LINESTYLE_DOTTED,
            lineWidth: 1,
            bidLineColor: u.colorsPalette["color-tv-blue-500"],
            askLineColor: u.colorsPalette["color-ripe-red-400"]
        };
        var p = i(954384)
          , m = i(668846)
          , g = i(255866);
        const _ = {
            ...n.candleStylePreferencesDefault,
            deltaAdjust: !0,
            showSummary: !0,
            type: g.VolumeFootprintTypeValues.BuyAndSell,
            pointOfControl: !0,
            bgColors: m.lightTheme.content.mainSourceProperties.volFootprintStyle.bgColors,
            imbalanceHighlight: {
                buyColor: (0,
                u.getHexColorByName)("color-minty-green-500"),
                sellColor: (0,
                u.getHexColorByName)("color-ripe-red-500"),
                visible: !0
            },
            inputs: {
                rowSize: "Auto",
                atrLength: 14,
                imbalancePercent: 300,
                ticksPerRow: 100,
                showVA: !0,
                vaPercent: 70,
                calcStackedImbalance: !1,
                stackedImbalanceCount: 3
            }
        };
        var v = i(394954)
          , S = i(548544);
        const f = (0,
        r.getLogger)("Chart.ApplyPreferencesToAllCharts")
          , b = {
            color: "",
            style: 0
        }
          , y = {
            autoScale: !1,
            autoScaleDisabled: !1,
            lockScale: !1,
            percentage: !1,
            percentageDisabled: !1,
            log: !1,
            logDisabled: !1,
            alignLabels: !1,
            isInverted: !1,
            indexedTo100: !1
        }
          , C = {
            backgroundType: d.ColorType.Solid,
            background: "",
            backgroundGradientStartColor: "",
            backgroundGradientEndColor: "",
            topMargin: 0,
            bottomMargin: 0,
            gridLinesMode: "both",
            horzGridProperties: (0,
            c.deepExtend)({}, b),
            vertGridProperties: (0,
            c.deepExtend)({}, b),
            crossHairProperties: (0,
            c.deepExtend)({}, {
                color: "",
                style: 0,
                transparency: 0,
                width: 0
            }),
            legendProperties: (0,
            c.deepExtend)({}, {
                showStudyArguments: !1,
                showStudyTitles: !1,
                showStudyValues: !1,
                showSeriesTitle: !1,
                showSeriesOHLC: !1,
                showLegend: !1,
                showLastDayChange: !1,
                showBarChange: !0,
                showVolume: !1,
                showPriceSource: !1,
                showBackground: !0,
                backgroundTransparency: 0,
                showLogo: !0
            }),
            axisProperties: (0,
            c.deepExtend)({}, y),
            separatorColor: ""
        }
          , w = {
            lineColor: "",
            textColor: "",
            fontSize: 0,
            scaleSeriesOnly: !1,
            showSeriesLastValue: !1,
            seriesLastValueMode: a.PriceAxisLastValueMode.LastValueAccordingToScale,
            showSeriesPrevCloseValue: !1,
            showStudyLastValue: !1,
            showSymbolLabels: !1,
            showStudyPlotLabels: !1,
            showBidAskLabels: !1,
            showPrePostMarketPriceLabel: !0,
            showFundamentalLastValue: !1,
            showFundamentalNameLabel: !1,
            showPriceScaleCrosshairLabel: !0,
            showTimeScaleCrosshairLabel: !0
        }
          , T = {
            ...w
        }
          , P = {
            visible: !1,
            futureOnly: !1,
            breaks: (0,
            c.deepExtend)({}, {
                color: "",
                visible: !1,
                style: 0,
                width: 0
            })
        }
          , x = {
            style: 0,
            minTick: "",
            showPriceLine: !1,
            priceLineWidth: 0,
            priceLineColor: "",
            baseLineColor: "",
            showPrevClosePriceLine: !1,
            showCountdown: !0,
            prevClosePriceLineWidth: 0,
            sessionId: "regular",
            prevClosePriceLineColor: "",
            esdShowDividends: !1,
            esdShowSplits: !1,
            esdShowEarnings: !1,
            esdShowBreaks: !1,
            showContinuousContractSwitches: !1,
            showContinuousContractSwitchesBreaks: !1,
            showFuturesContractExpiration: !1,
            showLastNews: !1,
            showKeyFactsToday: !1,
            dividendsAdjustment: !1,
            backAdjustment: !1,
            settlementAsClose: !0,
            statusViewStyle: (0,
            c.deepExtend)({}, {
                fontSize: 16,
                showExchange: !0,
                showInterval: !0,
                symbolTextSource: "description"
            }),
            priceAxisProperties: (0,
            c.deepExtend)({}, y),
            bidAsk: (0,
            c.deepExtend)({}, h),
            prePostMarket: (0,
            c.deepExtend)({}, p.defaultPrePostMarketPreferences),
            volFootprintStyle: (0,
            c.deepExtend)({}, _),
            tpoStyle: (0,
            c.deepExtend)({}, v.tpoStylePreferencesDefault),
            volCandlesStyle: (0,
            c.deepExtend)({}, n.candleStylePreferencesDefault),
            svpStyle: (0,
            c.deepExtend)({}, S.svpStylePreferencesDefault),
            highLowAvgPrice: (0,
            c.deepExtend)({}, {
                highLowPriceLinesVisible: !1,
                highLowPriceLabelsVisible: !1,
                averageClosePriceLabelVisible: !1,
                averageClosePriceLineVisible: !1,
                highLowPriceLinesColor: "",
                highLowPriceLinesWidth: 0,
                averagePriceLineColor: "",
                averagePriceLineWidth: 0
            }),
            candleStyle: (0,
            c.deepExtend)({}, n.candleStylePreferencesDefault),
            hollowCandleStyle: (0,
            c.deepExtend)({}, n.hollowCandlePreferencesStyleDefault),
            barStyle: (0,
            c.deepExtend)({}, n.barStylePreferencesDefault),
            lineStyle: (0,
            c.deepExtend)({}, n.lineStyleDefault),
            lineWithMarkersStyle: (0,
            c.deepExtend)({}, n.lineStyleDefault),
            steplineStyle: (0,
            c.deepExtend)({}, n.lineStyleDefault),
            areaStyle: (0,
            c.deepExtend)({}, n.areaStylePreferencesDefault),
            hlcAreaStyle: (0,
            c.deepExtend)({}, n.hlcAreaStylePreferencesDefault),
            baselineStyle: (0,
            c.deepExtend)({}, n.baselineStylePreferencesDefault),
            hiloStyle: (0,
            c.deepExtend)({}, n.hiloStylePreferencesDefault),
            haStyle: (0,
            c.deepExtend)({}, n.haStylePreferencesDefault),
            renkoStyle: (0,
            c.deepExtend)({}, n.renkoStylePreferencesDefault),
            pbStyle: (0,
            c.deepExtend)({}, n.pbStylePreferencesDefault),
            kagiStyle: (0,
            c.deepExtend)({}, n.kagiStylePreferencesDefault),
            pnfStyle: (0,
            c.deepExtend)({}, n.pnfStylePreferencesDefault),
            rangeStyle: (0,
            c.deepExtend)({}, n.rangeStylePreferencesDefault),
            columnStyle: (0,
            c.deepExtend)({}, n.columnStylePreferencesDefault)
        }
          , M = {
            priceScaleSelectionStrategyName: "auto",
            timeScale: (0,
            c.deepExtend)({}, {
                defaultRightOffset: 0,
                defaultRightOffsetPercentage: 5,
                usePercentageRightOffset: !1
            }),
            mainSeries: (0,
            c.deepExtend)({}, x),
            sessions: (0,
            c.deepExtend)({}, l.sessionsPreferencesDefault),
            paneProperties: (0,
            c.deepExtend)({}, C),
            chartEventsSourceProperties: (0,
            c.deepExtend)({}, P),
            tradingProperties: (0,
            c.deepExtend)({}, o.tradingPreferencesDefault)
        }
          , I = {
            timezone: "",
            scalesProperties: (0,
            c.deepExtend)({}, T),
            ...M
        }
          , A = {
            scalesProperties: (0,
            c.deepExtend)({}, w),
            ...M
        };
        function L(e, t, i, o, n=!0) {
            if (void 0 === t[e])
                return f.logDebug(`We haven't had this property ${o}.${e} yet, please, remove it from whiteList`),
                null;
            if ((0,
            s.isObject)(i[e])) {
                const s = Object.keys(i[e]);
                let r = "";
                return s.map((s=>({
                    [s]: L(s, t[e], i[e], `${o}.${e}`, n)
                }))).reduce(((e,t)=>(r = Object.keys(t)[0],
                e[r] = t[r],
                e)), {})
            }
            return n ? t[e].value() : t[e]
        }
        function E(e, t, i=I) {
            const s = {
                timezone: "",
                priceScaleSelectionStrategyName: "auto",
                timeScale: {
                    defaultRightOffset: e.timeScale().defaultRightOffset().value(),
                    defaultRightOffsetPercentage: e.timeScale().defaultRightOffsetPercentage().value(),
                    usePercentageRightOffset: e.timeScale().usePercentageRightOffset().value()
                },
                mainSeries: {},
                sessions: {},
                paneProperties: {},
                scalesProperties: {},
                chartEventsSourceProperties: {},
                tradingProperties: {}
            }
              , o = ["timeScale", "mainSeries", "sessions"]
              , n = i.mainSeries
              , r = Object.keys(i)
              , a = Object.keys(n)
              , l = t.properties()
              , c = e.sessions().properties()
              , d = e.properties()
              , u = i.sessions
              , h = Object.keys(u);
            return a.forEach((e=>{
                s.mainSeries[e] = L(e, l, n, "mainSeries")
            }
            )),
            h.forEach((e=>{
                s.sessions[e] = L(e, c, u, "sessions")
            }
            )),
            r.forEach((e=>{
                o.includes(e) || (s[e] = L(e, d, i, "preferences"))
            }
            )),
            s
        }
        function k(e, t, i=A, s=!0) {
            const o = {
                timeScale: {
                    defaultRightOffset: e.timeScale().rightOffsetDefaultValue(),
                    defaultRightOffsetPercentage: e.timeScale().defaultRightOffsetPercentage().value(),
                    usePercentageRightOffset: e.timeScale().usePercentageRightOffset().value()
                },
                mainSeries: {},
                sessions: {},
                paneProperties: {},
                scalesProperties: {},
                chartEventsSourceProperties: {},
                tradingProperties: {},
                priceScaleSelectionStrategyName: "auto"
            }
              , n = ["timeScale", "mainSeries", "sessions"]
              , r = i.mainSeries
              , a = Object.keys(i)
              , l = Object.keys(r)
              , c = i.sessions
              , d = Object.keys(c)
              , u = e.mainSeries().properties().factoryDefaults()
              , h = e.properties().factoryDefaults()
              , p = e.sessions().properties().factoryDefaults();
            return l.forEach((e=>{
                s && "style" === e || (o.mainSeries[e] = L(e, u, r, "mainSeries", !1))
            }
            )),
            a.forEach((e=>{
                n.includes(e) || (o[e] = L(e, h, i, "preferences", !1))
            }
            )),
            d.forEach((e=>{
                o.sessions[e] = L(e, p, c, "sessions", !1)
            }
            )),
            o
        }
    }
    ,
    883188: (e,t,i)=>{
        "use strict";
        i.d(t, {
            actualAutoLogButtonsVisibility: ()=>a,
            autoLogButtonsVisibilityOptions: ()=>n,
            autoLogButtonsVisibilityProperty: ()=>o,
            restoreAutoLogButtonsVisibilitySettingsValue: ()=>r
        });
        var s = i(154241);
        const {property: o, availableValues: n, restoreDefaultValue: r, actualBehavior: a} = (0,
        s.createVisibilityController)("PriceAxisAutoLogButtons.visibility")
    }
    ,
    443874: (e,t,i)=>{
        "use strict";
        i.d(t, {
            BarsMarksContainer: ()=>g
        });
        var s = i(650151)
          , o = i(338619)
          , n = i(62802)
          , r = i.n(n)
          , a = i(953297)
          , l = i(378975)
          , c = i(124829)
          , d = i(975179)
          , u = i(903424)
          , h = i(169532);
        const p = (0,
        o.getLogger)("Chart.BarsMarksContainer")
          , m = Math.round(new Date(2037,0,1).getTime() / 1e3);
        class g extends u.DataSource {
            constructor(e, t, i) {
                const o = e.onWidget();
                let n;
                n = o ? !e.hideIdeas() : !!a.enabled("bars_marks") && r().getBool("BarsMarksContainer.visibile", !1),
                t.merge({
                    visible: n
                }),
                t.childs().visible.subscribe(null, (t=>{
                    o || e.isSnapshot() || !a.enabled("bars_marks") || r().setValue("BarsMarksContainer.visibile", !!t.value())
                }
                )),
                super(i),
                this._paneViews = [],
                this._model = e,
                this._properties = t,
                this._requests = [],
                this._marks = {},
                this._loadedRange = null,
                this._getDataTimeout = null,
                this._collectedRange = null,
                this._lastRange = null;
                const l = this._model.mainSeries();
                l.onSymbolIntervalChanged().subscribe(this, this.clearMarks),
                l.dataEvents().symbolResolved().subscribe(this, this.clearMarks),
                l.dataEvents().completed().subscribe(this, (()=>{
                    var e, t;
                    const i = l.data();
                    if (0 === i.size())
                        return;
                    const o = (0,
                    s.ensureNotNull)(i.first()).index
                      , n = (0,
                    s.ensureNotNull)(i.last()).index
                      , r = this.timeScale();
                    this.getData({
                        start: null !== (e = r.indexToTimePoint(o)) && void 0 !== e ? e : 1 / 0,
                        end: null !== (t = r.indexToTimePoint(n)) && void 0 !== t ? t : -1 / 0
                    })
                }
                )),
                this._initialize(),
                this._pinnedTooltips = {}
            }
            destroy() {
                const e = this._model.mainSeries();
                e.onSymbolIntervalChanged().unsubscribeAll(this),
                e.dataEvents().symbolResolved().unsubscribeAll(this),
                e.dataEvents().completed().unsubscribeAll(this),
                super.destroy()
            }
            properties() {
                return this._properties
            }
            marks() {
                return this._marks
            }
            pinTooltip(e, t) {
                this._pinnedTooltips[e] = t
            }
            timeScale() {
                return this._model.timeScale()
            }
            getIntervalInTicks() {
                const e = this._model.mainSeries().properties().childs().interval.value()
                  , t = l.Interval.parse(e);
                if (!t.isValid())
                    throw new TypeError("Unexpected interval");
                return t.isRange() ? 60 : t.inMilliseconds() / 1e3
            }
            getVisibleTickMarksRange() {
                var e, t;
                if (this.timeScale().isEmpty())
                    return {
                        start: 0,
                        end: 0
                    };
                const i = (0,
                s.ensureNotNull)(this.timeScale().visibleBarsStrictRange())
                  , {firstIndex: o, lastIndex: n} = (0,
                s.ensureNotNull)(this.timeScale().points().range().value());
                if (!(i.lastBar() > o && i.firstBar() < n))
                    return {
                        start: 0,
                        end: 0
                    };
                let r;
                r = i.lastBar() < n ? this.timeScale().indexToTimePoint(i.lastBar()) : m;
                const a = {
                    start: this.timeScale().indexToTimePoint(Math.max(i.firstBar(), o)),
                    end: r
                };
                return {
                    start: null !== (e = a.start) && void 0 !== e ? e : 1 / 0,
                    end: null !== (t = a.end) && void 0 !== t ? t : -1 / 0
                }
            }
            getVisibleRangePlates() {
                const e = []
                  , t = this.getVisibleTickMarksRange()
                  , i = this.getIntervalInTicks();
                return Object.keys(this._marks).forEach((s=>{
                    var o, n;
                    const r = this._marks[s]
                      , a = r.tickmark;
                    a >= (null !== (o = t.start) && void 0 !== o ? o : 1 / 0) && a <= (null !== (n = t.end) && void 0 !== n ? n : -1 / 0) + i && e.push(r)
                }
                )),
                e
            }
            getPublishedPlates() {
                const e = {};
                return window.is_authenticated ? (this.getVisibleRangePlates().forEach((t=>{
                    t.is_public && (this._pinnedTooltips[t.id] || t.user__id === window.user.id) && (e[t.id] = t)
                }
                )),
                e) : e
            }
            filterDisplayedPlates(e) {
                const t = e.reduce(((e,t)=>{
                    const i = this._getIndex(t.tickmark);
                    return null !== i && (e[i] = e[i] || [],
                    e[i].push(t)),
                    e
                }
                ), {});
                return Object.keys(t).reduce(((e,i)=>{
                    let s = t[i];
                    return s = s.sort(((e,t)=>t.views_count - e.views_count)),
                    s = s.slice(0, 10),
                    e.concat(s)
                }
                ), [])
            }
            getPlatesViewData() {
                var e, t, i;
                const o = this._model.mainSeries();
                if (o.data().isEmpty())
                    return [];
                const n = (0,
                d.isPriceSourceStyle)(o.style()) ? o.barFunction() : null
                  , r = this.filterDisplayedPlates(this.getVisibleRangePlates())
                  , a = {}
                  , l = null !== (e = this._model.lastHittestData()) && void 0 !== e ? e : this._model.lastSelectedHittestData();
                let c = null;
                null !== l && this._model.hoveredSource() === this && (c = null !== (t = l.activeItem) && void 0 !== t ? t : null);
                const u = [];
                for (const e of r) {
                    const t = (0,
                    s.ensureNotNull)(this._getIndex(e.tickmark))
                      , i = this._getBar(t);
                    if (null === i)
                        continue;
                    const o = this._layout(e.direction)
                      , r = this._theme(e.direction)
                      , l = c === e.id
                      , d = this.timeScale().indexToCoordinate(t)
                      , h = this._offset(o, i, n)
                      , p = (0,
                    s.ensureNotNull)(this.priceScale()).isInverted();
                    let m = 0;
                    t in a || (a[t] = {
                        up: 0,
                        down: 0
                    }),
                    m = a[t][o]++,
                    u.push({
                        id: e.id,
                        x: d,
                        y: h,
                        yInverted: p,
                        order: m,
                        direction: o,
                        theme: r,
                        hovered: l,
                        pinned: !0 === this._pinnedTooltips[e.id],
                        user__id: e.user__id,
                        label: e.label,
                        labelFontColor: e.labelFontColor || "#444",
                        minSize: e.minSize || 5,
                        ...this._plateViewData(e)
                    })
                }
                const h = u.filter((e=>!0 === e.hovered));
                for (let e = 0; e < r.length; e++)
                    r[e].user__id === (null === (i = h[0]) || void 0 === i ? void 0 : i.user__id) && (r[e].highlightByAuthor = !0);
                return u.sort(((e,t)=>e.hovered && !t.hovered ? 1 : 0)),
                u
            }
            priceAxisViews() {
                return null
            }
            updateAllViews(e) {
                for (const t of this._paneViews)
                    t.update(e)
            }
            updateAllViewsAndRepaint() {
                this.updateAllViews((0,
                h.sourceChangeEvent)(this.id())),
                this._model.updateSource(this)
            }
            roundRange(e) {
                return {
                    start: Math.round(e.start),
                    end: Math.round(e.end)
                }
            }
            refreshData() {
                null !== this._lastRange && this.getData(this._lastRange)
            }
            getData(e) {
                (0,
                c.isNumber)(e.start) && (0,
                c.isNumber)(e.end) ? (this._lastRange = e,
                e.end = m,
                this._pushGetDataStack(Object.assign({}, e))) : p.logError("Wrong range")
            }
            clearMarks() {
                this._abortAllRequests(),
                this._marks = {},
                this._loadedRange = null
            }
            isUserDeletable() {
                return !1
            }
            isSavedInChart(e) {
                return !1
            }
            isSpeciallyZOrderedSource() {
                return !0
            }
            showInObjectTree() {
                return !1
            }
            _plateViewData(e) {
                return {}
            }
            _layout(e) {
                switch (e) {
                default:
                case 0:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    return "up";
                case 1:
                    return "down"
                }
            }
            _theme(e) {
                switch (e) {
                default:
                case 0:
                    return "neutral";
                case 1:
                case 5:
                    return "green";
                case 2:
                case 6:
                    return "red";
                case 3:
                    return "yellow";
                case 4:
                    return "blue"
                }
            }
            _offset(e, t, i) {
                let o;
                switch (e) {
                default:
                case "up":
                    o = null === i ? t[2] : i(t);
                    break;
                case "down":
                    o = null === i ? t[3] : i(t)
                }
                return (0,
                s.ensureNotNull)(this.priceScale()).priceToCoordinate(o, (0,
                s.ensureNotNull)((0,
                s.ensureNotNull)(this.ownerSource()).firstValue()))
            }
            _getIndex(e) {
                return this.timeScale().timePointToIndex(e)
            }
            _getBar(e) {
                return this._model.mainSeries().data().valueAt(e)
            }
            _rangeDifference(e) {
                return e = Object.assign({
                    start: 1 / 0,
                    end: -1 / 0
                }, e),
                this._loadedRange && (e.start < this._loadedRange.start ? e.end = this._loadedRange.start : e.end > this._loadedRange.end && (e.start = this._loadedRange.end)),
                e
            }
            _rangeUnion(e, t) {
                return e = Object.assign({
                    start: 1 / 0,
                    end: -1 / 0
                }, e),
                t && (e.start = Math.min(t.start, e.start),
                e.end = Math.max(t.end, e.end)),
                e
            }
            _pushGetDataStack(e) {
                (0,
                c.isNumber)(e.start) && (0,
                c.isNumber)(e.end) ? (this._getDataTimeout && clearTimeout(this._getDataTimeout),
                this._collectedRange = this._rangeUnion(e, this._collectedRange),
                this._getDataTimeout = setTimeout((()=>{
                    this._getData(this._collectedRange),
                    this._getDataTimeout = this._collectedRange = null
                }
                ), 300)) : p.logError("Wrong tickmark range")
            }
            _abortAllRequests() {
                this._requests.forEach((e=>{
                    e.cancel()
                }
                )),
                this._requests = [],
                this._getDataTimeout && clearTimeout(this._getDataTimeout),
                this._getDataTimeout = this._collectedRange = null
            }
        }
    }
    ,
    331218: (e,t,i)=>{
        "use strict";
        i.d(t, {
            BarsRange: ()=>o
        });
        var s = i(650151);
        class o {
            constructor(e, t) {
                (0,
                s.assert)(e <= t, "The last bar in the bars range should be greater than or equal to the first bar"),
                this._firstBar = e,
                this._lastBar = t
            }
            firstBar() {
                return this._firstBar
            }
            lastBar() {
                return this._lastBar
            }
            count() {
                return this._lastBar - this._firstBar + 1
            }
            contains(e) {
                return this._firstBar <= e && e <= this._lastBar
            }
            unite(e) {
                return null === e ? this : new o(Math.min(this._firstBar, e.firstBar()),Math.max(this._lastBar, e.lastBar()))
            }
            equals(e) {
                return this._firstBar === e.firstBar() && this._lastBar === e.lastBar()
            }
            static compare(e, t) {
                return null === e || null === t ? e === t : e.equals(t)
            }
        }
    }
    ,
    508918: (e,t,i)=>{
        "use strict";
        var s;
        i.d(t, {
            ChartEventsSourceId: ()=>s
        }),
        function(e) {
            e.Value = "ChartEventsSource"
        }(s || (s = {}))
    }
    ,
    647042: (e,t,i)=>{
        "use strict";
        i.d(t, {
            ChartModelBase: ()=>lo
        });
        var s = i(290484)
          , o = i(920057)
          , n = i(154834)
          , r = i(650151)
          , a = i(86441)
          , l = i(724377)
          , c = i(166770)
          , d = i(444372)
          , u = i(909740)
          , h = i(308721)
          , p = i(61499)
          , m = i(668846)
          , g = i(345848)
          , _ = i(955273)
          , v = i(251954)
          , S = i(49437)
          , f = i(120984)
          , b = i(779732)
          , y = i(803279)
          , C = i(828473)
          , w = i(938614)
          , T = i(465836);
        function P(e) {
            return (0,
            T.isLineTool)(e) && e.boundToSymbol() || (0,
            w.isAlertLabel)(e)
        }
        class x {
            constructor() {
                this._items = [],
                this._set = new Set,
                this._dataSourcesCache = null,
                this._customSourcesCache = null,
                this._lineSourcesCache = null
            }
            isEmpty() {
                return 0 === this._items.length
            }
            add(e) {
                if (this._items.length > 0 && !P(this._items[0]) && this.clear(),
                P(e)) {
                    const t = (0,
                    C.lowerbound)(this._items, e, ((e,t)=>e.zorder() < t.zorder()));
                    this._items.splice(t, 0, e)
                } else
                    this.clear(),
                    this._items = [e];
                this._set.add(e),
                this._invalidateCache()
            }
            canBeAddedToSelection(e) {
                return 0 === this._items.length || P(this._items[0]) && P(e)
            }
            isSelected(e) {
                return this._set.has(e)
            }
            allSources() {
                return this._items.slice(0)
            }
            dataSources() {
                return null === this._dataSourcesCache && (this._dataSourcesCache = this._items.filter(y.isDataSource)),
                this._dataSourcesCache
            }
            lineDataSources() {
                return null === this._lineSourcesCache && (this._lineSourcesCache = this._items.filter(T.isLineTool)),
                this._lineSourcesCache
            }
            customSources() {
                return null === this._customSourcesCache && (this._customSourcesCache = this._items.filter((e=>!(0,
                y.isDataSource)(e)))),
                this._customSourcesCache
            }
            checkLineToolSelection() {
                this._items.forEach((e=>(0,
                T.isLineTool)(e) && e.calcIsActualSymbol())),
                this._items = this._items.filter((e=>!(0,
                T.isLineTool)(e) || e.isActualSymbol())),
                this._invalidateCache()
            }
            remove(e) {
                this._items = this._items.filter((t=>t !== e)),
                this._set.delete(e),
                this._invalidateCache()
            }
            clear() {
                this._items = [],
                this._set.clear(),
                this._invalidateCache()
            }
            _invalidateCache() {
                this._customSourcesCache = null,
                this._dataSourcesCache = null,
                this._lineSourcesCache = null
            }
        }
        var M = i(218049)
          , I = i(872842)
          , A = i(971899)
          , L = i(378975)
          , E = i(262624)
          , k = i(658843)
          , D = i(970427)
          , N = i(694852)
          , B = i(511275);
        class R {
            constructor(e) {
                this._rendererOptions = {
                    borderSize: 1,
                    additionalPaddingInner: 0,
                    fontSize: NaN,
                    font: "",
                    color: "",
                    paneBackgroundColor: "",
                    paddingBottom: 0,
                    paddingInner: 0,
                    paddingOuter: 0,
                    paddingTop: 0,
                    lineSpacing: 0
                },
                this._chartModel = e
            }
            options() {
                const e = this._rendererOptions
                  , t = this._chartModel.properties().childs()
                  , i = t.scalesProperties.childs().fontSize.value();
                return e.fontSize !== i && (e.fontSize = i,
                e.font = (0,
                N.makeFont)(i, B.CHART_FONT_FAMILY, ""),
                e.paddingTop = i / 12 * 2.5,
                e.paddingBottom = i / 12 * 2.5,
                e.paddingInner = i / 12 * 4,
                e.additionalPaddingInner = i / 12 * 4,
                e.paddingOuter = i / 12 * 4,
                e.lineSpacing = i / 12 * 2),
                e.color = t.scalesProperties.childs().textColor.value(),
                e.paneBackgroundColor = t.paneProperties.childs().background.value(),
                this._rendererOptions
            }
        }
        var O = i(850723)
          , V = i(211183)
          , W = i(975179)
          , F = i(707311);
        function H(e) {
            e.hasChild("properties") && (e.removeProperty("properties"),
            (0,
            E.allowSavingDefaults)(!0),
            e.childChanged(null, ""),
            (0,
            E.allowSavingDefaults)(!1))
        }
        class z extends f.AsyncResourceWrapper {
            constructor(e, t, i) {
                super(e, (e=>e.destroy())),
                this._sessionsStateData = null,
                this._model = t,
                this._properties = i,
                t.mainSeries().sessionIdProxyProperty().subscribe(this, this._updateVisibleOfPreAndPostMarketBackground),
                this._updateVisibleOfPreAndPostMarketBackground(t.mainSeries().properties().childs().sessionId),
                e.then((e=>{
                    !this._destroyed && this._sessionsStateData && (e.restoreStateData(this._sessionsStateData),
                    this._sessionsStateData = null)
                }
                ))
            }
            destroy() {
                this._model.mainSeries().sessionIdProxyProperty().unsubscribeAll(this),
                super.destroy()
            }
            properties() {
                return this._properties
            }
            applyOverrides(e) {
                (0,
                V.applyPropertiesOverrides)(this._properties.childs().graphics, void 0, !1, e, "sessions");
                const t = this.get();
                t && this._model.updateSource(t)
            }
            state(e) {
                var t, i, s;
                const o = {
                    properties: this._properties.state()
                };
                return e && (o.data = null !== (s = null !== (i = null === (t = this.get()) || void 0 === t ? void 0 : t.stateData()) && void 0 !== i ? i : this._sessionsStateData) && void 0 !== s ? s : void 0),
                o
            }
            restoreState(e, t) {
                e.oldState && (e = function(e, t) {
                    const i = {
                        properties: {
                            graphics: e.state.graphics
                        }
                    };
                    return void 0 !== e.data && void 0 !== e.metaInfo && t && (i.data = {
                        metaInfo: e.metaInfo,
                        graphics: e.data.graphics
                    }),
                    i
                }(e, t));
                const i = e.properties;
                if (this._migrateOutOfSessionProperty(i),
                this._properties.mergeAndFire(i),
                H(this._properties),
                this._updateVisibleOfPreAndPostMarketBackground(this._model.mainSeries().properties().childs().sessionId),
                this._sessionsStateData = null,
                void 0 !== e.data && t) {
                    const t = this.get();
                    t ? t.restoreStateData(e.data) : this._sessionsStateData = e.data
                }
            }
            _migrateOutOfSessionProperty(e) {
                const t = e.graphics.backgrounds;
                if (void 0 !== t) {
                    const i = t.outOfSession;
                    i.color === (0,
                    r.ensureDefined)(F.sessionsPreferencesDefault.graphics.backgrounds).outOfSession.color || "postMarket"in t || (e.graphics.backgrounds = {
                        ...t,
                        postMarket: {
                            color: i.color,
                            transparency: i.transparency
                        },
                        preMarket: {
                            color: i.color,
                            transparency: i.transparency
                        }
                    },
                    "visible"in i && (e.graphics.backgrounds.preMarket.visible = i.visible,
                    e.graphics.backgrounds.postMarket.visible = i.visible))
                }
            }
            _updateVisibleOfPreAndPostMarketBackground(e) {
                const t = !(0,
                W.isRegularSessionId)(e.value())
                  , i = this._properties.childs().graphics.childs().backgrounds.childs();
                i.outOfSession.childs().visible.setValue(t),
                i.preMarket.childs().visible.setValue(t),
                i.postMarket.childs().visible.setValue(t)
            }
        }
        var U = i(434396)
          , G = i(942634)
          , j = i(978296)
          , q = i(566238)
          , X = i(472512)
          , K = i(546821)
          , Y = i(883188)
          , Z = i(481251)
          , $ = i(62802);
        const J = "symbolWatermark"
          , Q = {
            visibility: !1,
            color: "rgba(80, 83, 94, 0.25)"
        };
        function ee() {
            const e = $.getJSON(J);
            return Object.assign({}, Q, e)
        }
        const te = (0,
        Z.default)((()=>{
            const e = new k.Property(ee());
            return $.onSync.subscribe(null, (()=>e.mergeAndFire(ee()))),
            e.subscribe(null, (()=>$.setJSON(J, e.state()))),
            e
        }
        ));
        var ie = i(903424)
          , se = i(257288)
          , oe = i(151848)
          , ne = i(367637)
          , re = i(5486);
        class ae extends ne.MediaCoordinatesPaneRenderer {
            constructor() {
                super(...arguments),
                this._data = null,
                this._widthCache = new re.TextWidthCache
            }
            setData(e) {
                this._data = e
            }
            hitTest(e) {
                return null
            }
            _drawImpl(e) {
                if (!this._data)
                    return;
                const {lines: t, color: i} = this._data
                  , {context: s, mediaSize: {width: o, height: n}} = e;
                s.fillStyle = i;
                let r = 0;
                const a = [];
                for (const e of t) {
                    if (!e.text)
                        continue;
                    s.font = e.font;
                    const t = this._widthCache.measureText(s, e.text)
                      , i = t > o ? o / t : 1;
                    a.push(i),
                    r += e.lineHeight * i
                }
                let l = Math.max((n - r) / 2, 0)
                  , c = -1;
                for (const e of t) {
                    if (!e.text)
                        continue;
                    c += 1;
                    const t = a[c];
                    s.save(),
                    s.translate(o / 2, l),
                    s.textBaseline = "top",
                    s.textAlign = "center",
                    s.font = e.font,
                    s.scale(t, t),
                    s.fillText(e.text, 0, e.vertOffset),
                    s.restore(),
                    l += e.lineHeight * t
                }
            }
        }
        class le {
            constructor(e, t) {
                this._renderer = new ae,
                this._invalidated = !0,
                this._model = e,
                this._watermark = t
            }
            update() {
                this._invalidated = !0
            }
            renderer() {
                return this._invalidated && (this._updateImpl(),
                this._invalidated = !1),
                this._renderer
            }
            _updateImpl() {
                const e = this._watermark.properties().childs()
                  , t = this._model.mainSeries()
                  , i = t.symbolInfo();
                if (!i || !e.visibility.value())
                    return void this._renderer.setData(null);
                let s = i.name;
                if (/QUANDL/.test(i.exchange)) {
                    const e = s.split(/\//);
                    e.length && (s = e[e.length - 1])
                }
                const o = {
                    description: i.description,
                    short_description: i.short_description,
                    pro_name: i.pro_name,
                    short_name: i.name,
                    local_description: i.local_description,
                    language: i.language
                }
                  , n = [{
                    text: s ? `${s}, ${(0,
                    oe.translatedIntervalString)(t.interval())}` : "",
                    font: (0,
                    N.makeFont)(96, B.CHART_FONT_FAMILY),
                    lineHeight: 117,
                    vertOffset: 0
                }, {
                    text: (0,
                    se.getTranslatedSymbolDescription)(o) || "",
                    font: (0,
                    N.makeFont)(48, B.CHART_FONT_FAMILY),
                    lineHeight: 58,
                    vertOffset: 5
                }];
                this._renderer.setData({
                    color: e.color.value(),
                    lines: n
                })
            }
        }
        const ce = "symbolWatermark";
        class de extends ie.DataSource {
            constructor(e) {
                super(),
                this._properties = te(),
                (0,
                V.applyDefaultsOverrides)(this._properties, void 0, !1, ce),
                this._properties.subscribe(this, (()=>e.updateSource(this))),
                this._paneView = new le(e,this)
            }
            destroy() {
                this._properties.unsubscribeAll(this),
                super.destroy()
            }
            name() {
                return "watermark"
            }
            properties() {
                return this._properties
            }
            restorePropertiesDefaults() {
                te().mergeAndFire(Q)
            }
            applyOverrides(e) {
                (0,
                V.applyPropertiesOverrides)(this._properties, void 0, !1, e, ce)
            }
            paneViews() {
                return [this._paneView]
            }
            updateAllViews(e) {
                super.updateAllViews(e),
                this._paneView.update()
            }
        }
        var ue = i(953297)
          , he = i(338619)
          , pe = i(79342)
          , me = i(79200)
          , ge = i(128011)
          , _e = i(637761)
          , ve = i(124829)
          , Se = i(40495)
          , fe = i(726978)
          , be = i(283323)
          , ye = i(862954)
          , Ce = i(354957)
          , we = i(322825)
          , Te = i(475892)
          , Pe = i(343272);
        function xe(e, t, i) {
            return i.hasDataSource(t) ? Ae(t, i) === e : !!i.isMainPane() && Ae(i.model().mainSeries(), i) === e
        }
        const Me = new Map([["price", e=>(0,
        Te.isPriceDataSource)(e)], ["trading", e=>(0,
        T.isTrading)(e)], ["drawing", e=>(0,
        T.isLineTool)(e) && !(0,
        T.isTrading)(e) && !e.isPhantom()], ["drawingsForAllSymbols", e=>(0,
        T.isLineTool)(e) && !(0,
        T.isTrading)(e) && !e.isPhantom()], ["phantom", e=>(0,
        T.isLineTool)(e) && e.isPhantom()], ["restRowSources", e=>!(0,
        T.isLineTool)(e) && !(0,
        T.isTrading)(e)], ["legendViewSources", (e,t)=>t.hasDataSource(e) && ((0,
        Te.isPriceDataSource)(e) || (0,
        T.isStudyLineTool)(e))], ["leftPriceScale", xe.bind(null, "left")], ["rightPriceScale", xe.bind(null, "right")], ["overlayPriceScale", xe.bind(null, "overlay")], ["multipane", (e,t)=>!t.hasDataSource(e)], ["allWithoutMultipane", (e,t)=>t.hasDataSource(e)]])
          , Ie = new Map([["price", "visibleSorted"], ["trading", "visibleSorted"], ["drawing", "visibleSorted"], ["drawingsForAllSymbols", "allSorted"], ["phantom", "visibleSorted"], ["restRowSources", "visibleSorted"], ["legendViewSources", "visibleSorted"], ["leftPriceScale", "visibleSorted"], ["rightPriceScale", "visibleSorted"], ["overlayPriceScale", "visibleSorted"], ["multipane", "visibleSorted"], ["allWithoutMultipane", "visibleSorted"]]);
        function Ae(e, t) {
            const i = e.priceScale();
            return null === i ? "overlay" : t.priceScalePosition(i)
        }
        class Le {
            constructor(e) {
                this._groupedSources = new Map,
                this._sources = null,
                this._pane = e
            }
            clear() {
                this._groupedSources.clear(),
                this._sources = null
            }
            destroy() {
                this.clear()
            }
            all() {
                return this._groupedSources.has("visibleSorted") || this._sortSources(),
                (0,
                r.ensureDefined)(this._groupedSources.get("visibleSorted"))
            }
            allIncludingHidden() {
                return this._groupedSources.has("allSorted") || this._sortSources(),
                (0,
                r.ensureDefined)(this._groupedSources.get("allSorted"))
            }
            allWithoutMultipane() {
                return this._getSourcesByGroupType("allWithoutMultipane")
            }
            allExceptSpecialSources() {
                if (!this._groupedSources.has("exceptSpecial")) {
                    const e = this.allIncludingHidden().filter((e=>!e.isSpeciallyZOrderedSource()));
                    this._groupedSources.set("exceptSpecial", e)
                }
                return (0,
                r.ensureDefined)(this._groupedSources.get("exceptSpecial"))
            }
            tradingSources() {
                return this._getSourcesByGroupType("trading")
            }
            priceSources() {
                return this._getSourcesByGroupType("price")
            }
            lineSources() {
                return this._getSourcesByGroupType("drawing")
            }
            lineSourcesForAllSymbols() {
                return this._getSourcesByGroupType("drawingsForAllSymbols")
            }
            phantomSources() {
                return this._getSourcesByGroupType("phantom")
            }
            allExceptLineAndTradingSources() {
                return this._getSourcesByGroupType("restRowSources")
            }
            hitTestSources() {
                if (!this._groupedSources.has("hitTest")) {
                    const e = this.allExceptLineAndTradingSources().concat(this.lineSources());
                    this._groupedSources.set("hitTest", (0,
                    Pe.sortSources)(e, this._pane))
                }
                return (0,
                r.ensureDefined)(this._groupedSources.get("hitTest"))
            }
            generalSources() {
                if (!this._groupedSources.has("general")) {
                    const e = this.allExceptLineAndTradingSources().concat(this.lineSources());
                    this._groupedSources.set("general", (0,
                    Pe.sortSources)(e, this._pane))
                }
                return (0,
                r.ensureDefined)(this._groupedSources.get("general"))
            }
            leftPriceScalesSources() {
                return this._getSourcesByGroupType("leftPriceScale")
            }
            rightPriceScalesSources() {
                return this._getSourcesByGroupType("rightPriceScale")
            }
            overlayPriceScaleSources() {
                return this._getSourcesByGroupType("overlayPriceScale")
            }
            multipaneSources() {
                return this._getSourcesByGroupType("multipane")
            }
            legendViewSources() {
                return this._getSourcesByGroupType("legendViewSources")
            }
            _getSourcesByGroupType(e) {
                const t = (0,
                r.ensureDefined)(Ie.get(e));
                return this._groupedSources.has(t) ? this._groupedSources.has(e) || this._groupSources(e) : (this._sortSources(),
                this._groupSources(e)),
                (0,
                r.ensureDefined)(this._groupedSources.get(e))
            }
            _sortSources() {
                null === this._sources && (this._sources = this._pane.dataSources());
                const e = this._pane.model().multiPaneSources(this._pane)
                  , t = (0,
                Pe.sortSources)(this._sources.concat(e), this._pane)
                  , i = t.filter((e=>!(0,
                T.isLineTool)(e) || e.isActualSymbol() && e.isActualCurrency() && e.isActualUnit()));
                this._groupedSources.set("allSorted", t),
                this._groupedSources.set("visibleSorted", i)
            }
            _groupSources(e) {
                const t = (0,
                r.ensureDefined)(Ie.get(e))
                  , i = Me.get(e);
                if (void 0 !== i) {
                    const s = (0,
                    r.ensureDefined)(this._groupedSources.get(t)).filter((e=>i(e, this._pane)));
                    this._groupedSources.set(e, s)
                }
            }
        }
        var Ee = i(627620)
          , ke = i(704670)
          , De = i(613438)
          , Ne = i(526910)
          , Be = i(487945)
          , Re = i(674720)
          , Oe = i(960521)
          , Ve = i(750139);
        function We(e, t, i) {
            const s = e.div(t).toNumber();
            return Math.abs(Math.round(s) - s) < i
        }
        const Fe = [2, 5]
          , He = [5, 2];
        class ze {
            constructor(e, t, i) {
                if (this._base = e,
                this._integralDividers = t,
                (0,
                Ve.isBaseDecimal)(e))
                    this._fractionalDividers = [2, 2.5, 2];
                else {
                    this._fractionalDividers = [];
                    const e = i ? Fe : He;
                    for (let t = this._base; 1 !== t; ) {
                        if (t % e[0] == 0)
                            this._fractionalDividers.push(e[0]),
                            t /= e[0];
                        else {
                            if (t % e[1] != 0)
                                throw new Error("unexpected base");
                            this._fractionalDividers.push(e[1]),
                            t /= e[1]
                        }
                        if (this._fractionalDividers.length > 100)
                            throw new Error("something wrong with base")
                    }
                }
            }
            tickSpan(e, t, i) {
                const s = 0 === this._base ? 0 : 1 / this._base
                  , o = Math.min(1e-14, (e - t) / 1e3);
                let n = Math.pow(10, Math.max(0, Math.ceil((0,
                Ve.log10)(e - t))));
                if (!isFinite(n))
                    return 1e305;
                let r = 0
                  , a = this._integralDividers[0];
                for (; ; ) {
                    const e = (0,
                    Ve.greaterOrEqual)(n, s, o) && n > s + o
                      , t = (0,
                    Ve.greaterOrEqual)(n, i * a, o)
                      , l = (0,
                    Ve.greaterOrEqual)(n, 1, o)
                      , c = new Oe.Big(n).div(a)
                      , d = 0 === s || We(c, s, o);
                    if (!(e && t && l && d))
                        break;
                    n = c.toNumber(),
                    a = this._integralDividers[++r % this._integralDividers.length]
                }
                if (n <= s + o && (n = s),
                n = Math.max(1, n),
                this._fractionalDividers.length > 0 && (0,
                Ve.equal)(n, 1, o))
                    for (r = 0,
                    a = this._fractionalDividers[0]; ; ) {
                        const e = (0,
                        Ve.greaterOrEqual)(n, i * a, o) && n > s + o
                          , t = new Oe.Big(n).div(a)
                          , l = 0 === s || We(t, s, o);
                        if (!e || !l)
                            break;
                        n = t.toNumber(),
                        a = this._fractionalDividers[++r % this._fractionalDividers.length]
                    }
                return n
            }
        }
        class Ue {
            constructor(e, t, i, s) {
                this._marks = null,
                this._priceScale = e,
                this._base = t,
                this._coordinateToLogicalFunc = i,
                this._logicalToCoordinateFunc = s
            }
            base() {
                return this._base
            }
            setBase(e) {
                if (e < 0)
                    throw new Error("base < 0");
                this._base = e
            }
            tickSpan(e, t, i=0) {
                if (e < t)
                    throw new Error("high < low");
                const s = this._priceScale.height()
                  , o = this._tickMarkHeight()
                  , n = (e - t) * o / s
                  , r = [new ze(this._base,[2, 2.5, 2],!0), new ze(this._base,[2, 2, 2.5],!0), new ze(this._base,[2.5, 2, 2],!0), new ze(this._base,[2, 2.5, 2],!1), new ze(this._base,[2, 2, 2.5],!1), new ze(this._base,[2.5, 2, 2],!1)].reduce(((s,o)=>{
                    const r = o.tickSpan(e, t, n);
                    return r > i ? Math.min(r, s) : s
                }
                ), 1 / 0);
                return r > 0 && isFinite(r) ? r : e - t
            }
            rebuildTickMarks() {
                this._marks = null
            }
            marks() {
                return null === this._marks && (this._marks = this._rebuildTickMarksImpl()),
                this._marks
            }
            _fontHeight() {
                return this._priceScale.fontSize()
            }
            _tickMarkHeight() {
                return Math.ceil(2.5 * this._fontHeight())
            }
            _rebuildTickMarksImpl() {
                const e = this._priceScale
                  , t = []
                  , i = e.mainSource();
                if (e.isEmpty() || !e.hasCalculatedPriceRange() || null === i)
                    return t;
                let s = i.firstValue();
                null === s && (s = 0);
                const o = e.height()
                  , n = this._coordinateToLogicalFunc(o - 1, s)
                  , r = this._coordinateToLogicalFunc(0, s)
                  , a = Math.max(n, r)
                  , l = Math.min(n, r);
                if (a === l)
                    return t;
                let c = this.tickSpan(a, l)
                  , d = a % c;
                d += d < 0 ? c : 0;
                const u = a >= l ? 1 : -1;
                let h = null;
                const p = e.formatter();
                let m = NaN;
                for (let i = a - d; i > l; i -= c) {
                    i === m && (c = this.tickSpan(a, l, c)),
                    m = i;
                    const o = this._logicalToCoordinateFunc(i, s);
                    null !== h && Math.abs(o - h) < this._tickMarkHeight() || (t.push({
                        coord: o,
                        label: p.format(i)
                    }),
                    h = o,
                    e.isLog() && (c = this.tickSpan(i * u, l)))
                }
                return t
            }
        }
        var Ge = i(419283)
          , je = i(924918)
          , qe = i(758697);
        ue.enabled("hide_price_scale_if_all_sources_hidden");
        const Xe = (0,
        qe.getPercentageFormatter)()
          , Ke = new je.PriceFormatter({
            priceScale: 100,
            minMove: 1
        })
          , Ye = {
            autoScale: !0,
            autoScaleDisabled: !1,
            lockScale: !1,
            percentage: !1,
            percentageDisabled: !1,
            log: !1,
            logDisabled: !1,
            alignLabels: !0,
            isInverted: !1,
            indexedTo100: !1
        };
        class Ze {
            constructor(e, t) {
                this._marksCache = null,
                this._onMarksChanged = new G.Delegate,
                this.m_dataSources = [],
                this._sourcesForAutoscale = null,
                this._sourcesThatAffectVisibility = [],
                this._hasSeries = !1,
                this._studiesCount = 0,
                this._drawingCount = 0,
                this._seriesLikeSources = [],
                this._priceDataSources = [],
                this._mainSource = null,
                this._lastSourceRemoved = new G.Delegate,
                this._scaleSeriesOnly = !1,
                this._invalidatedForRange = {
                    isValid: !0,
                    visibleBars: null
                },
                this._priceRange = null,
                this._hasCalculatedPriceRange = !1,
                this._logFormula = (0,
                De.logFormulaForBase)(null),
                this.m_height = 0,
                this._margins = {
                    top: 0,
                    bottom: 0
                },
                this._correctedMarginsCache = null,
                this._topPixelMargin = 0,
                this._bottomPixelMargin = 0,
                this._internalHeightCache = null,
                this._internalHeightChanged = new G.Delegate,
                this._priceRangeSnapshot = null,
                this._scrollStartPoint = null,
                this._currencyCache = null,
                this._unitCache = null,
                this._measureUnitIdCache = null,
                this._recalculatePriceRangeOnce = !1,
                this._cachedOrderedSoruces = null,
                this._scaleStartPoint = null,
                this._twoPointsScaleStartPosition = null,
                this._maxPriceRange = null,
                this._minPriceRange = null,
                this._priceRangeChanged = new G.Delegate,
                this._modeChanged = new G.Delegate,
                this._sourcesToUpdateViews = null,
                this._markBuilder = new Ue(this,100,this._coordinateToLogical.bind(this),this._logicalToCoordinate.bind(this)),
                this._formatter = null,
                this._resetScaleAvailable = new j.WatchedValue(!1),
                this._id = "",
                this._isVisible = new j.WatchedValue(!0),
                t = Object.assign({}, Ye, t),
                this._properties = new k.Property(t),
                this._boundOnSourceIsActingAsSymbolSourceChanged = this._onSourceIsActingAsSymbolSourceChanged.bind(this),
                this._scalesProperties = e,
                this._properties.childs().isInverted.subscribe(this, this._onIsInvertedChanged),
                this._properties.subscribe(null, (()=>{
                    const e = this.mainSource();
                    if (e && e.model()) {
                        const t = e.model().paneForSource(e);
                        t && e.model().updatePane(t)
                    }
                }
                )),
                this._scalesProperties.subscribe(this, (()=>{
                    this._marksCache = null
                }
                )),
                this._properties.childs().lockScale.subscribe(this, this._updateResetAvailableValue),
                this._properties.childs().autoScale.subscribe(this, this._updateResetAvailableValue),
                this._updateResetAvailableValue(),
                this.setId((0,
                pe.randomHash)())
            }
            id() {
                return this._id
            }
            setId(e) {
                this._id = e
            }
            isLog() {
                return this._properties.childs().log.value()
            }
            isPercentage() {
                return this._properties.childs().percentage.value()
            }
            isInverted() {
                return this._properties.childs().isInverted.value()
            }
            isIndexedTo100() {
                return this._properties.childs().indexedTo100.value()
            }
            isAutoScale() {
                return this._properties.childs().autoScale.value() && !this.isLockScale()
            }
            isLockScale() {
                return this._properties.childs().lockScale.value()
            }
            isRegular() {
                return !this.isPercentage() && !this.isLog() && !this.isIndexedTo100()
            }
            isScaleSeriesOnly() {
                return this._scaleSeriesOnly
            }
            properties() {
                return this._properties
            }
            height() {
                return this.m_height
            }
            setHeight(e) {
                this.m_height !== e && (this.m_height = e,
                this._invalidateInternalHeightCache(),
                this._marksCache = null)
            }
            internalHeight() {
                if (this._internalHeightCache)
                    return this._internalHeightCache;
                const e = this.height() - this.topPixelMargin() - this.bottomPixelMargin();
                return this._internalHeightCache = e,
                e
            }
            fontSize() {
                return this._scalesProperties.childs().fontSize.value()
            }
            priceRange() {
                return this._makeSureItIsValid(),
                this._priceRange
            }
            setPriceRange(e, t, i) {
                if (!(e instanceof ke.PriceRange))
                    throw new TypeError("incorrect price range");
                const s = this._priceRange;
                if (!t && ke.PriceRange.compare(s, e))
                    return;
                const o = null !== this._maxPriceRange && this._maxPriceRange.containsStrictly(e)
                  , n = null !== this._minPriceRange && e.containsStrictly(this._minPriceRange);
                this.isLockScale() && !t && (o || n) || (this._marksCache = null,
                this._priceRange = e,
                i || this._priceRangeChanged.fire(s, e))
            }
            setMinPriceRange(e) {
                this._minPriceRange = e
            }
            setMaxPriceRange(e) {
                this._maxPriceRange = e
            }
            recalculatePriceRangeOnce() {
                this._recalculatePriceRangeOnce = !0
            }
            priceRangeShouldBeRecalculatedOnce() {
                if (!this._recalculatePriceRangeOnce || this.isLockScale())
                    return !1;
                const e = this.mainSource();
                return null !== e && e.priceRangeReady()
            }
            priceRangeChanged() {
                return this._priceRangeChanged
            }
            mode() {
                const e = this._properties.childs();
                return {
                    autoScale: e.autoScale.value(),
                    lockScale: e.lockScale.value(),
                    percentage: e.percentage.value(),
                    indexedTo100: e.indexedTo100.value(),
                    log: e.log.value()
                }
            }
            setMode(e) {
                const t = {}
                  , i = this.mode()
                  , s = this._properties.state();
                let o = null;
                void 0 !== e.autoScale && e.autoScale !== s.autoScale && (t.autoScale = e.autoScale,
                this._setAutoScaleValueWithDependentProperties(e.autoScale)),
                void 0 !== e.lockScale && e.lockScale !== s.lockScale && (t.lockScale = e.lockScale,
                this._setLockScaleValueWithDependentProperties(e.lockScale)),
                void 0 !== e.percentage && e.percentage !== s.percentage && (t.percentage = e.percentage,
                this._setPercentageValueWithDependentProperties(e.percentage),
                this._invalidatedForRange.isValid = !1),
                void 0 !== e.indexedTo100 && e.indexedTo100 !== s.indexedTo100 && (t.indexedTo100 = e.indexedTo100,
                this._setIndexedTo100ValueWithDependentProperties(e.indexedTo100),
                this._invalidatedForRange.isValid = !1),
                void 0 !== e.log && e.log !== s.log && (t.log = e.log,
                this._setLogValueWithDependentProperties(e.log));
                const n = this._properties.childs();
                s.log && !n.log.value() && (this._canConvertPriceRangeFromLog(this._priceRange) ? (o = this._convertPriceRangeFromLog(this._priceRange),
                null !== o && this.setPriceRange(o)) : n.autoScale.setValue(!0)),
                !s.log && n.log.value() && (o = this._convertPriceRangeToLog(this._priceRange),
                null !== o && this.setPriceRange(o)),
                s.autoScale !== n.autoScale.value() && n.autoScale.listeners().fire(n.autoScale, ""),
                s.autoScaleDisabled !== n.autoScaleDisabled.value() && n.autoScaleDisabled.listeners().fire(n.autoScaleDisabled, ""),
                s.lockScale !== n.lockScale.value() && n.lockScale.listeners().fire(n.lockScale, ""),
                s.percentage !== n.percentage.value() && (n.percentage.listeners().fire(n.percentage, ""),
                this.updateFormatter()),
                s.indexedTo100 !== n.indexedTo100.value() && (n.indexedTo100.listeners().fire(n.indexedTo100, ""),
                this.updateFormatter()),
                s.percentageDisabled !== n.percentageDisabled.value() && n.percentageDisabled.listeners().fire(n.percentageDisabled, ""),
                s.log !== n.log.value() && n.log.listeners().fire(n.log, ""),
                s.logDisabled !== n.logDisabled.value() && n.logDisabled.listeners().fire(n.logDisabled, ""),
                void 0 === t.log && void 0 === t.percentage && void 0 === t.lockScale && void 0 === t.autoScale && void 0 === t.indexedTo100 || this._modeChanged.fire(i, this.mode())
            }
            modeChanged() {
                return this._modeChanged
            }
            isEmpty() {
                return this._makeSureItIsValid(),
                0 === this.m_height || !this._priceRange || this._priceRange.isEmpty()
            }
            hasCalculatedPriceRange() {
                return this._hasCalculatedPriceRange
            }
            canDetachSource(e) {
                return this.m_dataSources.some((t=>t !== e && !(0,
                ye.isLollipopDataSource)(t) && (0,
                Te.isPriceDataSource)(t) && !((0,
                U.isStudy)(t) && t.isLinkedToSeries())))
            }
            updateAllViews(e) {
                const t = this._getSourcesToUpdateViews();
                for (const i of t)
                    i.updateAllViews(e)
            }
            logFormula() {
                return this._logFormula
            }
            state() {
                var e;
                const t = this._properties.childs();
                return {
                    id: this._id,
                    m_priceRange: this.isAutoScale() ? null : (null === (e = this.priceRange()) || void 0 === e ? void 0 : e.serialize()) || null,
                    m_isAutoScale: this.isAutoScale(),
                    m_isPercentage: t.percentage.value(),
                    m_isIndexedTo100: t.indexedTo100.value(),
                    m_isLog: t.log.value(),
                    m_isLockScale: this.isLockScale(),
                    m_isInverted: this.isInverted(),
                    m_topMargin: this._margins.top,
                    m_bottomMargin: this._margins.bottom,
                    alignLabels: t.alignLabels.value(),
                    logFormula: (0,
                    ve.clone)(this._logFormula),
                    hasCalculatedPriceRange: this._hasCalculatedPriceRange
                }
            }
            restoreState(e) {
                var t;
                let i = e.m_priceRange;
                if (void 0 === i)
                    throw new TypeError("invalid state");
                if (void 0 === e.m_isAutoScale)
                    throw new TypeError("invalid state");
                void 0 !== e.id && (this._id = e.id);
                const s = {
                    autoScale: e.m_isAutoScale
                };
                void 0 !== e.m_isPercentage && (s.percentage = e.m_isPercentage),
                void 0 !== e.m_isIndexedTo100 && (s.indexedTo100 = e.m_isIndexedTo100),
                void 0 !== e.m_isLog && (s.log = e.m_isLog),
                void 0 !== e.m_isLockScale && (s.lockScale = e.m_isLockScale),
                void 0 !== e.m_isInverted && this._properties.childs().isInverted.setValue(e.m_isInverted),
                this.setMode(s),
                this._hasCalculatedPriceRange = null !== (t = e.hasCalculatedPriceRange) && void 0 !== t ? t : null !== i,
                i ? (i instanceof ke.PriceRange || (i = new ke.PriceRange(i)),
                this.setPriceRange(i, !0)) : this.clearPriceRange(),
                e.logFormula && (this._logFormula = e.logFormula),
                void 0 !== e.m_topMargin && (this._margins.top = e.m_topMargin),
                void 0 !== e.m_bottomMargin && (this._margins.bottom = e.m_bottomMargin),
                void 0 !== e.alignLabels && this._properties.childs().alignLabels.setValue(e.alignLabels),
                this._mainSource = null,
                this._scaleSeriesOnly = !1
            }
            priceToLogical(e) {
                return this.isLog() && e ? (0,
                De.toLog)(e, this._logFormula) : e
            }
            logicalToPrice(e) {
                return this.isLog() ? (0,
                De.fromLog)(e, this._logFormula) : e
            }
            priceToCoordinate(e, t) {
                const i = this._priceToPercentOrIndexedTo100IfNeeded(e, t);
                return this._logicalToCoordinate(i)
            }
            coordinateToPrice(e, t) {
                let i = this._coordinateToLogical(e);
                return this.isPercentage() ? i = (0,
                De.fromPercent)(i, t) : this.isIndexedTo100() && (i = (0,
                De.fromIndexedTo100)(i, t)),
                i
            }
            mainSource() {
                if (null !== this._mainSource)
                    return this._mainSource;
                let e;
                for (const t of this._priceDataSources) {
                    if (t instanceof Ne.Series) {
                        e = t;
                        break
                    }
                    e || (e = t)
                }
                return this._mainSource = e || null,
                this._correctedMarginsCache = null,
                this._mainSource
            }
            priceToCoordinateFn(e) {
                this._makeSureItIsValid();
                const t = this.bottomPixelMargin()
                  , i = (0,
                r.ensureNotNull)(this.priceRange())
                  , s = i.minValue()
                  , o = i.maxValue()
                  , n = this.internalHeight() - 1
                  , a = this.isInverted()
                  , l = n / (o - s)
                  , c = this.m_height
                  , d = e=>{
                    const i = t + l * (e - s);
                    return a ? i : c - 1 - i
                }
                ;
                return this.isPercentage() ? t=>d((0,
                De.toPercent)(t, e)) : this.isIndexedTo100() ? t=>d((0,
                De.toIndexedTo100)(t, e)) : this.isLog() ? e=>d((0,
                De.toLog)(e, this._logFormula)) : e=>d(e)
            }
            pricesArrayToCoordinates(e, t, i) {
                this._makeSureItIsValid();
                const s = this.bottomPixelMargin()
                  , o = (0,
                r.ensureNotNull)(this.priceRange())
                  , n = o.minValue()
                  , a = o.maxValue()
                  , l = this.internalHeight() - 1
                  , c = this.isInverted()
                  , d = l / (a - n);
                void 0 === i && (i = e.length);
                const u = this.isPercentage()
                  , h = this.isIndexedTo100()
                  , p = this.isLog()
                  , m = this.m_height;
                let g, _;
                for (let o = 0; o < i; o++)
                    g = e[o],
                    Number.isFinite(g) && (u ? g = (0,
                    De.toPercent)(g, t) : h ? g = (0,
                    De.toIndexedTo100)(g, t) : p && (g = (0,
                    De.toLog)(g, this._logFormula)),
                    _ = s + d * (g - n),
                    e[o] = c ? _ : m - 1 - _)
            }
            pointsArrayToCoordinates(e, t, i) {
                var s, o;
                this._makeSureItIsValid();
                const n = (0,
                r.ensureNotNull)(this.priceRange())
                  , a = this.bottomPixelMargin()
                  , l = n.minValue()
                  , c = n.maxValue()
                  , d = this.internalHeight() - 1
                  , u = this.isInverted()
                  , h = d / (c - l)
                  , p = e
                  , m = null !== (s = null == i ? void 0 : i.startItemIndex) && void 0 !== s ? s : 0
                  , g = null !== (o = null == i ? void 0 : i.endItemIndex) && void 0 !== o ? o : p.length;
                if (this.isPercentage())
                    for (let e = m; e < g; e++)
                        p[e].y = (0,
                        De.toPercent)(p[e].y, t);
                if (this.isIndexedTo100())
                    for (let e = m; e < g; e++)
                        p[e].y = (0,
                        De.toIndexedTo100)(p[e].y, t);
                if (this.isLog())
                    for (let e = m; e < g; e++)
                        p[e].y = this.priceToLogical(p[e].y);
                for (let e = m; e < g; e++) {
                    const t = p[e].y;
                    if (isNaN(t) || null == t)
                        continue;
                    const i = a + h * (t - l)
                      , s = u ? i : this.m_height - 1 - i;
                    p[e].y = s
                }
            }
            barPricesToCoordinates(e, t) {
                this._makeSureItIsValid();
                const i = (0,
                r.ensureNotNull)(this.priceRange())
                  , s = e
                  , o = this.bottomPixelMargin()
                  , n = i.minValue()
                  , a = i.maxValue()
                  , l = this.internalHeight() - 1;
                let c = null;
                if (this.isPercentage() ? c = De.toPercent : this.isIndexedTo100() ? c = De.toIndexedTo100 : this.isLog() && (c = (e,t)=>e ? (0,
                De.toLog)(e, this._logFormula) : e),
                0 === s.length)
                    return;
                const d = "open"in s[0]
                  , u = "close"in s[0];
                if (null !== c)
                    for (let e = 0; e < s.length; e++) {
                        if (!s[e])
                            continue;
                        const i = s[e];
                        d && (i.open = c(i.open, t)),
                        i.high = c(i.high, t),
                        i.low = c(i.low, t),
                        u && (i.close = c(i.close, t)),
                        void 0 !== i.additionalPrice && (i.additionalPrice = c(i.additionalPrice, t))
                    }
                const h = l / (a - n)
                  , p = this.isInverted();
                for (let e = 0; e < s.length; e++) {
                    const t = s[e];
                    if (!t)
                        continue;
                    if (d) {
                        const e = o + h * (t.open - n)
                          , i = p ? e : this.m_height - 1 - e;
                        t.open = i
                    }
                    const i = o + h * (t.high - n)
                      , r = p ? i : this.m_height - 1 - i;
                    t.high = r;
                    const a = o + h * (t.low - n)
                      , l = p ? a : this.m_height - 1 - a;
                    if (t.low = l,
                    u) {
                        const e = o + h * (t.close - n)
                          , i = p ? e : this.m_height - 1 - e;
                        t.close = i
                    }
                    if (void 0 !== t.additionalPrice) {
                        const e = o + h * (t.additionalPrice - n);
                        t.additionalPrice = p ? e : this.m_height - 1 - e
                    }
                }
            }
            formatter() {
                return null === this._formatter && this.updateFormatter(),
                (0,
                r.ensureNotNull)(this._formatter)
            }
            updateFormatter() {
                this._marksCache = null;
                const e = this.mainSource();
                let t = 100;
                e && (t = e.base()),
                this._formatter = null,
                this.isPercentage() ? (this._formatter = Xe,
                t = 100) : this.isIndexedTo100() ? (this._formatter = Ke,
                t = 100) : this._formatter = e ? e.formatter() : Ke,
                this._markBuilder = new Ue(this,t,this._coordinateToLogical.bind(this),this._logicalToCoordinate.bind(this)),
                this._markBuilder.rebuildTickMarks()
            }
            formatPrice(e, t, i) {
                return this.isPercentage() ? this.formatPricePercentage(e, t, i) : this.isIndexedTo100() ? this.formatPriceIndexedTo100(e, t, i) : this.formatter().format(e, i)
            }
            formatPriceAbsolute(e, t) {
                return this._mainSourceFormatter().format(e, t)
            }
            formatPricePercentage(e, t, i) {
                return e = (0,
                De.toPercent)(e, t),
                Xe.format(e, i)
            }
            formatPriceIndexedTo100(e, t, i) {
                const s = (0,
                De.toIndexedTo100)(e, t);
                return this.formatter().format(s, i)
            }
            getFormattedValues(e, t, i, s) {
                null != s || (s = this.formatPriceAbsolute(e));
                const o = this.formatPricePercentage(e, t, {
                    signPositive: i
                })
                  , n = this.formatPriceIndexedTo100(e, t);
                return {
                    formattedPriceAbsolute: s,
                    formattedPricePercentage: o,
                    formattedPriceIndexedTo100: n,
                    text: (0,
                    De.getCurrentModePriceText)(this, {
                        formattedPriceAbsolute: s,
                        formattedPricePercentage: o,
                        formattedPriceIndexedTo100: n
                    })
                }
            }
            resetScale() {
                this.setMode({
                    autoScale: !0
                })
            }
            resetScaleAvailable() {
                return this._resetScaleAvailable.readonly()
            }
            dataSources() {
                return this.m_dataSources
            }
            seriesLikeSources() {
                return this._seriesLikeSources
            }
            addDataSource(e, t) {
                this._addDataSourceImpl(e, t)
            }
            removeDataSource(e) {
                const t = this.m_dataSources.indexOf(e);
                if ((0,
                r.assert)(-1 !== t, "Source is not attached to scale"),
                this.m_dataSources.splice(t, 1),
                (0,
                Te.isPriceDataSource)(e)) {
                    const t = this._priceDataSources.indexOf(e);
                    if ((0,
                    r.assert)(-1 !== t, "Source is not found"),
                    this._priceDataSources.splice(t, 1),
                    (0,
                    Be.isSymbolSource)(e)) {
                        const t = this._seriesLikeSources.indexOf(e);
                        (0,
                        r.assert)(-1 !== t, "Source is not found"),
                        this._seriesLikeSources.splice(t, 1),
                        e.symbolResolved().unsubscribeAll(this),
                        e.isActingAsSymbolSource().unsubscribe(this._boundOnSourceIsActingAsSymbolSourceChanged),
                        e instanceof Ne.Series && (this._hasSeries = !1)
                    }
                    e.currencyChanged().unsubscribeAll(this),
                    e.unitChanged().unsubscribeAll(this)
                }
                this.mainSource() || this.setMode({
                    autoScale: !0
                }),
                (0,
                U.isStudy)(e) && (e.onIsActualIntervalChange().unsubscribe(this, this._dropScaleCache),
                e.onHibernationStateChange().unsubscribe(this, this._dropScaleCache),
                e.properties().childs().styles.listeners().unsubscribe(this, this._dropScaleCache),
                this._studiesCount--,
                0 === this._studiesCount && (0,
                Ge.hideAllIndicators)().unsubscribe(this, this._dropScaleCache)),
                (0,
                T.isLineTool)(e) && (this._drawingCount--,
                0 === this._drawingCount && (0,
                Ge.hideAllDrawings)().unsubscribe(this, this._dropScaleCache));
                const i = this._sourcesThatAffectVisibility.indexOf(e);
                -1 !== i && (this._sourcesThatAffectVisibility.splice(i, 1),
                e.properties().childs().visible.listeners().unsubscribe(this, this._onSourceVisibilityChanged)),
                e === this._mainSource && (this._correctedMarginsCache = null,
                this._internalHeightCache = null,
                this._marksCache = null),
                this._mainSource = null,
                this._dropScaleCache(),
                this.updateFormatter(),
                this.invalidateSourcesCache(),
                this._updateIsVisible(),
                this._updateLogFormula(),
                0 === this.m_dataSources.length && this._lastSourceRemoved.fire()
            }
            replaceSource(e, t) {
                const i = (0,
                Te.isPriceDataSource)(e) ? this._priceDataSources.indexOf(e) : void 0;
                return this._addDataSourceImpl(t, void 0, -1 === i ? void 0 : i),
                this.removeDataSource(e),
                -1 !== i
            }
            currency(e) {
                if (null !== this._currencyCache && e.size() === this._currencyCache.availableCurrenciesCount)
                    return this._currencyCache.value;
                let t;
                const i = new Set
                  , s = new Set
                  , o = new Set
                  , n = new Map
                  , a = new Set;
                let l, c = 0 === this._seriesLikeSources.length, d = !0, u = 0, h = 0;
                const p = this._seriesLikeSources.filter(Be.isActingAsSymbolSource);
                for (const h of p) {
                    if (!h.isVisible())
                        continue;
                    const p = h.symbolInfo();
                    if (null === p) {
                        t = null;
                        break
                    }
                    const m = (0,
                    W.symbolOriginalCurrency)(p);
                    if (null === m) {
                        t = null;
                        break
                    }
                    n.set(m, (0,
                    r.ensureNotNull)((0,
                    W.symbolOriginalCurrency)(p, !0)));
                    const g = h.currency();
                    if (null === g) {
                        t = null;
                        break
                    }
                    n.set(g, (0,
                    r.ensureNotNull)((0,
                    W.symbolCurrency)(p, !0)));
                    const _ = (0,
                    W.symbolBaseCurrency)(p);
                    null !== _ && s.add(_),
                    d = d && m === g,
                    o.add(g),
                    i.add(m),
                    void 0 === l ? l = g : null !== l && l !== g && (l = null),
                    c || e.convertible(g) && (0,
                    W.symbolCurrencyConvertible)(p) || (c = !0),
                    u += 1,
                    a.add((0,
                    W.proSymbol)(p, h.symbol()))
                }
                if (null !== t)
                    for (const i of this._priceDataSources) {
                        if (p.includes(i))
                            continue;
                        const s = i;
                        if (!s.isCurrencySource() || !s.isVisible())
                            continue;
                        const a = s.currency();
                        if (null === a) {
                            t = null;
                            break
                        }
                        o.add(a),
                        h += 1;
                        const d = (0,
                        r.ensureNotNull)(s.symbolSource())
                          , u = s.currencySourceSymbolInfo();
                        if (null === u) {
                            t = null;
                            break
                        }
                        if (c || e.convertible(a) && (0,
                        W.symbolCurrencyConvertible)(u) || (c = !0),
                        n.set(a, (0,
                        r.ensureNotNull)((0,
                        W.symbolCurrency)(u, !0))),
                        p.includes(d) || (c = !0),
                        void 0 === l)
                            l = a;
                        else if (null !== l && l !== a) {
                            l = null;
                            break
                        }
                    }
                return void 0 === t && (t = 0 === u && 0 === h ? null : {
                    readOnly: c,
                    selectedCurrency: l || null,
                    currencies: o,
                    originalCurrencies: i,
                    baseCurrencies: s,
                    symbolSourceCount: u,
                    allCurrenciesAreOriginal: d,
                    displayedValues: n,
                    symbols: a
                }),
                this._currencyCache = {
                    value: t,
                    availableCurrenciesCount: e.size()
                },
                t
            }
            unit(e) {
                if (null !== this._unitCache && e.size() === this._unitCache.availableUnitsCount)
                    return this._unitCache.value;
                let t;
                const i = new Set
                  , s = new Set
                  , o = new Map
                  , n = new Map
                  , a = new Set;
                let l, c = 0 === this._seriesLikeSources.length ? new Set : e.allGroups(), d = !0, u = 0, h = 0;
                const p = this._seriesLikeSources.filter(Be.isActingAsSymbolSource);
                for (const r of p) {
                    if (!r.isVisible())
                        continue;
                    const h = r.symbolInfo();
                    if (null === h) {
                        t = null;
                        break
                    }
                    const p = (0,
                    W.symbolOriginalUnit)(h, r.model().unitConversionEnabled());
                    if (null === p) {
                        t = null;
                        break
                    }
                    o.set(p, e.name(p)),
                    n.set(p, e.description(p));
                    const m = r.unit();
                    if (null === m) {
                        t = null;
                        break
                    }
                    if (o.set(m, e.name(m)),
                    n.set(m, e.description(m)),
                    d = d && p === m,
                    s.add(m),
                    i.add(p),
                    void 0 === l ? l = m : null !== l && l !== m && (l = null),
                    c.size > 0) {
                        const t = (0,
                        Re.unitConvertibleGroups)(h, m, e);
                        c = (0,
                        C.intersect)(c, new Set(t))
                    }
                    u += 1,
                    a.add((0,
                    W.proSymbol)(h, r.symbol()))
                }
                if (null !== t)
                    for (const i of this._priceDataSources) {
                        if (p.includes(i))
                            continue;
                        const a = i;
                        if (!a.isUnitSource() || !a.isVisible())
                            continue;
                        const d = a.unit();
                        if (null === d) {
                            t = null;
                            break
                        }
                        s.add(d),
                        h += 1;
                        const u = (0,
                        r.ensureNotNull)(a.symbolSource())
                          , m = u.symbolInfo();
                        if (null === m) {
                            t = null;
                            break
                        }
                        if (c.size > 0) {
                            const t = (0,
                            Re.unitConvertibleGroups)(m, d, e);
                            c = (0,
                            C.intersect)(c, new Set(t))
                        }
                        if (o.set(d, e.name(d)),
                        n.set(d, e.description(d)),
                        p.includes(u) || (c = new Set),
                        void 0 === l)
                            l = d;
                        else if (null !== l && l !== d) {
                            l = null;
                            break
                        }
                    }
                if (void 0 === t)
                    if (0 === u && 0 === h)
                        t = null;
                    else {
                        t = {
                            availableGroups: c,
                            selectedUnit: l || null,
                            units: s,
                            originalUnits: i,
                            symbolSourceCount: u,
                            allUnitsAreOriginal: d,
                            names: o,
                            descriptions: n,
                            symbols: a
                        }
                    }
                return this._unitCache = {
                    value: t,
                    availableUnitsCount: e.size()
                },
                t
            }
            measureUnitId(e) {
                if (null !== this._measureUnitIdCache && e.size() === this._measureUnitIdCache.availableUnitsCount)
                    return this._measureUnitIdCache.value;
                let t, i;
                const s = new Map
                  , o = new Map
                  , n = new Set;
                let r = 0;
                const a = this._seriesLikeSources.filter(Be.isActingAsSymbolSource);
                for (const l of a) {
                    if (!l.isVisible())
                        continue;
                    const a = l.measureUnitId();
                    if (null === a) {
                        t = null;
                        break
                    }
                    n.add(a),
                    s.set(a, e.name(a)),
                    o.set(a, e.description(a)),
                    void 0 === i ? i = a : null !== i && i !== a && (i = null),
                    r += 1
                }
                return void 0 === t && (t = 0 === r ? null : {
                    selectedMeasureUnitId: i || null,
                    measureUnitIds: n,
                    names: s,
                    descriptions: o,
                    symbolSourceCount: r
                }),
                this._measureUnitIdCache = {
                    value: t,
                    availableUnitsCount: e.size()
                },
                t
            }
            setMargins(e) {
                if (!(0,
                ve.isNumber)(e.top) || !(0,
                ve.isNumber)(e.bottom))
                    throw new TypeError("invalid margin");
                if (e.top < 0 || e.top > 30 || e.bottom < 0 || e.bottom > 30)
                    throw new RangeError("invalid margin");
                this._margins.top === e.top && this._margins.bottom === e.bottom || (this._margins = e,
                this._correctedMarginsCache = null,
                this._invalidateInternalHeightCache(),
                this._marksCache = null)
            }
            topMargin() {
                return this._correctedMargins().top
            }
            bottomMargin() {
                return this._correctedMargins().bottom
            }
            invalidateMargins() {
                this._correctedMarginsCache = null
            }
            topPixelMargin() {
                return this.isInverted() ? this.bottomMargin() * this.height() + this._bottomPixelMargin : this.topMargin() * this.height() + this._topPixelMargin
            }
            bottomPixelMargin() {
                return this.isInverted() ? this.topMargin() * this.height() + this._topPixelMargin : this.bottomMargin() * this.height() + this._bottomPixelMargin
            }
            marks() {
                return this.isEmpty() ? (this._marksCache = null,
                []) : (null === this._marksCache && (this._markBuilder.rebuildTickMarks(),
                this._marksCache = this._markBuilder.marks(),
                this._onMarksChanged.fire()),
                this._marksCache)
            }
            onMarksChanged() {
                return this._onMarksChanged
            }
            priceRangeInPrice() {
                if (this.isEmpty())
                    return null;
                const e = this.mainSource();
                if (null === e)
                    return null;
                const t = (0,
                r.ensureNotNull)(e.firstValue())
                  , i = this.height();
                return {
                    from: this.coordinateToPrice(i - 1, t),
                    to: this.coordinateToPrice(0, t)
                }
            }
            setPriceRangeInPrice(e) {
                if (this.isPercentage() || this.isIndexedTo100())
                    return;
                const t = this.isInverted()
                  , i = t ? this.bottomMargin() : this.topMargin()
                  , s = t ? this.topMargin() : this.bottomMargin()
                  , o = this.isLog();
                let n = o ? (0,
                De.toLog)(e.from, this._logFormula) : e.from
                  , r = o ? (0,
                De.toLog)(e.to, this._logFormula) : e.to;
                const a = r - n;
                n += s * a,
                r -= i * a,
                this.setMode({
                    autoScale: !1
                }),
                this.setPriceRange(new ke.PriceRange(n,r)),
                this._marksCache = null,
                this._onMarksChanged.fire()
            }
            hasMainSeries() {
                return this._hasSeries
            }
            getStudies() {
                return this.dataSources().filter(U.isStudy)
            }
            lastSourceRemoved() {
                return this._lastSourceRemoved
            }
            sourcesForAutoscale() {
                return this._mainSource && this._scaleSeriesOnly !== this._scalesProperties.childs().scaleSeriesOnly.value() && (this._sourcesForAutoscale = null),
                this._sourcesForAutoscale || (this._sourcesForAutoscale = this._recalculateSourcesForAutoscale()),
                this._sourcesForAutoscale
            }
            recalculatePriceRange(e) {
                this._invalidatedForRange = {
                    visibleBars: e,
                    isValid: !1
                }
            }
            internalHeightChanged() {
                return this._internalHeightChanged
            }
            orderedSources() {
                if (this._cachedOrderedSoruces)
                    return this._cachedOrderedSoruces;
                let e = this.m_dataSources.slice();
                return e = e.filter((e=>!(0,
                ye.isLollipopDataSource)(e))),
                e = (0,
                Pe.sortSources)(e),
                this._cachedOrderedSoruces = e,
                this._cachedOrderedSoruces
            }
            invalidateSourcesCache() {
                this._cachedOrderedSoruces = null,
                this._sourcesToUpdateViews = null
            }
            startScale(e) {
                var t, i;
                this.isEmpty() || this.isPercentage() || this.isIndexedTo100() || null !== this._scaleStartPoint || null !== this._priceRangeSnapshot || (this._scaleStartPoint = this.m_height - e,
                this._priceRangeSnapshot = null !== (i = null === (t = this.priceRange()) || void 0 === t ? void 0 : t.clone()) && void 0 !== i ? i : null)
            }
            scaleTo(e) {
                if (this.isPercentage() || this.isIndexedTo100() || null === this._scaleStartPoint)
                    return;
                this.setMode({
                    autoScale: !1
                }),
                (e = this.m_height - e) < 0 && (e = 0);
                let t = (this._scaleStartPoint + .2 * (this.m_height - 1)) / (e + .2 * (this.m_height - 1));
                const i = (0,
                r.ensureNotNull)(this._priceRangeSnapshot).clone();
                t = Math.max(t, .1),
                i.scaleAroundCenter(t),
                this.setPriceRange(i)
            }
            endScale() {
                this.isPercentage() || this.isIndexedTo100() || null !== this._scaleStartPoint && (this._scaleStartPoint = null,
                this._priceRangeSnapshot = null)
            }
            startTwoPointsScale(e, t) {
                if (this.isEmpty() || this.isPercentage() || this.isIndexedTo100() || null !== this._twoPointsScaleStartPosition)
                    return;
                const i = Math.min(e, t)
                  , s = Math.max(e, t);
                this._twoPointsScaleStartPosition = {
                    topLogical: this._coordinateToLogical(i),
                    bottomLogical: this._coordinateToLogical(s)
                }
            }
            twoPointsScale(e, t) {
                if (this.isPercentage() || this.isIndexedTo100() || null === this._twoPointsScaleStartPosition)
                    return;
                this.setMode({
                    autoScale: !1
                });
                const i = Math.min(e, t)
                  , s = Math.max(e, t)
                  , {topLogical: o, bottomLogical: n} = this._twoPointsScaleStartPosition
                  , r = this.bottomPixelMargin()
                  , a = this.internalHeight() - 1
                  , l = (this._invertedCoordinate(i) - r) / a
                  , c = (n - o) / ((this._invertedCoordinate(s) - r) / a - l);
                if (!Number.isFinite(c))
                    return;
                const d = o - c * l
                  , u = d + c;
                this.setPriceRange(new ke.PriceRange(this.priceToLogical(d),this.priceToLogical(u)))
            }
            endTwoPointsScale() {
                this._twoPointsScaleStartPosition = null
            }
            startScroll(e) {
                var t, i;
                this.isAutoScale() || null === this._scrollStartPoint && null === this._priceRangeSnapshot && (this.isEmpty() || (this._scrollStartPoint = e,
                this._priceRangeSnapshot = null !== (i = null === (t = this.priceRange()) || void 0 === t ? void 0 : t.clone()) && void 0 !== i ? i : null))
            }
            scrollTo(e) {
                if (this.isAutoScale())
                    return;
                if (null === this._scrollStartPoint || null === this._priceRangeSnapshot)
                    return;
                const t = this.priceRange();
                if (null === t)
                    return;
                let i = e - this._scrollStartPoint;
                this.isInverted() && (i *= -1);
                const s = i * (t.length() / (this.internalHeight() - 1))
                  , o = this._priceRangeSnapshot.clone();
                o.shift(s),
                this.setPriceRange(o, !0),
                this._marksCache = null
            }
            endScroll() {
                this.isAutoScale() || null !== this._scrollStartPoint && (this._scrollStartPoint = null,
                this._priceRangeSnapshot = null)
            }
            clearPriceRange() {
                this._priceRange = null,
                this.recalculatePriceRangeOnce()
            }
            isVisible() {
                return this._isVisible
            }
            _addDataSourceImpl(e, t, i) {
                if (t || -1 === this.m_dataSources.indexOf(e)) {
                    if ((0,
                    Te.isPriceDataSource)(e)) {
                        if (void 0 === i ? this._priceDataSources.push(e) : this._priceDataSources.splice(i, 0, e),
                        e.currencyChanged().subscribe(this, (()=>this._currencyCache = null)),
                        e.unitChanged().subscribe(this, (()=>this._unitCache = null)),
                        (0,
                        Be.isSymbolSource)(e) && (this._seriesLikeSources.push(e),
                        e.symbolResolved().subscribe(this, (()=>{
                            this._currencyCache = null,
                            this._unitCache = null,
                            this._measureUnitIdCache = null,
                            this._updateLogFormula()
                        }
                        )),
                        e.isActingAsSymbolSource().subscribe(this._boundOnSourceIsActingAsSymbolSourceChanged),
                        e instanceof Ne.Series)) {
                            const t = e.properties();
                            this._hasSeries || (t.childs().lockScale && (this.setMode({
                                lockScale: t.childs().lockScale.value()
                            }),
                            t.removeProperty("lockScale")),
                            t.childs().pnfStyle.child("lockScale") && t.childs().pnfStyle.removeProperty("lockScale")),
                            this._hasSeries = !0
                        }
                        e.isSpeciallyZOrderedSource() || (this._sourcesThatAffectVisibility.push(e),
                        e.properties().childs().visible.listeners().subscribe(this, this._onSourceVisibilityChanged))
                    }
                    (0,
                    U.isStudy)(e) && (e.onIsActualIntervalChange().subscribe(this, this._dropScaleCache),
                    e.onHibernationStateChange().subscribe(this, this._dropScaleCache),
                    e.properties().childs().styles.listeners().subscribe(this, this._dropScaleCache),
                    0 === this._studiesCount && (0,
                    Ge.hideAllIndicators)().subscribe(this, this._dropScaleCache),
                    this._studiesCount++),
                    (0,
                    T.isLineTool)(e) && (0 === this._drawingCount && (0,
                    Ge.hideAllDrawings)().subscribe(this, this._dropScaleCache),
                    this._drawingCount++),
                    this.m_dataSources.push(e),
                    this._mainSource = null,
                    this.mainSource() === e && (this._correctedMarginsCache = null,
                    this._internalHeightCache = null,
                    this._marksCache = null),
                    this._dropScaleCache(),
                    this.updateFormatter(),
                    this._initScaleProperties(),
                    this.invalidateSourcesCache(),
                    this._updateIsVisible(),
                    this._updateLogFormula()
                }
            }
            _recalculateSourcesForAutoscale() {
                this._mainSource && (this._scaleSeriesOnly = this._scalesProperties.childs().scaleSeriesOnly.value());
                const e = this._scaleSeriesOnly && this._hasSeries;
                return this.m_dataSources.filter((t=>!!(t.properties().visible.value() || t instanceof Ne.Series) && (e ? t instanceof Ne.Series : (0,
                U.isStudy)(t) ? !t.isSourceHidden() && t.isIncludedInAutoScale() : t.isIncludedInAutoScale())))
            }
            _updateAutoScaleDisabledProperty(e) {
                const t = this._properties.childs()
                  , i = t.indexedTo100.value() || t.percentage.value() || t.lockScale.value();
                e ? t.autoScaleDisabled.setValueSilently(i) : t.autoScaleDisabled.setValue(i)
            }
            _setAutoScaleValueWithDependentProperties(e) {
                const t = this._properties.childs();
                t.autoScale.setValueSilently(e),
                e && (t.percentage.setValueSilently(!1),
                t.indexedTo100.setValueSilently(!1),
                t.lockScale.setValueSilently(!1),
                t.logDisabled.setValueSilently(!1)),
                this._updateAutoScaleDisabledProperty(!0)
            }
            _setLockScaleValueWithDependentProperties(e) {
                const t = this._properties.childs();
                t.lockScale.setValueSilently(e),
                e && (t.autoScale.setValueSilently(!1),
                t.percentage.setValueSilently(!1),
                t.indexedTo100.setValueSilently(!1),
                t.log.setValueSilently(!1)),
                t.percentageDisabled.setValueSilently(e),
                t.logDisabled.setValueSilently(e),
                this._updateAutoScaleDisabledProperty(!0)
            }
            _setPercentageValueWithDependentProperties(e) {
                const t = this._properties.childs();
                t.percentage.setValueSilently(e),
                e && (t.autoScale.setValueSilently(!0),
                t.log.setValueSilently(!1),
                t.lockScale.setValueSilently(!1),
                t.indexedTo100.setValueSilently(!1)),
                this._updateAutoScaleDisabledProperty(!0)
            }
            _setIndexedTo100ValueWithDependentProperties(e) {
                const t = this._properties.childs();
                t.indexedTo100.setValueSilently(e),
                e && (t.autoScale.setValueSilently(!0),
                t.log.setValueSilently(!1),
                t.lockScale.setValueSilently(!1),
                t.percentage.setValueSilently(!1)),
                this._updateAutoScaleDisabledProperty(!0)
            }
            _setLogValueWithDependentProperties(e) {
                const t = this._properties.childs();
                t.log.setValueSilently(e),
                e && (t.lockScale.setValueSilently(!1),
                t.percentage.setValueSilently(!1),
                t.indexedTo100.setValueSilently(!1)),
                this._updateAutoScaleDisabledProperty(!0)
            }
            _recalculatePriceRangeImpl() {
                const e = this._invalidatedForRange.visibleBars;
                if (null === e)
                    return;
                let t = null;
                const i = this.sourcesForAutoscale()
                  , s = this.isPercentage()
                  , o = this.isIndexedTo100();
                let n = 0
                  , r = 0;
                const a = {
                    targetPriceScale: this,
                    scaleSeriesOnly: this._scaleSeriesOnly
                };
                for (const l of i) {
                    if (!l.properties().visible.value())
                        continue;
                    const i = l.firstValue();
                    if (null === i || s && 0 === i)
                        continue;
                    const c = e.firstBar()
                      , d = e.lastBar()
                      , u = l.autoScaleInfo(c, d, a);
                    let h = u.range;
                    h && (s ? h = (0,
                    De.toPercentRange)(h, i) : o && (h = (0,
                    De.toIndexedTo100Range)(h, i)),
                    t = null === t ? h : t.merge(h)),
                    void 0 !== u.topPixelMargin && (n = Math.max(n, u.topPixelMargin)),
                    void 0 !== u.bottomPixelMargin && (r = Math.max(r, u.bottomPixelMargin))
                }
                (Math.abs(n - this._topPixelMargin) > 0 || Math.abs(r - this._bottomPixelMargin) > 0) && (this._bottomPixelMargin = r,
                this._topPixelMargin = n,
                this._marksCache = null,
                this._invalidateInternalHeightCache()),
                t ? (this._hasCalculatedPriceRange = !0,
                t.minValue() === t.maxValue() && (t = new ke.PriceRange(t.minValue() - .5,t.maxValue() + .5)),
                this.setPriceRange(t)) : this._priceRange || this.setPriceRange(new ke.PriceRange(-.5,.5)),
                this._invalidatedForRange.isValid = !0;
                const l = this.mainSource();
                null !== l && this._recalculatePriceRangeOnce && (this._recalculatePriceRangeOnce = !l.priceRangeReady())
            }
            _makeSureItIsValid() {
                this._invalidatedForRange.isValid || (this._invalidatedForRange.isValid = !0,
                this._recalculatePriceRangeImpl())
            }
            _invalidateInternalHeightCache() {
                this._internalHeightCache = null,
                this._internalHeightChanged.fire()
            }
            _coordinateToLogical(e) {
                if (this._makeSureItIsValid(),
                this.isEmpty())
                    return 0;
                const t = this._invertedCoordinate(e)
                  , i = (0,
                r.ensureNotNull)(this.priceRange())
                  , s = i.minValue() + (i.maxValue() - i.minValue()) * ((t - this.bottomPixelMargin()) / (this.internalHeight() - 1));
                return this.logicalToPrice(s)
            }
            _logicalToCoordinate(e) {
                if (this._makeSureItIsValid(),
                this.isEmpty())
                    return 0;
                e = this.priceToLogical(e);
                const t = (0,
                r.ensureNotNull)(this.priceRange())
                  , i = this.bottomPixelMargin() + (this.internalHeight() - 1) * (e - t.minValue()) / (t.maxValue() - t.minValue());
                return this._invertedCoordinate(i)
            }
            _convertPriceRangeFromLog(e) {
                if (null === e)
                    return null;
                const t = (0,
                De.fromLog)(e.minValue(), this._logFormula)
                  , i = (0,
                De.fromLog)(e.maxValue(), this._logFormula);
                return new ke.PriceRange(t,i)
            }
            _convertPriceRangeToLog(e) {
                if (null === e)
                    return null;
                const t = (0,
                De.toLog)(e.minValue(), this._logFormula)
                  , i = (0,
                De.toLog)(e.maxValue(), this._logFormula);
                return new ke.PriceRange(t,i)
            }
            _canConvertPriceRangeFromLog(e) {
                if (null === e)
                    return !1;
                const t = (0,
                De.fromLog)(e.minValue(), this._logFormula)
                  , i = (0,
                De.fromLog)(e.maxValue(), this._logFormula);
                return isFinite(t) && isFinite(i)
            }
            _onSourceVisibilityChanged() {
                this._dropScaleCache(),
                this._updateIsVisible()
            }
            _dropScaleCache() {
                this._sourcesForAutoscale = null,
                this._currencyCache = null,
                this._unitCache = null,
                this._measureUnitIdCache = null
            }
            _updateIsVisible() {
                this._isVisible.setValue(!0)
            }
            _updateLogFormula() {
                const e = this.isLog() ? this._convertPriceRangeFromLog(this.priceRange()) : null
                  , t = this.mainSource();
                if (null === t)
                    this._logFormula = (0,
                    De.logFormulaForBase)(null);
                else {
                    const e = t.base() || null
                      , i = (0,
                    De.logFormulaForBase)(e);
                    (0,
                    De.logFormulasAreSame)(i, this._logFormula) || (this._logFormula = i)
                }
                e && this.setPriceRange(this._convertPriceRangeToLog(e))
            }
            _invertedCoordinate(e) {
                return this.isInverted() ? e : this.height() - 1 - e
            }
            _initScaleProperties() {
                const e = this.isLockScale()
                  , t = this.properties().childs();
                e && (t.percentage.setValue(!1),
                t.indexedTo100.setValue(!1),
                t.log.setValue(!1),
                t.autoScale.setValue(!1)),
                t.percentageDisabled.setValue(e),
                t.logDisabled.setValue(e),
                this._updateAutoScaleDisabledProperty(!1),
                t.percentage.value() && (t.log.setValue(!1),
                t.indexedTo100.setValue(!1)),
                t.indexedTo100.value() && (t.log.setValue(!1),
                t.percentage.setValue(!1))
            }
            _correctedMargins() {
                if (null === this._correctedMarginsCache) {
                    const e = this.mainSource();
                    this._correctedMarginsCache = null !== e ? e.correctScaleMargins(this._margins) : this._margins
                }
                return this._correctedMarginsCache
            }
            _getSourcesToUpdateViews() {
                return this._sourcesToUpdateViews || (this._sourcesToUpdateViews = this.m_dataSources.filter((e=>!(0,
                T.isLineTool)(e) || e.isActualSymbol() && e.isActualCurrency()))),
                this._sourcesToUpdateViews
            }
            _mainSourceFormatter() {
                const e = this.mainSource();
                return (null == e ? void 0 : e.formatter()) || Ke
            }
            _priceToPercentOrIndexedTo100IfNeeded(e, t) {
                return this.isPercentage() ? (0,
                De.toPercent)(e, t) : this.isIndexedTo100() ? (0,
                De.toIndexedTo100)(e, t) : e
            }
            _onSourceIsActingAsSymbolSourceChanged() {
                this._dropScaleCache()
            }
            _onIsInvertedChanged() {
                this._marksCache = null,
                this._markBuilder.rebuildTickMarks()
            }
            _updateResetAvailableValue() {
                this._resetScaleAvailable.setValue(!this.isLockScale() && !this.isAutoScale())
            }
        }
        var $e = i(134392)
          , Je = i(691246)
          , Qe = i(198930)
          , et = i(540519)
          , tt = i(757402)
          , it = i(336068)
          , st = i(487416);
        var ot = i(412788)
          , nt = i(316589)
          , rt = i(441788)
          , at = i(221542)
          , lt = i(734493)
          , ct = i(97917)
          , dt = i(169532)
          , ut = i(149109)
          , ht = i(500323);
        const pt = (0,
        he.getLogger)("Chart.Pane");
        function mt(e, t, i) {
            e.setMargins({
                top: t,
                bottom: i
            })
        }
        const gt = "chart.pane";
        class _t {
            constructor(e, t, i, s) {
                this.m_dataSources = [],
                this._sourceWatchedValuesSubscriptions = new Map,
                this.m_mainDataSource = null,
                this._cachedOrderedSources = new Le(this),
                this._sourcesById = new Map,
                this._priceSourcesById = new Map,
                this._sourcePropertiesChanged = new G.Delegate,
                this._sourcesZOrderChanged = new G.Delegate,
                this._tagsChanged = new G.Delegate,
                this._stretchFactor = 1e3,
                this._isInInsertManyDataSourcesState = !1,
                this._lastLineDataSourceZOrder = null,
                this._rightPriceScales = [],
                this._leftPriceScales = [],
                this._lockedPriceScale = null,
                this._currentPriceScaleRatio = null,
                this._onPriceScalesChanged = new G.Delegate,
                this._isRecalculatingScales = !1,
                this._priceDataSources = [],
                this._symbolSources = [],
                this._lollipopDataSources = [],
                this._symbolSourceResolved = new G.Delegate,
                this._symbolSourceResolvingActive = new j.WatchedValue(!1),
                this._bulkActions = {
                    activeCounter: 0
                },
                this._height = 0,
                this._width = 0,
                this._sizeChanged = new G.Delegate,
                this._dataSourcesCollectionChanged = new G.Delegate,
                this._symbolSourceCollectionChanged = new G.Delegate,
                this._priceSourcesCollectionChanged = new G.Delegate,
                this._maximized = new j.WatchedValue(!1),
                this._collapsed = new j.WatchedValue(!1),
                this._resetPriceScalesAvailable = new j.WatchedValue(!1),
                this._destroyed = new G.Delegate,
                this._executionsPositionController = null,
                this._seriesDisplayError = null,
                this._onPriceScaleIsVisibleChanged = ()=>{
                    this._model.fullUpdate()
                }
                ,
                this._recalcSymbolSourceResolvingActive = ()=>{
                    for (const e of this._symbolSources)
                        if (e.symbolResolvingActive().value())
                            return void this._symbolSourceResolvingActive.setValue(!0);
                    this._symbolSourceResolvingActive.setValue(!1)
                }
                ,
                this._onSymbolSourceCollectionChanged = ()=>{
                    0 === this._bulkActions.activeCounter ? this._symbolSourceCollectionChanged.fire() : this._bulkActions.symbolSourceCollectionChanged = !0
                }
                ,
                this._onSeriesDisplayError = e=>{}
                ,
                this._updateResetPriceScalesAvailableValue = ()=>{
                    const e = e=>e.resetScaleAvailable().value()
                      , t = this._leftPriceScales.some(e) || this._rightPriceScales.some(e);
                    this._resetPriceScalesAvailable.setValue(t)
                }
                ,
                this._priceScaleSelectionStrategy = (0,
                ge.createPriceScaleSelectionStrategy)(i.properties().childs().priceScaleSelectionStrategyName.value()),
                this._id = null != s ? s : (0,
                pe.randomHashN)(6),
                this._timeScale = e,
                this.m_mainDataSource = null,
                this._properties = t,
                this._model = i,
                i.properties().childs().priceScaleSelectionStrategyName.subscribe(null, (e=>{
                    this._priceScaleSelectionStrategy = (0,
                    ge.createPriceScaleSelectionStrategy)(e.value()),
                    this._priceScaleSelectionStrategy.apply(this)
                }
                )),
                this._timeScale.barSpacingChanged().subscribe(this, (()=>{
                    this.m_mainDataSource === this._model.mainSeries() && this._recalculatePriceScaleByScaleRatio(this.m_mainDataSource.priceScale())
                }
                )),
                i.onMultipaneSourcesCollectionChanged().subscribe(this, this._invalidateSourcesCache),
                i.panesCollectionChanged().subscribe(this, this._invalidateSourcesCache),
                t.childs().topMargin.subscribe(this, this._updateMargins),
                t.childs().bottomMargin.subscribe(this, this._updateMargins),
                this._updateMargins()
            }
            destroy() {
                var e;
                this._properties.childs().topMargin.unsubscribeAll(this),
                this._properties.childs().bottomMargin.unsubscribeAll(this),
                this._model.properties().childs().priceScaleSelectionStrategyName.unsubscribeAll(this),
                this._timeScale.barSpacingChanged().unsubscribeAll(this),
                this._leftPriceScales.concat(this._rightPriceScales).forEach((e=>{
                    e.modeChanged().unsubscribeAll(this),
                    e.priceRangeChanged().unsubscribeAll(this),
                    e.internalHeightChanged().unsubscribeAll(this),
                    e.isVisible().unsubscribe(this._onPriceScaleIsVisibleChanged),
                    e.resetScaleAvailable().unsubscribe(this._updateResetPriceScalesAvailableValue)
                }
                ));
                for (const e of this.m_dataSources)
                    this.removeSourceFromPriceScale(e),
                    e.destroy && e.destroy();
                null === (e = this._seriesDisplayError) || void 0 === e || e.destroy(),
                this._model.onMultipaneSourcesCollectionChanged().unsubscribeAll(this),
                this._model.panesCollectionChanged().unsubscribeAll(this),
                this._destroyed.fire()
            }
            id() {
                return this._id
            }
            bulkActionMacro(e) {
                const t = this._bulkActions;
                t.activeCounter += 1,
                e(),
                t.activeCounter -= 1,
                0 === t.activeCounter && (this._dataSourcesCollectionChanged.fire(),
                t.symbolSourceCollectionChanged && (this._symbolSourceCollectionChanged.fire(),
                t.symbolSourceCollectionChanged = !1),
                t.priceSourcesCollectionChanged && (this._priceSourcesCollectionChanged.fire(),
                t.priceSourcesCollectionChanged = !1))
            }
            defaultPriceScale() {
                var e, t;
                const i = null !== (t = null === (e = this.m_mainDataSource) || void 0 === e ? void 0 : e.priceScale()) && void 0 !== t ? t : null;
                if (null !== i)
                    return i;
                const s = this.properties().childs().axisProperties.state();
                return s.autoScale = !0,
                new Ze(this._model.properties().childs().scalesProperties,s)
            }
            leftPriceScales() {
                return this._leftPriceScales
            }
            rightPriceScales() {
                return this._rightPriceScales
            }
            visibleLeftPriceScales() {
                var e;
                const t = this._model.priceScaleSlotsCount()
                  , i = this._leftPriceScales.filter((e=>e.isVisible().value()))
                  , s = null === (e = this.mainDataSource()) || void 0 === e ? void 0 : e.priceScale();
                if (i.length > t.left && (null == s ? void 0 : s.isVisible().value())) {
                    const e = (0,
                    C.moveToHead)(i, s);
                    return e.splice(t.left),
                    e
                }
                return i
            }
            visibleRightPriceScales() {
                var e;
                const t = this._model.priceScaleSlotsCount()
                  , i = this._rightPriceScales.filter((e=>e.isVisible().value()))
                  , s = null === (e = this.mainDataSource()) || void 0 === e ? void 0 : e.priceScale();
                if (i.length > t.right && (null == s ? void 0 : s.isVisible().value())) {
                    const e = (0,
                    C.moveToHead)(i, s);
                    return e.splice(t.right),
                    e
                }
                return i
            }
            clearSeries(e) {
                const t = this._model.mainSeries();
                for (let i = this.m_dataSources.length - 1; i >= 0; i--)
                    this.m_dataSources[i] === t && this._removeSourceFromCollections(i, e)
            }
            sourcesByGroup() {
                return this._cachedOrderedSources
            }
            dataSourceForId(e) {
                return this._sourcesById.get(e) || null
            }
            changeSourceId(e, t) {
                var i;
                e === this._model.mainSeries() && (null === (i = (0,
                me.getPersistentLogger)()) || void 0 === i || i.addPersistentLogEntry(`changeSourceId for series from ${e.id()} to ${t}`, he.LOGLEVEL.INFO, gt)),
                (0,
                r.assert)(this.hasDataSource(e));
                const s = e.id();
                e.setId(t),
                this._sourcesById.delete(s),
                this._sourcesById.set(t, e),
                (0,
                Te.isPriceDataSource)(e) && (this._priceSourcesById.delete(s),
                this._priceSourcesById.set(t, e))
            }
            movePriceScale(e, t, i) {
                const s = this.priceScalePosition(e);
                if (s !== t)
                    this.removePriceScale(e),
                    this._placePriceScale(e, t, i),
                    e.invalidateMargins(),
                    this._invalidateSourcesCache();
                else if (void 0 !== i && "overlay" !== s) {
                    const t = "left" === s ? this._leftPriceScales : this._rightPriceScales
                      , o = t.indexOf(e);
                    t.splice(o, 1),
                    t.splice(i, 0, e)
                }
            }
            mainDataSource() {
                return this.m_mainDataSource
            }
            isEmpty() {
                return null === this.m_mainDataSource
            }
            recalculatePriceScale(e, t) {
                if (!e)
                    return;
                let i = e.sourcesForAutoscale();
                if (e === this._model.mainSeries().priceScale() && (i = [...i, ...this._cachedOrderedSources.multipaneSources()]),
                (e.isAutoScale() || e.priceRangeShouldBeRecalculatedOnce() || null === e.priceRange()) && i.length > 0 && !this.timeScale().isEmpty()) {
                    const t = this.timeScale().visibleBarsStrictRange();
                    e.recalculatePriceRange(t)
                }
                e.updateAllViews(t)
            }
            onSourceTagsChanged() {
                this._tagsChanged.fire()
            }
            insertDataSource(e, t, i, s) {
                e.setZorder(i),
                t || (s = !1,
                t = this.findSuitableScale(e)),
                this._addSourceToCollections(e);
                let o = !1;
                e === this.model().mainSeries() ? (this.m_mainDataSource = this.model().mainSeries(),
                o = !0) : null === this.m_mainDataSource && (0,
                Te.isPriceDataSource)(e) && (this.m_mainDataSource = e,
                o = !0),
                s || t.addDataSource(e, this._isInInsertManyDataSourcesState),
                e.setPriceScale(t),
                t.invalidateMargins(),
                e.onTagsChanged && e.onTagsChanged().subscribe(this, this.onSourceTagsChanged),
                o && this._processMainSourceChange(),
                this._tagsChanged.fire(),
                (0,
                Te.isPriceDataSource)(e) && this.recalculatePriceScale(t, (0,
                dt.sourceChangeEvent)(e.id())),
                this._invalidateSourcesCache(),
                this._isInInsertManyDataSourcesState || (0,
                r.ensureNotNull)(this.model().alertsWatcher()).syncSourceAlertLabels(e)
            }
            addDataSource(e, t, i) {
                let s = e.zorder();
                i || ((0,
                T.isLineTool)(e) && !e.isSpeciallyZOrderedSource() ? (s = null !== this._lastLineDataSourceZOrder ? this._lastLineDataSourceZOrder + 1 : this.newLineToolZOrder(),
                this._isInInsertManyDataSourcesState && (this._lastLineDataSourceZOrder = s)) : (0,
                U.isStudy)(e) && !e.isSpeciallyZOrderedSource() && (s = this.newStudyZOrder())),
                this.insertDataSource(e, t, s)
            }
            removeDataSource(e, t, i, s) {
                const o = this.m_dataSources.indexOf(e);
                if (-1 === o)
                    return void pt.logDebug("removeDataSource: invalid data source");
                (0,
                r.ensureNotNull)(this.model().alertsWatcher()).detachSourceAlertLabels(e),
                this._removeSourceFromCollections(o, !!i),
                e !== this.m_mainDataSource || t || (this.m_mainDataSource = null);
                const n = e.priceScale();
                s || this.removeSourceFromPriceScale(e),
                e.onTagsChanged && e.onTagsChanged().unsubscribe(this, this.onSourceTagsChanged),
                (0,
                Te.isPriceDataSource)(e) && !t && this._processMainSourceChange(),
                (0,
                U.isStudy)(e) && e.metaInfo().hasForceOverlayPlots() && this._model.removeMultiPaneSource(e),
                this._tagsChanged.fire(),
                n && (0,
                Te.isPriceDataSource)(e) && this.recalculatePriceScale(n, (0,
                dt.sourceChangeEvent)(e.id())),
                this._invalidateSourcesCache()
            }
            hasDataSource(e) {
                return this._sourcesById.has(e.id())
            }
            hasPriceDataSource(e) {
                return this._priceSourcesById.has(e.id())
            }
            dataSources() {
                return this.m_dataSources
            }
            priceDataSources() {
                return this._priceDataSources
            }
            lollipopDataSources() {
                return this._lollipopDataSources
            }
            symbolSources() {
                return this._symbolSources
            }
            replaceSource(e, t, i) {
                const s = this.m_mainDataSource === e
                  , o = e.zorder()
                  , n = null == i ? void 0 : i.replaceSource(e, t);
                this.removeDataSource(e, s, void 0, n),
                this.insertDataSource(t, i, o, n),
                this._sourcesById.set(t.id(), t),
                (0,
                Te.isPriceDataSource)(t) && this._priceSourcesById.set(t.id(), t),
                s && (this.m_mainDataSource = t,
                this._processMainSourceChange())
            }
            findSuitableScale(e, t, i) {
                return this._priceScaleSelectionStrategy.findSuitableScale(this, e, t, i)
            }
            createNewPriceScaleIfPossible() {
                return this._priceScaleSelectionStrategy.createNewPriceScaleIfPossible(this)
            }
            canCreateNewPriceScale() {
                return this._priceScaleSelectionStrategy.canCreateNewPriceScale(this)
            }
            isOverlay(e) {
                const t = e.priceScale();
                return null === t || "overlay" === this.priceScalePosition(t)
            }
            recalculate(e) {
                this._leftPriceScales.forEach((t=>this.recalculatePriceScale(t, e))),
                this._rightPriceScales.forEach((t=>this.recalculatePriceScale(t, e)));
                for (const t of this.m_dataSources)
                    this.isOverlay(t) && !(0,
                    T.isLineTool)(t) && this.recalculatePriceScale(t.priceScale(), e);
                this.updateAllViews(e),
                this._model.updatePane(this)
            }
            updateAllViews(e) {
                const t = this._cachedOrderedSources.all();
                for (const i of t)
                    i.updateAllViews(e);
                for (const t of this.model().customSources())
                    t.updateViewsForPane(this, e)
            }
            updateLollipopViews(e) {
                for (const t of this._lollipopDataSources)
                    t.updateAllViews(e)
            }
            priceScalePosition(e) {
                return this._leftPriceScales.includes(e) ? "left" : this._rightPriceScales.includes(e) ? "right" : "overlay"
            }
            createPriceScaleAtPosition(e, t) {
                const i = this.properties().childs().axisProperties.state();
                i.autoScale = !0;
                const s = new Ze(this.model().properties().childs().scalesProperties,i);
                return s.setHeight(this.height()),
                mt(s, this._defaultTopMargin(), this._defaultBottomMargin()),
                this._placePriceScale(s, e, t),
                s
            }
            removePriceScale(e) {
                e.modeChanged().unsubscribeAll(this),
                e.priceRangeChanged().unsubscribeAll(this),
                e.internalHeightChanged().unsubscribeAll(this),
                e.isVisible().unsubscribe(this._onPriceScaleIsVisibleChanged),
                e.resetScaleAvailable().unsubscribe(this._updateResetPriceScalesAvailableValue),
                e === this._lockedPriceScale && (this._lockedPriceScale = null,
                this._currentPriceScaleRatio = null);
                const t = this._leftPriceScales.indexOf(e);
                -1 !== t && (this._leftPriceScales[t].invalidateMargins(),
                this._leftPriceScales.splice(t, 1));
                const i = this._rightPriceScales.indexOf(e);
                if (-1 !== i && (this._rightPriceScales[i].invalidateMargins(),
                this._rightPriceScales.splice(i, 1)),
                null === e.mainSource()) {
                    const t = e.dataSources().length;
                    0 !== t && pt.logError("Invalid priceScale state: empty mainSource but non-empty data sources=" + t)
                }
                this._onPriceScalesChanged.fire(),
                this._updateResetPriceScalesAvailableValue()
            }
            priceScaleIndex(e, t) {
                switch (t) {
                case "left":
                    return this.leftPriceScales().indexOf(e);
                case "right":
                    return this.rightPriceScales().indexOf(e)
                }
            }
            move(e, t, i) {
                const s = e.priceScale();
                this.removeSourceFromPriceScale(e),
                t.addDataSource(e),
                e.setPriceScale(t),
                t.invalidateMargins(),
                this._processMainSourceChange(),
                this._invalidateSourcesCache(),
                e.isIncludedInAutoScale() && (null !== s && this.recalculatePriceScale(s, (0,
                dt.sourceChangeEvent)(e.id())),
                this.recalculatePriceScale(t, (0,
                dt.sourceChangeEvent)(e.id()))),
                this._onPriceScalesChanged.fire()
            }
            setZOrders(e) {
                e.forEach(((e,t)=>{
                    t.setZorder(e)
                }
                )),
                this._invalidateSourcesCache(),
                0 === this._bulkActions.activeCounter && this._dataSourcesCollectionChanged.fire(),
                this.model().fullUpdate()
            }
            isMainPane() {
                return this.hasDataSource(this.model().mainSeries())
            }
            isLast() {
                const e = this.model().panes();
                return e[e.length - 1] === this
            }
            newStudyZOrder() {
                return (0,
                Je.newStudyZOrder)(this._priceDataSources)
            }
            newLineToolZOrder(e) {
                return (0,
                Je.newLineToolZOrder)(this.m_dataSources, e)
            }
            model() {
                return this._model
            }
            containsMainSeries() {
                return this._sourcesById.has(this.model().mainSeries().id())
            }
            applyPriceScaleRatio(e, t) {
                var i;
                null !== this._lockedPriceScale && this._lockedPriceScale !== e || this._currentPriceScaleRatio === t || !this.isMainPane() || null === this._lockedPriceScale && e !== (null === (i = this.mainDataSource()) || void 0 === i ? void 0 : i.priceScale()) || (this._setNewPriceRangeByScaleRatio(e, t, this._mainSourceVisiblePriceRange(e), !0, !0),
                null !== this._lockedPriceScale ? this._tryToApplyNewPriceScaleRatio() : e.isLog() || this.model().mainSeriesScaleRatioPropertyOnChanged())
            }
            sendToBack(e) {
                const t = this.sourcesByGroup().allExceptSpecialSources();
                this._batchReorder(e, t[0], Je.moveBeforeSource)
            }
            bringToFront(e) {
                const t = this.sourcesByGroup().allExceptSpecialSources();
                this._batchReorder(e, t[t.length - 1], Je.moveAfterSource)
            }
            sendBackward(e) {
                const t = this.sourcesByGroup().allIncludingHidden()
                  , i = t.indexOf(e[0]);
                if (0 === i)
                    this.bringToFront(e);
                else {
                    const s = t[i - 1];
                    this.insertBefore(e, s)
                }
            }
            bringForward(e) {
                const t = this.sourcesByGroup().allExceptSpecialSources()
                  , i = t.indexOf(e[e.length - 1]);
                if (i === t.length - 1)
                    this.sendToBack(e);
                else {
                    const s = t[i + 1];
                    this.insertAfter(e, s)
                }
            }
            insertAfter(e, t) {
                this._batchReorder(e, t, Je.moveAfterSource)
            }
            insertBefore(e, t) {
                this._batchReorder(e, t, Je.moveBeforeSource)
            }
            maximized() {
                return this._maximized
            }
            collapsed() {
                return this._collapsed
            }
            getPriceScaleById(e) {
                const t = this.m_dataSources.find((t=>{
                    var i;
                    return (null === (i = t.priceScale()) || void 0 === i ? void 0 : i.id()) === e
                }
                ));
                return void 0 === t ? null : t.priceScale()
            }
            priceScaleSelectionStrategy() {
                return this._priceScaleSelectionStrategy
            }
            setPriceScaleSelectionStrategy(e) {
                this._priceScaleSelectionStrategy = e,
                e.apply(this)
            }
            findTargetPriceAxisViews(e, t, i, s) {
                if ((0,
                y.isDataSource)(e) && this.model().paneForSource(e) !== this)
                    return [];
                const o = e.priceScale();
                if (t === o)
                    return i;
                if (null === o)
                    return [];
                if ("overlay" === this.priceScalePosition(o))
                    return t === this.defaultPriceScale() ? i : [];
                const n = this.priceScalePosition(t);
                if (n !== this.priceScalePosition(o))
                    return [];
                const r = "left" === n ? this.leftPriceScales() : this.rightPriceScales();
                return r.indexOf(t) < r.indexOf(o) ? s : []
            }
            actionNoScaleIsEnabled(e) {
                return !(!this.isOverlay(e) && (0,
                Te.isPriceDataSource)(e)) || this._nonOverlayPricesSourcesCount() > 1
            }
            properties() {
                return this._properties
            }
            setPriceAutoScale(e, t) {
                e.setMode({
                    autoScale: t
                }),
                this.timeScale().isEmpty() || this.recalculatePriceScale(e, (0,
                dt.viewportChangeEvent)())
            }
            state(e, t, i, s, o, n) {
                var r, a;
                const l = {
                    sources: [],
                    mainSourceId: null === (r = this.m_mainDataSource) || void 0 === r ? void 0 : r.id(),
                    stretchFactor: this._stretchFactor,
                    leftAxisesState: [],
                    rightAxisesState: [],
                    overlayPriceScales: {},
                    priceScaleRatio: this._currentPriceScaleRatio,
                    isCollapsed: this._collapsed.value()
                }
                  , c = new Map
                  , d = e=>{
                    if (c.has(e))
                        return c.get(e);
                    let r = null;
                    const a = i && !e.isSavedInStudyTemplates() || (0,
                    w.isAlertLabel)(e) || !e.state || (0,
                    T.isLineTool)(e) && n || !e.isSavedInChart(Boolean(t)) || !(r = e.state(t, o)) || s && (0,
                    T.isLineTool)(e) && e.isActualSymbol && !e.isActualSymbol() || e.isPhantom() ? null : r;
                    return c.set(e, a),
                    a
                }
                ;
                if (e) {
                    l.sources = [];
                    for (let e = 0; e < this.m_dataSources.length; e++) {
                        const t = d(this.m_dataSources[e]);
                        null !== t && l.sources.push(t)
                    }
                }
                const u = e=>null !== c.get(e)
                  , h = e=>!n || !(0,
                T.isLineTool)(e);
                l.leftAxisesState = this._leftPriceScales.map((e=>({
                    state: e.state(),
                    sources: e.dataSources().filter(u).filter(h).map((e=>e.id()))
                }))),
                l.rightAxisesState = this._rightPriceScales.map((e=>({
                    state: e.state(),
                    sources: e.dataSources().filter(u).filter(h).map((e=>e.id()))
                }))),
                l.overlayPriceScales = {};
                for (const e of this.m_dataSources)
                    if (this.isOverlay(e) && e.isSavedInChart(Boolean(t))) {
                        const t = e.priceScale();
                        l.overlayPriceScales[e.id()] = null !== (a = null == t ? void 0 : t.state()) && void 0 !== a ? a : null
                    }
                return l
            }
            restoreState(e) {
                var t;
                const {state: i, withData: s, version: o, seriesId: n=this._model.mainSeries().id(), settingsMigration: a={}, contentOverrides: l, restoreSilently: c, reason: d=0} = e;
                null === (t = (0,
                me.getPersistentLogger)()) || void 0 === t || t.addPersistentLogEntry(`Restoring pane with seriesId ${n}`, he.LOGLEVEL.INFO, gt),
                i.stretchFactor && (this._stretchFactor = i.stretchFactor);
                const u = {};
                if (i.sources) {
                    const e = i.sources.filter((e=>{
                        var t;
                        return !!e && ("MainSeries" === e.type || (!(null === (t = e.points) || void 0 === t ? void 0 : t.some((e=>null === e.time_t || !isFinite(e.time_t)))) || (pt.logNormal("Dropped invalid " + e.type + ". Reason: non-numeric point time"),
                        !1)))
                    }
                    ))
                      , t = e.findIndex(Qe.isMainSeriesState);
                    -1 !== t && this.model().mainSeries().setObsoleteZOrder(e[t].zorder),
                    o < 3 && (0,
                    Je.reorderDataSourcesStateZOrder)(e);
                    const r = -1 !== this.m_dataSources.indexOf(this._model.mainSeries());
                    this.clearSeries(Boolean(c)),
                    this.m_mainDataSource = null,
                    r && this._addSourceToCollections(this._model.mainSeries(), c),
                    (()=>{
                        const t = e.find((e=>e.id === i.mainSourceId));
                        if (void 0 === t)
                            return void pt.logWarn("There is no main source with id " + i.mainSourceId + ", total sources=" + e.length);
                        if (!window.TradingView[t.type] || !(0,
                        Ee.isLineToolName)(t.type))
                            return void pt.logNormal("The type of main source is not line tool - fix is unnecessary");
                        let s = null;
                        for (const i of e)
                            if (!window.TradingView[t.type] || !(0,
                            Ee.isLineToolName)(i.type)) {
                                if (null !== s)
                                    return void pt.logWarn("Pane contains more than 1 possibly main sources - auto fix cannot be applied");
                                s = i
                            }
                        if (null === s)
                            return void pt.logWarn("Pane contains only line tools - possible we need to remove this pane?");
                        const o = i.mainSourceId;
                        let n = 0;
                        i.mainSourceId = s.id,
                        e.forEach((e=>{
                            e.ownerSource === o && (e.ownerSource = null == s ? void 0 : s.id,
                            n += 1)
                        }
                        )),
                        pt.logNormal("Auto fix broken pane is applied, changed line tools=" + n + ", changed from=" + o + " to=" + s.id)
                    }
                    )();
                    for (const t of e)
                        if ("study_Sessions" === t.type) {
                            const e = t;
                            e.oldState = !0,
                            this.model().sessions().restoreState(e, s);
                            break
                        }
                    for (const t of e)
                        "study_Sessions" !== t.type && (null === this._model.dataSourceForId(t.id) || "MainSeries" === t.type ? (u[t.id] = t.ownerSource,
                        (0,
                        Qe.isMainSeriesState)(t) ? this._restoreMainSeries(t, s, r, a, l, c) : (0,
                        Qe.isStudyState)(t) ? this.restoreStudy(t, s, n, a, c, d) : (0,
                        Qe.isLineToolState)(t) ? (t.state && (t.state.zOrderVersion = 2),
                        this.restoreLineTool(t, s, void 0, c)) : "ChartEventsSource" === t.type && this._restoreSpecialSource(t, s, c)) : pt.logError("Duplicate id while restoring pane: " + t.type + "," + t.id))
                }
                const h = new Set
                  , p = (e,t)=>{
                    e.priceScale() !== t && (this.removeSourceFromPriceScale(e),
                    e.setPriceScale(t),
                    t.addDataSource(e))
                }
                  , m = (e,t,i)=>{
                    if (h.has(e))
                        return;
                    h.add(e);
                    const s = i.m_showSymbolLabels;
                    void 0 !== s && e === this.model().mainSeries() && this.model().properties().childs().scalesProperties.childs().showSymbolLabels.setValue(s),
                    this._model.children(e, !0).forEach((e=>m(e, t, i))),
                    p(e, t)
                }
                  , g = e=>{
                    const t = (0,
                    V.defaults)("chartproperties").paneProperties.axisProperties
                      , i = new Ze(this.model().properties().childs().scalesProperties,t);
                    return i.restoreState(e.state),
                    i.setHeight(this._height),
                    e.sources.forEach((e=>{
                        const s = this.dataSourceForId(e);
                        s && m(s, i, t)
                    }
                    )),
                    0 === i.dataSources().length ? null : i
                }
                  , _ = e=>e.map(g).filter((e=>null !== e));
                let v;
                if (i.leftAxisesState)
                    v = _(i.leftAxisesState);
                else {
                    const e = g({
                        state: i.leftAxisState,
                        sources: i.leftAxisSources
                    });
                    v = null !== e ? [e] : []
                }
                let S;
                if (this._leftPriceScales.slice().forEach((e=>this.removePriceScale(e))),
                this._leftPriceScales = [],
                v.forEach((e=>this._placePriceScale(e, "left"))),
                i.rightAxisesState)
                    S = _(i.rightAxisesState);
                else {
                    const e = g({
                        state: i.rightAxisState,
                        sources: i.rightAxisSources
                    });
                    S = null !== e ? [e] : []
                }
                this._rightPriceScales.slice().forEach((e=>this.removePriceScale(e))),
                this._rightPriceScales = [],
                S.forEach((e=>this._placePriceScale(e, "right"))),
                this._currentPriceScaleRatio = i.priceScaleRatio || i.leftPriceScaleRatio || i.rightPriceScaleRatio || null;
                const f = new Map;
                for (const e of this.m_dataSources) {
                    if (h.has(e))
                        continue;
                    let t;
                    if (i.overlayPriceScales && i.overlayPriceScales[e.id()]) {
                        let s = i.overlayPriceScales[e.id()];
                        f.has(null == s ? void 0 : s.id) ? t = f.get(null == s ? void 0 : s.id) : (s = (0,
                        r.ensure)(s),
                        t = new Ze(this._model.properties().childs().scalesProperties),
                        t.setHeight(this._height),
                        s.m_isAutoScale = !0,
                        s.m_isLog = !1,
                        s.m_isPercentage = !1,
                        s.m_isLockScale = !1,
                        t.restoreState(s),
                        f.set(s.id, t))
                    } else
                        t = new Ze(this._model.properties().childs().scalesProperties),
                        t.setHeight(this._height);
                    p(e, t)
                }
                for (const e of Object.keys(u)) {
                    const t = u[e]
                      , i = this.dataSourceForId(e);
                    t && i && null === i.ownerSource() && i.setOwnerSource(this.dataSourceForId(t))
                }
                if (i.mainSourceId && !this.containsMainSeries() && (this.m_mainDataSource = this.dataSourceForId(i.mainSourceId)),
                !this.m_mainDataSource)
                    for (const e of this.m_dataSources)
                        if ((0,
                        Te.isPriceDataSource)(e)) {
                            this.m_mainDataSource = e;
                            break
                        }
                for (const e of this.m_dataSources)
                    (0,
                    T.isLineTool)(e) ? (e.ownerSource() || e.setOwnerSource(this.mainDataSource()),
                    e.isFixed() && e.restoreFixedPoint()) : (0,
                    U.isStudy)(e) && !e.ownerSource() && e.isLinkedToSeries() && e.setOwnerSource(this.model().mainSeries());
                this._updateMargins(),
                this._cachedOrderedSources.clear()
            }
            onPriceScalesChanged() {
                return this._onPriceScalesChanged
            }
            setPaneSize(e) {
                let t;
                switch (e) {
                case "large":
                    t = 1;
                    break;
                case "medium":
                    t = .6;
                    break;
                case "small":
                    t = .3;
                    break;
                case "tiny":
                    t = .15;
                    break;
                default:
                    throw new Error("Unknown size enum value: " + e)
                }
                this._stretchFactor = 1e3 * t
            }
            stretchFactor() {
                return this._stretchFactor
            }
            setStretchFactor(e) {
                this._stretchFactor = e
            }
            customSources(e) {
                return this.model().customSources(e)
            }
            createDrawingsCaches() {
                0
            }
            clearDrawingCaches() {
                0
            }
            executionsPositionController() {
                return null
            }
            width() {
                return this._width
            }
            height() {
                return this._height
            }
            setHeight(e) {
                if (this._height !== e) {
                    this._height = e,
                    this._leftPriceScales.forEach((t=>t.setHeight(e))),
                    this._rightPriceScales.forEach((t=>t.setHeight(e)));
                    for (let t = 0; t < this.m_dataSources.length; t++) {
                        const i = this.m_dataSources[t];
                        this.isOverlay(i) && i.priceScale() && (0,
                        r.ensureNotNull)(i.priceScale()).setHeight(e)
                    }
                    this.updateAllViews((0,
                    dt.viewportChangeEvent)()),
                    this._sizeChanged.fire()
                }
            }
            setWidth(e) {
                return this._width !== e && (this._width = e,
                this.updateAllViews((0,
                dt.viewportChangeEvent)()),
                this._sizeChanged.fire(),
                !0)
            }
            onSizeChanged() {
                return this._sizeChanged
            }
            onTagsChanged() {
                return this._tagsChanged
            }
            onDestroyed() {
                return this._destroyed
            }
            dataSourcesCollectionChanged() {
                return this._dataSourcesCollectionChanged
            }
            symbolSourceCollectionChanged() {
                return this._symbolSourceCollectionChanged
            }
            priceSourcesCollectionChanged() {
                return this._priceSourcesCollectionChanged
            }
            symbolSourceResolved() {
                return this._symbolSourceResolved
            }
            symbolSourceResolvingActive() {
                return this._symbolSourceResolvingActive
            }
            sourcePropertiesChanged() {
                return this._sourcePropertiesChanged
            }
            sourceZOrderChanged() {
                return this._sourcesZOrderChanged
            }
            lineToolsForArea(e, t) {
                const i = this.logicalRectToPixels(e);
                return [...this.m_dataSources, ...this.model().multiPaneSources(this)].filter(T.isLineTool).filter((e=>(e.paneViews(this) || []).some((e=>{
                    const s = e.renderer(t);
                    return s && s.doesIntersectWithBox && s.doesIntersectWithBox(i, t)
                }
                ))))
            }
            logicalRectToPixels(e) {
                const t = this.defaultPriceScale()
                  , i = this.timeScale()
                  , s = (0,
                r.ensureNotNull)((0,
                r.ensureNotNull)(t.mainSource()).firstValue())
                  , o = t.priceToCoordinate(e.p1.price, s)
                  , n = i.indexToCoordinate(e.p1.index)
                  , l = t.priceToCoordinate(e.p2.price, s)
                  , c = i.indexToCoordinate(e.p2.index)
                  , d = new a.Point(Math.min(n, c),Math.min(o, l))
                  , u = new a.Point(Math.max(n, c),Math.max(o, l));
                return (0,
                a.box)(d, u)
            }
            timeScale() {
                return this._timeScale
            }
            restoreLineTool(e, t, s, o, n) {
                var a, l, c, u, h, p, m, g, _, v;
                if ((0,
                Ee.isMtpPredictorToolName)(e.type))
                    return pt.logWarn(`No longer supported tool ${e.type} is skipped while restoring state`),
                    null;
                delete e.state.lastUpdateTime,
                e.state.intervalsVisibilities = (0,
                ot.mergeIntervalVisibilitiesDefaults)(e.state.intervalsVisibilities),
                s = void 0 === s || s,
                st.LineToolElliott.migrateState(e),
                "LineToolGannComplex" !== (v = e).type || void 0 !== v.version && 1 !== v.version || (v.type = "LineToolGannFixed"),
                Array.isArray(e.positionPercents) && (e.positionPercents = e.positionPercents[0]);
                const S = e.type
                  , f = e.id
                  , b = e.state
                  , y = s ? e.zorder : this.newLineToolZOrder();
                (0,
                r.assert)((0,
                Ee.isLineToolName)(S), "invalid data source type:" + S + " (expected to be a Line Tool)");
                let C, w, P = null;
                if ((0,
                Qe.isStudyLineToolState)(e)) {
                    P = this._model.isSnapshot() ? new ht.StudyVersioning([],[]) : (0,
                    O.studyMetaInfoRepository)().studyVersioning();
                    const s = ht.StudyVersioning.patchPointsBasedStudyState(e);
                    e = s;
                    const n = new _e.StudyMetaInfo(s.metaInfo);
                    if (!t && n) {
                        const t = n.productId;
                        if (!(null === (a = window.pro) || void 0 === a ? void 0 : a.hasPackage(t))) {
                            const t = new be.StudyLineToolStub(this._model,e,n.shortDescription);
                            return t.setId(f),
                            this._addSourceToCollections(t, o),
                            void 0 !== y && t.setZorder(y),
                            t.setFailed(d.t(null, void 0, i(432101))),
                            null
                        }
                    }
                    const r = P.updateMetaInfo(n)
                      , l = null != r ? r : n;
                    w = (0,
                    T.createStudyLineToolProperties)(S, n, l, b, P),
                    C = (0,
                    T.createLineTool)(S, this._model, w, l, !0)
                } else
                    w = (0,
                    T.createLineToolProperties)(S, b, this._model, !1),
                    C = (0,
                    T.createLineTool)(S, this._model, w, null, !0);
                C.setId(f),
                C.linkKey().setValue(e.linkKey || null);
                const x = e.alertId;
                x && C.canHasAlert() && Ce.alertsAvailable && !this._model.readOnly() && !this._model.isJustClonedChart() && C.restoreAlert(+x);
                let M = null !== (l = e.indexes) && void 0 !== l ? l : [];
                if (M = M.slice(0, null !== (u = null === (c = e.points) || void 0 === c ? void 0 : c.length) && void 0 !== u ? u : M.length),
                C.isFixed() ? void 0 !== e.positionPercents ? C.restorePositionPercents(e.positionPercents) : C.restorePositionPercents({
                    x: .5,
                    y: .5
                }) : e.points && C.restorePoints(e.points, M, t),
                C instanceof nt.LineToolBarsPattern || C instanceof rt.LineToolCallout || C instanceof at.LineToolTrendAngle || C instanceof lt.LineToolGhostFeed || C instanceof ct.LineToolParallelChannel || C instanceof Se.LineToolTweet || C instanceof fe.LineToolIdea)
                    null === (p = (h = C).restoreData) || void 0 === p || p.call(h, e);
                else if (t && (0,
                Qe.isStudyLineToolState)(e) && C.restoreData) {
                    const t = e;
                    P && (t.graphics = ht.StudyVersioning.patchPointsBasedStudyData(new _e.StudyMetaInfo(t.metaInfo), t.graphics)),
                    null === (m = C.restoreData) || void 0 === m || m.call(C, t)
                }
                const I = null == e.version ? 1 : e.version
                  , A = null == C.version ? 1 : C.version;
                if (I !== A && (null === (_ = (g = C).migrateVersion) || void 0 === _ || _.call(g, I, A, {
                    pane: this,
                    model: this._model,
                    properties: w
                })),
                void 0 !== y && C.setZorder(y),
                n)
                    (0,
                    T.prepareLineToolPropertiesByOwnerSource)(C.properties(), n),
                    C.setOwnerSource(n);
                else {
                    const t = e.ownerSource ? this.dataSourceForId(e.ownerSource) : null;
                    C.setOwnerSource(t)
                }
                return C.isFixed() && C.restoreFixedPoint(),
                void 0 !== e.sharingMode && C.share(e.sharingMode),
                this._addSourceToCollections(C, o),
                this._cachedOrderedSources.clear(),
                C
            }
            restoreStudy(e, t, s, o, n, r) {
                var a, l;
                if (t && void 0 === e.data && void 0 === e.nonSeriesData && void 0 === e.indexes)
                    return pt.logError("Cannot restore (skipping) study without data " + e.id + ", " + e.metaInfo.id),
                    null;
                const c = e.id
                  , u = e.state
                  , h = e.zorder;
                s = null != s ? s : this._model.mainSeries().id();
                const p = (null !== (a = e.parentSources) && void 0 !== a ? a : e.ownerSource ? [e.ownerSource] : []).filter((e=>e !== s));
                let m = new _e.StudyMetaInfo(e.metaInfo);
                if (function(e) {
                    return "Script$TV_EARNINGS@tv-scripting" === e || "Script$TV_DIVIDENDS@tv-scripting" === e || "Script$TV_SPLITS@tv-scripting" === e || "ESD$TV_EARNINGS@tv-scripting" === e || "ESD$TV_DIVIDENDS@tv-scripting" === e || "ESD$TV_SPLITS@tv-scripting" === e || "Earnings@tv-basicstudies" === e || "Dividends@tv-basicstudies" === e || "Splits@tv-basicstudies" === e || "BarSetContinuousRollDates@tv-corestudies" === e
                }(m.id) && !t)
                    return pt.logNormal("Skipping study " + m.id),
                    null;
                let g = u;
                const _ = new I.StudyStub(this._model,e,null !== (l = m.shortDescription) && void 0 !== l ? l : m.name);
                _.setId(c),
                _.setZorder(h);
                let S = !1;
                const f = (i,s)=>{
                    if (S && this._model.dataSourceForId(c) !== _)
                        return;
                    _.setStatus({
                        type: tt.StudyStatusType.Undefined
                    });
                    const o = null != i ? i : m
                      , n = it.DeferredStudies.instance(this._model)
                      , a = async a=>{
                        var l;
                        const d = (0,
                        A.prepareStudyPropertiesForLoadChart)(m, i, g, s)
                          , u = await (0,
                        U.createStudy)(this._model, d, a, o, void 0, r);
                        if (u.setId(c),
                        u.setOwnFirstValue(null !== (l = e.ownFirstValue) && void 0 !== l ? l : null),
                        e.customFields && u.restoreStateCustomFields(e.customFields),
                        t) {
                            const t = e
                              , {data: i, nsData: s, indexes: o} = ht.StudyVersioning.patchStudyData(m, t.data, t.nonSeriesData, t.indexes);
                            u.restoreData(i, s, o)
                        }
                        this._model.replaceStudyStub(_, u),
                        n.add(c, u)
                    }
                    ;
                    if (p.length > 0) {
                        const e = p.map((e=>n.get(e)));
                        Promise.all(e).then(a)
                    } else
                        a([])
                }
                ;
                let b;
                if (t) {
                    const e = ht.StudyVersioning.patchPropsStateAndMetaInfo(u, m, {
                        oldShowStudyLastValueProperty: !(null == o ? void 0 : o.showStudyLastValueProperty)
                    });
                    b = Promise.resolve(new _e.StudyMetaInfo(e.metaInfo))
                } else {
                    b = (0,
                    O.studyMetaInfoRepository)().requestMetaInfo().then((()=>i.e(37819).then(i.bind(i, 749072)).then((e=>{
                        const {pineIdForJavaId: i, migrateJavaStateToPine: s} = e
                          , n = i(m.id);
                        if (n)
                            return (0,
                            O.studyMetaInfoRepository)().findById({
                                pineId: n,
                                pineVersion: "last",
                                type: "pine"
                            }).then((e=>(s(u, m, e),
                            m = e,
                            v.emit("chart_migrated"),
                            e)));
                        {
                            const e = ht.StudyVersioning.patchPropsStateAndMetaInfo(u, m, {
                                oldShowStudyLastValueProperty: t && !(null == o ? void 0 : o.showStudyLastValueProperty)
                            });
                            return g = e.propsState,
                            new _e.StudyMetaInfo(e.metaInfo)
                        }
                    }
                    ))))
                }
                b.then((e=>{
                    var t;
                    const i = this._model.isSnapshot() ? new ht.StudyVersioning([],[]) : (0,
                    O.studyMetaInfoRepository)().studyVersioning();
                    if (null === e || this._model.isSnapshot())
                        return void f(e, i);
                    const s = i.updateMetaInfoAsync(e);
                    s.sync ? f(null !== (t = s.result) && void 0 !== t ? t : e, i) : s.result.then((e=>f(e, i))).catch((e=>_.setFailed("error: " + e)))
                }
                )).catch((()=>_.setFailed(d.t(null, void 0, i(411768))))),
                _.setZorder(h);
                const y = e.metaInfo.linkedToSeries ? this._model.mainSeries() : p.length ? this.dataSourceForId(p[0]) : null;
                return _.setOwnerSource(y),
                this._addSourceToCollections(_, n),
                S = !0,
                this._processMainSourceChange(),
                this._cachedOrderedSources.clear(),
                _
            }
            clipboardLineToolOwnerSource(e) {
                const t = this.dataSourceForId(e);
                if (null !== t) {
                    const e = t.ownerSource();
                    if (null !== e && null !== e.firstValue())
                        return e
                }
                const i = this.mainDataSource();
                if (null !== i && null !== i.firstValue())
                    return i;
                for (const e of this.dataSources())
                    if ((0,
                    Te.isPriceDataSource)(e) && null !== e.firstValue())
                        return e;
                return null
            }
            realignLineTools(e) {
                var t;
                let i = !1;
                for (const s of this.m_dataSources)
                    !(0,
                    T.isLineTool)(s) || void 0 !== e && (null === (t = null == s ? void 0 : s.ownerSource()) || void 0 === t ? void 0 : t.symbolSource()) !== e && (0,
                    Be.isActingAsSymbolSource)(e) || (s.realign(),
                    s.updateAllViews((0,
                    dt.sourceChangeEvent)(s.id())),
                    i = !0);
                return i && this._invalidateSourcesCache(),
                i
            }
            startScalePrice(e, t) {
                e.startScale(t)
            }
            scalePriceTo(e, t) {
                e.scaleTo(t),
                this.updateAllViews((0,
                dt.viewportChangeEvent)())
            }
            endScalePrice(e) {
                e.endScale()
            }
            startScrollPrice(e, t) {
                e.startScroll(t)
            }
            scrollPriceTo(e, t) {
                e.scrollTo(t),
                this.updateAllViews((0,
                dt.viewportChangeEvent)())
            }
            endScrollPrice(e) {
                e.endScroll()
            }
            resetPriceScale(e) {
                const t = this.timeScale().visibleBarsStrictRange();
                e.resetScaleAvailable().value() && e.resetScale(),
                e.recalculatePriceRange(t),
                this.updateAllViews((0,
                dt.viewportChangeEvent)())
            }
            resetPriceScalesAvailable() {
                return this._resetPriceScalesAvailable.readonly()
            }
            restorePriceScaleState(e, t) {
                e.restoreState(t),
                this.updateAllViews((0,
                dt.viewportChangeEvent)())
            }
            beginInsertManyLineDataSources() {
                this._isInInsertManyDataSourcesState = !0,
                this._lastLineDataSourceZOrder = null
            }
            endInsertManyLineDataSources() {
                this._isInInsertManyDataSourcesState = !1,
                this._lastLineDataSourceZOrder = null;
                {
                    const e = (0,
                    r.ensureNotNull)(this.model().alertsWatcher());
                    for (const t of this.m_dataSources)
                        e.syncSourceAlertLabels(t)
                }
            }
            removeSourceFromPriceScale(e) {
                const t = e.priceScale();
                if (null !== t) {
                    const i = t.dataSources();
                    i.indexOf(e) >= 0 && t.removeDataSource(e),
                    0 === i.length && this.removePriceScale(t)
                }
            }
            _invalidateSourcesCache() {
                this._cachedOrderedSources.clear(),
                this._leftPriceScales.forEach((e=>e.invalidateSourcesCache())),
                this._rightPriceScales.forEach((e=>e.invalidateSourcesCache()))
            }
            _processMainSourceChange() {
                let e = !1;
                if (null === this.m_mainDataSource)
                    for (const t of this.m_dataSources)
                        if ((0,
                        Te.isPriceDataSource)(t) && !this.isOverlay(t) && (!(0,
                        U.isStudy)(t) || !t.isLinkedToSeries())) {
                            this.m_mainDataSource = t,
                            e = !0;
                            break
                        }
                if (this.m_mainDataSource && e) {
                    let e = this.m_dataSources.filter(T.isLineTool);
                    e = (0,
                    Pe.sortSources)(e);
                    for (const t of e)
                        this.move(t, (0,
                        r.ensureNotNull)(this.m_mainDataSource.priceScale()), !0)
                } else if (!this.m_mainDataSource || this.isOverlay(this.m_mainDataSource) && 0 === this._nonOverlayPricesSourcesCount()) {
                    let e = null;
                    if (this.m_dataSources.includes(this._model.mainSeries()))
                        e = this._model.mainSeries();
                    else
                        for (const t of this.m_dataSources)
                            if ((0,
                            Te.isPriceDataSource)(t) && this.isOverlay(t) && t.showInObjectTree()) {
                                e = t;
                                break
                            }
                    if (null !== e) {
                        const t = this.m_mainDataSource === e;
                        this.m_mainDataSource = e;
                        const i = this.createNewPriceScaleIfPossible();
                        if (t && e === this._model.mainSeries()) {
                            const t = (0,
                            r.ensureNotNull)(e.priceScale());
                            this._model.children(e, !0).forEach((e=>{
                                this.removeSourceFromPriceScale(e),
                                i.addDataSource(e),
                                e.setPriceScale(i)
                            }
                            )),
                            this.removePriceScale(t)
                        }
                        this.move(e, i, !0),
                        this.recalculatePriceScale(e.priceScale(), (0,
                        dt.globalChangeEvent)())
                    }
                }
            }
            _addSourceToCollections(e, t) {
                this.m_dataSources.push(e),
                this._sourcesById.set(e.id(), e),
                this._invalidateSourcesCache();
                const i = ()=>{
                    this._sourcePropertiesChanged.fire(e)
                }
                ;
                e.properties().subscribe(this, i),
                e.zOrderChanged().subscribe(this, (t=>this._sourcesZOrderChanged.fire(e, t))),
                (0,
                T.isLineTool)(e) && (e.normalizedPointsChanged().subscribe(this, i),
                e.fixedPointChanged().subscribe(this, i),
                e.hasAlert().subscribe(i),
                e.sharingMode().subscribe(i),
                e.linkKey().subscribe(i),
                this._sourceWatchedValuesSubscriptions.set(e.id(), i));
                const s = (0,
                Be.isSymbolSource)(e) ? e : null;
                if ((0,
                Te.isPriceDataSource)(e) && (this._priceSourcesById.set(e.id(), e),
                e.currencyChanged().subscribe(this, (()=>this._invalidateSourcesCache())),
                e.unitChanged().subscribe(this, (()=>this._invalidateSourcesCache())),
                this._priceDataSources.push(e),
                this._onPriceSourcesCollectionChanged(),
                null !== s && (this._symbolSources.push(s),
                s.symbolResolved().subscribe(this, (()=>this._symbolSourceResolved.fire(e))),
                s.symbolResolvingActive().subscribe(this._recalcSymbolSourceResolvingActive),
                s.symbolHibernated().subscribe(this._onSymbolSourceCollectionChanged),
                this._recalcSymbolSourceResolvingActive(),
                this._onSymbolSourceCollectionChanged()),
                (0,
                U.isStudy)(e) || (0,
                U.isStudyStub)(e))) {
                    const t = e.metaInfo();
                    t && (0,
                    we.isCountedUserScript)(t) && (0,
                    we.addUserScriptOnLayout)(t.scriptIdPart, (0,
                    r.ensureDefined)(t.pine).version)
                }
                e.isMultiPaneAvailable() && this.model().addMultiPaneSource(e),
                (0,
                ye.isLollipopDataSource)(e) && (this._lollipopDataSources.push(e),
                this.updateLollipopViews((0,
                dt.sourceChangeEvent)(e.id()))),
                t || 0 !== this._bulkActions.activeCounter || this._dataSourcesCollectionChanged.fire()
            }
            _removeSourceFromCollections(e, t) {
                const i = this.m_dataSources[e]
                  , s = i.id();
                if (i.properties().unsubscribeAll(this),
                i.zOrderChanged().unsubscribeAll(this),
                this.m_dataSources.splice(e, 1),
                this._sourcesById.delete(i.id()),
                (0,
                T.isLineTool)(i) && (i.normalizedPointsChanged().unsubscribeAll(this),
                i.fixedPointChanged().unsubscribeAll(this),
                this._sourceWatchedValuesSubscriptions.has(s))) {
                    const e = this._sourceWatchedValuesSubscriptions.get(s);
                    i.hasAlert().unsubscribe(e),
                    i.linkKey().unsubscribe(e)
                }
                this._invalidateSourcesCache();
                const o = (0,
                Be.isSymbolSource)(i) ? i : null;
                if ((0,
                Te.isPriceDataSource)(i) && (this._priceSourcesById.delete(i.id()),
                i.currencyChanged().unsubscribeAll(this),
                i.unitChanged().unsubscribeAll(this),
                (0,
                C.removeItemFromArray)(this._priceDataSources, i),
                this._onPriceSourcesCollectionChanged(),
                null !== o && ((0,
                C.removeItemFromArray)(this._symbolSources, o),
                o.symbolResolved().unsubscribeAll(this),
                o.symbolResolvingActive().unsubscribe(this._recalcSymbolSourceResolvingActive),
                o.symbolHibernated().unsubscribe(this._onSymbolSourceCollectionChanged),
                this._recalcSymbolSourceResolvingActive(),
                this._onSymbolSourceCollectionChanged()),
                (0,
                U.isStudy)(i) || (0,
                U.isStudyStub)(i))) {
                    const e = i.metaInfo();
                    e && (0,
                    we.isCountedUserScript)(e) && (0,
                    we.removeUserScriptFromLayout)(e.scriptIdPart, (0,
                    r.ensureDefined)(e.pine).version)
                }
                i.isMultiPaneAvailable() && this.model().removeMultiPaneSource(i),
                (0,
                ye.isLollipopDataSource)(i) && ((0,
                C.removeItemFromArray)(this._lollipopDataSources, i),
                this.updateLollipopViews((0,
                dt.sourceChangeEvent)(i.id()))),
                t || 0 !== this._bulkActions.activeCounter || this._dataSourcesCollectionChanged.fire()
            }
            _recalculatePriceScaleByScaleRatio(e) {
                this.isMainPane() && e === this._lockedPriceScale && (null !== this._currentPriceScaleRatio ? this._applyOldScaleRatioToPriceScale() : this._tryToApplyNewPriceScaleRatio())
            }
            _defaultBottomMargin() {
                return .01 * this.properties().childs().bottomMargin.value()
            }
            _defaultTopMargin() {
                return .01 * this.properties().childs().topMargin.value()
            }
            _updateMargins() {
                const e = this._defaultTopMargin()
                  , t = this._defaultBottomMargin();
                for (const i of this._leftPriceScales)
                    mt(i, e, t);
                for (const i of this._rightPriceScales)
                    mt(i, e, t);
                for (const i of this.m_dataSources)
                    if (this.isOverlay(i)) {
                        const s = i.priceScale();
                        null !== s && (mt(s, e, t),
                        this.recalculatePriceScale(s, (0,
                        dt.viewportChangeEvent)()))
                    }
                for (const e of this._leftPriceScales)
                    this.recalculatePriceScale(e, (0,
                    dt.viewportChangeEvent)());
                for (const e of this._rightPriceScales)
                    this.recalculatePriceScale(e, (0,
                    dt.viewportChangeEvent)());
                this.updateAllViews((0,
                dt.viewportChangeEvent)())
            }
            _batchReorder(e, t, i) {
                i(this.sourcesByGroup().allExceptSpecialSources(), e, t),
                this._invalidateSourcesCache(),
                this._dataSourcesCollectionChanged.fire(),
                this.model().fullUpdate()
            }
            _placePriceScale(e, t, i) {
                if ("overlay" === t)
                    return void e.invalidateMargins();
                const s = "left" === t ? this._leftPriceScales : this._rightPriceScales
                  , o = void 0 === i ? s.length : i;
                s.splice(o, 0, e),
                e.modeChanged().subscribe(this, this._onPriceScaleModeChanged.bind(this, e)),
                e.internalHeightChanged().subscribe(this, this._recalculatePriceScaleByScaleRatio.bind(this, e)),
                e.priceRangeChanged().subscribe(this, this._recalculateTimeScaleByScaleRatio.bind(this, e)),
                e.priceRangeChanged().subscribe(this, this._onPriceScaleSetMinMaxPriceRange.bind(this, e)),
                e.isVisible().subscribe(this._onPriceScaleIsVisibleChanged),
                e.resetScaleAvailable().subscribe(this._updateResetPriceScalesAvailableValue),
                e.isLockScale() && ((0,
                r.assert)(null === this._lockedPriceScale),
                this._lockedPriceScale = e,
                this._currentPriceScaleRatio = null),
                e.invalidateMargins(),
                this._onPriceScalesChanged.fire(),
                this._updateResetPriceScalesAvailableValue()
            }
            _onPriceScaleModeChanged(e, t, i) {
                if (i.lockScale && (this._lockedPriceScale !== e && null !== this._lockedPriceScale && this._lockedPriceScale.setMode({
                    lockScale: !1
                }),
                this._lockedPriceScale = e,
                this._currentPriceScaleRatio = (0,
                $e.scaleRatio)(this.timeScale(), e)),
                t.lockScale && !i.lockScale && (this._lockedPriceScale = null,
                this._currentPriceScaleRatio = null),
                t.percentage === i.percentage && t.indexedTo100 === i.indexedTo100)
                    return;
                const s = this.timeScale().visibleBarsStrictRange();
                null !== s && (e.recalculatePriceRange(s),
                e.updateAllViews((0,
                dt.viewportChangeEvent)()))
            }
            _applyOldScaleRatioToPriceScale() {
                this._isRecalculatingScales || null === this._currentPriceScaleRatio || null === this._lockedPriceScale || (this._isRecalculatingScales = !0,
                this._setNewPriceRangeByScaleRatio(this._lockedPriceScale, this._currentPriceScaleRatio, this._mainSourceVisiblePriceRange(this._lockedPriceScale)),
                this._isRecalculatingScales = !1)
            }
            _setNewPriceRangeByScaleRatio(e, t, i, s, o) {
                const n = (0,
                $e.priceRangeByScaleRatio)(e, this.timeScale().barSpacing(), t);
                e.setPriceRange(null !== n ? n : i, s, o)
            }
            _applyOldScaleRatioToTimeScale() {
                this._isRecalculatingScales || null === this._currentPriceScaleRatio || (this._isRecalculatingScales = !0,
                this._setNewBarSpacingByScaleRatio(),
                this._isRecalculatingScales = !1)
            }
            _tryToApplyNewPriceScaleRatio() {
                const e = (0,
                r.ensureNotNull)(this._lockedPriceScale)
                  , t = (0,
                $e.scaleRatio)(this.timeScale(), e);
                this._currentPriceScaleRatio === t || e.isLog() || (this._currentPriceScaleRatio = t,
                this.model().mainSeriesScaleRatioPropertyOnChanged())
            }
            _recalculateTimeScaleByScaleRatio(e) {
                e === this._lockedPriceScale && (null !== this._currentPriceScaleRatio ? this._applyOldScaleRatioToTimeScale() : this._tryToApplyNewPriceScaleRatio())
            }
            _setNewBarSpacingByScaleRatio() {
                const e = this.timeScale().getValidBarSpacing((0,
                $e.barSpacingByScaleRatio)((0,
                r.ensureNotNull)(this._lockedPriceScale), this._currentPriceScaleRatio));
                this.timeScale().isValidBarSpacing(e) && this.timeScale().setBarSpacing(e)
            }
            _mainSourceVisiblePriceRange(e) {
                const t = this.timeScale().visibleBarsStrictRange();
                return null !== t ? (0,
                r.ensureNotNull)((0,
                r.ensureNotNull)(e.mainSource()).priceRange(t.firstBar(), t.lastBar(), {
                    targetPriceScale: e,
                    scaleSeriesOnly: e.isScaleSeriesOnly()
                })) : new ke.PriceRange(-.5,.5)
            }
            _setMinMaxPriceRange() {
                const e = (0,
                r.ensureNotNull)(this._lockedPriceScale)
                  , t = (0,
                $e.priceRangeByScaleRatio)(e, this.timeScale().maxBarSpacing(), this._currentPriceScaleRatio)
                  , i = (0,
                $e.priceRangeByScaleRatio)(e, this.timeScale().minBarSpacing(), this._currentPriceScaleRatio);
                null !== t && e.setMaxPriceRange(t),
                null !== i && e.setMinPriceRange(i)
            }
            _onPriceScaleSetMinMaxPriceRange(e) {
                e === this._lockedPriceScale && this._setMinMaxPriceRange()
            }
            _onPriceSourcesCollectionChanged() {
                0 === this._bulkActions.activeCounter ? this._priceSourcesCollectionChanged.fire() : this._bulkActions.priceSourcesCollectionChanged = !0
            }
            _nonOverlayPricesSourcesCount() {
                return this.m_dataSources.filter((e=>(!(0,
                U.isStudy)(e) || !e.isLinkedToSeries()) && ((0,
                Te.isPriceDataSource)(e) && e.showInObjectTree() && !this.isOverlay(e)))).length
            }
            _restoreMainSeries(e, t, i, s, o, n) {
                var a, l, c;
                const d = e.id
                  , u = e.state;
                if (u && o && (u.style = null !== (a = o.style) && void 0 !== a ? a : u.style,
                u.interval = o.interval || u.interval,
                o.symbol && o.symbol !== u.symbol && (u.symbol = o.symbol,
                delete u.currencyId,
                delete u.unitId)),
                u && ["candleStyle", "hollowCandleStyle", "haStyle"].forEach((e=>{
                    u[e] && (u[e].wickUpColor = u[e].wickUpColor || u[e].wickColor,
                    u[e].wickDownColor = u[e].wickDownColor || u[e].wickColor)
                }
                )),
                u && (u.statusViewStyle = u.statusViewStyle || {},
                !u.statusViewStyle.symbolTextSource)) {
                    const e = !!u.statusViewStyle.showSymbolAsDescription;
                    u.statusViewStyle.symbolTextSource = e ? "ticker" : "description"
                }
                if (u) {
                    u.extendedHours ? u.sessionId = "extended" : u.sessionId || (u.sessionId = "regular"),
                    delete u.extendedHours,
                    (0,
                    ut.allChartStyles)().includes(u.style) || (u.style = 2);
                    const e = u.lineStyle.styleType;
                    let t;
                    delete u.lineStyle.styleType,
                    0 === e && (t = 14,
                    u.lineWithMarkersStyle = (0,
                    ve.clone)(u.lineStyle)),
                    1 === e && (t = 15,
                    u.steplineStyle = (0,
                    ve.clone)(u.lineStyle)),
                    void 0 !== t && 2 === u.style && (u.style = t)
                }
                if (!i) {
                    const e = this._model.mainSeries();
                    (0,
                    r.ensureNotNull)(this._model.mainPane()).removeDataSource(e, !1, n),
                    this._addSourceToCollections(e, n)
                }
                const h = this.model().mainSeries()
                  , p = h.properties().childs();
                this.m_mainDataSource = h;
                const m = u && u.style ? u.style : void 0;
                6 === m && "ATR" === p.pnfStyle.childs().inputs.childs().style.value() ? p.pnfStyle.childs().inputs.childs().style.setValueSilently("Traditional") : 4 === m && "ATR" === p.renkoStyle.childs().inputs.childs().style.value() && p.renkoStyle.childs().inputs.childs().style.setValueSilently("Traditional"),
                u && !u.hasOwnProperty("showSessions") && (u.showSessions = !1),
                u && void 0 === u.settlementAsClose && (u.settlementAsClose = !1),
                u && t && (u.showCountdown = !1),
                u && (t && !("showSeriesLastValueProperty"in s) && "showLastValue"in u && this._model.properties().childs().scalesProperties.childs().showSeriesLastValue.setValue(u.showLastValue),
                delete u.showLastValue),
                u && this._restoreMainSeriesStudyInputs(e, h.styleStudyInfos());
                const g = h.sessionId();
                null === (l = (0,
                me.getPersistentLogger)()) || void 0 === l || l.addPersistentLogEntry(`Restore series. source.id: ${e.id} id: ${d}`, he.LOGLEVEL.INFO, gt),
                h.restoreState(e, t),
                this.changeSourceId(h, d),
                null === (c = (0,
                me.getPersistentLogger)()) || void 0 === c || c.addPersistentLogEntry(`Series has been successfully restored. id: ${h.id()}`, he.LOGLEVEL.INFO, gt),
                h.sessionId() !== g && p.sessionId.listeners().fire(p.sessionId, "")
            }
            async _restoreMainSeriesStudyInputs(e, t) {
                var i;
                await (0,
                O.studyMetaInfoRepository)().requestMetaInfo();
                const s = (0,
                O.studyMetaInfoRepository)().studyVersioning()
                  , o = {
                    haStyle: (0,
                    W.chartStyleStudyId)(8, !0),
                    renkoStyle: (0,
                    W.chartStyleStudyId)(4, !0),
                    pbStyle: (0,
                    W.chartStyleStudyId)(7, !0),
                    kagiStyle: (0,
                    W.chartStyleStudyId)(5, !0),
                    pnfStyle: (0,
                    W.chartStyleStudyId)(6, !0),
                    rangeStyle: (0,
                    W.chartStyleStudyId)(11, !0),
                    volFootprintStyle: (0,
                    W.chartStyleStudyId)(17, !0),
                    tpoStyle: (0,
                    W.chartStyleStudyId)(18, !0),
                    svpStyle: (0,
                    W.chartStyleStudyId)(20, !0)
                }
                  , n = {}
                  , a = (0,
                r.ensureDefined)(e.state);
                for (const [r] of Object.entries(et.SYMBOL_STRING_DATA)) {
                    const l = `${et.STYLE_SHORT_NAMES[r]}Style`
                      , c = null === (i = a[l]) || void 0 === i ? void 0 : i.inputs;
                    if (null == c)
                        continue;
                    const d = l in e ? e[l].studyId : o[l]
                      , u = _e.StudyMetaInfo.parseIdString(d)
                      , h = t[l].studyId
                      , p = _e.StudyMetaInfo.parseIdString(h)
                      , m = s.updateStudyInputs(u.id, u.version, p.version, c.inputs, null);
                    n[l] = {
                        inputs: m
                    }
                }
                this.model().mainSeries().properties().mergeAndFire(n)
            }
            _restoreSpecialSource(e, t, i) {
                "ChartEventsSource" === e.type && t && this._model.restoreChartEvents(e)
            }
        }
        var vt = i(930203)
          , St = i(45003)
          , ft = i(331218)
          , bt = i(764921);
        const yt = (0,
        he.getLogger)("Chart.TimePoints");
        function Ct(e, t) {
            return null === e || null === t ? e === t : e.firstIndex === t.firstIndex && e.lastIndex === t.lastIndex
        }
        class wt {
            constructor() {
                this._zoffset = 0,
                this._items = [],
                this._range = new q.WatchedObject(null,Ct)
            }
            clear() {
                this._zoffset = 0,
                this._items = [],
                this._range.setValue(null)
            }
            size() {
                return this._items.length
            }
            range() {
                return this._range.readonly()
            }
            merge(e, t, i) {
                const s = this._mergeImpl(e, t, i);
                return this._updateFirstAndLastIndex(),
                s
            }
            addTail(e, t) {
                for (let i = t ? 1 : 0; i < e.length; i++)
                    this._items.push(e[i]);
                this._updateFirstAndLastIndex()
            }
            remove(e) {
                const t = this._indexToOffset(e);
                if (null === t)
                    return [];
                const i = this._items.splice(t)
                  , s = [];
                for (let t = 0; t < i.length; t++)
                    s.push({
                        change: "remove",
                        index: e + t,
                        value: i[t]
                    });
                return this._updateFirstAndLastIndex(),
                s
            }
            valueAt(e) {
                const t = this._indexToOffset(e);
                return null !== t ? this._items[t] : null
            }
            indexOf(e, t) {
                if (this._items.length < 1)
                    return null;
                if (e > this._items[this._items.length - 1])
                    return t ? this._validOffsetToIndex(this._items.length - 1) : null;
                for (let i = 0; i < this._items.length; ++i) {
                    if (e === this._items[i])
                        return this._validOffsetToIndex(i);
                    if (e < this._items[i])
                        return t ? this._validOffsetToIndex(i) : null
                }
                return null
            }
            state(e) {
                var t, i;
                let s = 0
                  , o = this._items.length;
                return null !== e && (s = null !== (t = this._indexToOffset(e.firstBar())) && void 0 !== t ? t : 0,
                o = (null !== (i = this._indexToOffset(e.lastBar())) && void 0 !== i ? i : o - 1) + 1),
                {
                    items: this._items.slice(s, o),
                    zoffset: this._zoffset - s
                }
            }
            restoreState(e) {
                null !== e && (this._items = e.items,
                this._zoffset = e.zoffset,
                this._updateFirstAndLastIndex())
            }
            roughTime(e, t=null) {
                e = Math.round(e);
                const i = this.valueAt(e);
                if (null !== i)
                    return i;
                const s = this._items;
                if (!s.length || s.length < 2)
                    return null;
                const o = s.length - 1
                  , n = this._validOffsetToIndex(0)
                  , r = this._validOffsetToIndex(o)
                  , a = s[0]
                  , l = s[o]
                  , c = (l - a) / (r - n);
                if (e < n) {
                    return a - (n - e) * c
                }
                if (e > r) {
                    const i = e - r;
                    if (i < 500 && null != t)
                        return t(l, i);
                    return l + i * c
                }
                return null
            }
            roughIndex(e, t=null) {
                const i = this._items;
                if (!i.length || i.length < 2)
                    return null;
                const s = i.length - 1
                  , o = this._validOffsetToIndex(0)
                  , n = this._validOffsetToIndex(s)
                  , r = i[0]
                  , a = i[s];
                if (e >= r && e <= a)
                    return this.closestIndexLeft(e);
                const l = (a - r) / (n - o);
                if (e < r) {
                    const t = r - e;
                    return o - Math.round(t / l)
                }
                if (e > a) {
                    const i = e - a;
                    let s = Math.trunc(i / l);
                    if (s < 500 && null !== t) {
                        const i = t(a, e);
                        i.success && (s = i.result)
                    }
                    return n + s
                }
                return null
            }
            closestIndexLeft(e) {
                const t = this._items;
                if (!t.length)
                    return null;
                if (Number.isNaN(e))
                    return null;
                let i = t.length - 1;
                if (e >= t[i])
                    return this._validOffsetToIndex(i);
                let s = 0;
                const o = t[s];
                if (e < o)
                    return null;
                if (e === o)
                    return this._validOffsetToIndex(s);
                for (; i > s + 1; ) {
                    const o = s + i >> 1
                      , n = t[o];
                    if (n > e)
                        i = o;
                    else {
                        if (!(n < e))
                            return n === e ? this._validOffsetToIndex(o) : null;
                        s = o
                    }
                }
                return this._validOffsetToIndex(s)
            }
            _mergeImpl(e, t, i) {
                if (0 === i.length)
                    return yt.logError("merge: 'values' does not contain any time points"),
                    [];
                if (t > this._zoffset && e + t > 0)
                    return yt.logError("merge: when the first time point index is updated, we should fill the time points starting from the first one"),
                    [];
                if (0 === this._items.length)
                    return this._items = i.slice(),
                    this._zoffset = t,
                    [{
                        change: "rebuild",
                        index: this._validOffsetToIndex(0)
                    }];
                const s = e + this._zoffset;
                if (s < 0) {
                    const o = Math.abs(s);
                    if (i.length < o)
                        return yt.logError("merge: 'values' does not contain enough time points to fill in the new items. 'index': " + e.toString() + ", previous 'zoffset': " + this._zoffset.toString() + ", new 'zoffset': " + t.toString() + ", 'values.length': " + i.length),
                        [];
                    this._items = new Array(o).concat(this._items),
                    this._zoffset = t;
                    for (let s = 0; s < i.length; ++s)
                        this._items[e + s + t] = i[s];
                    return [{
                        change: "rebuild",
                        index: this._validOffsetToIndex(0)
                    }]
                }
                const o = [];
                let n = s;
                for (; n < this._items.length && n - s < i.length; ++n)
                    this._items[n] = i[n - s],
                    o.push({
                        change: "update",
                        index: this._validOffsetToIndex(n),
                        value: i[n - s]
                    });
                const r = s + i.length;
                if (r > this._items.length) {
                    const e = r - this._items.length;
                    for (let t = n; t < n + e; ++t) {
                        const e = this._items.length;
                        this._items.push(i[t - s]),
                        o.push({
                            change: "append",
                            index: this._validOffsetToIndex(e),
                            value: i[t - s]
                        })
                    }
                } else {
                    for (let e = r; e < this._items.length; ++e)
                        o.push({
                            change: "remove",
                            index: this._validOffsetToIndex(e),
                            value: this._items[e]
                        });
                    this._items.length = r
                }
                return this._zoffset = t,
                o
            }
            _updateFirstAndLastIndex() {
                const e = this._offsetToIndex(0)
                  , t = this._offsetToIndex(this._items.length - 1);
                this._range.setValue(null === e || null === t ? null : {
                    firstIndex: e,
                    lastIndex: t
                })
            }
            _validOffsetToIndex(e) {
                return e - this._zoffset
            }
            _offsetToIndex(e) {
                return 0 <= e && e < this.size() ? this._validOffsetToIndex(e) : null
            }
            _indexToOffset(e) {
                const t = e + this._zoffset;
                return 0 <= t && t < this.size() ? t : null
            }
        }
        var Tt = i(501571);
        const Pt = new Map([[0, .1], [11, .1], [1, .35], [9, .35], [12, .35], [8, .35]]);
        class xt {
            constructor(e, t) {
                this._styleSpecificRanges = new Map,
                this._logicalRange = e,
                this._defaultStyle = t
            }
            strictRange(e) {
                if (null === this._logicalRange)
                    return null;
                void 0 === e && (e = this._defaultStyle);
                let t = this._styleSpecificRanges.get(e);
                if (void 0 === t) {
                    const i = (Pt.get(e) || 0) / 2;
                    t = new ft.BarsRange(Math.floor(this._logicalRange.left() + i),Math.ceil(this._logicalRange.right() - i)),
                    this._styleSpecificRanges.set(e, t)
                }
                return t
            }
            logicalRange() {
                return this._logicalRange
            }
            isValid() {
                return null !== this._logicalRange
            }
            static invalid() {
                return new xt(null,1)
            }
        }
        var Mt = i(944843)
          , It = i(596673);
        class At {
            constructor(e, t=50) {
                this._actualSize = 0,
                this._usageTick = 1,
                this._oldestTick = 1,
                this._cache = new Map,
                this._tick2Labels = new Map,
                this._format = e,
                this._maxSize = t
            }
            format(e) {
                const t = this._cache.get(e.valueOf());
                if (void 0 !== t)
                    return t.string;
                if (this._actualSize === this._maxSize) {
                    const e = this._tick2Labels.get(this._oldestTick);
                    this._tick2Labels.delete(this._oldestTick),
                    this._cache.delete((0,
                    r.ensureDefined)(e)),
                    this._oldestTick++,
                    this._actualSize--
                }
                const i = this._format(e);
                return this._cache.set(e.valueOf(), {
                    string: i,
                    tick: this._usageTick
                }),
                this._tick2Labels.set(this._usageTick, e.valueOf()),
                this._actualSize++,
                this._usageTick++,
                i
            }
        }
        var Lt = i(339709);
        let Et;
        var kt = i(220003)
          , Dt = i(662445)
          , Nt = i(69184)
          , Bt = i(518439)
          , Rt = i(848891);
        class Ot {
            constructor() {
                this._baseIndex = 0
            }
            setBaseIndex(e) {
                this._baseIndex = e
            }
            indexToTotalWeight(e) {
                return e - this._baseIndex
            }
            totalWeightToIndex(e) {
                return this._baseIndex + e
            }
            indexRangeToWeights(e, t, i) {
                const s = e - this._baseIndex;
                return [{
                    left: s - .5,
                    center: s,
                    right: s + .5,
                    timePointIndex: e
                }]
            }
            state(e) {
                return {
                    type: "constant",
                    state: {
                        baseIndex: this._baseIndex
                    }
                }
            }
            restoreState(e) {
                this._baseIndex = e.state.baseIndex
            }
            needAdjustingOnDataRestoring() {
                return !1
            }
        }
        var Vt = i(655988);
        const Wt = {
            preserveBarSpacing: !1,
            lockVisibleTimeRangeOnResize: !1,
            rightBarStaysOnScroll: !0,
            minBarSpacing: .5
        }
          , Ft = ue.enabled("low_density_bars")
          , Ht = Ft ? 1 : 2
          , zt = (0,
        he.getLogger)("Chart.TimeScale");
        class Ut {
            constructor(e, t) {
                this._width = 0,
                this._widthChanged = new G.Delegate,
                this._rightOffset = 10,
                this._rightOffsetChanged = new G.Delegate,
                this._maxRightOffsetChanged = new G.Delegate,
                this._defaultRightOffset = new j.WatchedValue(10),
                this._defaultRightOffsetPercentage = new j.WatchedValue(5),
                this._usePercentageRightOffset = new j.WatchedValue(!1),
                this._lastDefaultRightOffset = void 0,
                this._baseIndex = null,
                this._leftEdgeIndex = null,
                this._barSpacingChanged = new G.Delegate,
                this._barSpacing = 6,
                this._snapshotBarSpacing = null,
                this._visibleBars = xt.invalid(),
                this._visibleBarsInvalidated = !0,
                this._visibleBarsChanged = new G.Delegate,
                this._logicalRangeChanged = new G.Delegate,
                this._points = new wt,
                this._tickMarks = new Mt.Tickmarks,
                this._onScroll = new G.Delegate,
                this._resetDelegate = new G.Delegate,
                this._scrollData = null,
                this._scaleStartPoint = null,
                this._commonTransitionStartState = null,
                this._formattedBySpan = new Map,
                this._requestingMoreData = !1,
                this._requestedTickmarksCount = 0,
                this._endOfData = !1,
                this._lockBarsAndLogicalRangeEvents = !1,
                this._resetAvailable = new j.WatchedValue(!1),
                this._pointWeights = new Ot,
                this._weightedPointsCache = [],
                this._options = (0,
                St.deepExtend)({}, Wt, t),
                this._model = e,
                this._scalesProperties = e.properties().childs().scalesProperties,
                this._defaultRightOffset.subscribe((()=>{
                    this._usePercentageRightOffset.setValue(!1),
                    this._defaultRightOffsetOptionsUpdated()
                }
                )),
                this._defaultRightOffsetPercentage.subscribe((e=>{
                    if (e >= 100 || e < 0) {
                        const t = Math.max(0, Math.min(e, 99));
                        this._defaultRightOffsetPercentage.setValue(t)
                    } else
                        this._usePercentageRightOffset.setValue(!0),
                        this._defaultRightOffsetOptionsUpdated()
                }
                )),
                this._usePercentageRightOffset.subscribe((()=>{
                    this._defaultRightOffsetOptionsUpdated()
                }
                )),
                this._options.preserveBarSpacing && (this._barSpacing = this._scalesProperties.childs().barSpacing.value() || 6),
                this._barSpacingChanged.subscribe(this, this._maxRightOffsetOnChanged),
                this._barSpacingChanged.subscribe(this, this._updateResetAvailableValue),
                this._rightOffsetChanged.subscribe(this, this._updateResetAvailableValue),
                this._widthChanged.subscribe(this, this._maxRightOffsetOnChanged),
                this._updateResetAvailableValue()
            }
            destroy() {
                this._barSpacingChanged.unsubscribeAll(this),
                this._barSpacingChanged.destroy(),
                this._widthChanged.unsubscribeAll(this),
                this._widthChanged.destroy()
            }
            isEmpty() {
                return 0 === this._width || !this.canNormalize()
            }
            canNormalize() {
                return this._points.size() > 0
            }
            update(e, t, i, s) {
                this._visibleBarsInvalidated = !0,
                i.length > 0 && this._points.merge(e, t, i),
                this._tickMarks.merge(s),
                this.correctOffset()
            }
            addTail(e, t, i) {
                this._tickMarks.removeTail(t);
                const s = e.params
                  , o = (0,
                r.ensureDefined)(this._tickMarks.maxIndex) + (i ? 0 : 1);
                for (let e = 0; e < s.marks.length; e++)
                    s.marks[e].index = o + e;
                this._tickMarks.addTail(s.marks),
                this._points.addTail(s.changes, i);
                const n = this._rightOffset - s.changes.length;
                this._updateRightOffset(n)
            }
            state(e) {
                const t = {
                    m_barSpacing: this.barSpacing(),
                    m_rightOffset: this._defaultRightOffset.value(),
                    rightOffsetPercentage: this._defaultRightOffsetPercentage.value(),
                    usePercentageRightOffset: this._usePercentageRightOffset.value()
                };
                if (e) {
                    t.m_rightOffset = Math.max(0, this._rightOffset);
                    const e = this.visibleBarsStrictRange()
                      , i = this.visibleExtendedDataRange(this._model.mainSeries().data(), 0)
                      , s = e ? e.unite(i) : i;
                    t.points = this._points.state(s),
                    t.tickmarks = this._tickMarks.state(s),
                    t.width = this._width,
                    t.weights = this._pointWeights.state(s),
                    t.baseIndex = this._baseIndex
                }
                return t
            }
            restoreState(e, t) {
                var i;
                if (void 0 === e.m_barSpacing)
                    return void zt.logDebug("restoreState: invalid state");
                if (void 0 === e.m_rightOffset)
                    return void zt.logDebug("restoreState: invalid state");
                e.weights && (this._pointWeights = function(e) {
                    let t;
                    switch (e.type) {
                    case "constant":
                        return t = new Ot,
                        t.restoreState(e),
                        t;
                    case "computed":
                        return t = new Vt.ComputedTimePointWeights,
                        t.restoreState(e),
                        t
                    }
                    throw new Error(`Unexpected time point weigths type ${e.type}`)
                }(e.weights));
                let s = e.m_barSpacing;
                this._snapshotBarSpacing = t ? s : null;
                const o = e.m_rightOffset < 0 && !t ? this.rightOffsetDefaultValue() : e.m_rightOffset
                  , n = o < 0 ? this.rightOffsetDefaultValue() : Math.round(o);
                if (this._defaultRightOffset.setValue(n),
                void 0 !== e.rightOffsetPercentage && Number.isFinite(e.rightOffsetPercentage) && this._defaultRightOffsetPercentage.setValue(e.rightOffsetPercentage),
                this._usePercentageRightOffset.setValue(Boolean(e.usePercentageRightOffset)),
                this._rightOffset = o,
                this._baseIndex = null !== (i = e.baseIndex) && void 0 !== i ? i : this._baseIndex,
                t && (this._requestedTickmarksCount = 1 / 0,
                this._endOfData = !0,
                this._points.restoreState(e.points || null),
                this._tickMarks.restoreState(e.tickmarks || null),
                e.width && this._width > 0 && (s *= this._width / e.width)),
                t && this._pointWeights.needAdjustingOnDataRestoring()) {
                    this._tryToUpdateBarSpacing(this._barSpacing, s);
                    const e = this._points.range().value();
                    if (e) {
                        const t = e.firstIndex;
                        let i = s
                          , o = s
                          , n = 0;
                        (()=>{
                            n = this.indexToCoordinate(t),
                            n < 0 ? (o = s,
                            i = s / 10) : (i = s,
                            o = 10 * s)
                        }
                        )();
                        for (let e = 0; e < 20 && Math.abs(n) > 2; e++) {
                            const e = (o + i) / 2;
                            this._tryToUpdateBarSpacing(this._barSpacing, e),
                            n = this.indexToCoordinate(t),
                            n < 0 ? o = e : i = e
                        }
                    }
                } else
                    this._tryToUpdateBarSpacing(this._barSpacing, s);
                this.correctOffset(),
                this._usePercentageRightOffset.value() && (this._rightOffset = this.percentsToBarIndexLength(this._defaultRightOffsetPercentage.value())),
                this._rightOffsetChanged.fire(this._rightOffset)
            }
            marks() {
                if (this.isEmpty())
                    return null;
                const e = this._barSpacing
                  , t = 5 * ((this._scalesProperties.childs().fontSize.value() || 0) + 4)
                  , i = Math.round(t / e)
                  , s = (0,
                r.ensureNotNull)(this.visibleBarsStrictRange())
                  , o = Math.max(s.firstBar(), s.firstBar() - i)
                  , n = Math.max(s.lastBar(), s.lastBar() - i)
                  , a = this._tickMarks.build(e, t)
                  , l = [];
                for (const e of a) {
                    if (!(o <= e.index && e.index <= n))
                        continue;
                    const t = this._tickMarks.indexToTime(e.index);
                    null !== t && l.push({
                        coord: this.indexToCoordinate(e.index),
                        label: this.formatLabel(t, e.span),
                        span: e.span,
                        major: e.label >= It.DAY_SPAN
                    })
                }
                return l
            }
            visibleBarsStrictRange() {
                return this._visibleBarsInvalidated && (this._visibleBarsInvalidated = !1,
                this._updateVisibleBars()),
                this._visibleBars.strictRange()
            }
            visibleBarsStrictRangeChanged() {
                return this._visibleBarsChanged
            }
            visibleStrictDataRange(e) {
                const t = this.visibleBarsStrictRange();
                if (null === t)
                    return null;
                const i = e.search(t.firstBar(), Bt.PlotRowSearchMode.NearestRight)
                  , s = e.search(t.lastBar(), Bt.PlotRowSearchMode.NearestLeft);
                return null === i || null === s ? null : new ft.BarsRange(i.index,s.index)
            }
            visibleExtendedDataRange(e, t) {
                const i = this.visibleBarsStrictRange();
                if (null === i)
                    return null;
                let s = 1 === t ? null : e.search(i.firstBar() - 1, Bt.PlotRowSearchMode.NearestLeft)
                  , o = 0 === t ? null : e.search(i.lastBar() + 1, Bt.PlotRowSearchMode.NearestRight);
                return null === s && (s = e.search(i.firstBar(), Bt.PlotRowSearchMode.NearestRight)),
                null === o && (o = e.search(i.lastBar(), Bt.PlotRowSearchMode.NearestLeft)),
                null === s || null === o ? null : new ft.BarsRange(s.index,o.index)
            }
            logicalRangeChanged() {
                return this._logicalRangeChanged
            }
            tickMarks() {
                return this._tickMarks
            }
            points() {
                return this._points
            }
            width() {
                return this._width
            }
            setWidth(e, t) {
                if (!Number.isFinite(e) || e <= 0)
                    return void zt.logWarn(`setWidth: invalid argument: ${e}`);
                if (this._width === e)
                    return;
                const i = this._usePercentageRightOffset.value() && this._rightOffset > 0 ? this.barIndexLengthToPercents(this._rightOffset) : -1;
                if (this._visibleBarsInvalidated = !0,
                (t || this._options.lockVisibleTimeRangeOnResize) && this._width) {
                    const t = this._barSpacing * e / this._width;
                    this._tryToUpdateBarSpacing(this._barSpacing, t)
                } else
                    this._width && this.setBarSpacing(this._barSpacing);
                if (null !== this._leftEdgeIndex) {
                    if ((0,
                    r.ensureNotNull)(this.visibleBarsStrictRange()).firstBar() <= this._leftEdgeIndex) {
                        const t = this._width - e;
                        this._rightOffset -= Math.round(t / this._barSpacing) + 1
                    }
                }
                this._width = e,
                this._widthChanged.fire(e);
                const s = this._rightOffset;
                i > 0 ? this._rightOffset = this.percentsToBarIndexLength(i) : this.correctOffset(),
                this._rightOffset !== s && this._rightOffsetChanged.fire(this._rightOffset),
                this._requestMoreData()
            }
            setLeftEdgeFix(e) {
                this._leftEdgeIndex = e;
                const t = this.visibleBarsStrictRange();
                if (null === t)
                    return;
                const i = t.firstBar() - e;
                if (i < 0) {
                    const e = this._rightOffset - i - 1;
                    this.scrollToOffsetAnimated(e, 500)
                }
            }
            indexToCoordinate(e) {
                if (this.isEmpty())
                    return 0;
                const t = this.baseIndex()
                  , i = this._pointWeights.indexToTotalWeight(t + this._rightOffset + .5) - this._pointWeights.indexToTotalWeight(e);
                return this._width - i * this._barSpacing
            }
            indexToUserTime(e) {
                return this._tickMarks.indexToTime(e)
            }
            timePointToIndex(e, t) {
                switch (t) {
                case 0:
                    return this._points.indexOf(e, !1);
                case 1:
                    return this._points.closestIndexLeft(e);
                default:
                    return this._points.indexOf(e, !0)
                }
            }
            indexToTimePoint(e) {
                return this._points.valueAt(e)
            }
            timeToCoordinate(e) {
                const t = this._points.closestIndexLeft(e);
                if (null === t)
                    return null;
                const i = (0,
                r.ensureNotNull)(this._points.valueAt(t))
                  , s = this.indexToCoordinate(t);
                if (s <= 0 || s >= this._width)
                    return null;
                const o = this.barSpacing()
                  , n = this.baseIndex();
                let a;
                a = 0 === n ? this._model.mainSeries().intervalObj().inMilliseconds() / 1e3 : (0,
                r.ensureNotNull)(this._points.valueAt(n)) - (0,
                r.ensureNotNull)(this._points.valueAt(n - 1));
                const l = s + (e - i) / a * o + 1;
                return l <= 0 || l >= this._width ? null : l
            }
            barBorders(e) {
                const t = {
                    timePointIndex: e,
                    left: NaN,
                    center: NaN,
                    right: NaN
                };
                return this.fillBarBorders([t]),
                t
            }
            fillBarBorders(e, t, i) {
                var s, o;
                if (0 === e.length)
                    return;
                let n = null !== (s = null == t ? void 0 : t.startItemIndex) && void 0 !== s ? s : 0;
                const a = (null !== (o = null == t ? void 0 : t.endItemIndex) && void 0 !== o ? o : e.length) - 1;
                if (!0 === i && (n = (0,
                C.upperbound)(e, Tt.UNPLOTTABLE_TIME_POINT_INDEX, ((e,t)=>e < t.timePointIndex), n, a + 1)),
                n > a)
                    return;
                const l = this._pointWeights.indexToTotalWeight(this.baseIndex() + this._rightOffset + .5)
                  , c = this._pointWeights.indexRangeToWeights(e[n].timePointIndex, e[a].timePointIndex, this._weightedPointsCache);
                let d = 0
                  , u = c[d];
                const h = u
                  , p = c[c.length - 1];
                let m = NaN
                  , g = NaN
                  , _ = NaN
                  , v = !0;
                for (let t = n; t <= a; t += 1) {
                    const i = e[t];
                    if (i.timePointIndex < h.timePointIndex)
                        m = h.left - (h.timePointIndex - i.timePointIndex),
                        g = m + .5,
                        _ = m + 1;
                    else if (i.timePointIndex > p.timePointIndex)
                        _ = p.right + (i.timePointIndex - p.timePointIndex),
                        g = _ - .5,
                        m = _ - 1;
                    else
                        for (v && (m = u.left,
                        g = u.center,
                        _ = u.right,
                        v = !1); u.timePointIndex < i.timePointIndex; )
                            d += 1,
                            (0,
                            r.assert)(d < c.length, "Bar borders coordinates are not correct"),
                            u = c[d],
                            m = u.left,
                            g = u.center,
                            _ = u.right;
                    i.left = this._width - (l - m) * this._barSpacing,
                    i.center = this._width - (l - g) * this._barSpacing,
                    i.right = this._width - (l - _) * this._barSpacing
                }
            }
            timedValuesToCoordinates(e, t, i) {
                var s, o;
                const n = this._pointWeights.indexToTotalWeight(this.baseIndex() + this._rightOffset + .5)
                  , r = null !== (s = null == t ? void 0 : t.startItemIndex) && void 0 !== s ? s : 0;
                let a = r;
                const l = null !== (o = null == t ? void 0 : t.endItemIndex) && void 0 !== o ? o : e.length;
                !0 === i && (a = (0,
                C.upperbound)(e, Tt.UNPLOTTABLE_TIME_POINT_INDEX, ((e,t)=>e < t.x), r, l));
                for (let t = a; t < l; ++t) {
                    const i = e[t]
                      , s = n - this._pointWeights.indexToTotalWeight(i.x);
                    i.x = this._width - s * this._barSpacing
                }
                for (let t = r; t < a; ++t)
                    e[t].x = -500
            }
            rightOffsetForTimePoint(e) {
                const t = this.timeToCoordinate(e);
                if (null === t)
                    return null;
                const i = (t - this._baseIndexBarCenterCoordinate()) / this._barSpacing;
                return this._pointWeights.totalWeightToIndex(i)
            }
            scrollToRealtime(e, t) {
                let i = this.targetDefaultRightOffset();
                i < 0 && (i = this.rightOffsetDefaultValue());
                const s = ()=>{
                    void 0 !== t && t(),
                    this._requestMoreData()
                }
                ;
                if (e) {
                    const e = this.logicalRange()
                      , t = this._model.mainSeries().bars().lastIndex();
                    if (null === e || null === t)
                        return;
                    const i = this.indexToCoordinate(e.right() + .5)
                      , o = this.indexToCoordinate(t + this._defaultRightOffset.value() + .5);
                    return this._model.stopTimeScaleAnimation(),
                    void this._model.setTimeScaleAnimation(new Rt.Animation({
                        from: 0,
                        to: i - o,
                        duration: 1e3,
                        easing: vt.easingFunc.easeInOutQuint,
                        onFinish: s
                    }))
                }
                this._visibleBarsInvalidated = !0,
                this._updateRightOffset(i),
                this._onScroll.fire(),
                s()
            }
            scrollToFirstBar(e=(()=>{}
            )) {
                this._model.gotoTime(new Date("1800-01-01").getTime()).then(e),
                this._onScroll.fire()
            }
            scrollToOffsetAnimated(e, t) {
                if (!isFinite(e))
                    throw new RangeError("offset is required and must be finite number");
                const i = void 0 === t ? 400 : t;
                if (!isFinite(i) || i <= 0)
                    throw new RangeError("animationDuration (optional) must be finite positive number");
                const s = this._rightOffset
                  , o = Date.now()
                  , n = ()=>{
                    this._visibleBarsInvalidated = !0;
                    const t = (Date.now() - o) / i;
                    if (t >= 1)
                        return this._updateRightOffset(e),
                        this._visibleBarsInvalidated = !0,
                        this._model.recalculateAllPanes((0,
                        dt.viewportChangeEvent)()),
                        void this._model.lightUpdate();
                    const r = s + (e - s) * t;
                    this._updateRightOffset(r),
                    this._model.recalculateAllPanes((0,
                    dt.viewportChangeEvent)()),
                    setTimeout(n, 20)
                }
                ;
                n()
            }
            defaultRightOffset() {
                return this._defaultRightOffset
            }
            rightOffsetDefaultValue() {
                return 10
            }
            defaultRightOffsetPercentage() {
                return this._defaultRightOffsetPercentage
            }
            usePercentageRightOffset() {
                return this._usePercentageRightOffset
            }
            barSpacing() {
                return this._barSpacing
            }
            barSpacingScaleRatio() {
                return null === this._snapshotBarSpacing ? 1 : this._barSpacing / this._snapshotBarSpacing
            }
            setBarSpacing(e) {
                Number.isFinite(e) ? (e = this.getValidBarSpacing(e),
                this._tryToUpdateBarSpacing(this._barSpacing, e) && (this.correctOffset(),
                this._options.preserveBarSpacing && ((0,
                E.allowSavingDefaults)(!0),
                this._scalesProperties.childs().barSpacing.setValue(this._barSpacing),
                (0,
                E.allowSavingDefaults)(!1)),
                this._model.recalculateAllPanes((0,
                dt.viewportChangeEvent)()),
                this._model.lightUpdate())) : zt.logWarn(`setBarSpacing: invalid argument: ${e}`)
            }
            barSpacingChanged() {
                return this._barSpacingChanged
            }
            getValidBarSpacing(e) {
                return null == e && (e = this.barSpacing()),
                e < this.minBarSpacing() ? this.minBarSpacing() : e > this.maxBarSpacing() ? this.maxBarSpacing() : e
            }
            isValidBarSpacing(e) {
                return e >= this.minBarSpacing() && e <= this.maxBarSpacing()
            }
            preserveBarSpacing() {
                return this._options.preserveBarSpacing
            }
            normalizeBarIndex(e) {
                let t = 0
                  , i = 0;
                const s = this.baseIndex()
                  , o = (0,
                r.ensureNotNull)(this._points.range().value()).firstIndex;
                return e < o ? (t = (0,
                r.ensureNotNull)(this._points.valueAt(o)),
                i = e - o) : e > s ? (t = (0,
                r.ensureNotNull)(this._points.valueAt(s)),
                i = e - s) : (t = (0,
                r.ensureNotNull)(this._points.valueAt(e)),
                i = 0),
                {
                    time_t: t,
                    offset: i
                }
            }
            denormalizeTimePoint(e) {
                const t = this._points.indexOf(e.time_t, !1);
                if (null !== t)
                    return t + e.offset
            }
            rightOffset() {
                return this._rightOffset
            }
            rightOffsetChanged() {
                return this._rightOffsetChanged
            }
            minRightOffset() {
                var e;
                const t = null === (e = this.points().range().value()) || void 0 === e ? void 0 : e.firstIndex
                  , i = this._baseIndex;
                if (void 0 === t || null === i)
                    return null;
                if (null !== this._leftEdgeIndex) {
                    const e = this.width() / this._barSpacing;
                    return this._leftEdgeIndex - i + e - 1
                }
                return t - i - 1 + Ht
            }
            maxRightOffset() {
                return this.width() / this._barSpacing - Ht
            }
            maxRightOffsetChanged() {
                return this._maxRightOffsetChanged
            }
            onReset() {
                return this._resetDelegate
            }
            baseIndex() {
                return this._baseIndex || 0
            }
            zoom(e, t, i) {
                if (!Number.isFinite(e) || !Number.isFinite(t))
                    return void zt.logWarn(`zoom: invalid arguments: ${e}, ${t}, ${i}`);
                const s = this.rightOffset()
                  , o = void 0 !== i ? !i : this._options.rightBarStaysOnScroll
                  , n = o && this.usePercentageRightOffset().value() && s >= 0
                  , r = n ? this.barIndexLengthToPercents(s) : void 0
                  , a = this.coordinateToIndex(e)
                  , l = this.barSpacing()
                  , c = l + t * (l / 10);
                this.setBarSpacing(c),
                o || (this.startScroll(this.indexToCoordinate(a)),
                this.scrollTo(e),
                this.endScroll()),
                n && void 0 !== r && this.setRightOffset(this.percentsToBarIndexLength(r)),
                this._requestMoreData()
            }
            zoomToBarsRange(e, t) {
                if (null !== this._leftEdgeIndex && (e = Math.max(e, this._leftEdgeIndex)),
                t < e)
                    return;
                const i = this.baseIndex()
                  , s = this._rightOffset;
                this._rightOffset = t - i;
                const o = e - .5
                  , n = t + .5
                  , r = Math.max(this._pointWeights.indexToTotalWeight(n) - this._pointWeights.indexToTotalWeight(o), Ht);
                this.setBarSpacing(this.width() / r),
                this._visibleBarsInvalidated = !0,
                this.correctOffset(),
                this._rightOffset !== s && this._rightOffsetChanged.fire(this._rightOffset),
                this._requestMoreData()
            }
            coordinateToIndex(e) {
                return Math.round(this.coordinateToFloatIndex(e))
            }
            coordinateToFloatIndex(e) {
                const t = (e - this._baseIndexBarCenterCoordinate()) / this._barSpacing
                  , i = this._pointWeights.totalWeightToIndex(t);
                return Math.round(1e6 * i) / 1e6
            }
            coordinateToVisibleIndex(e) {
                let t = this.coordinateToIndex(e);
                const i = this.visibleBarsStrictRange();
                return null === i || i.contains(t) || (t = Math.min(Math.max(i.firstBar(), t), i.lastBar())),
                t
            }
            canZoomIn() {
                return this.barSpacing() < this.maxBarSpacing()
            }
            canZoomOut() {
                return this.barSpacing() > this._options.minBarSpacing
            }
            minBarSpacing() {
                return this._options.minBarSpacing
            }
            maxBarSpacing() {
                const e = this.width();
                return Ft ? e : e / Ht
            }
            minVisibleBarCount() {
                return Ht
            }
            resetRightOffset() {
                this.setRightOffset(this.targetDefaultRightOffset())
            }
            reset() {
                this._visibleBarsInvalidated = !0,
                this._points.clear(),
                this._scrollData = null,
                this._scaleStartPoint = null,
                this._clearCommonTransitionsStartState(),
                this._tickMarks.reset(),
                this._leftEdgeIndex = null,
                this._resetDelegate.fire(),
                this.disconnect()
            }
            resetAvailable() {
                return this._resetAvailable.readonly()
            }
            disconnect() {
                this._requestingMoreData = !1,
                this._requestedTickmarksCount = 0,
                this._endOfData = !1
            }
            setBaseIndex(e) {
                Number.isFinite(e) ? (this._visibleBarsInvalidated = !0,
                this._baseIndex = e,
                this._pointWeights.setBaseIndex(this._baseIndex),
                this.correctOffset()) : zt.logDebug(`setBaseIndex: invalid argument: ${e}`)
            }
            resetBaseIndex() {
                this._visibleBarsInvalidated = !0,
                this._baseIndex = null
            }
            setRightOffset(e) {
                Number.isFinite(e) ? (this._visibleBarsInvalidated = !0,
                this._updateRightOffset(e)) : zt.logWarn(`setRightOffset: invalid argument: ${e}`)
            }
            correctBarSpacing() {
                this.isEmpty() || this.points().size() < this.width() / this.barSpacing() && (this.setRightOffset(this.targetDefaultRightOffset()),
                this.setBarSpacing(this.width() / (this.points().size() + this.rightOffset())))
            }
            setTimePointWeights(e) {
                this._weightedPointsCache = [],
                this._pointWeights = null != e ? e : new Ot,
                this._pointWeights.setBaseIndex(this.baseIndex()),
                this._visibleBarsInvalidated = !0
            }
            correctOffset() {
                const e = this.maxRightOffset();
                this._rightOffset > e && (this._rightOffset = e,
                this._visibleBarsInvalidated = !0);
                const t = this.minRightOffset();
                null !== t && this._rightOffset < t && (this._rightOffset = t,
                this._visibleBarsInvalidated = !0)
            }
            logicalRange() {
                return this._visibleBarsInvalidated && (this._visibleBarsInvalidated = !1,
                this._updateVisibleBars()),
                this._visibleBars.logicalRange()
            }
            restoreDefault() {
                this._visibleBarsInvalidated = !0,
                this._lockBarsAndLogicalRangeEvents = !0;
                const e = this._visibleBars;
                this.setBarSpacing(6),
                this.resetRightOffset(),
                this._lockBarsAndLogicalRangeEvents = !1,
                this._fireVisibleBarsChangedIfRequired(e, this._visibleBars),
                this._requestMoreData()
            }
            startScale(e) {
                this._scrollData && this.endScroll(),
                null === this._scaleStartPoint && null === this._commonTransitionStartState && (this.isEmpty() || (this._scaleStartPoint = e,
                this._saveCommonTransitionsStartState()))
            }
            scaleTo(e) {
                if (null === this._commonTransitionStartState)
                    return;
                const t = (0,
                Ve.clamp)(this._width - e, 0, this._width)
                  , i = (0,
                Ve.clamp)(this._width - (0,
                r.ensureNotNull)(this._scaleStartPoint), 0, this._width);
                if (0 === t || 0 === i)
                    return;
                const s = this.barIndexLengthToPercents(this.rightOffset());
                this.setBarSpacing(this._commonTransitionStartState.barSpacing * t / i),
                this.usePercentageRightOffset().value() && this.rightOffset() >= 0 && this.setRightOffset(this.percentsToBarIndexLength(s))
            }
            endScale() {
                null !== this._scaleStartPoint && (this._scaleStartPoint = null,
                this._clearCommonTransitionsStartState(),
                this._requestMoreData())
            }
            startScroll(e) {
                null === this._scrollData && null === this._commonTransitionStartState && (this.isEmpty() || (this._scrollData = {
                    startCoordinate: e,
                    startRightEdgeLogical: this.baseIndex() + this._rightOffset + .5,
                    startBaseIndex: this.baseIndex()
                },
                this._saveCommonTransitionsStartState()))
            }
            scrollTo(e) {
                if (this._visibleBarsInvalidated = !0,
                null === this._scrollData)
                    return;
                const {startCoordinate: t, startRightEdgeLogical: i, startBaseIndex: s} = this._scrollData
                  , o = e - t
                  , n = i + (this.baseIndex() - s)
                  , r = this.indexToCoordinate(n)
                  , a = this.coordinateToFloatIndex(r - o) - .5 - this.baseIndex();
                this._updateRightOffset(a),
                this._onScroll.fire()
            }
            endScroll() {
                null !== this._scrollData && (this._scrollData = null,
                this._clearCommonTransitionsStartState(),
                this._requestMoreData())
            }
            formatLabel(e, t) {
                const i = "24-hours" === kt.timeHoursFormatProperty.value() ? t.toString() : `${t}_ampm`;
                let s = this._formattedBySpan.get(i);
                return void 0 === s && (s = new At((e=>this.formatLabelImpl(e, t))),
                this._formattedBySpan.set(i, s)),
                s.format(new Date(e))
            }
            formatLabelImpl(e, t) {
                if (!(e && e instanceof Date))
                    return "incorrect time";
                const s = function(e, t) {
                    if (e === It.MILLISECOND_SPAN && t)
                        return "TimeWithMilliseconds";
                    if (e < It.MINUTE_SPAN && t)
                        return "TimeWithSeconds";
                    if (e < It.DAY_SPAN && t)
                        return "Time";
                    if (e < It.WEEK_SPAN)
                        return "DayOfMonth";
                    if (e < It.MONTH_SPAN)
                        return "DayOfMonth";
                    if (e < It.YEAR_SPAN)
                        return "Month";
                    return "Year"
                }(t, !this._model.mainSeries().isDWM());
                return null !== Lt.customFormatters.tickMarkFormatter ? Lt.customFormatters.tickMarkFormatter(e, s) : function(e, t) {
                    switch (t) {
                    case "TimeWithMilliseconds":
                        return new Dt.TimeFormatter(Dt.hourMinuteSecondMillisecFormat).format(e);
                    case "TimeWithSeconds":
                    case "Time":
                        const s = "TimeWithSeconds" === t ? (0,
                        Nt.getHourMinuteSecondFormat)(kt.timeHoursFormatProperty.value()) : (0,
                        Nt.getHourMinuteFormat)(kt.timeHoursFormatProperty.value());
                        return new Dt.TimeFormatter(s).format(e);
                    case "DayOfMonth":
                        return e.getUTCDate().toString();
                    case "Month":
                        return (void 0 === Et && (Et = [d.t(null, void 0, i(562310)), d.t(null, void 0, i(302507)), d.t(null, void 0, i(92767)), d.t(null, void 0, i(227072)), d.t(null, {
                            context: "short"
                        }, i(13132)), d.t(null, void 0, i(800429)), d.t(null, void 0, i(853786)), d.t(null, void 0, i(546450)), d.t(null, void 0, i(806816)), d.t(null, void 0, i(912179)), d.t(null, void 0, i(526899)), d.t(null, void 0, i(532084))]),
                        Et)[e.getUTCMonth()];
                    case "Year":
                        return e.getUTCFullYear().toString()
                    }
                }(e, s)
            }
            onScroll() {
                return this._onScroll
            }
            invalidateVisibleBars() {
                this._visibleBarsInvalidated = !0
            }
            onTimeScaleCompleted(e) {
                var t;
                if (this._requestingMoreData = !1,
                this._endOfData = e,
                ue.enabled("fix_left_edge") && this._endOfData) {
                    const e = null === (t = this._points.range().value()) || void 0 === t ? void 0 : t.firstIndex;
                    void 0 !== e && this.setLeftEdgeFix(e)
                }
                this._requestMoreData()
            }
            requestMoreHistoryPoints(e) {
                this._model.mainSeries().requestMoreData(e)
            }
            targetDefaultRightOffset() {
                return this.usePercentageRightOffset().value() ? this.percentsToBarIndexLength(this._defaultRightOffsetPercentage.value()) : this._defaultRightOffset.value()
            }
            percentsToBarIndexLength(e) {
                return .01 * e * this._width / this._barSpacing
            }
            barIndexLengthToPercents(e) {
                return 100 * e * this._barSpacing / this._width
            }
            requestHistoryPointsIfNeeded() {
                this._model.mainSeries().requestMoreData()
            }
            _requestMoreData() {
                this._requestFutureTickmarksIfNeeded(),
                this.requestHistoryPointsIfNeeded()
            }
            _requestFutureTickmarksIfNeeded() {
                this._model.mainSeries().requestMoreData()
            }
            _requestHistoryPoints(e) {
                this._model.chartApi().isConnected().value() && (this._requestingMoreData ? zt.logNormal("Skipping loading more data due active loading") : (this._requestingMoreData = !0,
                this._model.chartApi().requestMoreData(e)))
            }
            _updateVisibleBars() {
                const e = this._visibleBars;
                if (this.isEmpty())
                    return void (this._visibleBars.isValid() && (this._visibleBars = xt.invalid(),
                    this._visibleBarsChanged.fire(null, e.strictRange()),
                    this._logicalRangeChanged.fire(null, e.logicalRange())));
                const t = this.width() / this.barSpacing()
                  , i = this.baseIndex()
                  , s = i + this._rightOffset
                  , o = s + .5
                  , n = this._pointWeights.indexToTotalWeight(o) - t
                  , r = Math.min(o - 1, this._pointWeights.totalWeightToIndex(n)) + .5;
                Number.isFinite(r) && Number.isFinite(s) ? (this._visibleBars = new xt(new bt.LogicalRange(r,s),this._model.mainSeries().style()),
                this._lockBarsAndLogicalRangeEvents || this._fireVisibleBarsChangedIfRequired(e, this._visibleBars)) : zt.logWarn(`updateVisibleBars error: baseIndex: ${i}, barSpacing: ${this._barSpacing}, rightOffset: ${this._rightOffset}`)
            }
            _fireVisibleBarsChangedIfRequired(e, t) {
                ft.BarsRange.compare(e.strictRange(), t.strictRange()) || this._visibleBarsChanged.fire(t.strictRange(), e.strictRange()),
                bt.LogicalRange.compare(e.logicalRange(), t.logicalRange()) || this._logicalRangeChanged.fire(t.logicalRange(), e.logicalRange())
            }
            _baseIndexBarCenterCoordinate() {
                const e = this.baseIndex() + this._rightOffset + .5
                  , t = this._pointWeights.indexToTotalWeight(e);
                return this._width - t * this._barSpacing
            }
            _tryToUpdateBarSpacing(e, t) {
                return e !== t && (this._visibleBarsInvalidated = !0,
                this._barSpacing = t,
                this._barSpacingChanged.fire(t),
                !0)
            }
            _saveCommonTransitionsStartState() {
                this._commonTransitionStartState = {
                    barSpacing: this.barSpacing(),
                    rightOffset: this.rightOffset()
                }
            }
            _clearCommonTransitionsStartState() {
                this._commonTransitionStartState = null
            }
            _maxRightOffsetOnChanged() {
                this._maxRightOffsetChanged.fire(this.maxRightOffset())
            }
            _updateRightOffset(e) {
                const t = this._rightOffset;
                this._rightOffset = e,
                this.correctOffset(),
                this._rightOffset !== t && this._rightOffsetChanged.fire(this._rightOffset),
                this._model.recalculateAllPanes((0,
                dt.viewportChangeEvent)()),
                this._model.lightUpdate()
            }
            _defaultRightOffsetOptionsUpdated() {
                this.rightOffset();
                this.setRightOffset(this.targetDefaultRightOffset()),
                this._updateResetAvailableValue(),
                this._lastDefaultRightOffset = this._defaultRightOffsetPercentage.value()
            }
            _updateResetAvailableValue() {
                this._resetAvailable.setValue(6 !== this.barSpacing() || this.rightOffset() !== this.targetDefaultRightOffset())
            }
        }
        var Gt = i(319448)
          , jt = i(553220)
          , qt = i(590250)
          , Xt = i(684634);
        class Kt {
            constructor(e) {
                this._onChanged = new G.Delegate,
                this._groups = [],
                this._groups = e || [],
                this._groups.forEach((e=>{
                    e.onChanged().subscribe(null, (t=>this._onChanged.fire(e.id, t)))
                }
                ))
            }
            groups() {
                return this._groups.filter((e=>e.isActualSymbol()))
            }
            groupsForAllSymbols() {
                return this._groups
            }
            createGroup(e, t, i) {
                t = t || this._generateNextName();
                const s = new Xt.LineToolsGroup(e,t,i);
                this._groups.push(s),
                s.onChanged().subscribe(null, (e=>this._onChanged.fire(s.id, e)));
                const o = {
                    visibilityChanged: !1,
                    lockedChanged: !1,
                    isActualIntervalChanged: !1,
                    affectedLineTools: e.map((e=>e.id()))
                };
                return this._onChanged.fire(s.id, o),
                s
            }
            addGroup(e) {
                this._groups.push(e),
                e.onChanged().subscribe(null, (t=>this._onChanged.fire(e.id, t))),
                this._onChanged.fire(e.id)
            }
            removeGroup(e) {
                const t = this._groups.findIndex((t=>t.id === e.id));
                this._groups.splice(t, 1),
                this._onChanged.fire(e.id)
            }
            groupForId(e) {
                return this._groups.find((t=>t.id === e)) || null
            }
            groupForLineTool(e) {
                return this._groups.find((t=>t.containsLineTool(e))) || null
            }
            removeLineTools(e) {
                const t = new Set;
                this._groups.forEach((i=>{
                    const s = e.filter(i.containsLineTool.bind(i));
                    s.length && (i.excludeLineTools(s),
                    t.add(i.id))
                }
                ));
                return this._groups.filter((e=>0 === e.lineTools().length)).forEach((e=>this.removeGroup(e))),
                Array.from(t)
            }
            state(e) {
                return {
                    groups: (e ? this._groups.filter((e=>e.isActualSymbol())) : this._groups).map((e=>e.state()))
                }
            }
            onChanged() {
                return this._onChanged
            }
            fireChangedAll() {
                this._groups.forEach((e=>{
                    this._onChanged.fire(e.id)
                }
                ))
            }
            static fromState(e, t) {
                const i = [];
                for (const s of t.groups) {
                    const t = Xt.LineToolsGroup.fromState(e, s);
                    null !== t && i.push(t)
                }
                return new Kt(i)
            }
            _generateNextName() {
                const e = new Set(this.groups().map((e=>e.name().value())));
                for (let t = 1; ; t++) {
                    const i = `Group ${t}`
                      , s = `Group_${t}`;
                    if (!e.has(i) && !e.has(s))
                        return i
                }
            }
        }
        var Yt = i(870045)
          , Zt = i.n(Yt)
          , $t = i(242095);
        let Jt = null;
        function Qt(e) {
            return Boolean(e.symbolInfo.timezone) && Boolean(e.symbolInfo.session)
        }
        class ei {
            constructor(e, t) {
                var i, s;
                this._sourceTargetBarBuilder = null,
                this._cache = new Map,
                this._source = e,
                this._sourceSession = $t.SessionInfo.fromState(e.session),
                this._target = t,
                this._targetSession = $t.SessionInfo.fromState(t.session),
                this._isResolutionTheSame = L.Interval.isEqual(e.resolution, t.resolution) || L.Interval.isTicks(e.resolution) && L.Interval.isTicks(t.resolution),
                this._isSessionTheSame = (i = e.symbolInfo,
                s = t.symbolInfo,
                i.timezone === s.timezone && i.session === s.session && i.session_holidays === s.session_holidays && i.corrections === s.corrections),
                this._shouldCorrectTradingDay = L.Interval.isDWM(e.resolution) && !this._isSessionTheSame
            }
            sourceTimeToTargetTime(e) {
                if (this._isSessionTheSame && this._isResolutionTheSame)
                    return e;
                if (!Qt(this._source) || !Qt(this._target))
                    return e;
                let t = this._cache.get(e);
                if (void 0 === t) {
                    let i = 1e3 * e;
                    if (this._shouldCorrectTradingDay) {
                        let e = Zt().utc_to_cal(this._sourceSession.timezone, i);
                        e = this._sourceSession.spec.correctTradingDay(e);
                        const t = new Date(e);
                        Zt().set_hms(t, 0, 0, 0, 0, this._sourceSession.timezone),
                        i = t.valueOf()
                    }
                    const s = this._sourceTargetBuilder();
                    s.moveTo(i);
                    const o = s.indexOfBar(i);
                    t = s.startOfBar(Math.max(0, o)) / 1e3,
                    this._cache.set(e, t)
                }
                return t
            }
            _sourceTargetBuilder() {
                if (null === this._sourceTargetBarBuilder) {
                    const e = this._isSessionTheSame ? this._targetSession : (null === Jt && (Jt = new $t.SessionInfo("Etc/UTC","24x7")),
                    Jt);
                    this._sourceTargetBarBuilder = (0,
                    $t.newBarBuilder)(this._target.resolution, this._targetSession, e)
                }
                return this._sourceTargetBarBuilder
            }
        }
        var ti = i(638456)
          , ii = i(314802);
        const si = "#000000";
        var oi = i(447935);
        async function ni(e) {
            (await (0,
            oi.getChartAlertsFacade)()).invokeAlertEditor(e)
        }
        class ri {
            constructor(e) {
                this._alertLabelsBySource = new Map,
                this._alertsByAlertSeriesId = new Map,
                this._alertSeriesIdByAlert = new Map,
                this._alertLabelsOwnerSourcesByAlert = new Map,
                this._chartModel = e
            }
            destroy() {
                this.removeAllAlertLabels()
            }
            removeAllAlertLabels() {
                const e = this._alertLabelsBySource;
                this._alertLabelsBySource = new Map,
                this._alertsByAlertSeriesId.clear(),
                this._alertSeriesIdByAlert.clear(),
                this._alertLabelsOwnerSourcesByAlert.clear(),
                e.forEach((e=>{
                    e.forEach((e=>this._chartModel.removeSource(e)))
                }
                ))
            }
            removeSourceAlertLabels(e) {
                for (const t of this._getAlertLabelsBySource(e))
                    this.removeAlertLabel(t)
            }
            syncSourceAlertLabels(e) {
                if (!(0,
                Te.isPriceDataSource)(e) || !e.hasStateForAlert())
                    return;
                for (const t of this._getAlertLabelsBySource(e))
                    t.alertOwnerSource().idForAlert() === t.alertSeriesId() || t.alert().isOHLC() || this.removeAlertLabel(t);
                const t = this._alertsByAlertSeriesId.get(e.idForAlert())
                  , i = this._getAlertLabelsBySource(e);
                void 0 !== t && t.forEach((e=>{
                    i.some((t=>t.alert() === e)) || this._updateAlertLabelsByAlert(e, (0,
                    r.ensureDefined)(this._alertSeriesIdByAlert.get(e)))
                }
                ));
                const s = (0,
                r.ensureNotNull)(this._chartModel.paneForSource(e));
                for (const t of this._getAlertLabelsBySource(e)) {
                    const i = this._chartModel.paneForSource(t);
                    i !== s ? (null !== i && i.removeDataSource(t),
                    s.addDataSource(t, (0,
                    r.ensureNotNull)(e.priceScale()), !1)) : e.priceScale() !== t.priceScale() && s.move(t, (0,
                    r.ensureNotNull)(e.priceScale()))
                }
            }
            detachSourceAlertLabels(e) {
                for (const t of this._getAlertLabelsBySource(e))
                    this._chartModel.detachSource(t)
            }
            removeAlertLabel(e) {
                const t = e.alertOwnerSource()
                  , i = this._alertLabelsBySource.get(t);
                void 0 !== i && (i.delete(e),
                0 === i.size && this._alertLabelsBySource.delete(t));
                const s = e.alert()
                  , o = this._alertLabelsOwnerSourcesByAlert.get(s);
                void 0 !== o && (o.delete(t),
                0 === o.size && this._alertLabelsOwnerSourcesByAlert.delete(s)),
                this._chartModel.removeSource(e)
            }
            addAlert(e, t) {
                (0,
                r.assert)(!this._alertSeriesIdByAlert.has(e), "Alert is already added on the chart"),
                this._alertSeriesIdByAlert.set(e, t);
                let i = this._alertsByAlertSeriesId.get(t);
                void 0 === i && (i = new Set,
                this._alertsByAlertSeriesId.set(t, i)),
                i.add(e),
                this._updateAlertLabelsByAlert(e, t)
            }
            removeAlert(e) {
                const t = this._alertLabelsOwnerSourcesByAlert.get(e);
                void 0 !== t && t.forEach((t=>{
                    const i = this._alertLabelsBySource.get(t);
                    void 0 !== i && i.forEach((t=>{
                        t.alert() === e && this.removeAlertLabel(t)
                    }
                    ))
                }
                ));
                const i = this._alertSeriesIdByAlert.get(e);
                if (!i)
                    return;
                this._alertSeriesIdByAlert.delete(e);
                const s = this._alertsByAlertSeriesId.get(i);
                void 0 !== s && s.delete(e)
            }
            _findPanes(e) {
                const t = [];
                for (const i of this._chartModel.panes()) {
                    const s = i.priceDataSources()
                      , o = new Set;
                    for (const t of s)
                        t.hasStateForAlert() && t.idForAlert() === e && o.add(t);
                    o.size > 0 && t.push({
                        pane: i,
                        sources: o
                    })
                }
                return t
            }
            _addLabelToPane(e, t, i, s) {
                const o = new w.AlertLabel(this._chartModel,e,s,ni);
                i.addDataSource(o, s.priceScale(), !1);
                let n = this._alertLabelsBySource.get(s);
                void 0 === n && (n = new Set,
                this._alertLabelsBySource.set(s, n)),
                n.add(o);
                let r = this._alertLabelsOwnerSourcesByAlert.get(e);
                void 0 === r && (r = new Set,
                this._alertLabelsOwnerSourcesByAlert.set(e, r)),
                r.add(s)
            }
            _updateAlertLabelsByAlert(e, t) {
                const i = this._findPanes(t);
                if (i.length)
                    for (const s of i)
                        s.sources.forEach((i=>this._addLabelToPane(e, t, s.pane, i)));
                else if (e.isOHLC()) {
                    const i = this._chartModel.mainSeries();
                    this._addLabelToPane(e, t, (0,
                    r.ensureNotNull)(this._chartModel.paneForSource(i)), i)
                }
                this._chartModel.lightUpdate()
            }
            _getAlertLabelsBySource(e) {
                const t = this._alertLabelsBySource.get(e);
                return void 0 === t ? [] : Array.from(t)
            }
        }
        var ai = i(954384)
          , li = i(590508)
          , ci = i(795688)
          , di = i(893556)
          , ui = i(622429)
          , hi = i(640146)
          , pi = i(540975)
          , mi = i(509078)
          , gi = i(666574)
          , _i = i(432059)
          , vi = i(443874)
          , Si = i(201871);
        function fi(e, t) {
            return e.code < t.code ? -1 : e.code > t.code ? 1 : 0
        }
        class bi {
            constructor(e) {
                this._convertibleItems = e,
                this._idsToItems = new Map;
                for (const t of e)
                    this._idsToItems.set(t.id, t)
            }
            convertible(e) {
                return void 0 !== this._idsToItems.get(e)
            }
            item(e) {
                var t;
                return null !== (t = this._idsToItems.get(e)) && void 0 !== t ? t : null
            }
            size() {
                return this._convertibleItems.length
            }
            filterConvertible(e, t) {
                const i = this._convertibleItems.filter(function(e, t) {
                    return i=>!e.has(i.id) && t(i.id)
                }(e, t));
                return i.sort(fi),
                i
            }
            getItems() {
                return this._convertibleItems.map((e=>e.id))
            }
        }
        class yi {
            constructor(e) {
                this._allGroups = new Set,
                this._idToName = new Map,
                this._idToDescription = new Map,
                this._groupedUnitIds = new Map,
                this._groupedUnits = new Map,
                this._groupById = new Map,
                this._size = 0,
                this._units = e;
                for (const t in e)
                    if (e.hasOwnProperty(t)) {
                        this._allGroups.add(t),
                        this._groupedUnitIds.set(t, new Set(e[t].map((e=>e.id)))),
                        this._groupedUnits.set(t, e[t]);
                        for (const i of e[t])
                            this._size++,
                            this._idToName.set(i.id, i.name),
                            this._idToDescription.set(i.id, i.description),
                            this._groupById.set(i.id, t)
                    }
            }
            unitsChanged(e) {
                return this._units !== e
            }
            size() {
                return this._size
            }
            name(e) {
                return this._idToName.get(e) || e
            }
            description(e) {
                return this._idToDescription.get(e) || e
            }
            unitGroupById(e) {
                return this._groupById.get(e) || null
            }
            allGroups() {
                return new Set(this._allGroups)
            }
            unitsByGroups(e) {
                const t = [];
                return e.forEach((e=>{
                    const i = this._groupedUnits.get(e);
                    void 0 !== i && t.push({
                        name: e,
                        units: i
                    })
                }
                )),
                t
            }
            convertible(e, t) {
                for (const i of t) {
                    const t = this._groupedUnitIds.get(i);
                    if (void 0 !== t && t.has(e))
                        return !0
                }
                return !1
            }
        }
        var Ci = i(150335);
        class wi {
            constructor(e) {
                this._source = null,
                this._sourcePane = null,
                this._currentToolSupportsPhantomMode = !1,
                this._model = e
            }
            destroy() {
                this._source = null,
                this._sourcePane = null
            }
            source() {
                return this._source
            }
            onToolChanged() {
                this._removeSource();
                const e = this._model.currentTool();
                this._currentToolSupportsPhantomMode = (0,
                Ee.isLineToolName)(e) && (0,
                T.supportsPhantomMode)(e)
            }
            onCursorPositionUpdated() {
                if (!this._currentToolSupportsPhantomMode)
                    return;
                const e = this._model.crossHairSource();
                if (this._sourcePane !== e.pane && this._removeSource(),
                null === e.pane || !(0,
                Ci.isNumber)(e.index) || !(0,
                Ci.isNumber)(e.price))
                    return void this._removeSource();
                const t = {
                    index: e.index,
                    price: e.price
                };
                null !== this._source ? this._source.setPoint(0, t) : (this._source = this._model.createLineTool({
                    pane: e.pane,
                    point: t,
                    linetool: this._model.currentTool()
                }),
                this._sourcePane = e.pane)
            }
            _removeSource() {
                null !== this._source && (this._model.removeSource(this._source),
                this._source = null,
                this._sourcePane = null)
            }
        }
        var Ti = i(570701)
          , Pi = i(205899)
          , xi = i(195121);
        class Mi {
            constructor() {
                this._lastValue = null
            }
            align(e, t, i) {
                this._lastValue = null;
                let s = e;
                if (!(0,
                xi.magnetEnabled)().value())
                    return s;
                const o = i.mainDataSource();
                if (null === o)
                    return s;
                const n = o.model().mainSeries();
                if (o !== n)
                    return s;
                const a = n.priceScale();
                if (a.isEmpty())
                    return s;
                const l = function(e, t) {
                    const i = e.bars().valueAt(t);
                    if (null === i)
                        return;
                    let s;
                    if (null !== e.priceSource())
                        s = [e.barFunction()(i)];
                    else
                        switch (e.style()) {
                        case 12:
                            s = [i[2], i[3]];
                            break;
                        case 16:
                            s = [i[2], i[4], i[3]];
                            break;
                        default:
                            s = [i[1], i[2], i[3], i[4]]
                        }
                    return s
                }(n, t);
                if (!l)
                    return s;
                const c = (0,
                r.ensure)(n.firstValue())
                  , d = l.map((e=>({
                    y: a.priceToCoordinate(e, c),
                    price: e
                })))
                  , u = a.priceToCoordinate(e, c);
                d.sort(((e,t)=>Math.abs(e.y - u) - Math.abs(t.y - u)));
                const h = d[0];
                return ((0,
                xi.magnetMode)().value() === Pi.MagnetMode.StrongMagnet || Math.abs(h.y - u) < 50) && (s = h.price,
                this._lastValue = s),
                s
            }
            lastValue() {
                return this._lastValue
            }
            resetLastValue() {
                this._lastValue = null
            }
        }
        var Ii = i(269665)
          , Ai = i(665798)
          , Li = i(961970);
        class Ei extends Li.BitmapCoordinatesPaneRenderer {
            constructor() {
                super(...arguments),
                this._data = null
            }
            setData(e) {
                this._data = e
            }
            hitTest(e) {
                return null
            }
            _drawImpl(e) {
                if (null === this._data)
                    return;
                const {context: t, verticalPixelRatio: i, horizontalPixelRatio: s, bitmapSize: o} = e
                  , n = Math.max(1, Math.floor(s));
                t.lineWidth = n;
                const r = Math.ceil(o.height * i)
                  , a = Math.ceil(o.width * s);
                if (t.lineCap = "butt",
                this._data.vertLinesVisible) {
                    t.strokeStyle = this._data.vertLinesColor,
                    (0,
                    Ai.setLineStyle)(t, this._data.vertLineStyle);
                    for (const e of this._data.timeMarks) {
                        const i = Math.round(e.coord * s);
                        (0,
                        Ai.drawVerticalLine)(t, i, 0, r)
                    }
                }
                if (this._data.horzLinesVisible) {
                    t.strokeStyle = this._data.horzLinesColor,
                    (0,
                    Ai.setLineStyle)(t, this._data.horzLineStyle);
                    for (const e of this._data.priceMarks) {
                        const s = Math.round(e.coord * i);
                        (0,
                        Ai.drawHorizontalLine)(t, s, 0, a)
                    }
                }
            }
        }
        class ki {
            constructor(e) {
                this._renderer = new Ei,
                this._pane = e
            }
            update() {}
            renderer() {
                const e = this._pane.defaultPriceScale()
                  , t = this._pane.model().timeScale();
                if (e.isEmpty() || t.isEmpty())
                    return null;
                const i = this._pane.model().properties().childs().paneProperties.childs()
                  , s = t.marks()
                  , o = i.gridLinesMode.value()
                  , n = {
                    horzLinesVisible: "both" === o || "horz" === o,
                    vertLinesVisible: "both" === o || "vert" === o,
                    horzLinesColor: i.horzGridProperties.childs().color.value(),
                    vertLinesColor: i.vertGridProperties.childs().color.value(),
                    horzLineStyle: i.horzGridProperties.childs().style.value(),
                    vertLineStyle: i.vertGridProperties.childs().style.value(),
                    priceMarks: e.marks(),
                    timeMarks: null !== s ? s : []
                };
                return this._renderer.setData(n),
                this._renderer
            }
        }
        class Di extends ie.DataSource {
            id() {
                return "grid"
            }
            paneViews(e) {
                return [new ki(e)]
            }
            name() {
                return "Grid"
            }
        }
        var Ni = i(347808);
        class Bi extends Ni.PriceAxisView {
            constructor(e, t, i, s) {
                super(),
                this._source = e,
                this._pane = t,
                this._priceScale = i,
                this._priceProvider = s,
                this._properties = e.model().properties().childs().scalesProperties
            }
            setHitTestData(e) {
                this._hitTestData = e
            }
            setXCoord(e) {
                this._xCoord = e
            }
            additionalPadding(e) {
                return 0
            }
            _updateRendererData(e, t, i) {
                e.visible = !1,
                t.visible = !1;
                const s = this._priceScale
                  , o = s.mainSource()
                  , n = null !== o ? o.firstValue() : null;
                if (!this._isVisible() || s.isEmpty() || null === n)
                    return;
                const r = this._currentPrice(s);
                if (null === r)
                    return;
                i.background = (0,
                _i.resetTransparency)(this._bgColor()),
                i.textColor = this.generateTextColor(i.background);
                const a = this.additionalPadding(s.fontSize());
                i.additionalPaddingTop = a,
                i.additionalPaddingBottom = a,
                i.coordinate = s.priceToCoordinate(r, n),
                e.text = s.formatPrice(r, n),
                e.visible = !0,
                t.visible = !0,
                t.hitTestData = this._hitTestData,
                t.xCoord = this._xCoord
            }
            _currentPrice(e) {
                return this._priceProvider(e)
            }
        }
        class Ri extends Bi {
            additionalPadding(e) {
                return 2 / 12 * e
            }
            _isVisible() {
                const e = this._source.lockedPane();
                return this._properties.childs().showPriceScaleCrosshairLabel.value() && (this._source.visible || null !== e) && (null != e ? e : this._source.pane) === this._pane
            }
            _currentPrice(e) {
                const t = Ge.crosshairLock.value();
                return null !== t && 1 === t.type ? this._pane === this._source.lockedPane() ? t.price : null : super._currentPrice(e)
            }
            _bgColor() {
                const e = this._properties.childs();
                return this._source.model().dark().value() ? e.crosshairLabelBgColorDark.value() : e.crosshairLabelBgColorLight.value()
            }
            _updateRendererData(e, t, i) {
                const s = t.visible;
                super._updateRendererData(e, t, i),
                this._source.isHovered() ? t.backgroung = this._source.model().dark().value() ? c.colorsPalette["color-cold-gray-600"] : c.colorsPalette["color-cold-gray-650"] : t.backgroung = void 0,
                s || (t.visible = s)
            }
        }
        class Oi extends Bi {
            _isVisible() {
                return null !== this._source.measurePane().value()
            }
            _bgColor() {
                return this._properties.childs().axisLineToolLabelBackgroundColorCommon.value()
            }
        }
        var Vi = i(95370)
          , Wi = i(84281)
          , Fi = i(683833)
          , Hi = i(691371)
          , zi = i(716004)
          , Ui = i(586450)
          , Gi = i(310681)
          , ji = i(966837)
          , qi = i(417947)
          , Xi = i(67326)
          , Ki = i(621452)
          , Yi = i(287741)
          , Zi = i(344158)
          , $i = i(314824);
        function Ji(e) {
            const t = e.priceScale();
            return null === t ? 0 : t.isPercentage() || t.isIndexedTo100() ? 2 : 1
        }
        class Qi extends Vi.PanePriceAxisView {
            constructor(e, t, i, s, o) {
                super(e, t, s),
                this._crossHairMenuCachedState = null,
                this._hasActions = !1,
                this._gaOrigin = "CH menu",
                this._crosshairPriceAxisView = e,
                e.setPaneRendererLabelIcon(0),
                this._crosshair = t,
                this._scale = i,
                this._options = o,
                this._updateGaOrigin(),
                (0,
                Wi.waitTradingService)().then((()=>{
                    this._crossHairMenuCachedState = null
                }
                ))
            }
            _updateImpl(e) {
                const t = this._crosshair.y
                  , i = this._chartModel.properties().childs().scalesProperties.childs().fontSize.value()
                  , s = this._chartModel.timeScale().width()
                  , o = this._crosshair.model().priceAxisRendererOptions()
                  , n = i + 2 * this._crosshairPriceAxisView.additionalPadding(i) + o.paddingTop + o.paddingBottom
                  , r = n
                  , l = t - n / 2
                  , c = this._crosshair.pane
                  , d = this._mainDataSourceOnPane()
                  , u = d && d.symbolSource()
                  , h = !!u && (u.isConvertedToOtherCurrency() || u.isConvertedToOtherUnit());
                if (this._updateGaOrigin(),
                null !== d) {
                    const e = Ji(d)
                      , t = d.idForAlert()
                      , i = this._chartModel.isInReplay().value()
                      , s = this._crossHairMenuCachedState
                      , o = ue.enabled("chart_crosshair_menu");
                    null !== s && s.id === t && s.priceScale === e && s.isCurrencyOrUnitConverted === h && s.isInReplay === i && s.isMenuEnabled === o || (this._updateTooltipAndActionsAvailability(d, e, h),
                    this._crossHairMenuCachedState = {
                        id: t,
                        priceScale: e,
                        isCurrencyOrUnitConverted: h,
                        isInReplay: i,
                        isMenuEnabled: o
                    })
                }
                null !== d && (0,
                Be.isActingAsSymbolSource)(d) && d.symbol();
                const p = null !== c && (c.maximized().value() || !c.collapsed().value()) && this._hasActions;
                this._crosshairPriceAxisView.setPaneLabelVisible(p);
                const m = this._position();
                if (null !== m) {
                    const e = 0
                      , t = s - r
                      , i = Boolean(Zi.showPlusButtonOnCursor.value())
                      , o = i ? this._crosshair.x : void 0
                      , c = void 0 !== o ? o - r / 2 : "left" === m ? e : t
                      , d = void 0 !== o ? o + r / 2 : "left" === m ? e + r : t + r
                      , u = (0,
                    a.box)(new a.Point(c,l), new a.Point(d,l + n));
                    this._data = {
                        itemBox: u,
                        clickHandler: this._handleClick.bind(this, m, i, u)
                    },
                    this._crosshairPriceAxisView.setHitTestData(this._data),
                    this._crosshairPriceAxisView.setXCoord(o)
                }
                super._updateImpl(e)
            }
            _priceScale() {
                return this._scale
            }
            _updateGaOrigin() {
                this._gaOrigin = Boolean(Zi.showPlusButtonOnCursor.value()) ? "CH menu cursor" : "CH menu"
            }
            _updateTooltipAndActionsAvailability(e, t, i) {
                this._hasActions = !1;
                if (!(1 === t))
                    return;
                const s = !this._chartModel.isInReplay().value()
                  , o = !i && e.alertCreationAvailable().value() && s
                  , n = !this._options.disableDrawHorizLineMenuAction
                  , r = !i && e === this._chartModel.mainSeries() && Boolean((0,
                Wi.tradingService)()) && s;
                this._hasActions = r || o || n
            }
            _handleClick(e, t, i, s, o) {
                if (ue.enabled("widget") && ue.enabled("referral_program_for_widget_owners"))
                    return void (0,
                    Gi.showGoToTradingViewReferralDialog)({
                        feature: "plusMenu"
                    });
                (0,
                g.trackEvent)(this._gaOrigin, "click");
                const n = this._mainDataSourceOnPane()
                  , r = null !== n && (0,
                Be.isActingAsSymbolSource)(n) ? n.symbol() : null
                  , a = {
                    pageX: o.pageX,
                    pageY: o.pageY,
                    clientX: o.clientX,
                    clientY: o.clientY,
                    screenX: o.screenX,
                    screenY: o.screenY,
                    price: this._crosshair.price,
                    symbol: r
                };
                v.emit("onPlusClick", a),
                this._getMenuItems(e).then((s=>{
                    s.length > 0 && this._showContextMenu(s, t, i, o, e)
                }
                ))
            }
            _getMenuItems(e) {
                const t = this._chartModel.mainSeries()
                  , i = t.symbolInfo()
                  , s = this._options.disableTradingMenuActions ? null : (0,
                Wi.tradingService)()
                  , o = (0,
                r.ensureNotNull)(this._crosshair.pane).mainDataSource()
                  , n = !this._chartModel.isInReplay().value()
                  , a = n
                  , l = o === t && !(0,
                Xi.isNonTradableSymbolType)(null == i ? void 0 : i.type) && Boolean(s) && n
                  , c = a ? this._createAlertMenuItems(e) : Promise.resolve([])
                  , d = l ? this._createTradingMenuItems() : Promise.resolve([]);
                return Promise.all([c, d]).then((([e,t])=>{
                    t.length > 0 && (0,
                    r.ensureNotNull)(s).trackEvent(this._gaOrigin, "click");
                    const i = this._createAddHorizontalLineMenuItem()
                      , o = e.length > 0 && t.length > 0;
                    return [...e, o ? new Hi.Separator : null, ...t, (e.length > 0 || t.length > 0) && i.length > 0 ? new Hi.Separator : null, ...i].filter((e=>null !== e))
                }
                ))
            }
            _createAlertMenuItems(e) {
                if (null === this._crosshair.pane)
                    return Promise.resolve([]);
                const t = this._crosshair.pane.mainDataSource();
                if (null === t)
                    return Promise.resolve([]);
                const i = t.symbolSource();
                if (!!i && (i.isConvertedToOtherCurrency() || i.isConvertedToOtherUnit()))
                    return Promise.resolve([]);
                const s = this._crosshair.y;
                if (this._options.menuForMainSourceOnly) {
                    if (t.alertCreationAvailable().value() && t.isVisible()) {
                        const e = this._getActionAddAlert({
                            source: t,
                            y: s,
                            isDisabled: !1
                        });
                        return Promise.resolve(null === e ? [] : [e])
                    }
                    return Promise.resolve([])
                }
                const o = (0,
                r.ensureNotNull)(this._crosshair.pane).sourcesByGroup();
                let n = ("left" === e ? o.leftPriceScalesSources() : o.rightPriceScalesSources()).filter((e=>(0,
                Te.isPriceDataSource)(e) && e.alertCreationAvailable().value() && e.isVisible()));
                return n.reverse(),
                n = (0,
                C.moveToHead)(n, this._chartModel.mainSeries()),
                (0,
                ji.filterAccessibleDataSources)(n).then((e=>{
                    const t = new Set(e)
                      , i = [];
                    for (const e of n) {
                        const o = this._getActionAddAlert({
                            source: e,
                            y: s,
                            isDisabled: !t.has(e)
                        });
                        null !== o && i.push(o)
                    }
                    return i
                }
                ))
            }
            _createTradingMenuItems() {
                const e = this._crosshair.y
                  , t = (0,
                Wi.tradingService)();
                if (null === t || null === this._crosshair.pane)
                    return Promise.resolve([]);
                const i = this._crosshair.pane.mainDataSource();
                if (null === i)
                    return Promise.resolve([]);
                const s = i.symbolSource()
                  , o = !!s && (s.isConvertedToOtherCurrency() || s.isConvertedToOtherUnit())
                  , n = Ji(i);
                return o || 1 !== n ? Promise.resolve([]) : (0,
                Fi.createTradeContext)(i, e).then((e=>t.chartContextMenuActions(e, {
                    onlyMainActions: !0,
                    hideNotExecutableAction: !0,
                    gaOrigin: this._gaOrigin
                })))
            }
            _createAddHorizontalLineMenuItem() {
                if (null === this._crosshair.pane)
                    return [];
                const e = this._crosshair.pane.mainDataSource();
                if (null === e)
                    return [];
                const t = this._crosshair.y
                  , i = this._getActionAddHorizontalLine({
                    source: e,
                    y: t,
                    pane: this._crosshair.pane
                });
                return null === i ? [] : [i]
            }
            _getActionAddAlert(e) {
                const {source: t, y: s, isDisabled: o} = e
                  , n = this._getValue(t, s)
                  , r = this._chartModel.mainSeries().interval();
                if (null === n || L.Interval.isTicks(r))
                    return null;
                const a = this._formatValue(n, t)
                  , l = function(e) {
                    return (0,
                    Be.isActingAsSymbolSource)(e) ? e.symbolTitle(Yi.TitleDisplayTarget.StatusLine, !0, !0) : (0,
                    zi.clean)(e.title(Yi.TitleDisplayTarget.StatusLine, !0, {}, !0), !0)
                }(t)
                  , c = {
                    label: (0,
                    qi.hasUsualAlertPlots)(t) ? d.t(null, {
                        replace: {
                            title: l,
                            price: a
                        }
                    }, i(989295)) : d.t(null, {
                        replace: {
                            title: l
                        }
                    }, i(669709)),
                    iconId: "Alert.Add"
                };
                return o ? c.disabled = !0 : c.onExecute = ()=>this._addAlert(n, t),
                new $i.ActionWithStandardIcon({
                    actionId: "Alert.Add",
                    options: c
                })
            }
            _getActionAddHorizontalLine(e) {
                if (this._options.disableDrawHorizLineMenuAction)
                    return null;
                const {source: t, y: s, pane: o} = e
                  , n = this._getValue(t, s);
                if (null === n)
                    return null;
                const r = this._formatValue(n, t)
                  , a = {
                    label: d.t(null, void 0, i(196890)) + ` ${r}`,
                    iconId: "Chart.AddHorzLine"
                };
                return a.onExecute = ()=>this._addHorizontalLineTool(o, n),
                new $i.ActionWithStandardIcon({
                    actionId: "Chart.Crosshair.PlusButton.DrawHorizontalLine",
                    options: a
                })
            }
            _getValue(e, t) {
                const i = e.priceScale()
                  , s = e.firstValue();
                if (null === i || null === s)
                    return null;
                return i.isPercentage() || i.isIndexedTo100() ? null : i.coordinateToPrice(t, s)
            }
            _formatValue(e, t) {
                return t.formatter().format(e)
            }
            async _addAlert(e, t) {
                const s = await async function() {
                    const {invokeAlertEditorWithOnlineSeries: e} = await Promise.all([i.e(92030), i.e(22172)]).then(i.bind(i, 314898));
                    return e
                }()
                  , o = async()=>{
                    const i = {
                        dataSourceHub: this._chartModel,
                        silent: !0,
                        actionSource: "crosshair_menu"
                    };
                    (0,
                    T.isLineTool)(t) ? i.drawing = t : (i.series = t,
                    i.value = e),
                    s(i),
                    (0,
                    g.trackEvent)(this._gaOrigin, "alert")
                }
                ;
                (0,
                Ui.runOrSigninWithFeature)((()=>o()), {
                    feature: "alert",
                    source: this._gaOrigin
                })
            }
            _addHorizontalLineTool(e, t) {
                this._chartModel.undoModel().createLineTool({
                    pane: e,
                    point: {
                        price: t,
                        index: 0
                    },
                    linetool: "LineToolHorzLine"
                })
            }
            _showContextMenu(e, t, i, s, o) {
                const n = "left" === o;
                setTimeout((()=>{
                    const o = s.clientX - s.localX
                      , a = s.clientY - s.localY
                      , l = i.min.x + o
                      , c = i.max.x + o
                      , d = i.min.y + a
                      , u = c - l
                      , h = i.max.y + a - d
                      , p = t ? Ge.crosshairLock.value() : void 0;
                    if (void 0 !== p) {
                        const e = (0,
                        r.ensureNotNull)(this._chartModel.timeScale().points().roughTime(this._crosshair.index));
                        Ge.crosshairLock.setValue({
                            type: 1,
                            price: this._crosshair.price,
                            time: e,
                            modelId: this._chartModel.id(),
                            paneId: (0,
                            r.ensureNotNull)(this._crosshair.pane).id()
                        })
                    }
                    Ki.ContextMenuManager.showMenu(e, {
                        clientX: s.clientX,
                        clientY: s.clientY,
                        box: {
                            x: l,
                            w: u,
                            y: d,
                            h
                        },
                        attachToXBy: t ? "auto" : n ? "left" : "right",
                        attachToYBy: "auto-strict",
                        marginX: t ? 0 : -u
                    }, void 0, {
                        menuName: "CrosshairMenuView"
                    }, (()=>{
                        void 0 !== p && Ge.crosshairLock.setValue(p)
                    }
                    ))
                }
                ))
            }
            _mainDataSourceOnPane() {
                const e = this._crosshair.pane;
                return null !== e ? e.mainDataSource() : null
            }
        }
        var es = i(937713);
        class ts extends Li.BitmapCoordinatesPaneRenderer {
            constructor(e) {
                super(),
                this._data = e
            }
            hitTest(e) {
                return void 0 === this._data.clickHandler ? null : new mi.HitTestResult(mi.HitTarget.Custom,{
                    clickHandler: this._data.clickHandler,
                    tapHandler: this._data.clickHandler
                })
            }
            _drawImpl(e) {
                const t = this._data.vertLinesVisible
                  , i = this._data.horzLinesVisible;
                if (!t && !i)
                    return;
                const {context: s, horizontalPixelRatio: o, verticalPixelRatio: n, bitmapSize: r} = e;
                s.lineWidth = Math.max(1, Math.floor(this._data.lineWidth * o)),
                s.strokeStyle = this._data.color,
                s.fillStyle = this._data.color,
                s.lineCap = "butt",
                (0,
                Ai.setLineStyle)(s, this._data.lineStyle);
                const a = Math.round(this._data.x * o)
                  , l = Math.round(this._data.y * n)
                  , c = Math.ceil(r.width * o)
                  , d = Math.ceil(r.height * n);
                t && a >= 0 && (0,
                Ai.drawVerticalLine)(s, a, 0, d),
                i && l >= 0 && (0,
                Ai.drawHorizontalLine)(s, l, 0, c),
                this._data.drawCenter && (s.beginPath(),
                s.arc(a, l, Math.round(3 * o), 0, 2 * Math.PI, !0),
                s.fillStyle = this._data.color,
                s.fill()),
                this._data.scissors && function(e, t, i) {
                    const {context: s, bitmapSize: o, horizontalPixelRatio: n, verticalPixelRatio: r} = e
                      , a = 24 * n
                      , l = Math.round(t - a / 2);
                    let c = Math.round(i - a / 2);
                    if (c < 0)
                        c = 0;
                    else {
                        const e = o.height - a;
                        c > e && (c = e)
                    }
                    s.translate(l, c),
                    s.scale(n, r),
                    s.fillStyle = "#131722",
                    s.fill(is),
                    s.strokeStyle = "#fff",
                    s.lineWidth = 1,
                    s.stroke(is)
                }(e, a, l)
            }
        }
        const is = new Path2D("m15.68 3.72-3.82 5.52-3.83-5.52-.28-.42-.42.3a2.84 2.84 0 0 0-.68 3.92l3.27 4.73-1.16 1.68a3.34 3.34 0 0 0-4.26 3.22 3.34 3.34 0 0 0 3.32 3.35 3.34 3.34 0 0 0 3.08-4.6l1-1.44 1.13 1.62a3.34 3.34 0 0 0 3.15 4.42c1.84 0 3.32-1.5 3.32-3.35a3.34 3.34 0 0 0-4.42-3.17l-1.23-1.78 3.22-4.65a2.86 2.86 0 0 0-.69-3.96l-.41-.29-.29.42ZM7.82 16.27c.47 0 .86.39.86.88 0 .48-.39.87-.86.87a.87.87 0 0 1-.86-.87c0-.5.4-.88.86-.88Zm8.36 0c.47 0 .86.39.86.88 0 .48-.4.87-.86.87a.87.87 0 0 1-.86-.87c0-.5.39-.88.86-.88Z");
        const ss = c.colorsPalette["color-tv-blue-500"];
        class os {
            constructor(e, t) {
                this._rendererData = {},
                this._renderer = new ts(this._rendererData),
                this._source = e,
                this._pane = t
            }
            update() {}
            renderer() {
                var e, t;
                const i = this._source.selectPointMode().value() !== Ge.SelectPointMode.None
                  , s = this._source.lockedPane()
                  , o = (this._source.visible || null !== s) && (this._source.areLinesVisible || i) && !this._source.linesShouldBeHidden()
                  , n = this._rendererData;
                if (!o || null === this._pane)
                    return null;
                const a = this._source.paneForPointSelect()
                  , l = this._source.isReplaySelection()
                  , c = null != s ? s : this._source.pane
                  , d = this._pane === c
                  , u = l || (null !== a ? c === a && this._pane === a : d);
                if (n.scissors = !1,
                i && (l || this._source.isOnHoveredChartWidget()) && u) {
                    const e = (0,
                    r.ensureNotNull)(this._source.pointToSelect());
                    n.color = this._source.lineColor() || ss,
                    l ? (n.lineWidth = 2,
                    n.scissors = d) : n.lineWidth = 1,
                    n.lineStyle = gi.LINESTYLE_SOLID,
                    n.horzLinesVisible = !0,
                    n.vertLinesVisible = !0,
                    n.drawCenter = !1,
                    "time" === e ? n.horzLinesVisible = !1 : "price" === e && (n.vertLinesVisible = !1)
                } else {
                    const e = this._source.properties()
                      , t = this._source.model().currentTool()
                      , i = (0,
                    es.lastMouseOrTouchEventInfo)()
                      , s = i.isTouch && !i.stylus && ((0,
                    Ee.isLineToolName)(t) || (0,
                    Ge.toolIsMeasure)(t));
                    let o;
                    o = s ? ss : e.childs().color.value();
                    const r = e.childs().transparency.value();
                    !s && r > 0 && (o = (0,
                    _i.generateColor)(o, r)),
                    n.color = o,
                    n.horzLinesVisible = this._pane === c && (this._pane.maximized().value() || !this._pane.collapsed().value()),
                    n.vertLinesVisible = !0,
                    n.lineWidth = e.childs().width.value(),
                    n.lineStyle = e.childs().style.value(),
                    n.drawCenter = s && this._pane === c
                }
                return n.x = null !== (e = this._source.lockedX()) && void 0 !== e ? e : this._source.x,
                n.y = null !== (t = this._source.lockedY()) && void 0 !== t ? t : this._source.y,
                this._renderer
            }
        }
        var ns = i(809137);
        const rs = {
            backgroundColor: (0,
            _i.generateColor)(c.colorsPalette["color-tv-blue-500"], 70),
            borderColor: (0,
            _i.generateColor)(c.colorsPalette["color-tv-blue-500"], 20)
        };
        class as {
            constructor(e) {
                this._renderer = new ns.RectangleRenderer,
                this._rectangle = null,
                this._crosshair = e
            }
            update() {
                const e = this._crosshair.selection();
                null !== e && null !== this._crosshair.pane ? this._rectangle = this._crosshair.pane.logicalRectToPixels(e) : this._rectangle = null
            }
            renderer() {
                if (!this._rectangle)
                    return null;
                const e = {
                    backcolor: rs.backgroundColor,
                    color: rs.borderColor,
                    fillBackground: !0,
                    linewidth: 1,
                    points: [this._rectangle.min, this._rectangle.max],
                    extendLeft: !1,
                    extendRight: !1
                };
                return this._renderer.setData(e),
                this._renderer
            }
        }
        var ls = i(881025)
          , cs = i(212642)
          , ds = i(970011)
          , us = i(539040)
          , hs = i(982949)
          , ps = i(758910);
        const ms = d.t(null, void 0, i(841643))
          , gs = d.t(null, {
            context: "study"
        }, i(424261))
          , _s = (0,
        qe.getPercentageFormatter)()
          , vs = new cs.TimeSpanFormatter
          , Ss = (0,
        qe.getVolumeFormatter)()
          , fs = (0,
        c.getHexColorByName)("color-tv-blue-500")
          , bs = (0,
        c.getHexColorByName)("color-ripe-red-400")
          , ys = {
            bgColorPositive: (0,
            _i.generateColor)(fs, 80),
            bgColorNegative: (0,
            _i.generateColor)(bs, 80),
            colorPositive: (0,
            c.getHexColorByName)("color-tv-blue-600"),
            colorNegative: (0,
            c.getHexColorByName)("color-ripe-red-400"),
            labelBgColorPositive: fs,
            labelBgColorNegative: bs
        };
        class Cs {
            constructor(e, t) {
                this._horzTrenRenderer = new ds.TrendLineRenderer,
                this._vertTrenRenderer = new ds.TrendLineRenderer,
                this._bgRenderer = new ns.RectangleRenderer,
                this._labelRenderer = new us.TextRenderer,
                this._p1 = null,
                this._p2 = null,
                this._label = null,
                this._source = e,
                this._pane = t
            }
            update(e) {
                var t, i;
                const [s,o] = this._source.measurePoints();
                if (void 0 === o)
                    return this._p1 = null,
                    void (this._p2 = null);
                const n = (0,
                r.ensureNotNull)(this._source.measurePane().value())
                  , l = s.price
                  , c = o.price
                  , d = o.index - s.index
                  , u = (0,
                ls.forceLTRStr)("" + d)
                  , h = (0,
                r.ensureNotNull)(n.mainDataSource())
                  , p = (0,
                r.ensureNotNull)(h.formatter())
                  , m = o.price - l;
                let g = null !== (i = null === (t = p.formatChange) || void 0 === t ? void 0 : t.call(p, o.price, l)) && void 0 !== i ? i : p.format(m);
                if (Math.abs(l) > 1e-8) {
                    const e = m / Math.abs(l);
                    g += " (" + _s.format(100 * e) + ")"
                }
                const _ = (0,
                ls.forceLTRStr)(g);
                this._label = _ + "\n" + ms.format({
                    count: u
                });
                const v = (0,
                r.ensureNotNull)(h.firstValue())
                  , S = this._source.model().timeScale().indexToCoordinate(s.index)
                  , f = this._source.model().timeScale().indexToCoordinate(o.index)
                  , b = n.defaultPriceScale().priceToCoordinate(l, v)
                  , y = n.defaultPriceScale().priceToCoordinate(c, v);
                this._p1 = new a.Point(S,b),
                this._p2 = new a.Point(f,y);
                const C = this._source.model().timeScale().indexToUserTime(s.index)
                  , w = this._source.model().timeScale().indexToUserTime(o.index);
                let T = null;
                null !== C && null !== w && (T = (w.valueOf() - C.valueOf()) / 1e3);
                const P = this._pane.model().mainSeries().symbolInfo()
                  , x = P && (0,
                qe.getPipFormatter)(P)
                  , M = x ? x.format(m) : null
                  , I = null !== M ? " , " + M : ""
                  , A = null !== T ? vs.format(T) : null
                  , L = null !== A ? ", " + (0,
                ls.startWithLTR)(A) : "";
                this._label = (0,
                ls.forceLTRStr)(_ + I) + "\n" + ms.format({
                    count: u
                }) + L;
                const E = this._source.measureVolume();
                Number.isNaN(E) || (this._label += `\n${gs} ${Ss.format(E)}`);
                const k = c < l ? ys.bgColorNegative : ys.bgColorPositive
                  , D = c < l ? ys.colorNegative : ys.colorPositive
                  , N = c < l ? ys.labelBgColorNegative : ys.labelBgColorPositive
                  , R = {
                    points: [this._p1, this._p2],
                    linewidth: 0,
                    fillBackground: !0,
                    color: k,
                    backcolor: k,
                    extendLeft: !1,
                    extendRight: !1
                };
                this._bgRenderer.setData(R);
                const O = this._p1.add(this._p2).scaled(.5);
                {
                    const e = Math.round(O.y)
                      , t = new a.Point(this._p1.x,e)
                      , i = new a.Point(this._p2.x,e)
                      , s = {
                        points: [t, i],
                        color: D,
                        linewidth: 1,
                        linestyle: gi.LINESTYLE_SOLID,
                        extendleft: !1,
                        extendright: !1,
                        leftend: ps.LineEnd.Normal,
                        rightend: Math.abs(t.x - i.x) >= 50 ? ps.LineEnd.Arrow : ps.LineEnd.Normal
                    };
                    this._horzTrenRenderer.setData(s)
                }
                {
                    const e = Math.round(O.x)
                      , t = new a.Point(e,this._p1.y)
                      , i = new a.Point(e,this._p2.y)
                      , s = {
                        points: [t, i],
                        color: D,
                        linewidth: 1,
                        linestyle: gi.LINESTYLE_SOLID,
                        extendleft: !1,
                        extendright: !1,
                        leftend: ps.LineEnd.Normal,
                        rightend: Math.abs(t.y - i.y) >= 50 ? ps.LineEnd.Arrow : ps.LineEnd.Normal
                    };
                    this._vertTrenRenderer.setData(s)
                }
                const V = {
                    x: 0,
                    y: 10
                }
                  , W = .5 * (this._p1.x + this._p2.x)
                  , F = this._p2.y
                  , H = new a.Point(W,F)
                  , z = (U = (0,
                r.ensureNotNull)(this._label),
                {
                    points: [H],
                    text: U,
                    color: "#FFFFFF",
                    horzAlign: "center",
                    vertAlign: "middle",
                    font: B.CHART_FONT_FAMILY,
                    offsetX: V.x,
                    offsetY: V.y,
                    bold: !1,
                    italic: !1,
                    fontsize: 12,
                    padding: 8,
                    highlightBorder: !1,
                    backgroundColor: N,
                    backgroundTransparency: 10,
                    boxPaddingVert: 9,
                    boxPaddingHorz: 9,
                    backgroundRoundRect: 4
                });
                var U;
                this._labelRenderer.setData(z);
                const G = this._labelRenderer.measure()
                  , j = (0,
                us.calculateLabelPosition)(G, this._p1, this._p2, V, this._pane.height());
                this._labelRenderer.setPoints([j])
            }
            renderer() {
                if (null === this._p1 || null === this._p2)
                    return null;
                const e = new hs.CompositeRenderer;
                return e.append(this._bgRenderer),
                e.append(this._horzTrenRenderer),
                e.append(this._vertTrenRenderer),
                e.append(this._labelRenderer),
                e
            }
        }
        var ws = i(965251)
          , Ts = i(699875);
        class Ps extends ne.MediaCoordinatesPaneRenderer {
            constructor(e) {
                super(),
                this._svgMap = new Map,
                this._data = e,
                this._svgMap.set(e.theme, this._createSvgRenderer(e.theme))
            }
            hitTest() {
                return null
            }
            setData(e) {
                this._svgMap.has(e.theme) || this._svgMap.set(e.theme, this._createSvgRenderer(e.theme)),
                this._data = e
            }
            _drawImpl(e) {
                const {context: t, mediaSize: i} = e
                  , {theme: s, x: o} = this._data
                  , n = this._svgMap.get(s);
                if (!n)
                    return;
                const r = n.viewBox()
                  , {width: a, height: l} = r
                  , c = a / 2;
                o + c < 0 || o - c > i.width || (t.translate(o - c, i.height - l),
                n.render(t, {
                    targetViewBox: r
                }))
            }
            _createSvgRenderer(e) {
                const t = 1 === e ? Ts.replace("backgroundColor", (0,
                c.getHexColorByName)("color-cold-gray-900")).replace("lineColor", (0,
                c.getHexColorByName)("color-cold-gray-450")) : Ts.replace("backgroundColor", (0,
                c.getHexColorByName)("color-white")).replace("lineColor", (0,
                c.getHexColorByName)("color-cold-gray-550"));
                return (0,
                ws.svgRenderer)(t)
            }
        }
        class xs {
            constructor(e) {
                this._source = e,
                this._renderer = new Ps(this._getRenderData(0))
            }
            update() {}
            renderer() {
                var e;
                const t = this._source.visible && this._source.areLinesVisible
                  , i = this._source.lockedX()
                  , s = 0 === (null === (e = Ge.crosshairLock.value()) || void 0 === e ? void 0 : e.type);
                return t && s && null !== i ? (this._renderer.setData(this._getRenderData(i + 1)),
                this._renderer) : null
            }
            _getRenderData(e) {
                return {
                    x: e,
                    theme: this._source.model().dark().value() ? 1 : 0
                }
            }
        }
        const Ms = 30;
        class Is {
            constructor(e, t, i) {
                this._renderer = new ns.RectangleRenderer,
                this._invalidated = !0,
                this._source = e,
                this._pane = t,
                this._model = i
            }
            update() {
                this._invalidated = !0
            }
            renderer() {
                return this._invalidated && (this._updateImpl(),
                this._invalidated = !1),
                this._renderer
            }
            _updateImpl() {
                var e;
                if (this._renderer.setData(null),
                !this._pane || !this._source.visible)
                    return;
                if (!this._source.model().mainSeries().lastValueData(void 0, !0, !0).index)
                    return;
                const t = new a.Point(null !== (e = this._source.lockedX()) && void 0 !== e ? e : this._source.x,0)
                  , i = new a.Point(this._pane.width(),this._pane.height())
                  , s = {
                    backcolor: (0,
                    _i.applyTransparency)(this._model.backgroundColorAtYPercentFromTop(.5), Ms),
                    color: (0,
                    _i.applyTransparency)(this._model.backgroundColorAtYPercentFromTop(.5), Ms),
                    fillBackground: !0,
                    linewidth: 0,
                    points: [t, i],
                    nohittest: !0,
                    extendLeft: !1,
                    extendRight: !1
                };
                this._renderer.setData(s)
            }
        }
        var As = i(907256)
          , Ls = i(49839)
          , Es = i(581899);
        class ks extends Ls.DataWindowView {
            constructor(e) {
                super(),
                this._invalidated = !0,
                this._dateItem = new Ls.DataWindowItem("",d.t(null, void 0, i(722677)),""),
                this._timeItem = new Ls.DataWindowItem("",d.t(null, void 0, i(312806)),""),
                this._model = e,
                this._items.push(this._dateItem),
                this._items.push(this._timeItem)
            }
            update() {
                this._invalidated = !0
            }
            items() {
                return this._invalidated && (this._updateImpl(),
                this._invalidated = !1),
                this._items
            }
            _updateImpl() {
                const e = this._model.mainSeries().isDWM();
                if (this._timeItem.setVisible(!e),
                this._timeItem.setValue(Es.notAvailable),
                this._dateItem.setValue(Es.notAvailable),
                this._model.timeScale().isEmpty())
                    return;
                let t = this._model.crossHairSource().appliedIndex();
                if (!(0,
                Ci.isNumber)(t)) {
                    const e = this._model.mainSeries().data().last();
                    if (null === e)
                        return;
                    t = e.index
                }
                const i = this._model.timeScale().indexToUserTime(t);
                null !== i && (this._dateItem.setValue(this._model.dateFormatter().format(i)),
                e || this._timeItem.setValue(this._model.timeFormatter().format(i)))
            }
        }
        var Ds = i(83810);
        const Ns = c.colorsPalette["color-tv-blue-500"]
          , Bs = d.t(null, {
            context: "Replay"
        }, i(753310));
        class Rs extends Ds.TimeAxisView {
            constructor(e, t, i, s=!1) {
                super(e),
                this._indexProvider = i,
                this._highlighted = s,
                this._source = t,
                this._properties = e.properties().childs().scalesProperties
            }
            _getText(e) {
                if (this._source.isReplaySelection()) {
                    const t = this._model.timeScale().indexToUserTime(e);
                    return null !== t ? `${Bs}: ${this._model.dateTimeFormatter().format(t)}` : ""
                }
                return super._getText(e)
            }
            _getBgColor() {
                if (this._source.isReplaySelection())
                    return Ns;
                const e = this._properties.childs();
                return this._highlighted ? e.axisLineToolLabelBackgroundColorCommon.value() : this._model.dark().value() ? e.crosshairLabelBgColorDark.value() : e.crosshairLabelBgColorLight.value()
            }
            _getIndex() {
                return this._model.crossHairSource().visible || null !== this._source.lockedPane() ? this._indexProvider() : null
            }
            _isVisible() {
                return this._properties.childs().showTimeScaleCrosshairLabel.value()
            }
        }
        var Os = i(259638)
          , Vs = i(813442);
        const Ws = {
            menuEnabled: !1,
            menuForMainSourceOnly: !1,
            disableTradingMenuActions: !1,
            disableDrawHorizLineMenuAction: !1
        };
        let Fs = 0;
        const Hs = (0,
        he.getLogger)("Chart.Crosshair");
        class zs extends ie.DataSource {
            constructor(e, t, i) {
                super(),
                this.pane = null,
                this.price = NaN,
                this.index = NaN,
                this.visible = !0,
                this.areLinesVisible = !0,
                this.x = NaN,
                this.y = NaN,
                this._lockData = null,
                this._measurePane = new j.WatchedValue(null),
                this._measurePaneViewCache = new WeakMap,
                this._startMeasurePoint = null,
                this._endMeasurePoint = null,
                this._lastValidMeasurePoint = null,
                this._isOnHoveredChartWidget = !1,
                this._crossHairSelectPointMode = new j.WatchedValue(Ge.SelectPointMode.None),
                this._selectionPane = null,
                this._selectionView = new as(this),
                this._selectionStartPoint = null,
                this._timeLockPaneView = null,
                this._crosshairPaneViewCache = new WeakMap,
                this._pointSelectionPaneViewCache = new WeakMap,
                this._priceAxisViews = new Map,
                this._panePriceAxisViews = new Map,
                this._startMeasurePriceAxisViews = new Map,
                this._endMeasurePriceAxisViews = new Map,
                this._originX = NaN,
                this._originY = NaN,
                this._subscribed = !1,
                this._movedDelegate = new G.Delegate,
                this._pointSelectedDelegate = new G.Delegate,
                this._requestedPoint = null,
                this._paneForRequestedPoint = null,
                this._selectLineColor = null,
                this._volumeCalculator = null,
                this._selectFromAllChartsIfOutOfData = null,
                this._currentMeasurePointsetAndSymbolId = null,
                this._model = e,
                this._options = Object.assign({}, Ws, i || {}),
                this._linesShouldBeHidden = this._model.readOnly(),
                this._dataWindowView = new ks(e),
                this.setSelectionEnabled(!1);
                const s = e=>t=>t === (0,
                r.ensureNotNull)(this._measurePane.value()).defaultPriceScale() ? e() : null;
                this._currentPosPriceProvider = e=>{
                    const t = (0,
                    r.ensureNotNull)(this.pane);
                    if (e === t.defaultPriceScale())
                        return this.price;
                    const i = (0,
                    r.ensureNotNull)(t.defaultPriceScale().mainSource()).firstValue();
                    if (null === i)
                        return null;
                    const s = t.defaultPriceScale().priceToCoordinate(this.price, i)
                      , o = (0,
                    r.ensureNotNull)(e.mainSource()).firstValue();
                    return null === o ? null : e.coordinateToPrice(s, o)
                }
                ,
                this._startMeasurePriceProvider = s((()=>(0,
                r.ensureNotNull)(this._startMeasurePoint).price)),
                this._endMeasurePriceProvider = s((()=>(0,
                r.ensureNotNull)(this._lastMeasurePoint()).price)),
                this._properties = t;
                this._timeAxisView = new Rs(e,this,(()=>this.appliedIndex()),!1),
                this._startMeasureTimeAxisView = new Rs(e,this,(()=>(0,
                r.ensureNotNull)(this._startMeasurePoint).index),!0),
                this._endMeasureTimeAxisView = new Rs(e,this,(()=>(0,
                r.ensureNotNull)(this._lastMeasurePoint()).index),!0),
                e.readOnly() || Ge.cursorTool.subscribe((e=>this.areLinesVisible = "arrow" !== e), {
                    callWithLast: !0
                }),
                this._crosshairLock = Ge.crosshairLock.spawn(),
                this._showPlusButtonOnCursor = Zi.showPlusButtonOnCursor.spawn();
                const o = ()=>{
                    this.updateAllViews((0,
                    dt.sourceChangeEvent)(this.id())),
                    this._model.lightUpdate()
                }
                ;
                this._crosshairLock.subscribe(o),
                this._showPlusButtonOnCursor.subscribe(o)
            }
            destroy() {
                null !== this._volumeCalculator && this._volumeCalculator.destroy(),
                this._measurePane.setValue(null),
                this._crosshairLock.destroy(),
                this._showPlusButtonOnCursor.destroy(),
                this._removeMeasurePointset(),
                super.destroy()
            }
            name() {
                return "Crosshair"
            }
            moved() {
                return this._movedDelegate
            }
            originX() {
                return this._originX
            }
            originY() {
                return this._originY
            }
            saveOriginCoords(e, t) {
                this._originX = e,
                this._originY = t
            }
            clearOriginCoords() {
                this._originX = NaN,
                this._originY = NaN
            }
            currentPoint() {
                return new a.Point(this.x,this.y)
            }
            model() {
                return this._model
            }
            appliedIndex() {
                var e;
                return null !== (e = this._getLockData().index) && void 0 !== e ? e : this.index
            }
            lockedX() {
                var e;
                return null !== (e = this._getLockData().xCoord) && void 0 !== e ? e : null
            }
            lockedY() {
                var e;
                return null !== (e = this._getLockData().yCoord) && void 0 !== e ? e : null
            }
            lockedPane() {
                const e = Ge.crosshairLock.value();
                return null === e || 1 !== e.type ? null : this._model.id() === e.modelId ? this._model.paneForId(e.paneId) : this._model.mainPane()
            }
            invalidateLockPosition() {
                this._lockData = null
            }
            startMeasurePoint() {
                return this._startMeasurePoint || null
            }
            endMeasurePoint() {
                return this._endMeasurePoint || null
            }
            measureVolume() {
                if (null === this._volumeCalculator)
                    return NaN;
                const [e,t] = this.measurePoints();
                return void 0 === t ? NaN : this._volumeCalculator.volume(e.index, t.index)
            }
            measurePane() {
                return this._measurePane.readonly()
            }
            startMeasuring(e, t) {
                this._startMeasurePoint = e,
                this._measurePane.setValue(t),
                t.containsMainSeries() && ((0,
                r.assert)(null === this._volumeCalculator),
                this._volumeCalculator = new Os.SeriesTimeRangeVolumeCalculator(this.model().mainSeries())),
                this._model.updatePane(t)
            }
            finishMeasure(e) {
                this._endMeasurePoint = e,
                this._createMeasurePointset((0,
                r.ensureNotNull)(this._startMeasurePoint), this._endMeasurePoint)
            }
            clearMeasure() {
                this._removeMeasurePointset(),
                this._measurePane.setValue(null),
                delete this._startMeasurePoint,
                delete this._endMeasurePoint,
                delete this._lastValidMeasurePoint,
                this._model.lightUpdate(),
                null !== this._volumeCalculator && (this._volumeCalculator.destroy(),
                this._volumeCalculator = null)
            }
            measurePoints() {
                const e = [(0,
                r.ensureNotNull)(this._startMeasurePoint)]
                  , t = this._lastMeasurePoint();
                return null !== t && e.push(t),
                e
            }
            startSelection(e) {
                this._selectionStartPoint = this.currentLogicalPoint(),
                this._selectionPane = e
            }
            clearSelection() {
                this._selectionStartPoint = null,
                this._selectionPane = null
            }
            selection() {
                return this._selectionStartPoint ? {
                    p1: this._selectionStartPoint,
                    p2: this.currentLogicalPoint()
                } : null
            }
            currentLogicalPoint() {
                return {
                    index: this.appliedIndex(),
                    price: this.price
                }
            }
            selectPointMode() {
                return this._crossHairSelectPointMode
            }
            lineColor() {
                return this._selectLineColor
            }
            cancelRequestSelectPoint() {
                this._crossHairSelectPointMode.value() !== Ge.SelectPointMode.None && this._setSelectPointModeState(Ge.SelectPointMode.None),
                this._selectFromAllChartsIfOutOfData = null
            }
            requestSelectPoint(e) {
                (0,
                r.assert)(this._crossHairSelectPointMode.value() === Ge.SelectPointMode.None, "Point already requested");
                const {pointType: t, pane: i, lineColor: s=null, selectFromAllChartsIfOutOfData: o, selectPointMode: n=Ge.SelectPointMode.Study} = e;
                i && ((0,
                r.assert)(-1 !== this._model.panes().indexOf(i), "Chartmodel doesn't contains specified pane"),
                this._paneForRequestedPoint = i,
                this._model.panesCollectionChanged().subscribe(this, this._paneCollectionChanged)),
                this._selectLineColor = s,
                this._requestedPoint = t,
                this._selectFromAllChartsIfOutOfData = null != o ? o : null,
                this._setSelectPointModeState(n)
            }
            onPointSelected() {
                return this._pointSelectedDelegate
            }
            trySelectCurrentPoint() {
                var e;
                const t = this.pane;
                if (!t)
                    return;
                const i = (0,
                r.ensureNotNull)(this._requestedPoint);
                let s = null;
                if (!this._model.mainSeries().bars().search(this.index, Bt.PlotRowSearchMode.Exact) && "price" !== i && (this._selectFromAllChartsIfOutOfData && (s = null !== (e = Math.min(...Array.from(Ge.barTimesUnderCursor.values()))) && void 0 !== e ? e : null),
                null === s))
                    return;
                if (this._paneForRequestedPoint && this._paneForRequestedPoint !== t)
                    return;
                let o, n = s;
                if ("price" === i || null !== s || (n = this._model.timeScale().indexToTimePoint(this.index),
                null !== n)) {
                    if ("time" !== i) {
                        const e = t.mainDataSource();
                        if (null === e)
                            return;
                        const i = e.firstValue()
                          , s = e.priceScale();
                        if (null === i || null === s)
                            return;
                        o = s.coordinateToPrice(this.y, i)
                    }
                    this._setSelectPointModeState(Ge.SelectPointMode.None),
                    this._pointSelectedDelegate.fire({
                        time: null != n ? n : void 0,
                        price: o
                    }, t)
                }
            }
            isOnHoveredChartWidget() {
                return this._isOnHoveredChartWidget
            }
            setOnHoveredChartWidget(e) {
                this._isOnHoveredChartWidget = e
            }
            isReplaySelection() {
                return ("AllCharts" === As.replayModeProperty.value() || this._isOnHoveredChartWidget) && this._crossHairSelectPointMode.value() === Ge.SelectPointMode.Replay
            }
            clearPosition() {
                this.visible = !1,
                this.index = NaN,
                this.price = NaN,
                this.x = NaN,
                this.y = NaN,
                this.pane = null,
                this.clearOriginCoords(),
                this._updateVisibilityDependentPaneViews()
            }
            setPosition(e, t, i) {
                this._subscribed || (this._model.mainSeries().onRestarted().subscribe(this, this.clearMeasure),
                this._subscribed = !0),
                this.visible = !0;
                const s = this._model.id()
                  , o = this._model.mainSeries().bars().search(this.index, Bt.PlotRowSearchMode.NearestRight);
                return o && Ge.barTimesUnderCursor.set(s, o.value[0]),
                this._tryToUpdateViews(e, t, i)
            }
            setLinesShouldBeHidden(e) {
                this._linesShouldBeHidden = e
            }
            linesShouldBeHidden() {
                return this._linesShouldBeHidden
            }
            handleContextMenuEvent(e) {
                this._crossHairSelectPointMode.value() !== Ge.SelectPointMode.None && this._setSelectPointModeState(Ge.SelectPointMode.None)
            }
            properties() {
                return this._properties
            }
            priceAxisViews(e, t) {
                var i;
                const s = null === this._requestedPoint || "time" !== this._requestedPoint || !this._isOnHoveredChartWidget
                  , o = [];
                return (null !== (i = this.lockedPane()) && void 0 !== i ? i : this.pane) === e && s && o.push(this._createPriceAxisViewOnDemand(this._priceAxisViews, this._panePriceAxisViews, e, t, this._currentPosPriceProvider, Ri, !0)[0]),
                this._startMeasurePoint && o.push(this._createPriceAxisViewOnDemand(this._startMeasurePriceAxisViews, null, e, t, this._startMeasurePriceProvider, Oi)[0]),
                this._lastMeasurePoint() && o.push(this._createPriceAxisViewOnDemand(this._endMeasurePriceAxisViews, null, e, t, this._endMeasurePriceProvider, Oi)[0]),
                o
            }
            timeAxisViews() {
                const e = []
                  , t = null === this._requestedPoint || "price" !== this._requestedPoint || !this._isOnHoveredChartWidget;
                return this._linesShouldBeHidden || !this.visible && null === Ge.crosshairLock.value() || !t || e.push(this._timeAxisView),
                this._startMeasurePoint && e.push(this._startMeasureTimeAxisView),
                this._lastMeasurePoint() && e.push(this._endMeasureTimeAxisView),
                e
            }
            paneViews(e) {
                var t, i;
                if (void 0 === e)
                    return null;
                const s = [];
                if (this.isReplaySelection()) {
                    let t = this._pointSelectionPaneViewCache.get(e);
                    t || (t = new Is(this,e,this._model),
                    this._pointSelectionPaneViewCache.set(e, t)),
                    s.push(t)
                }
                let o = this._crosshairPaneViewCache.get(e);
                if (o || (o = new os(this,e),
                this._crosshairPaneViewCache.set(e, o)),
                s.push(o),
                e === this._selectionPane && s.push(this._selectionView),
                e === this._measurePane.value()) {
                    let t = this._measurePaneViewCache.get(e);
                    t || (t = new Cs(this,e),
                    this._measurePaneViewCache.set(e, t)),
                    t.update((0,
                    dt.sourceChangeEvent)(this.id())),
                    s.push(t)
                }
                if ((Zi.addPlusButtonProperty.value() || this._showPlusButtonOnCursor.value()) && 1 !== (null === (t = Ge.crosshairLock.value()) || void 0 === t ? void 0 : t.type)) {
                    const t = e === this.pane
                      , i = !ti.CheckMobile.any() || window.screen.width >= 320
                      , o = Ge.tool.value()
                      , n = (0,
                    Ee.isLineToolName)(o)
                      , r = null !== this._model.lineBeingEdited() || null !== this._model.lineBeingCreated() || this._model.sourcesBeingMoved().length > 0 || null !== this._model.customSourceBeingMoved() || (0,
                    Ge.toolIsMeasure)(o);
                    if (t && this._isOnHoveredChartWidget && this._crossHairSelectPointMode.value() === Ge.SelectPointMode.None && i && !n && !r) {
                        const t = e.mainDataSource();
                        if (null !== t) {
                            const i = t.priceScale();
                            if (null !== i) {
                                const t = this._createPriceAxisViewOnDemand(this._priceAxisViews, this._panePriceAxisViews, e, i, this._currentPosPriceProvider, Ri, !0)[1];
                                null !== t && s.push(t)
                            }
                        }
                    }
                }
                return 0 === (null === (i = Ge.crosshairLock.value()) || void 0 === i ? void 0 : i.type) && (null === this._timeLockPaneView && (this._timeLockPaneView = new xs(this)),
                s.push(this._timeLockPaneView)),
                s
            }
            dataWindowView() {
                return this._dataWindowView
            }
            updateAllViews(e) {
                this._priceAxisViews.forEach((t=>{
                    t.forEach((t=>t.update(e)))
                }
                )),
                this._panePriceAxisViews.forEach((t=>{
                    t.forEach((t=>t.update(e)))
                }
                )),
                this._startMeasurePoint && (this._startMeasurePriceAxisViews.forEach((t=>{
                    t.forEach((t=>t.update(e)))
                }
                )),
                this._startMeasureTimeAxisView.update(e)),
                this._lastMeasurePoint() && (this._endMeasurePriceAxisViews.forEach((t=>{
                    t.forEach((t=>t.update(e)))
                }
                )),
                this._endMeasureTimeAxisView.update(e)),
                this._timeAxisView.update(e),
                this._selectionView.update(),
                this._dataWindowView.update(),
                this._updateVisibilityDependentPaneViews()
            }
            isMenuEnabled() {
                return this._options.menuEnabled
            }
            isHoveredEnabled() {
                return Zi.addPlusButtonProperty.value() || this._showPlusButtonOnCursor.value()
            }
            isHovered() {
                return this._model.hoveredSource() === this
            }
            pointToSelect() {
                return this._requestedPoint
            }
            paneForPointSelect() {
                return this._paneForRequestedPoint
            }
            _lastMeasurePoint() {
                return this._endMeasurePoint ? this._endMeasurePoint : (null !== this.pane && this._measurePane.value() === this.pane && (this._lastValidMeasurePoint = {
                    price: this._model.magnet().align(this.price, this.index, this.pane),
                    index: this.index
                }),
                this._lastValidMeasurePoint || null)
            }
            _createPriceAxisViewOnDemand(e, t, i, s, o, n, a=!1) {
                let l = e.get(i)
                  , c = null !== t ? t.get(i) : void 0;
                void 0 === l && (l = new Map,
                e.set(i, l),
                this.isMenuEnabled() && null !== t && (c = new Map,
                t.set(i, c)),
                a && i.onDestroyed().subscribe(this, (()=>this._onPaneDestroyed(i))));
                let d = l.get(s);
                if (void 0 === d) {
                    if (d = new n(this,i,s,o),
                    l.set(s, d),
                    void 0 !== c) {
                        const e = new Qi(d,this,s,this._model,this._options);
                        c.set(s, e)
                    }
                    a && s.lastSourceRemoved().subscribe(this, (()=>this._onPriceScaleCleared(s)))
                }
                let u = null;
                return void 0 !== c && (u = (0,
                r.ensureDefined)(c.get(s))),
                [d, u]
            }
            _onPaneDestroyed(e) {
                e.onDestroyed().unsubscribeAll(this),
                this._priceAxisViews.delete(e),
                this._panePriceAxisViews.delete(e),
                this._startMeasurePriceAxisViews.delete(e),
                this._endMeasurePriceAxisViews.delete(e)
            }
            _onPriceScaleCleared(e) {
                e.lastSourceRemoved().unsubscribeAll(this),
                this._priceAxisViews.forEach((t=>t.delete(e))),
                this._panePriceAxisViews.forEach((t=>t.delete(e))),
                this._startMeasurePriceAxisViews.forEach((t=>t.delete(e))),
                this._endMeasurePriceAxisViews.forEach((t=>t.delete(e)))
            }
            _tryToUpdateViews(e, t, i) {
                return !!this._tryToUpdateData(e, t, i) && (this.updateAllViews((0,
                dt.sourceChangeEvent)(this.id())),
                this._movedDelegate.fire({
                    index: this.index,
                    price: this.price
                }),
                !0)
            }
            _tryToUpdateData(e, t, i) {
                const s = this.x
                  , o = this.y
                  , n = this.price
                  , a = this.index
                  , l = this.pane
                  , c = this._priceScaleByPane(i);
                if (this.index = e,
                this.x = isNaN(e) ? NaN : this._model.timeScale().indexToCoordinate(e),
                null !== c && null !== i) {
                    this.pane = i,
                    this.price = t;
                    const e = (0,
                    r.ensureNotNull)(i.mainDataSource()).firstValue();
                    this.y = null === e ? NaN : c.priceToCoordinate(t, e)
                } else
                    this.pane = null,
                    this.price = NaN,
                    this.y = NaN;
                return s !== this.x || o !== this.y || a !== this.index || n !== this.price || l !== this.pane
            }
            _priceScaleByPane(e) {
                return e && !e.defaultPriceScale().isEmpty() ? e.defaultPriceScale() : null
            }
            _setSelectPointModeState(e) {
                e === Ge.SelectPointMode.None && (this._requestedPoint = null,
                this._selectLineColor = null,
                this._paneForRequestedPoint && (this._paneForRequestedPoint = null,
                this._model.panesCollectionChanged().unsubscribe(this, this._paneCollectionChanged))),
                Ge.activePointSelectionMode.setValue(e),
                this._crossHairSelectPointMode.setValue(e),
                this._model.lightUpdate()
            }
            _paneCollectionChanged(e) {
                const t = this._paneForRequestedPoint;
                null !== t && -1 === e.indexOf(t) && this.cancelRequestSelectPoint()
            }
            _updateVisibilityDependentPaneViews() {
                var e;
                for (const t of this.model().panes())
                    null === (e = this._pointSelectionPaneViewCache.get(t)) || void 0 === e || e.update()
            }
            _getLockData() {
                var e;
                if (null === this._lockData) {
                    const t = Ge.crosshairLock.value();
                    if (null === t)
                        this._lockData = {};
                    else {
                        const i = this._model.timeScale()
                          , s = null !== (e = i.points().roughIndex(t.time)) && void 0 !== e ? e : void 0
                          , o = void 0 === s ? void 0 : i.indexToCoordinate(s);
                        switch (t.type) {
                        case 0:
                            this._lockData = {
                                index: s,
                                xCoord: o
                            };
                            break;
                        case 1:
                            {
                                let e;
                                const i = this.lockedPane();
                                if (null !== i) {
                                    const s = i.mainDataSource();
                                    if (null !== s) {
                                        const i = s.firstValue()
                                          , o = s.priceScale();
                                        null !== o && null !== i && (e = o.priceToCoordinate(t.price, i))
                                    }
                                }
                                this._lockData = {
                                    index: s,
                                    xCoord: o,
                                    yCoord: e
                                }
                            }
                        }
                    }
                }
                return this._lockData
            }
            _createMeasurePointset(e, t) {
                const i = this._normalizePoint(e)
                  , s = this._normalizePoint(t)
                  , o = [[i.time_t, i.offset], [s.time_t, s.offset]];
                this._removeMeasurePointset(),
                ++Fs,
                this._currentMeasurePointsetAndSymbolId = {
                    measurePointsetId: Fs,
                    symbolId: (0,
                    r.ensureNotNull)(this._model.mainSeries().seriesSource().symbolInstanceId())
                };
                const n = (0,
                Vs.getServerInterval)(this._model.mainSeries().interval());
                this._model.chartApi().createPointset(this._currentMeasurePointsetIdWithPrefix(), "turnaround", this._currentMeasurePointsetAndSymbolId.symbolId, n, o, this._onPointsetResponse.bind(this))
            }
            _removeMeasurePointset() {
                null !== this._currentMeasurePointsetAndSymbolId && this._model.chartApi().isConnected().value() && this._model.chartApi().removePointset(this._currentMeasurePointsetIdWithPrefix()),
                this._currentMeasurePointsetAndSymbolId = null
            }
            _currentMeasurePointsetIdWithPrefix() {
                return "pointsetMeasure_" + (0,
                r.ensureNotNull)(this._currentMeasurePointsetAndSymbolId).measurePointsetId
            }
            _normalizePoint(e) {
                return {
                    ...this._model.timeScale().normalizeBarIndex(e.index),
                    price: e.price
                }
            }
            _onPointsetResponse(e) {
                if ("pointset_error" === e.method)
                    return void Hs.logError(`Error getting pointset: ${e.params[0]} ${e.params[1]}`);
                if (e.params.customId !== this._currentMeasurePointsetIdWithPrefix())
                    return;
                if (null === this._startMeasurePoint || null === this._endMeasurePoint)
                    return;
                const t = e.params.plots;
                if (2 !== t.length)
                    return;
                const i = t[0].value[0]
                  , s = t[1].value[0];
                this._startMeasurePoint.index = i,
                this._endMeasurePoint.index = s,
                this.updateAllViews((0,
                dt.sourceChangeEvent)(this.id())),
                this._model.updateSource(this)
            }
        }
        var Us = i(965402)
          , Gs = i(496416)
          , js = i(985429)
          , qs = i(370407)
          , Xs = i(615914)
          , Ks = i(427047)
          , Ys = i(348065);
        class Zs {
            constructor(e) {
                this._priceSourceNamesById = new Map,
                e.forEach((e=>this._priceSourceNamesById.set(e.id, e.name)))
            }
            name(e) {
                var t;
                return null !== (t = this._priceSourceNamesById.get(e)) && void 0 !== t ? t : null
            }
            priceSourcesChanged(e) {
                return e.length !== this._priceSourceNamesById.size
            }
        }
        var $s = i(643322)
          , Js = i(78007);
        const Qs = new qs.TranslatedString("remove deselected empty line tools",d.t(null, void 0, i(727171)))
          , eo = ue.enabled("auto_enable_symbol_labels")
          , to = (0,
        he.getLogger)("Chart.ChartModel");
        function io(e, t) {
            const i = e.indexOf(t);
            return -1 !== i && (e.splice(i, 1),
            !0)
        }
        function so(e) {
            var t, i;
            for (let s = e.length; s--; ) {
                const o = e[s].dataSources();
                for (let e = o.length; e--; )
                    null === (t = o[e].dataWindowView()) || void 0 === t || t.update();
                const n = e[s].priceDataSources();
                for (let e = n.length; e--; )
                    null === (i = n[e].legendView()) || void 0 === i || i.update()
            }
        }
        const oo = {
            isSnapshot: !1,
            readOnly: !1,
            watermarkEnabled: !0,
            shiftVisibleRangeOnNewBar: !0,
            currencyConversionEnabled: !1,
            unitConversionEnabled: !1,
            countdownEnabled: !0,
            lastPriceAnimationEnabled: !0,
            onWidget: !1,
            hideIdeas: !1
        }
          , no = {
            throttle: o.default,
            debounce: s.default
        }
          , ro = new Map([[b.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction, {
            timeout: 2e3,
            adapter: "debounce"
        }], [b.RecalcVisibleRangeStudiesReason.DataUpdate, {
            timeout: 5e3,
            adapter: "throttle"
        }], [b.RecalcVisibleRangeStudiesReason.SeriesRestart, {
            timeout: 2e3,
            adapter: "debounce"
        }], [b.RecalcVisibleRangeStudiesReason.SeriesCompleted, {
            timeout: 2e3,
            adapter: "debounce"
        }], [b.RecalcVisibleRangeStudiesReason.StudyCreation, {
            timeout: 2e3,
            adapter: "debounce"
        }]])
          , ao = Array.from(ro.values());
        class lo {
            constructor(e, t, i, o, n, r, a, l, c, d) {
                this._onRearrangePanes = new G.Delegate,
                this._lineToolsGroupModel = new Kt,
                this._sourcesBeingMoved = [],
                this._activeItemBeingMoved = null,
                this._lineBeingEdited = null,
                this._linePointBeingEdited = null,
                this._linePointBeingChanged = null,
                this._customSourceBeingMovedHitTestData = null,
                this._customSourceBeingMoved = null,
                this._dataSourceCollectionChanged = new G.Delegate,
                this._sourceProperitesChanged = new G.Delegate,
                this._sourceZOrderChanged = new G.Delegate,
                this._symbolSourceResolved = new G.Delegate,
                this._symbolSourceResolvingActive = new j.WatchedValue(!1),
                this._adjustForDividendsAvailability = new j.WatchedValue(0),
                this._adjustForDividendsEnabled = new j.WatchedValue(!1),
                this._currentTool = "",
                this._lineBeingCreated = null,
                this._paneBeingCreatedLineOn = null,
                this._lineCancelled = new G.Delegate,
                this._phantomSourceContainer = new wi(this),
                this._destroyed = !1,
                this._isSettingsExternalPosition = !1,
                this._isTimeScrolling = !1,
                this._magnet = new Mi,
                this._scrollingState = null,
                this._modelIntervals = [],
                this._rendererOptionsProvider = new R(this),
                this._studyInserted = new G.Delegate,
                this._cachedStudiesMaxOffset = 0,
                this._replayStatus = new j.WatchedValue(0),
                this._panes = [],
                this._tagsChanged = new G.Delegate,
                this._strategySources = [],
                this._strategySourcesChange = new G.Delegate,
                this._activeStrategySource = new j.WatchedValue(null),
                this._symbolIntervalChanged = new G.Delegate,
                this._paneCollapsingAvailable = new j.WatchedValue(!1),
                this._panesCollectionChanged = new G.Delegate,
                this._scrollEnabled = ue.enabled("chart_scroll"),
                this._zoomEnabled = ue.enabled("chart_zoom"),
                this._lollipopSourcesWatcher = null,
                this._alertsWatcher = null,
                this._hoveredSource = null,
                this._hoveredSourceChanged = new G.Delegate,
                this._lastHoveredHittestData = null,
                this._hoveredSourceOrigin = null,
                this._lastSelectedHittestData = null,
                this._topmostCustomSources = [],
                this._fgCustomSources = [],
                this._bgCustomSources = [],
                this._allCustomSources = [],
                this._customSourcesMap = new Map,
                this._multiPaneSources = [],
                this._showLegendProperty = new k.Property,
                this._id = (0,
                pe.guid)(),
                this._chartSaveTime = null,
                this._availableCurrenciesList = null,
                this._availableCurrencies = new bi([]),
                this._availablePriceSources = new Zs([]),
                this._availableUnitsObject = null,
                this._availableUnits = new yi({}),
                this._availablePriceSourcesBySymbol = new Map,
                this._shouldBeSavedEvenIfHidden = !1,
                this._watchedThemeSpawn = u.watchedTheme.spawn(),
                this._gradientColorsCache = null,
                this._studiesWV = new q.WatchedObject([],C.compareTwoCollectionsByIds),
                this._studiesExcludeInternalWV = new q.WatchedObject([],C.compareTwoCollectionsByIds),
                this._resetScalesAvailable = new j.WatchedValue(!1),
                this._recalcVRStudiesParams = {
                    reasons: new Set
                },
                this._recalcColorStudiesParams = {},
                this._replayStudyStrategy = new j.WatchedValue(null),
                this._recalcVisibleRangeStudiesImplDebouncedByAdapter = new Map(Object.keys(no).map((e=>[e, new Map(ao.filter((t=>t.adapter === e)).map((e=>[e.timeout, no[e.adapter](this._recalcVisibleRangeStudiesImpl.bind(this, this._recalcVRStudiesParams), e.timeout)])))]))),
                this._recalcColorStudiesImplDebounced = (0,
                s.default)(this._recalcColorStudiesImpl.bind(this, this._recalcColorStudiesParams), 250),
                this._width = 0,
                this._resetScales = new G.Delegate,
                this._chartThemeLoaded = new G.Delegate,
                this._selection = new x,
                this._selectedSourceChanged = new G.Delegate,
                this._symbolSourceCollectionChanged = new G.Delegate,
                this._gridSource = new Di,
                this._visibleRangeStudiesInputs = new q.WatchedObject(null),
                this._syncPointCache = new Map,
                this._lastAppliedGotoTimeRange = null,
                this._lastGotoTimeRange = null,
                this._lollipopSourcesWatcherLoader = null,
                this._sessions = null,
                this._onMultipaneSourcesCollectionChanged = new G.Delegate,
                this._replayStudyStrategyInputs = null,
                this._clearSelection = ()=>{
                    this._lastSelectedHittestData = null,
                    this._selection.clear()
                }
                ,
                this._removeSourceFromSelection = e=>{
                    this._selection.remove(e)
                }
                ,
                this._addSourceToSelection = (e,t)=>{
                    const i = this._selection.isSelected(e);
                    i && this._lastSelectedHittestData === t || e && !e.isSelectionEnabled() || (this._lastSelectedHittestData = t || null,
                    i || this._selection.add(e))
                }
                ,
                this._recalcSymbolResolvingActive = ()=>{
                    for (const e of this._panes)
                        if (e.symbolSourceResolvingActive().value())
                            return void this._symbolSourceResolvingActive.setValue(!0);
                    this._symbolSourceResolvingActive.setValue(!1)
                }
                ,
                this._recalcAdjustForDividendsAvailability = ()=>{
                    var e, t, i, s;
                    if (this._symbolSourceResolvingActive.value())
                        return;
                    const o = this.mainSeries();
                    switch (null !== (t = null === (e = o.symbolInfo()) || void 0 === e ? void 0 : e.allowed_adjustment) && void 0 !== t ? t : "none") {
                    case "dividends":
                        return void this._adjustForDividendsAvailability.setValue(2);
                    case "splits":
                        return void this._adjustForDividendsAvailability.setValue(1);
                    case "any":
                        return void this._adjustForDividendsAvailability.setValue(3)
                    }
                    for (const e of this.symbolSources().filter(Be.isActingAsSymbolSource)) {
                        if (e.symbolHibernated().value() || e === o)
                            continue;
                        if ("any" === (null !== (s = null === (i = e.symbolInfo()) || void 0 === i ? void 0 : i.allowed_adjustment) && void 0 !== s ? s : "none"))
                            return void this._adjustForDividendsAvailability.setValue(3)
                    }
                    this._adjustForDividendsAvailability.setValue(0)
                }
                ,
                this._recalcAdjustForDividendsEnabled = ()=>{
                    switch (this._adjustForDividendsAvailability.value()) {
                    case 2:
                        return void this._adjustForDividendsEnabled.setValue(!0);
                    case 0:
                    case 1:
                        return void this._adjustForDividendsEnabled.setValue(!1)
                    }
                    this._adjustForDividendsEnabled.setValue(this.mainSeries().properties().childs().dividendsAdjustment.value())
                }
                ,
                this._recalcPaneCollapsingAvailable = e=>{
                    let t = this._panes.filter((e=>!e.collapsed().value())).length;
                    0 === t && e && this._panes.length > 0 && (this._panes[0].collapsed().setValue(!1),
                    t = 1),
                    this._paneCollapsingAvailable.setValue(t > 1)
                }
                ,
                this._updateResetScalesAvailableValue = ()=>{
                    const e = this._timeScale.resetAvailable().value() || this._panes.some((e=>e.resetPriceScalesAvailable().value()));
                    this._resetScalesAvailable.setValue(e)
                }
                ,
                this._chartApi = e,
                this._invalidateHandler = t,
                this._undoModel = n,
                this._properties = i,
                this._options = (0,
                ve.merge)((0,
                ve.clone)(oo), a),
                this._hibernateWV = l,
                this._linkingGroupIndex = c,
                this._isAutoSaveEnabled = d,
                this._readOnly = this._options.readOnly,
                this._isSnapshot = this._options.isSnapshot,
                this._alertsWatcher = new ri(this),
                this.onWidget() || di.withWeekdayProperty.subscribe(this, (()=>this._updateDateTimeFormatter())),
                this._chartSaveTime = (new Date).valueOf(),
                this._backgroundColor = new j.WatchedValue(this._getBackgroundColor()),
                this._backgroundTopColor = new j.WatchedValue(this._getBackgroundColor(!0)),
                this._properties.childs().paneProperties.childs().background.subscribe(this, this._updateBackgroundColor),
                this._properties.childs().paneProperties.childs().backgroundType.subscribe(this, this._updateBackgroundColor),
                this._properties.childs().paneProperties.childs().backgroundGradientStartColor.subscribe(this, this._updateBackgroundColor),
                this._properties.childs().paneProperties.childs().backgroundGradientEndColor.subscribe(this, this._updateBackgroundColor),
                this._backgroundColor.subscribe(this.recalcColorStudies.bind(this, !1)),
                this._backgroundTopColor.subscribe(this.recalcColorStudies.bind(this, !1)),
                this._backgroundCounterColor = new j.WatchedValue(this._getBackgroundCounterColor()),
                this._backgroundColor.subscribe((()=>this._backgroundCounterColor.setValue(this._getBackgroundCounterColor()))),
                this._isDark = (0,
                $s.combine)((e=>"white" === e), this._backgroundCounterColor.weakReference()),
                this._watchedThemeSpawn.subscribe(this._updateBackgroundColor.bind(this)),
                this._symbolSourceResolvingActive.subscribe(this._recalcAdjustForDividendsAvailability),
                (0,
                Ge.init)();
                const h = this._readOnly ? new k.Property((0,
                ve.merge)((0,
                ve.clone)(m.lightTheme.content.chartProperties.paneProperties.crossHairProperties), (0,
                V.defaults)("chartproperties.paneProperties.crossHairProperties"))) : this._properties.childs().paneProperties.childs().crossHairProperties;
                this.m_crossHairSource = new zs(this,h,this._options.crossHair),
                this._crossHairSelectPointMode = this.m_crossHairSource.selectPointMode().spawn(),
                this._crossHairSelectPointMode.subscribe((e=>{
                    if (e !== Ge.SelectPointMode.None && this.lineBeingCreated()) {
                        const e = Ge.tool.value();
                        this.cancelCreatingLine(),
                        Ge.tool.setValue(e)
                    }
                }
                )),
                this._tagsChanged = new G.Delegate;
                const p = new E.DefaultProperty({
                    defaultName: "chartproperties.mainSeriesProperties",
                    excludedDefaultsKeys: ["priceAxisProperties.lockScale", "priceAxisProperties.percentage", "priceAxisProperties.indexedTo100", "priceAxisProperties.isInverted", "priceAxisProperties.log", "priceAxisProperties.logDisabled", "priceAxisProperties.percentageDisabled", "priceAxisProperties.autoScaleDisabled"],
                    excludedTemplateKeys: ["symbol", "interval", "currencyId", "unitId"],
                    themedColors: (0,
                    E.extractThemedColors)(m.lightTheme.content.mainSourceProperties, m.darkTheme.content.mainSourceProperties)
                });
                p.merge(i.childs().mainSeriesProperties.state()),
                this._timeScale = new Ut(this,this._options.timeScale),
                this._timeScale.resetAvailable().subscribe(this._updateResetScalesAvailableValue);
                const g = {
                    countdownEnabled: this._options.countdownEnabled,
                    lastPriceAnimationEnabled: this._options.lastPriceAnimationEnabled
                };
                this.m_mainSeries = new Ne.Series(this,p,g,o),
                this.m_mainSeries.onStyleChanged().subscribe(this._timeScale, this._timeScale.invalidateVisibleBars);
                const _ = ()=>this.fullUpdate();
                this.m_mainSeries.properties().childs().showCountdown.subscribe(this, (()=>{
                    this.m_mainSeries.updateAllViews((0,
                    dt.sourceChangeEvent)(this.m_mainSeries.id())),
                    _()
                }
                )),
                (0,
                K.currencyUnitVisibilityProperty)().subscribe(this, _),
                (0,
                Y.autoLogButtonsVisibilityProperty)().subscribe(this, _),
                this._timeScale.visibleBarsStrictRangeChanged().subscribe(this.m_mainSeries, this.m_mainSeries.clearHighLowPriceCache),
                this._timeScale.visibleBarsStrictRangeChanged().subscribe(this.m_mainSeries, this.m_mainSeries.clearAveragePriceCache),
                this.createPane(void 0, {
                    axisProperties: p.childs().priceAxisProperties.state(["autoScale"])
                }),
                this._adjustForDividendsAvailability.subscribe(this._recalcAdjustForDividendsEnabled),
                this.mainSeries().properties().childs().dividendsAdjustment.subscribe(this, this._recalcAdjustForDividendsEnabled),
                this._recalcAdjustForDividendsEnabled(),
                this._boundUpdateStudiesMaxOffset = this._updateStudiesMaxOffset.bind(this),
                this.mainSeries().dataEvents().seriesTimeFrame().subscribe(this, ((e,t,i,s)=>{
                    if (null !== this._lastAppliedGotoTimeRange && null !== i && s && (0,
                    Ti.areEqualTimeFrames)(this._lastAppliedGotoTimeRange.range, i)) {
                        const e = this.appliedTimeFrame().value();
                        null !== e && !this._lastAppliedGotoTimeRange.actual && (0,
                        Ti.areEqualTimeFrames)(this._lastAppliedGotoTimeRange.range, e.val) && this.appliedTimeFrame().setValue(null),
                        this._lastAppliedGotoTimeRange = null
                    }
                }
                )),
                this.mainSeries().dataEvents().completed().subscribe(this, (e=>{
                    null === this._lastAppliedGotoTimeRange && null !== this._lastGotoTimeRange && (this.gotoTimeRange(this._lastGotoTimeRange.from, this._lastGotoTimeRange.to),
                    this._lastGotoTimeRange = null)
                }
                ));
                const v = this._panes[0];
                v.setStretchFactor(2 * v.stretchFactor()),
                this._properties.listeners().subscribe(this, this.lightUpdate),
                this._properties.childs().timezone.subscribe(null, (()=>{
                    this._chartApi && this._chartApi.isConnected().value() && this._chartApi.switchTimezone(this.timezone())
                }
                )),
                v.addDataSource(this.m_mainSeries, v.findSuitableScale(this.m_mainSeries), !1),
                this._barsMarksSources = r(this);
                for (const e of this._barsMarksSources)
                    e.setOwnerSource(this.m_mainSeries),
                    v.addDataSource(e, this.m_mainSeries.priceScale(), !0);
                this.m_mainSeries.symbolResolved().subscribe(this, this._clearAvailablePriceSources),
                this.m_mainSeries.onSymbolIntervalChanged().subscribe(this, this._onSymbolIntervalChanged),
                this._createLollipopSourcesWatcher(),
                this._watermarkSource = this._options.watermarkEnabled ? new de(this) : null,
                this._timezoneExceptExchange = (0,
                $s.combine)(((e,t)=>"exchange" !== e ? e : t), (0,
                Js.createWVFromProperty)(this._properties.childs().timezone).ownership(), (0,
                Js.createWVFromGetterAndSubscription)((()=>{
                    var e, t;
                    return null !== (t = null === (e = this.mainSeries().symbolInfo()) || void 0 === e ? void 0 : e.timezone) && void 0 !== t ? t : null
                }
                ), this.mainSeries().symbolResolved()).ownership())
            }
            restart() {
                var e, t;
                this._chartApi.switchTimezone(this.timezone()),
                this._timeScale.reset(),
                this.m_mainSeries.restart();
                for (const e of this.dataSources())
                    e.restart && e !== this.m_mainSeries && e.restart();
                null === (t = null === (e = this._sessions) || void 0 === e ? void 0 : e.get()) || void 0 === t || t.restart()
            }
            version() {
                return 3
            }
            collapsed() {
                return this._hibernateWV
            }
            visibleRangeStudiesInputs() {
                return this._visibleRangeStudiesInputs.readonly()
            }
            chartSaveTime() {
                return this._chartSaveTime
            }
            setChartSaveTime(e) {
                this._chartSaveTime = e
            }
            destroy() {
                var e;
                this._phantomSourceContainer.destroy(),
                this._hoveredSourceChanged.destroy(),
                null !== this._watermarkSource && (this._watermarkSource.destroy(),
                this._watermarkSource = null),
                Array.from(this._customSourcesMap.keys()).forEach(this._removeCustomSource, this),
                (0,
                r.assert)(0 === this._topmostCustomSources.length),
                (0,
                r.assert)(0 === this._fgCustomSources.length),
                (0,
                r.assert)(0 === this._bgCustomSources.length),
                (0,
                r.assert)(0 === this._allCustomSources.length),
                (0,
                r.assert)(0 === this._customSourcesMap.size),
                null !== this._lollipopSourcesWatcher && (this._lollipopSourcesWatcher.destroy(),
                this._lollipopSourcesWatcher = null),
                null !== this._alertsWatcher && this._alertsWatcher.destroy(),
                this.onWidget() || di.withWeekdayProperty.unsubscribeAll(this),
                this._properties.childs().paneProperties.childs().background.unsubscribeAll(this),
                this._properties.childs().paneProperties.childs().backgroundType.unsubscribeAll(this),
                this._properties.childs().paneProperties.childs().backgroundGradientEndColor.unsubscribeAll(this),
                this._properties.childs().paneProperties.childs().backgroundGradientStartColor.unsubscribeAll(this),
                this._watchedThemeSpawn.destroy(),
                this._lastHoveredHittestData = null,
                this._lastSelectedHittestData = null,
                (0,
                K.currencyUnitVisibilityProperty)().unsubscribeAll(this),
                (0,
                Y.autoLogButtonsVisibilityProperty)().unsubscribeAll(this),
                this._alertsList && (this._alertsList.destroy(),
                this._alertsList = void 0),
                window.loginStateChange.unsubscribeAll(this),
                this._crossHairSelectPointMode.destroy(),
                this.m_mainSeries.symbolResolved().unsubscribe(this, this._clearAvailablePriceSources),
                this.m_mainSeries.onSymbolIntervalChanged().unsubscribe(this, this._onSymbolIntervalChanged),
                this._timezoneExceptExchange.destroy(),
                null === (e = this._lollipopSourcesWatcherLoader) || void 0 === e || e.destroy(),
                this._destroyed = !0
            }
            undoModel() {
                return this._undoModel
            }
            onData(e) {
                switch (e.method) {
                case "timescale_update":
                    {
                        const t = e.params;
                        this._updateTimeScale({
                            index: t.index,
                            zoffset: t.zoffset,
                            values: t.changes,
                            indexDiffs: t.index_diff,
                            baseIndex: t.baseIndex,
                            marks: t.marks,
                            clearFlag: t.clear
                        });
                        break
                    }
                case "timescale_completed":
                    {
                        const t = Boolean(e.params[0]);
                        this._timeScale.onTimeScaleCompleted(t);
                        break
                    }
                }
            }
            addStrategySource(e, t) {
                1 !== t && -1 === this._strategySources.indexOf(e) && (this._strategySources.push(e),
                this._strategySourcesChange.fire(t),
                this.setActiveStrategySource(e))
            }
            removeStrategySource(e, t) {
                if (1 === t)
                    return;
                const i = this._strategySources.indexOf(e);
                if (-1 !== i) {
                    if (this._strategySources.splice(i, 1)[0] === this._activeStrategySource.value() && this.unsetActiveStrategySource(),
                    this._strategySources.length > 0) {
                        const e = this._strategySources[this._strategySources.length - 1];
                        this.setActiveStrategySource(e)
                    }
                    this._strategySourcesChange.fire(t)
                }
            }
            setActiveStrategySource(e) {
                -1 !== this._strategySources.indexOf(e) && this._activeStrategySource.setValue(e)
            }
            unsetActiveStrategySource() {
                this._activeStrategySource.setValue(null)
            }
            activeStrategySource() {
                return this._activeStrategySource
            }
            strategySources() {
                return this._strategySources
            }
            strategySourcesChange() {
                return this._strategySourcesChange
            }
            replayStudyStrategy() {
                return this._replayStudyStrategy
            }
            setReplayStudyStrategy(e) {
                this._replayStudyStrategy.setValue(e)
            }
            async replayStudyStrategyProperties() {
                if (null === this._replayStudyStrategyInputs) {
                    const e = await (0,
                    pi.getReplayStrategyMetaInfo)();
                    if (null !== this._replayStudyStrategyInputs)
                        return this._replayStudyStrategyInputs;
                    this._replayStudyStrategyInputs = new E.DefaultProperty({
                        defaultName: "replayStudyStrategyInputs",
                        factoryDefaultsSupplier: ()=>(0,
                        ve.clone)(e.defaults.inputs)
                    })
                }
                return this._replayStudyStrategyInputs
            }
            clearReplayStudyStrategyProperties() {
                this._replayStudyStrategyInputs = null
            }
            setScrollEnabled(e) {
                this._scrollEnabled = e
            }
            scrollEnabled() {
                return this._scrollEnabled
            }
            setZoomEnabled(e) {
                this._zoomEnabled = e
            }
            zoomEnabled() {
                return this._zoomEnabled
            }
            zoomToViewport(e, t, i, s, o) {
                this.setTimeViewport(e, t);
                let n = Math.min(i, s)
                  , r = Math.max(i, s);
                const a = o.defaultPriceScale();
                a.isPercentage() || a.setMode({
                    autoScale: !1
                }),
                a.isLog() && (n = a.priceToLogical(n),
                r = a.priceToLogical(r)),
                a.setPriceRange(new ke.PriceRange(n,r)),
                this.recalculateAllPanes((0,
                dt.viewportChangeEvent)()),
                this.invalidate(this._paneInvalidationMask(o, X.InvalidationLevel.Light))
            }
            setTimeViewport(e, t) {
                const i = this.appliedTimeFrame().value();
                null !== this._lastAppliedGotoTimeRange && null !== i && (0,
                Ti.areEqualTimeFrames)(this._lastAppliedGotoTimeRange.range, i.val) && !this._lastAppliedGotoTimeRange.actual || (this.timeScale().zoomToBarsRange(e, t),
                this.recalculateAllPanes((0,
                dt.viewportChangeEvent)()),
                this.recalcVisibleRangeStudies(b.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction),
                this.lightUpdate())
            }
            onTagsChanged() {
                return this._tagsChanged
            }
            canZoomIn() {
                return this._timeScale.canZoomIn() && this._zoomEnabled
            }
            canZoomOut() {
                return this._timeScale.canZoomOut() && this._zoomEnabled
            }
            onPaneTagsChanged() {
                this._tagsChanged.fire()
            }
            panesCollectionChanged() {
                return this._panesCollectionChanged
            }
            dataSourceCollectionChanged() {
                return this._dataSourceCollectionChanged
            }
            symbolSourceCollectionChanged() {
                return this._symbolSourceCollectionChanged
            }
            symbolSourceResolved() {
                return this._symbolSourceResolved
            }
            symbolSourceResolvingActive() {
                return this._symbolSourceResolvingActive
            }
            adjustForDividendsAvailability() {
                return this._adjustForDividendsAvailability
            }
            adjustForDividendsEnabled() {
                return this._adjustForDividendsEnabled
            }
            paneCollapsingAvailable() {
                return this._paneCollapsingAvailable
            }
            sourcePropertiesChanged() {
                return this._sourceProperitesChanged
            }
            sourceZOrderChanged() {
                return this._sourceZOrderChanged
            }
            zoomTime(e, t, i) {
                if (!this._zoomEnabled)
                    return;
                const s = this.timeScale();
                if (s.isEmpty() || 0 === t)
                    return;
                const o = s.width();
                e = Math.max(1, Math.min(e, o - 2)),
                s.zoom(e, t, i),
                this.recalculateAllPanes((0,
                dt.viewportChangeEvent)()),
                this.lightUpdate(),
                this.recalcVisibleRangeStudies(b.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction)
            }
            lineBeingEdited() {
                return this._lineBeingEdited
            }
            linePointBeingEdited() {
                return this._linePointBeingEdited
            }
            activeItemBeingMoved() {
                return this._activeItemBeingMoved
            }
            linePointBeingChanged() {
                return this._linePointBeingChanged
            }
            mainSeries() {
                return this.m_mainSeries
            }
            updateAllPaneViews(e) {
                var t;
                for (const t of this._panes)
                    t.updateAllViews(e);
                null === (t = this._watermarkSource) || void 0 === t || t.updateAllViews(e)
            }
            dataSources() {
                const e = [this.crossHairSource()];
                for (const t of this._panes)
                    for (const i of t.dataSources())
                        e.push(i);
                return e
            }
            priceDataSources() {
                const e = [];
                for (const t of this._panes)
                    for (const i of t.priceDataSources())
                        e.push(i);
                return e
            }
            symbolSources() {
                const e = [];
                for (const t of this._panes)
                    for (const i of t.symbolSources())
                        e.push(i);
                return e
            }
            orderedDataSources(e) {
                let t = [this.m_crossHairSource];
                for (let i = 0; i < this._panes.length; i++) {
                    let s = this._panes[i].sourcesByGroup().all();
                    e && (s = s.slice().reverse()),
                    t = t.concat(s)
                }
                return t
            }
            timeScale() {
                return this._timeScale
            }
            selection() {
                return this._selection
            }
            selectionMacro(e, t=!1) {
                const i = this.selection().allSources();
                e({
                    removeSourceFromSelection: this._removeSourceFromSelection,
                    addSourceToSelection: this._addSourceToSelection,
                    clearSelection: this._clearSelection,
                    selection: this.selection.bind(this)
                });
                const s = (0,
                C.subtract)(i, this.selection().allSources())
                  , o = (0,
                C.subtract)(this.selection().allSources(), i);
                o.concat(i).forEach((e=>e.updateAllViews((0,
                dt.selectionChangeEvent)())));
                let n = [];
                if (s.forEach((e=>{
                    if ((0,
                    T.isLineTool)(e)) {
                        const i = e.hasAlert().value() && e.getAlertSync();
                        i && !i.isPrice() && i.setSelected(!1),
                        !t && e.shouldBeRemovedOnDeselect() && n.push(e)
                    }
                }
                )),
                o.forEach((e=>{
                    const t = (0,
                    T.isLineTool)(e) && e.hasAlert && e.hasAlert().value() && e.getAlertSync();
                    t && t.setSelected(!0)
                }
                )),
                1 === o.length) {
                    const [e] = o;
                    (0,
                    T.isLineTool)(e) && e.hasAlert().value() && 0 === e.alertStatus().value() && e.synchronizeAlert().catch((()=>{}
                    ))
                }
                n = n.filter((e=>null !== this.dataSourceForId(e.id()))),
                n.length > 0 && this._undoModel.removeSources(n, !1, Qs),
                this.lightUpdate(),
                (s.length > 0 || o.length > 0) && this._selectedSourceChanged.fire()
            }
            onSelectedSourceChanged() {
                return this._selectedSourceChanged
            }
            checkLineToolSelection() {
                const e = this.selection().allSources();
                this._selection.checkLineToolSelection(),
                e.length !== this.selection().allSources().length && this._selectedSourceChanged.fire()
            }
            lineToolsGroupModel() {
                return this._lineToolsGroupModel
            }
            restoreLineToolsGroups(e) {
                this._lineToolsGroupModel = Kt.fromState(this, e)
            }
            realignLineTools(e) {
                for (const t of this._panes)
                    (void 0 === e || t.hasDataSource(e)) && t.realignLineTools(e) && this._dataSourceCollectionChanged.fire(t)
            }
            copyToOtherCharts(e, t) {
                const i = this.mainSeries()
                  , s = i.syncModel()
                  , o = this.timeScale();
                if (s)
                    for (const n of e) {
                        if (!n.isSynchronizable())
                            continue;
                        const e = n.linkKey().value() || (0,
                        pe.randomHash)();
                        n.linkKey().setValue(e);
                        const a = n.state(!1)
                          , l = n.normalizedPoints()
                          , c = n.normalizedPointsForCreating()
                          , d = n.properties().interval.value()
                          , u = i.interval()
                          , h = e=>{
                            if (L.Interval.isEqual(d, u))
                                return e.map((e=>{
                                    const t = (0,
                                    r.ensureNotNull)(o.timePointToIndex(e.time_t)) + e.offset;
                                    return {
                                        price: e.price,
                                        timeStamp: (0,
                                        r.ensureNotNull)(this.externalTimeStamp(t))
                                    }
                                }
                                ));
                            {
                                const t = s.createNewModelWithResolution(d);
                                return e.map((e=>({
                                    price: e.price,
                                    timeStamp: 0 === e.offset ? e.time_t : t.projectTime(e.time_t, e.offset)
                                })))
                            }
                        }
                          , p = h(l)
                          , m = h(c)
                          , g = {
                            ...a,
                            id: n.id(),
                            linkKey: e,
                            points: p,
                            pointsForCreating: m,
                            linetool: n.toolname,
                            model: this,
                            symbol: i.symbol(),
                            withUndo: t,
                            zOrder: n.zorder(),
                            finalState: {
                                points: l,
                                interval: d
                            },
                            pointPositionPercents: n.isFixed() ? n.calcPositionPercents() : void 0,
                            sharingMode: n.sharingMode().value()
                        };
                        (0,
                        Ge.copyLineTool)(g)
                    }
            }
            isSnapshot() {
                return this._isSnapshot
            }
            onWidget() {
                return this._options.onWidget
            }
            hideIdeas() {
                return this._options.hideIdeas
            }
            updateSource(e) {
                const t = this._invalidationMaskForSource(e);
                null !== t && this.invalidate(t)
            }
            updateSourcePriceScale(e) {
                const t = this._invalidationMaskForSourcePriceScale(e);
                null !== t && this.invalidate(t)
            }
            updatePane(e) {
                this.invalidate(this._paneInvalidationMask(e))
            }
            updateTimeScaleBaseIndex(e) {
                const t = this.mainSeries().bars();
                t.isEmpty() || this._updateBaseIndex((0,
                r.ensureNotNull)(t.lastIndex()), !!(e && e.index > 0))
            }
            setInterval(e, t) {
                const i = setInterval(e, t);
                return this._modelIntervals.push(i),
                i
            }
            clearInterval(e) {
                clearInterval(e);
                const t = this._modelIntervals.indexOf(e);
                t > -1 && this._modelIntervals.splice(t, 1)
            }
            clearIntervals() {
                for (let e = 0; e < this._modelIntervals.length; e++)
                    clearInterval(this._modelIntervals[e]);
                this._modelIntervals = []
            }
            createStudyInserter(e) {
                const t = {
                    createStudy: (e,t,i,s,o,n,r,a,l,c,d,u,h)=>this.insertStudyWithParams(e, t, i, o, n, r, a, l, c, d, u, h),
                    storeFailedStub: e=>{}
                };
                return new Ys.StudyInserter(e,t)
            }
            insertStudyWithParams(e, t, i, s, o, a, l, c, d, u, h, p) {
                var m;
                let g = null;
                if (!o && void 0 !== e.groupingKey) {
                    const t = this.findNonOverlayStudyWithGroupingKey(e.groupingKey);
                    null !== t && (g = t.pane)
                }
                null === g && (o || e.is_price_study ? g = (0,
                r.ensureNotNull)(this.paneForSource(null !== (m = null == a ? void 0 : a[0]) && void 0 !== m ? m : this.m_mainSeries)) : (g = this.createPane(),
                void 0 !== u && g.setPaneSize(u))),
                "Compare@tv-basicstudies" === e.id && this.m_mainSeries.priceScale().setMode({
                    log: !1,
                    percentage: !0
                });
                const v = (0,
                ve.merge)((0,
                n.default)(null != s ? s : {}), {
                    inputs: t,
                    parentSources: []
                });
                let S = !1
                  , f = null
                  , y = null;
                const C = null != a ? a : []
                  , w = (0,
                A.prepareStudyProperties)(e, v, g, (0,
                O.studyMetaInfoRepository)().studyVersioning(), C)
                  , T = (0,
                U.createStudy)(this, w, C, e, p)
                  , P = (0,
                _.createDeferredPromise)();
                return T.then((e=>{
                    var t, s, o;
                    if (S)
                        return e.stop(),
                        void (null === (t = e.destroy) || void 0 === t || t.call(e));
                    f = e.id();
                    const n = g.findSuitableScale(e, null !== (s = null == a ? void 0 : a[0]) && void 0 !== s ? s : this.mainSeries(), l);
                    if (y = n.mode(),
                    n === this.mainSeries().priceScale() && (0,
                    Be.isSymbolSource)(e)) {
                        const t = c ? (0,
                        Xs.sourceNewCurrencyOnPinningToPriceScale)(e, n, this, !0) : null
                          , i = d ? (0,
                        Re.sourceNewUnitOnPinningToPriceScale)(e, n, this, !0) : null;
                        null === t && null === i || e.setSymbolParams({
                            currency: t || void 0,
                            unit: i || void 0
                        })
                    }
                    if ((0,
                    Be.isSymbolSource)(e) && (0,
                    r.ensureNotNull)(g).hasDataSource(this.mainSeries()) && eo && !$.getBool("enable_symbol_labels_on_inserting_compare_once", !1) && ((0,
                    E.allowSavingDefaults)(!0),
                    this.properties().childs().scalesProperties.childs().showSymbolLabels.setValue(!0),
                    (0,
                    E.allowSavingDefaults)(!1),
                    $.setValue("enable_symbol_labels_on_inserting_compare_once", !0)),
                    P.resolve(e.start()),
                    i && g.id() === i.paneId)
                        g.insertDataSource(e, n, i.zorder);
                    else {
                        g.addDataSource(e, n, !1);
                        null !== e.preferredZOrder() && g.insertAfter([e], this.mainSeries())
                    }
                    void 0 !== h && n.setMode(h),
                    e.isLinkedToSeries() && e.setOwnerSource(this.mainSeries()),
                    this.recalculatePane(g, (0,
                    dt.sourceChangeEvent)(e.id())),
                    this.fullUpdate(),
                    this._invalidateBarColorerCaches(),
                    this._recalcVisibleRangeStudiesImpl({
                        studies: [e],
                        reasons: new Set([b.RecalcVisibleRangeStudiesReason.StudyCreation])
                    }),
                    this._recalcColorStudiesImpl({
                        studies: [e],
                        force: !0
                    }),
                    this._studyInserted.fire(e),
                    null === (o = this.alertsWatcher()) || void 0 === o || o.syncSourceAlertLabels(e),
                    e.maxOffset().subscribe(this._boundUpdateStudiesMaxOffset, {
                        callWithLast: !0
                    })
                }
                )),
                {
                    study: T,
                    startPromise: P.promise,
                    cancel: ()=>S = !0,
                    entityId: ()=>f,
                    originalScaleMode: ()=>y
                }
            }
            replaceStudyStub(e, t) {
                const i = this.paneForSource(e);
                if (null === i)
                    return !1;
                const s = e.priceScale()
                  , o = e.zorder()
                  , n = e.ownerSource();
                return this.paneForSource(e) === i ? i.replaceSource(e, t, s) : (i.insertDataSource(t, s, o),
                this.removeSource(e)),
                t.setOwnerSource(n),
                this.dataSources().forEach((i=>{
                    i.ownerSource() === e && i.setOwnerSource(t)
                }
                )),
                this._invalidateBarColorerCaches(),
                t.start(),
                this.recalculatePane(i, (0,
                dt.sourceChangeEvent)(t.id())),
                this.fullUpdate(),
                !0
            }
            insertStudyStub(e, t, i, s) {
                const o = void 0 !== t
                  , n = new I.StudyStub(this,null != i ? i : null,e,o,null != s ? s : null);
                let a;
                if (t || !o) {
                    a = (0,
                    r.ensureNotNull)(this.mainPane());
                    const e = !0 === t ? this.mainSeries().priceScale() : a.createPriceScaleAtPosition("overlay");
                    a.addDataSource(n, e, !1)
                } else
                    a = this.createPane(),
                    a.addDataSource(n, null, !1);
                return n.setZorder(a.newStudyZOrder()),
                this.recalculatePane(a, (0,
                dt.sourceChangeEvent)(n.id())),
                this.fullUpdate(),
                n
            }
            removeStudyStub(e) {
                const t = this.dataSourceForId(e);
                return null === t ? (to.logNormal("StudyStub id=" + e + " is not found in chart model"),
                !1) : (this.removeSource(t),
                !0)
            }
            restoreStudyStub(e) {
                var t;
                const i = this.insertStudyStub(e.title, e.isOverlay, e.descriptor);
                return null === (t = this.paneForSource(i)) || void 0 === t || t.changeSourceId(i, e.id),
                i.setStatus(e.status),
                i
            }
            allLineTools() {
                return this._getAllSources(T.isLineTool)
            }
            setHoveredSource(e, t=null, i) {
                const s = this._hoveredSource !== e;
                if (this._hoveredSourceOrigin = null != i ? i : null,
                !s && (0,
                mi.hitTestResultDataAreEqual)(this._lastHoveredHittestData, t))
                    return;
                this._lastHoveredHittestData = t;
                let o = null;
                if (this._hoveredSource) {
                    this._hoveredSource.updateAllViews((0,
                    dt.selectionChangeEvent)()),
                    o = new X.InvalidationMask(X.InvalidationLevel.Cursor);
                    const e = this._invalidationMaskForSource(this._hoveredSource, X.InvalidationLevel.Light);
                    null !== e && o.merge(e)
                }
                if (this._hoveredSource = e,
                e) {
                    e.updateAllViews((0,
                    dt.selectionChangeEvent)()),
                    o || (o = new X.InvalidationMask(X.InvalidationLevel.Cursor));
                    const t = this._invalidationMaskForSource(e, X.InvalidationLevel.Light);
                    null !== t && o.merge(t)
                }
                o && this.invalidate(o),
                s && this._hoveredSourceChanged.fire(e)
            }
            properties() {
                return this._properties
            }
            chartApi() {
                return this._chartApi
            }
            disconnect() {
                var e, t;
                null === (t = null === (e = this._sessions) || void 0 === e ? void 0 : e.get()) || void 0 === t || t.stop();
                for (const e of this.dataSources())
                    e.disconnect && e.disconnect();
                this._timeScale.disconnect()
            }
            crossHairSource() {
                return this.m_crossHairSource
            }
            gridSource() {
                return this._gridSource
            }
            publishedChartsTimelineSource() {
                for (const e of this._barsMarksSources)
                    if (e instanceof ui.PublishedChartsTimeline)
                        return e;
                return null
            }
            hoveredSource() {
                return this._hoveredSource
            }
            hoveredSourceOrigin() {
                return this._hoveredSourceOrigin
            }
            hoveredSourceChanged() {
                return this._hoveredSourceChanged
            }
            lastHittestData() {
                return this._lastHoveredHittestData
            }
            lastSelectedHittestData() {
                return this._lastSelectedHittestData
            }
            lightUpdate() {
                this.invalidate(X.InvalidationMask.light())
            }
            fullUpdate() {
                this.invalidate(X.InvalidationMask.full())
            }
            syncTimeWithModel(e, t) {
                const i = this.mainSeries().syncModel();
                if (null === i)
                    return;
                const s = 1e3 * this.createSyncPoint(e, i.syncSourceTarget()).sourceTimeToTargetTime(t / 1e3)
                  , o = (0,
                Yt.get_timezone)(this.timezone());
                let n = (0,
                Yt.utc_to_cal)(o, s);
                this.mainSeries().isDWM() && (n = i.getSession().spec.correctTradingDay(n),
                (0,
                Yt.set_hms)(n, 0, 0, 0, 0, (0,
                Yt.get_timezone)("Etc/UTC"))),
                this._gotoTimeImpl(n.getTime(), {
                    centerIfVisible: !1
                })
            }
            gotoTime(e) {
                return this._gotoTimeImpl(e, {
                    centerIfVisible: !0
                })
            }
            recalculatePane(e, t) {
                null == e || e.recalculate(t)
            }
            recalculateAllPanes(e) {
                this._panes.forEach((t=>t.recalculate(e))),
                this.updateAllPaneViews(e),
                this.crossHairSource().updateAllViews(e)
            }
            gotoTimeRange(e, t) {
                const i = this.timeScale()
                  , s = i.tickMarks()
                  , o = this.mainSeries();
                if (void 0 === s.minIndex)
                    return void (this._lastGotoTimeRange = {
                        from: e,
                        to: t
                    });
                let n = e
                  , a = t;
                if (null !== o.symbolInfo()) {
                    const i = (0,
                    r.ensureNotNull)(this.timezoneExceptExchange().value())
                      , s = (0,
                    Yt.get_timezone)(i)
                      , l = (0,
                    Yt.utc_to_cal)(s, e)
                      , c = (0,
                    Yt.utc_to_cal)(s, t);
                    if (o.isDWM()) {
                        const e = (0,
                        Yt.get_timezone)("Etc/UTC");
                        (0,
                        Yt.set_hms)(l, 0, 0, 0, 0, e),
                        (0,
                        Yt.set_hms)(c, 0, 0, 0, 0, e)
                    }
                    n = l.getTime(),
                    a = c.getTime()
                }
                const l = (0,
                r.ensureDefined)(s.maxIndex)
                  , c = (0,
                r.ensureDefined)(s.minIndex);
                if (n >= (0,
                r.ensureNotNull)(s.indexToTime(c)).valueOf() || o.endOfData()) {
                    const e = (e,t)=>e < t
                      , t = e=>(0,
                    r.ensureNotNull)(s.indexToTime(e)).valueOf()
                      , d = (0,
                    C.lowerboundExt)(t, n, e, s.nearestIndex(n), l);
                    let u = n === a ? d : (0,
                    C.lowerboundExt)(t, a, e, s.nearestIndex(a), l);
                    this._lastGotoTimeRange = null,
                    null !== this._lastAppliedGotoTimeRange && (this._lastAppliedGotoTimeRange.actual = !1);
                    const h = i.baseIndex();
                    if (d + Math.max(u - d + 1, i.minVisibleBarCount()) > h) {
                        const e = i.targetDefaultRightOffset();
                        u - h < e && (u = h + e)
                    }
                    const p = d === u && d === c && o.endOfData() ? d - 1 : d;
                    i.zoomToBarsRange(p, u),
                    this.lightUpdate()
                } else {
                    const i = {
                        type: "time-range",
                        from: e / 1e3,
                        to: t / 1e3
                    };
                    null === this._lastAppliedGotoTimeRange ? (this._lastAppliedGotoTimeRange = {
                        range: i,
                        actual: !0
                    },
                    o.loadDataTo(i)) : (0,
                    Ti.areEqualTimeFrames)(this._lastAppliedGotoTimeRange.range, i) || (this._lastGotoTimeRange = {
                        from: e,
                        to: t
                    })
                }
            }
            paneForSource(e) {
                if (!(0,
                y.isDataSource)(e))
                    return Array.from(this._customSourcesMap.values()).includes(e) ? this.paneForSource(this.mainSeries()) : null;
                for (let t = this._panes.length - 1; t >= 0; t--)
                    if (this._panes[t].hasDataSource(e))
                        return this._panes[t];
                return e instanceof vi.BarsMarksContainer ? this.paneForSource(this.mainSeries()) : null
            }
            mainPane() {
                var e;
                return null !== (e = this._panes.find((e=>e.isMainPane()))) && void 0 !== e ? e : null
            }
            lastPane() {
                return this._panes[this._panes.length - 1]
            }
            removeSource(e, t) {
                this.selectionMacro((t=>t.removeSourceFromSelection(e)), !0),
                this._hoveredSource === e && (this._hoveredSource = null,
                this._lastHoveredHittestData = null),
                this._sourcesBeingMoved.includes(e) && (this._sourcesBeingMoved = this._sourcesBeingMoved.filter((t=>t !== e)),
                this._sourcesBeingMoved.length || (this._activeItemBeingMoved = null)),
                e === this._lineBeingEdited && (this._lineBeingEdited = null,
                Ge.isToolEditingNow.setValue(!1)),
                e === this.lineBeingCreated() && (this._lineBeingCreated = null,
                Ge.isToolCreatingNow.setValue(!1)),
                !t && e.stop && e.stop();
                (0,
                r.ensureNotNull)(this.alertsWatcher()).removeSourceAlertLabels(e);
                const i = this.detachSource(e)
                  , s = this.mainSeries().priceScale();
                return (0,
                U.isStudy)(e) && (0,
                Be.isActingAsSymbolSource)(e) && e.priceScale() === s && s.isPercentage() && 1 === s.seriesLikeSources().filter(Be.isActingAsSymbolSource).length && s.setMode({
                    percentage: !1
                }),
                this.fullUpdate(),
                this._invalidateBarColorerCaches(),
                (0,
                U.isStudy)(e) && ((0,
                v.emit)("study_event", e.id(), "remove"),
                e.isChildStudy() && e.parentSources().forEach((t=>t.unsetChild(e))),
                e.maxOffset().unsubscribe(this._boundUpdateStudiesMaxOffset)),
                !t && e.destroy && e.destroy(),
                (0,
                T.isLineTool)(e) && (e.removeAlert(),
                (0,
                v.emit)("drawing_event", e.id(), "remove")),
                i
            }
            timezone() {
                return this._properties.childs().timezone.value()
            }
            timezoneExceptExchange() {
                return this._timezoneExceptExchange
            }
            allStudies(e) {
                const t = e ? e=>(0,
                U.isStudy)(e) && !(0,
                ye.isLollipopDataSource)(e) : U.isStudy;
                return this._getAllSources(t)
            }
            studiesWV(e) {
                return e ? this._studiesExcludeInternalWV.readonly() : this._studiesWV.readonly()
            }
            listUserStudies(e) {
                const t = [];
                for (const i of this._panes)
                    for (const s of i.priceDataSources())
                        if (!(0,
                        U.isFundamentalStudy)(s) && (0,
                        U.isStudy)(s) && s.showInObjectTree()) {
                            const {id: i, shortDescription: o} = s.metaInfo();
                            if (e.dontCountVolume && "Volume@tv-basicstudies" === i || e.dontCountCompare && "Compare@tv-basicstudies" === i || e.dontCountOverlay && "Overlay@tv-basicstudies" === i)
                                continue;
                            t.push(o)
                        }
                return t
            }
            findNonOverlayStudyWithGroupingKey(e, t) {
                const i = void 0 !== t ? [t] : this._panes;
                for (const t of i) {
                    const i = t.dataSources().find((i=>(0,
                    U.isStudy)(i) && i.metaInfo().groupingKey === e && !t.isOverlay(i)));
                    if (void 0 !== i)
                        return {
                            pane: t,
                            study: i
                        }
                }
                return null
            }
            movePaneUp(e) {
                this.movePane(e, e - 1)
            }
            movePaneDown(e) {
                this.movePane(e, e + 1)
            }
            movePane(e, t) {
                const i = this._panes[e];
                this._panes.splice(e, 1),
                this._panes.splice(t, 0, i),
                this._panesCollectionChanged.fire(this._panes),
                this._onRearrangePanes.fire(),
                this.invalidate(X.InvalidationMask.panesOrder())
            }
            toggleCollapsedPane(e) {
                const t = this._panes[e];
                t.collapsed().setValue(!t.collapsed().value()),
                this.fullUpdate()
            }
            backgroundColor() {
                return this._backgroundColor
            }
            backgroundTopColor() {
                return this._backgroundTopColor
            }
            backgroundColorAtYPercentFromTop(e) {
                const t = this.backgroundColor().value()
                  , i = this.backgroundTopColor().value();
                if (t === i)
                    return t;
                if (e = Math.max(0, Math.min(100, Math.round(100 * e))),
                null === this._gradientColorsCache || this._gradientColorsCache.topColor !== i || this._gradientColorsCache.bottomColor !== t)
                    this._gradientColorsCache = {
                        topColor: i,
                        bottomColor: t,
                        colors: new Map
                    };
                else {
                    const t = this._gradientColorsCache.colors.get(e);
                    if (void 0 !== t)
                        return t
                }
                const s = (0,
                _i.gradientColorAtPercent)(i, t, e / 100);
                return this._gradientColorsCache.colors.set(e, s),
                s
            }
            backgroundCounterColor() {
                return this._backgroundCounterColor.readonly()
            }
            dark() {
                return this._isDark
            }
            readOnly() {
                return this._readOnly
            }
            defaultResolutions() {
                return this.chartApi().defaultResolutions()
            }
            availableCurrencies() {
                const e = this._getAvailableCurrencies();
                return e.length !== this._availableCurrencies.size() && (this._availableCurrencies = new bi(e)),
                this._availableCurrencies
            }
            currencyConversionEnabled() {
                return this._options.currencyConversionEnabled
            }
            availableUnits() {
                const e = this._getAvailableUnits();
                return this._availableUnits.unitsChanged(e) && (this._availableUnits = new yi(e)),
                this._availableUnits
            }
            unitConversionEnabled() {
                return this._options.unitConversionEnabled
            }
            availablePriceSources(e) {
                const t = this._getAvailablePriceSources(e);
                return null !== t && this._availablePriceSources.priceSourcesChanged(t) && (this._availablePriceSources = new Zs(t)),
                this._availablePriceSources
            }
            resetDeferredStudies() {
                it.DeferredStudies.instance(this).reset()
            }
            waitForStudy(e) {
                const t = this.dataSourceForId(e);
                return t && (0,
                U.isStudy)(t) ? Promise.resolve(t) : it.DeferredStudies.instance(this).get(e)
            }
            resetWaitForStudy(e) {
                it.DeferredStudies.instance(this).delete(e)
            }
            isJustClonedChart() {
                return this._undoModel.isJustClonedChart()
            }
            studyTemplate(e, t, i) {
                const s = {
                    panes: [],
                    version: this.version()
                };
                for (const e of this.panes())
                    s.panes.push(e.state(!0, !1, !0));
                const o = this.mainSeries();
                return e && (s.symbol = o.symbol(),
                this.currencyConversionEnabled() && i && (s.currency = o.currency()),
                this.unitConversionEnabled() && i && (s.unit = o.unit())),
                t && (s.interval = o.interval()),
                s
            }
            getStudyById(e) {
                const t = this.dataSourceForId(e);
                return null !== t && (0,
                U.isStudy)(t) ? t : null
            }
            getLineToolById(e) {
                const t = this.dataSourceForId(e);
                return null !== t && (0,
                T.isLineTool)(t) ? t : null
            }
            restoreLineToolState(e, t, i) {
                var s;
                e.restorePoints(t.points, t.indexes || []),
                t.state.intervalsVisibilities = (0,
                ot.mergeIntervalVisibilitiesDefaults)(t.state.intervalsVisibilities),
                e.properties().merge(t.state),
                e.restoreData && e.restoreData(t),
                e.linkKey().setValue(t.linkKey || null),
                e.createServerPoints(),
                e.setZorder(null !== (s = t.zorder) && void 0 !== s ? s : e.zorder()),
                this.fullUpdate();
                const o = e.linkKey().value();
                null !== o && i && (0,
                Ge.restoreLineToolState)({
                    model: this,
                    linkKey: o,
                    state: t
                })
            }
            restoreFactoryDefaults(e) {
                e.restoreFactoryDefaults(),
                this.recalcVisibleRangeStudies(b.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction)
            }
            preferences() {
                return (0,
                Gs.preferencesByWhiteList)(this, this.mainSeries())
            }
            applyPreferences(e) {
                for (const [t,i] of Object.entries(e)) {
                    const e = this._properties.child(t);
                    void 0 !== i && void 0 !== e && e.mergeAndFire(i)
                }
                if (void 0 !== e.timeScale) {
                    const t = e.timeScale;
                    this._timeScale.defaultRightOffset().setValue(t.defaultRightOffset),
                    this._timeScale.defaultRightOffsetPercentage().setValue(t.defaultRightOffsetPercentage),
                    this._timeScale.usePercentageRightOffset().setValue(t.usePercentageRightOffset)
                }
                this._properties.saveDefaults(),
                this.m_mainSeries.applyPreferences(e.mainSeries),
                this.sessions().restoreState({
                    properties: e.sessions
                }, !1),
                this.recalculateAllPanes((0,
                dt.globalChangeEvent)()),
                this.fullUpdate()
            }
            restoreTheme(e, t, i) {
                e.mainSourceProperties.hollowCandleStyle || (e.mainSourceProperties.hollowCandleStyle = e.mainSourceProperties.candleStyle),
                this._undoModel.chartLoadTheme(e, t, i)
            }
            onResetScales() {
                return this._resetScales
            }
            startMovingSources(e, t, i, s, o, n) {
                this._sourcesBeingMoved = e,
                this._activeItemBeingMoved = i;
                let a = !1;
                if (this._sourcesBeingMoved.forEach((e=>{
                    !a && (0,
                    U.isStudy)(e) && (a = !0);
                    const l = (0,
                    r.ensureNotNull)(this.paneForSource(e))
                      , c = (0,
                    T.isLineTool)(e)
                      , d = c && e.linkKey().value();
                    if (!1 !== d && null !== d && s.has(d) && c && e.isFixed()) {
                        const t = (0,
                        r.ensureDefined)(s.get(d))
                          , a = {
                            screen: this._percentPositionToPoint(t, l)
                        };
                        e.startMoving(a, i, o, n)
                    } else
                        e.startMoving(t, i, o, n);
                    const u = this._paneInvalidationMask(l, X.InvalidationLevel.Light);
                    this.invalidate(u)
                }
                )),
                !n) {
                    const s = e.filter(T.isLineTool).filter((e=>e.linkKey().value() && e.isSynchronizable())).map((e=>e.linkKey().value()));
                    if (s.length && t.logical) {
                        const n = this.externalTimeStamp(t.logical.index)
                          , a = {
                            linkKeys: s,
                            model: this,
                            symbol: this.mainSeries().symbol(),
                            point: {
                                price: t.logical.price,
                                timeStamp: n
                            },
                            activeItem: null !== i ? i : void 0,
                            envState: o,
                            pointPositionPercents: new Map
                        };
                        e.forEach((e=>{
                            if ((0,
                            T.isLineTool)(e)) {
                                const i = e.linkKey().value();
                                if (i && e.isSynchronizable() && e.isFixed()) {
                                    const s = (0,
                                    r.ensureNotNull)(this.paneForSource(e));
                                    a.pointPositionPercents.set(i, this._pointToPercentPosition((0,
                                    r.ensureDefined)(t.screen), s))
                                }
                            }
                        }
                        )),
                        (0,
                        Ge.startMovingLineTool)(a)
                    }
                }
                Ge.isToolMovingNow.setValue(!0),
                a && Ge.isStudyEditingNow.setValue(!0)
            }
            moveSources(e, t, i, s) {
                if (this._sourcesBeingMoved.filter((e=>!e.isLocked || !e.isLocked())).forEach((o=>{
                    const n = (0,
                    T.isLineTool)(o) ? o.linkKey().value() : null;
                    if (null !== n && t.has(n)) {
                        const e = (0,
                        r.ensureNotNull)(this.paneForSource(o))
                          , a = (0,
                        r.ensureDefined)(t.get(n))
                          , l = {
                            screen: this._percentPositionToPoint(a, e)
                        };
                        o.move(l, this._activeItemBeingMoved, i, s)
                    } else
                        o.move(e, this._activeItemBeingMoved, i, s)
                }
                )),
                this.lightUpdate(),
                !s && e.logical) {
                    const t = this._sourcesBeingMoved.filter(T.isLineTool).filter((e=>e.isSynchronizable() && !!e.linkKey().value())).map((e=>e.linkKey().value()))
                      , s = this.externalTimeStamp(e.logical.index)
                      , o = {
                        linkKeys: t,
                        model: this,
                        point: {
                            price: e.logical.price,
                            timeStamp: s
                        },
                        envState: i,
                        pointPositionPercents: new Map
                    };
                    this._sourcesBeingMoved.filter(T.isLineTool).forEach((t=>{
                        if (t.linkKey().value() && t.isSynchronizable() && t.isFixed()) {
                            const i = (0,
                            r.ensureNotNull)(this.paneForSource(t));
                            o.pointPositionPercents.set(t.linkKey().value(), this._pointToPercentPosition((0,
                            r.ensureDefined)(e.screen), i))
                        }
                    }
                    )),
                    (0,
                    Ge.moveLineTool)(o)
                }
            }
            endMovingSources(e, t, i) {
                const s = this._sourcesBeingMoved.map((s=>{
                    const o = (0,
                    r.ensureNotNull)(this.paneForSource(s))
                      , n = s.endMoving(e, t, i)
                      , a = this._paneInvalidationMask(o, X.InvalidationLevel.Light);
                    return a.invalidateAll(X.InvalidationLevel.Light),
                    this.invalidate(a),
                    n
                }
                ))
                  , o = this._sourcesBeingMoved.filter(T.isLineTool).filter((e=>e.isSynchronizable() && !!e.linkKey().value())).map((e=>e.linkKey().value()))
                  , n = this._sourcesBeingMoved.filter(T.isLineTool).filter((e=>e.isSynchronizable() && !!e.linkKey)).map((e=>{
                    const t = {
                        points: e.normalizedPoints(),
                        interval: this.mainSeries().interval()
                    };
                    return e.isFixed() && (t.pointPositionPercents = e.calcPositionPercents()),
                    t
                }
                ));
                o.length && (0,
                Ge.finishMovingLineTool)({
                    linkKeys: o,
                    model: this,
                    finalStates: n,
                    changes: s
                }),
                this._sourcesBeingMoved = [],
                this._activeItemBeingMoved = null,
                Ge.isToolMovingNow.setValue(!1),
                Ge.isStudyEditingNow.setValue(!1)
            }
            sourcesBeingMoved() {
                return this._sourcesBeingMoved
            }
            setMovingCustomSource(e, t) {
                this._customSourceBeingMoved = e,
                this._customSourceBeingMovedHitTestData = null !== t ? {
                    beingMoved: !1,
                    cancelled: !1,
                    ...t
                } : null
            }
            processingCustomSourceMove() {
                null !== this._customSourceBeingMovedHitTestData && (this._customSourceBeingMovedHitTestData.beingMoved = !0)
            }
            customSourceMovingHitTestData() {
                return this._customSourceBeingMovedHitTestData
            }
            customSourceBeingMoved() {
                return null !== this._customSourceBeingMovedHitTestData && this._customSourceBeingMovedHitTestData.beingMoved ? this._customSourceBeingMoved : null
            }
            lineToolsSynchronizer() {
                return this._lineToolsSynchronizer
            }
            setLineToolsSynchronizer(e) {
                this._lineToolsSynchronizer = e
            }
            width() {
                return this._width
            }
            setWidth(e, t) {
                (this._panes.reduce(((t,i)=>i.setWidth(e) || t), !1) || this._width !== e) && (this._width = e,
                this._timeScale.setWidth(e, t),
                this.recalculateAllPanes((0,
                dt.viewportChangeEvent)()),
                this.recalcVisibleRangeStudies(b.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction))
            }
            setPaneHeight(e, t) {
                e.setHeight(t),
                this.recalculateAllPanes((0,
                dt.viewportChangeEvent)()),
                this.lightUpdate()
            }
            resetScalesAvailable() {
                return this._resetScalesAvailable.readonly()
            }
            panes() {
                return this._panes
            }
            paneForId(e) {
                return this._panes.find((t=>t.id() === e)) || null
            }
            createPane(e, t, i) {
                this._undoModel.hideMaximizedPaneIfRequired();
                const s = this._properties.childs().paneProperties;
                t && s.merge(t);
                const o = new _t(this._timeScale,s,this,i);
                return void 0 !== e ? this._panes.splice(e, 0, o) : this._panes.push(o),
                o.onTagsChanged().subscribe(this, lo.prototype.onPaneTagsChanged),
                o.dataSourcesCollectionChanged().subscribe(this, (()=>this._dataSourceCollectionChanged.fire(o))),
                o.symbolSourceCollectionChanged().subscribe(this, (()=>this._onSymbolSourceCollectionChanged(o))),
                o.priceSourcesCollectionChanged().subscribe(this, (()=>this._onPriceSourcesCollectionChanged(o))),
                o.sourcePropertiesChanged().subscribe(this, (e=>this._sourceProperitesChanged.fire(o, e))),
                o.sourceZOrderChanged().subscribe(this, (e=>this._sourceZOrderChanged.fire(o, e))),
                o.symbolSourceResolved().subscribe(this, (e=>this._symbolSourceResolved.fire(o, e))),
                o.symbolSourceResolvingActive().subscribe(this._recalcSymbolResolvingActive),
                o.collapsed().subscribe(this._recalcPaneCollapsingAvailable),
                o.resetPriceScalesAvailable().subscribe(this._updateResetScalesAvailableValue, {
                    callWithLast: !0
                }),
                this._recalcPaneCollapsingAvailable(),
                this._panesCollectionChanged.fire(this._panes),
                this.invalidate(X.InvalidationMask.panesOrder()),
                o
            }
            removePane(e) {
                this._undoModel.hideMaximizedPaneIfRequired();
                const t = e;
                t.destroy();
                const i = this._panes.indexOf(t);
                -1 !== i && (this._panes.splice(i, 1),
                e.dataSourcesCollectionChanged().unsubscribeAll(this),
                e.symbolSourceCollectionChanged().unsubscribeAll(this),
                e.priceSourcesCollectionChanged().unsubscribeAll(this),
                e.sourcePropertiesChanged().unsubscribeAll(this),
                e.onTagsChanged().unsubscribeAll(this),
                e.symbolSourceResolved().unsubscribeAll(this),
                t.symbolSourceResolvingActive().unsubscribe(this._recalcSymbolResolvingActive),
                e.collapsed().unsubscribe(this._recalcPaneCollapsingAvailable),
                e.resetPriceScalesAvailable().unsubscribe(this._updateResetScalesAvailableValue),
                this._recalcPaneCollapsingAvailable(!0)),
                this._updateResetScalesAvailableValue();
                this.crossHairSource().pane === e && this.clearCurrentPosition(),
                this._panesCollectionChanged.fire(this._panes),
                this.invalidate(X.InvalidationMask.panesOrder())
            }
            changePanesHeight(e, t) {
                if (this._panes.length < 2)
                    return;
                (0,
                r.assert)(e >= 0 && e < this._panes.length, "Invalid pane index");
                const i = this._panes[e]
                  , s = this._panes.reduce(((e,t)=>e + t.stretchFactor()), 0)
                  , o = this._panes.reduce(((e,t)=>e + t.height()), 0)
                  , n = o - 30 * (this._panes.length - 1);
                t = Math.min(n, Math.max(30, t));
                const a = s / o
                  , l = i.height();
                i.setStretchFactor(t * a);
                let c = t - l
                  , d = this._panes.length - 1;
                for (const e of this._panes)
                    if (e !== i) {
                        const t = Math.min(n, Math.max(30, e.height() - c / d));
                        c -= e.height() - t,
                        d -= 1;
                        const i = t * a;
                        e.setStretchFactor(i)
                    }
                this.fullUpdate()
            }
            clearCurrentPosition() {
                const e = this.crossHairSource();
                e.clearPosition(),
                (0,
                r.ensureNotNull)(e.dataWindowView()).update(),
                so(this._panes),
                this.invalidate(X.InvalidationMask.cursor()),
                this._undoModel.syncCrosshair(null),
                this._phantomSourceContainer.onCursorPositionUpdated()
            }
            setAndSaveCurrentPosition(e, t, i, s) {
                this.crossHairSource().saveOriginCoords(e, t),
                this.setCurrentPosition(e, t, i, s)
            }
            setCurrentPosition(e, t, i, s) {
                var o, n, a, l, c, d;
                let u = NaN;
                const h = this._timeScale.coordinateToVisibleIndex(e)
                  , p = null !== (a = null === (n = null !== (o = this._lineBeingEdited) && void 0 !== o ? o : this.lineBeingCreated()) || void 0 === n ? void 0 : n.priceScale()) && void 0 !== a ? a : i.defaultPriceScale();
                let m = null;
                !p.isEmpty() && Number.isFinite(t) && (m = (0,
                r.ensureNotNull)(i.mainDataSource()).firstValue(),
                null !== m && (u = p.coordinateToPrice(t, m)));
                const g = this._crossHairSelectPointMode.value() !== Ge.SelectPointMode.None
                  , _ = this.currentTool()
                  , v = this.mainSeries()
                  , S = this.crossHairSource()
                  , f = S.index
                  , b = S.price
                  , y = g || Ge.isStudyEditingNow.value()
                  , C = p === this.m_mainSeries.priceScale() && !(0,
                Ee.isLineDrawnWithPressedButton)(_) && (this._lineBeingCreated || this._lineBeingEdited || (0,
                Ee.isLineToolName)(_) || (0,
                Ge.toolIsMeasure)(_) || y);
                !this._isSettingsExternalPosition && C ? (u = this._magnet.align(u, h, i),
                null !== m && this._setCorrectedPositionToCrosshair(h, u, i)) : this._magnet.resetLastValue();
                let w = null;
                if (isNaN(u) || (w = i),
                this._isTimeScrolling) {
                    if (!this._isSettingsExternalPosition && g) {
                        const e = v.bars().firstIndex()
                          , t = v.bars().lastIndex();
                        if (null !== e && null !== t) {
                            const s = Math.min(Math.max(h, e), t);
                            s !== h && this._setCorrectedPositionToCrosshair(s, u, i)
                        }
                    } else
                        S.setPosition(S.index, u, w);
                    return
                }
                S.setOnHoveredChartWidget(!0),
                S.setPosition(h, u, w),
                (0,
                r.ensureNotNull)(S.dataWindowView()).update(),
                so(this._panes);
                const T = v.syncModel();
                this.crossHairSource().startMeasurePoint() || this._lineBeingCreated ? this.lightUpdate() : this.invalidate(X.InvalidationMask.cursor());
                const P = this.lineBeingCreated();
                if (P) {
                    const e = P.linkKey().value();
                    if (!this._isSettingsExternalPosition) {
                        const t = P.setLastPoint({
                            index: h,
                            price: u
                        }, s);
                        if (P.updateAllViews((0,
                        dt.sourceChangeEvent)(P.id())),
                        t.price === u && t.index === h || this._setCorrectedPositionToCrosshair(t.index, t.price, i),
                        T && e) {
                            const i = this._timeScale.points().roughTime(t.index, T.projectTime.bind(T));
                            (0,
                            Ge.setLineToolLastPoint)({
                                model: this,
                                linkKey: e,
                                point: {
                                    timeStamp: (0,
                                    r.ensureNotNull)(i),
                                    price: t.price
                                }
                            })
                        }
                    }
                }
                if (!this._isSettingsExternalPosition && null !== this._lineBeingEdited && null !== this._linePointBeingEdited) {
                    const e = {
                        index: h,
                        price: u
                    };
                    if (null === (l = this._linePointBeingChanged) || void 0 === l ? void 0 : l.nonDiscreteIndex) {
                        const t = this.crossHairSource().originX();
                        Number.isFinite(t) && (e.index = this._timeScale.coordinateToFloatIndex(t))
                    }
                    this.changeLinePoint(e, s);
                    const t = this._lineBeingEdited.alignCrossHairToAnchor(this._linePointBeingEdited) ? this._lineBeingEdited.getPoint(this._linePointBeingEdited) : e;
                    null !== t && this._setCorrectedPositionToCrosshair(t.index, t.price, i)
                }
                if (!this._isSettingsExternalPosition && 1 === this._sourcesBeingMoved.length) {
                    const e = this._sourcesBeingMoved[0];
                    if (null === (c = e.alignCrossHairToMovePoint) || void 0 === c ? void 0 : c.call(e)) {
                        const t = null === (d = e.currentMovingPoint) || void 0 === d ? void 0 : d.call(e);
                        t && t.logical && this._setCorrectedPositionToCrosshair(t.logical.index, t.logical.price, i)
                    }
                }
                if (!this._isSettingsExternalPosition && y) {
                    const e = v.bars().firstIndex()
                      , t = v.bars().lastIndex();
                    if (null !== e && null !== t) {
                        const s = Math.min(Math.max(h, e), t);
                        s !== h && this._setCorrectedPositionToCrosshair(s, u, i)
                    }
                }
                (f !== h || b !== u) && this._syncCrosshair(s)
            }
            setExternalPosition(e, t) {
                let i;
                const s = this.crossHairSource();
                if (s.setOnHoveredChartWidget(!1),
                null !== e && (0,
                ve.isNumber)(e.timeStamp)) {
                    const t = this.mainSeries().syncModel();
                    if (t) {
                        const s = this.createSyncPoint(e.syncSourceTarget, t.syncSourceTarget()).sourceTimeToTargetTime(e.timeStamp);
                        i = this._timeScale.points().roughIndex(s, t.distance.bind(t))
                    }
                }
                if (null !== e && null != i && Number.isFinite(i)) {
                    this._isSettingsExternalPosition = !0;
                    const o = (0,
                    r.ensureNotNull)(this.paneForSource(this.mainSeries()))
                      , n = this._timeScale.indexToCoordinate(i)
                      , a = (0,
                    r.ensureNotNull)(o.mainDataSource()).firstValue();
                    if (null !== a) {
                        let i = NaN;
                        void 0 !== e.price && Number.isFinite(e.price) && (i = this.mainSeries().priceScale().priceToCoordinate(e.price, a)),
                        s.clearOriginCoords(),
                        this.setCurrentPosition(n, i, o, t)
                    }
                    return s.setOnHoveredChartWidget(!1),
                    void (this._isSettingsExternalPosition = !1)
                }
                s.clearPosition(),
                (0,
                r.ensureNotNull)(s.dataWindowView()).update(),
                so(this._panes),
                this.invalidate(X.InvalidationMask.cursor())
            }
            startScaleTime(e) {
                this._timeScale.startScale(e)
            }
            scaleTimeTo(e) {
                this._timeScale.scaleTo(e),
                this.recalculateAllPanes((0,
                dt.viewportChangeEvent)()),
                this.lightUpdate()
            }
            endScaleTime() {
                this._timeScale.endScale(),
                this.lightUpdate(),
                this.recalcVisibleRangeStudies(b.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction)
            }
            resetTimeScale() {
                this._timeScale.restoreDefault(),
                this.recalculateAllPanes((0,
                dt.viewportChangeEvent)()),
                this.recalcVisibleRangeStudies(b.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction),
                this.lightUpdate(),
                this._resetScales.fire()
            }
            startScalePrice(e, t, i) {
                e.startScalePrice(t, i)
            }
            scalePriceTo(e, t, i) {
                e.scalePriceTo(t, i),
                this.mainSeries().priceScale().isLockScale() ? this.lightUpdate() : this.invalidate(this._paneInvalidationMask(e, X.InvalidationLevel.Light))
            }
            endScalePrice(e, t) {
                e.endScalePrice(t),
                this.invalidate(this._paneInvalidationMask(e, X.InvalidationLevel.Light))
            }
            startTwoPointsScalePrice(e, t, i, s) {
                t.startTwoPointsScale(i, s)
            }
            twoPointsScalePriceTo(e, t, i, s) {
                t.twoPointsScale(i, s),
                this.invalidate(this._paneInvalidationMask(e))
            }
            endTwoPointsScalePrice(e, t) {
                t.endTwoPointsScale(),
                this.invalidate(this._paneInvalidationMask(e))
            }
            resetPriceScale(e, t) {
                e.resetPriceScale(t),
                this.invalidate(this._paneInvalidationMask(e, X.InvalidationLevel.Light))
            }
            restorePriceScaleState(e, t, i) {
                e.restorePriceScaleState(t, i),
                this.invalidate(this._paneInvalidationMask(e, X.InvalidationLevel.Light))
            }
            currentTool() {
                return this._currentTool
            }
            setCurrentTool(e) {
                this._currentTool !== e && ((0,
                Ee.isLineToolName)(e) && this.selectionMacro((e=>{
                    e.clearSelection()
                }
                )),
                this._currentTool = e,
                this._phantomSourceContainer.onToolChanged())
            }
            detachSource(e) {
                const t = this.paneForSource(e);
                return !!t && (t.removeDataSource(e),
                t.isEmpty() ? (this._lineBeingCreated && t === this._paneBeingCreatedLineOn && this.cancelCreatingLine(),
                this.removePane(t),
                !0) : (this.fullUpdate(),
                !1))
            }
            children(e, t) {
                return this.dataSources().filter((i=>(0,
                U.isStudy)(i) && !(0,
                ye.isLollipopDataSource)(i) ? !t && i.parentSources().includes(e) : i.ownerSource() === e))
            }
            onRearrangePanes() {
                return this._onRearrangePanes
            }
            studyInserted() {
                return this._studyInserted
            }
            finishLineTool(e) {
                const t = e.linkKey().value();
                (0,
                Ge.drawOnAllCharts)().value() && null !== t && e.isSynchronizable() && (0,
                Ge.finishLineTool)({
                    linkKey: t,
                    model: this
                })
            }
            startChangingLinetool(e, t, i, s, o) {
                this._lineBeingEdited = e,
                this._linePointBeingChanged = t || null,
                this._linePointBeingEdited = void 0 === i ? null : i,
                this._lineBeingEdited.startChanging(i, t, o),
                Ge.isToolEditingNow.setValue(!0);
                const n = (0,
                r.ensureNotNull)(this.paneForSource(e));
                this._lineBeingEdited.startDragPoint && void 0 !== i && void 0 !== t && this._lineBeingEdited.startDragPoint(i, t),
                o || void 0 === i || void 0 === t || this._lineBeingEdited.setPoint(i, t, s, o),
                this._lineBeingEdited.updateAllViews((0,
                dt.sourceChangeEvent)(this._lineBeingEdited.id()));
                const a = this._paneInvalidationMask(n, X.InvalidationLevel.Light);
                this.invalidate(a);
                const l = e.linkKey().value();
                if (l && e.isSynchronizable() && void 0 !== i && void 0 !== t) {
                    const e = (0,
                    r.ensureNotNull)(this.externalTimeStamp(t.index));
                    (0,
                    Ge.startChangingLineTool)({
                        linkKey: l,
                        model: this,
                        symbol: this.mainSeries().symbol(),
                        point: {
                            price: t.price,
                            timeStamp: e
                        },
                        pointIndex: i,
                        envState: s || null
                    })
                }
            }
            createLineTool(e) {
                const {pane: t, point: i, linetool: s, linkKey: o=null, sharingMode: n=0, id: l, fromExternalModel: c} = e;
                let {properties: d, ownerSource: u} = e;
                if ((0,
                r.assert)((0,
                Ee.isLineToolName)(s), `Cannot create unknown line tool: ${s}`),
                d) {
                    const e = {
                        ...js.intervalsVisibilitiesDefaults
                    }
                      , t = d.childs().intervalsVisibilities.state();
                    (0,
                    ve.merge)(e, null != t ? t : {});
                    const i = d.state();
                    i.intervalsVisibilities = e,
                    d = (0,
                    T.createLineToolProperties)(s, i, this)
                }
                const h = (0,
                T.createLineTool)(s, this, d, null, void 0, l);
                if ("LineToolExecution" !== s) {
                    let e;
                    switch (s) {
                    case "LineToolIcon":
                        e = h.properties().childs().icon.value().toString(16).toUpperCase();
                        break;
                    case "LineToolEmoji":
                        e = h.properties().childs().emoji.value();
                        break;
                    case "LineToolSticker":
                        e = h.properties().childs().sticker.value()
                    }
                    (0,
                    g.trackEvent)("drawings", "Study_Drawing_" + s, e)
                }
                (0,
                T.isStudyLineTool)(h) && (0,
                g.trackEvent)("studies", `Study_${h.metaInfo().id}`);
                const p = !h.linkKey().value() && !o;
                u = (0,
                r.ensureDefined)(u || (0,
                r.ensureNotNull)(t.mainDataSource())),
                d || (0,
                T.prepareLineToolPropertiesByOwnerSource)(h.properties(), u),
                h.setOwnerSource(u);
                const m = u.priceScale();
                if (h.setPriceScale(m),
                u === this.mainSeries() && h.share(n),
                t.addDataSource(h, m, !1),
                null !== h.preferredZOrder() && t.insertAfter([h], this.mainSeries()),
                (0,
                Ge.drawOnAllCharts)().value()) {
                    const e = h.isSynchronizable() ? o || (0,
                    pe.randomHash)() : null;
                    h.linkKey().setValue(e)
                } else
                    h.linkKey().setValue(o);
                let _;
                if (p && h.enableCurrentIntervalVisibility(),
                h.isFixed()) {
                    const e = (0,
                    r.ensureNotNull)((0,
                    r.ensureNotNull)(t.mainDataSource()).firstValue())
                      , s = this._timeScale.indexToCoordinate(i.index)
                      , o = (0,
                    r.ensureNotNull)(m).priceToCoordinate(i.price, e);
                    _ = h.addFixedPoint(new a.Point(s,o))
                } else
                    _ = h.addPoint(i);
                return _ || (this._lineBeingCreated = {
                    lineDataSource: h,
                    fromExternal: !!c
                },
                this._paneBeingCreatedLineOn = t,
                Ge.isToolCreatingNow.setValue(!0)),
                this.fullUpdate(),
                h
            }
            endChangingLinetool(e, t) {
                const i = (0,
                r.ensureNotNull)(this._lineBeingEdited)
                  , s = i.endChanging(!1, e, t);
                this._lineBeingEdited = null,
                Ge.isToolEditingNow.setValue(!1),
                this._linePointBeingEdited = null,
                this._linePointBeingChanged = null,
                this.lightUpdate();
                const o = {
                    points: i.normalizedPoints(),
                    interval: this.mainSeries().interval()
                }
                  , n = i.linkKey().value();
                null !== n && i.isSynchronizable() && !t && (0,
                Ge.finishChangingLineTool)({
                    model: this,
                    linkKey: n,
                    symbol: this.mainSeries().symbol(),
                    finalState: o,
                    changes: s
                })
            }
            continueCreatingLine(e, t, i, s, o) {
                const n = (0,
                r.ensureNotNull)(this.lineBeingCreated())
                  , a = n.addPoint(e, t, i, o);
                n.updateAllViews((0,
                dt.sourceChangeEvent)(n.id()));
                const l = new X.InvalidationMask(X.InvalidationLevel.Light);
                return a && (this._paneBeingCreatedLineOn = null,
                this._lineBeingCreated = null,
                Ge.isToolCreatingNow.setValue(!1)),
                this.invalidate(l),
                a
            }
            cancelCreatingLine() {
                const e = this.lineBeingCreated();
                e && (this.removeSource(e),
                this._lineBeingCreated = null,
                this._lineCancelled.fire(),
                Ge.isToolCreatingNow.setValue(!1),
                (0,
                Ge.drawOnAllCharts)().value() && e.isSynchronizable() && (0,
                Ge.cancelLineTool)({
                    model: this
                }))
            }
            lineBeingCreated() {
                var e;
                return (null === (e = this._lineBeingCreated) || void 0 === e ? void 0 : e.lineDataSource) || null
            }
            lineBeingCreateFromExternal() {
                var e;
                return (null === (e = this._lineBeingCreated) || void 0 === e ? void 0 : e.fromExternal) || !1
            }
            paneBeingCreatedLineOn() {
                return this._paneBeingCreatedLineOn
            }
            lineCancelled() {
                return this._lineCancelled
            }
            isPhantomLine(e) {
                return this._phantomSourceContainer.source() === e
            }
            alignTo45Degrees(e, t) {
                const [i,s] = t
                  , o = {
                    ...s
                };
                e.snapPoint45Degree(i, o),
                this.startChangingLinetool(e, s, s.pointIndex),
                this.changeLinePoint(o, D.EnvironmentState.create(!0)),
                this.endChangingLinetool(!1)
            }
            changeLinePoint(e, t, i) {
                const s = (0,
                r.ensureNotNull)(this._lineBeingEdited)
                  , o = (0,
                r.ensureNotNull)(this._linePointBeingEdited);
                let n = e.price
                  , a = e.index;
                if (s.setPoint(o, e, t, i),
                !i) {
                    const t = s.alignCrossHairToAnchor(o) ? s.getPoint(o) : e;
                    null !== t && (a = t.index,
                    n = t.price)
                }
                s.updateAllViews((0,
                dt.sourceChangeEvent)(s.id())),
                this.lightUpdate();
                const l = s.linkKey().value();
                if (!i && null !== l && s.isSynchronizable()) {
                    const e = (0,
                    r.ensureNotNull)(this._linePointBeingChanged)
                      , i = {
                        indexesChanged: a !== e.index,
                        pricesChanged: n !== e.price
                    }
                      , c = s.getChangePointForSync(o);
                    if (null !== c) {
                        const e = this.externalTimeStamp(a);
                        null !== e && (n = c.price,
                        (0,
                        Ge.changeLineTool)({
                            linkKey: l,
                            model: this,
                            symbol: this.mainSeries().symbol(),
                            point: {
                                price: n,
                                timeStamp: e
                            },
                            envState: t,
                            changes: i
                        }))
                    }
                }
            }
            changeLinePoints(e, t, i) {
                const s = e.points()
                  , o = e.linkKey().value();
                !i && o && e.isSynchronizable() && t.forEach(((t,i)=>{
                    const n = s[i]
                      , a = n.price !== t.price
                      , l = n.index !== t.index;
                    if (e.getChangePointForSync(i)) {
                        const e = (0,
                        r.ensureNotNull)(this.externalTimeStamp(t.index));
                        (0,
                        Ge.changeLineTool)({
                            linkKey: o,
                            model: this,
                            symbol: this.mainSeries().symbol(),
                            point: {
                                price: t.price,
                                timeStamp: e
                            },
                            changes: {
                                pricesChanged: a,
                                indexesChanged: l
                            }
                        })
                    }
                }
                )),
                e.setPoints(t),
                e.updateAllViews((0,
                dt.sourceChangeEvent)(e.id())),
                this.lightUpdate()
            }
            startScrollTime(e) {
                this._timeScale.startScroll(e),
                this._isTimeScrolling = !0,
                this.mainSeries().clearGotoDateResult()
            }
            scrollTimeTo(e) {
                this._timeScale.scrollTo(e),
                this.recalculateAllPanes((0,
                dt.viewportChangeEvent)()),
                this.lightUpdate()
            }
            endScrollTime() {
                this._timeScale.endScroll(),
                this.lightUpdate(),
                this.recalcVisibleRangeStudies(b.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction),
                this._isTimeScrolling = !1
            }
            startScrollPrice(e, t, i) {
                e.startScrollPrice(t, i)
            }
            scrollPriceTo(e, t, i) {
                e.scrollPriceTo(t, i),
                this.invalidate(this._paneInvalidationMask(e, X.InvalidationLevel.Light))
            }
            endScrollPrice(e, t) {
                e.endScrollPrice(t),
                this.invalidate(this._paneInvalidationMask(e, X.InvalidationLevel.Light))
            }
            addCustomSource(e, t, i=b.CustomSourceLayer.Foreground) {
                this._customSourcesMap.has(e) && to.logWarn(`Attempt to add the same custom source multiple time "${e}"`),
                to.logNormal(`Adding custom source "${e}"`);
                const s = t(e, this);
                switch (i) {
                case b.CustomSourceLayer.Background:
                    this._bgCustomSources.push(s);
                    break;
                case b.CustomSourceLayer.Foreground:
                    this._fgCustomSources.push(s);
                    break;
                case b.CustomSourceLayer.Topmost:
                    this._topmostCustomSources.push(s);
                    break;
                default:
                    throw new Error(`Unknown custom sources layer ${i}`)
                }
                this._allCustomSources.push(s),
                this._customSourcesMap.set(e, s),
                this.lightUpdate()
            }
            removeCustomSource(e) {
                this._removeCustomSource(e),
                this.lightUpdate()
            }
            hasCustomSource(e) {
                return this._customSourcesMap.has(e)
            }
            customSourceForName(e) {
                return this._customSourcesMap.get(e) || null
            }
            customSourceName(e) {
                let t = null;
                return this._customSourcesMap.forEach(((i,s)=>{
                    i === e && (t = s)
                }
                )),
                t
            }
            customSources(e) {
                switch (e) {
                case b.CustomSourceLayer.Background:
                    return this._bgCustomSources;
                case b.CustomSourceLayer.Foreground:
                    return this._fgCustomSources;
                case b.CustomSourceLayer.Topmost:
                    return this._topmostCustomSources;
                default:
                    return this._allCustomSources
                }
            }
            addMultiPaneSource(e) {
                this._multiPaneSources.push(e),
                this._onMultipaneSourcesCollectionChanged.fire(),
                this.lightUpdate()
            }
            removeMultiPaneSource(e) {
                const t = this._multiPaneSources.indexOf(e);
                -1 === t ? to.logWarn("Attempt to remove multi-pane source which does not exist in the model") : (this._onMultipaneSourcesCollectionChanged.fire(),
                this._multiPaneSources.splice(t, 1)),
                this.lightUpdate()
            }
            multiPaneSources(e) {
                return this._multiPaneSources.filter((t=>!e.hasDataSource(t)))
            }
            onMultipaneSourcesCollectionChanged() {
                return this._onMultipaneSourcesCollectionChanged
            }
            rendererOptionsProvider() {
                return this._rendererOptionsProvider
            }
            magnet() {
                return this._magnet
            }
            priceAxisRendererOptions() {
                return this._rendererOptionsProvider.options()
            }
            dateTimeFormatter() {
                return this._dateTimeFormatter
            }
            dateFormatter() {
                return this._dateFormatter
            }
            timeFormatter() {
                return this._timeFormatter
            }
            isUnmergeAvailableForSource(e) {
                if (!this._unmergeAvailable(e))
                    return !1;
                return (0,
                r.ensureNotNull)(this.paneForSource(e)).dataSources().filter(this._unmergeAvailable, this).length > 1
            }
            isMergeDownAvailableForSource(e) {
                if (!this._unmergeAvailable(e))
                    return !1;
                const t = this.paneForSource(e)
                  , i = this.panes();
                return t !== i[i.length - 1]
            }
            isMergeUpAvailableForSource(e) {
                if (!this._unmergeAvailable(e))
                    return !1;
                return this.paneForSource(e) !== this.panes()[0]
            }
            sessions() {
                return (0,
                r.ensureNotNull)(this._sessions)
            }
            createSessions(e) {
                if (null === this._sessions) {
                    const t = function() {
                        const e = new E.DefaultProperty({
                            defaultName: "sessions",
                            themedColors: (0,
                            E.extractThemedColors)(m.lightTheme.content.sessions, m.darkTheme.content.sessions)
                        });
                        return (0,
                        V.applyDefaultsOverrides)(e.childs().graphics, void 0, !1, "sessions"),
                        H(e),
                        e
                    }();
                    this._sessions = new z((async()=>{
                        const s = await Promise.all([i.e(50163), i.e(41995), i.e(32887), i.e(24951), i.e(87), i.e(12497), i.e(92013), i.e(88509), i.e(89052), i.e(97771), i.e(45749), i.e(26676), i.e(89745), i.e(47219), i.e(10203), i.e(31716), i.e(57539)]).then(i.bind(i, 885953));
                        return this.addCustomSource("sessions", ((i,o)=>{
                            const n = new s.Sessions(i,o,t,e);
                            return n.start(),
                            n
                        }
                        ), b.CustomSourceLayer.Background),
                        this.customSourceForName("sessions")
                    }
                    )(),this,t)
                }
            }
            createPrePostMarket(e) {
                this.addCustomSource("prePostMarket", ((t,i)=>new ai.PrePostMarket(t,i,e)))
            }
            watermarkSource() {
                return this._watermarkSource
            }
            watermarkContentProvider() {
                return null
            }
            replayStatus() {
                return this._replayStatus
            }
            setReplayStatus(e) {
                this._replayStatus.setValue(e)
            }
            isInReplay() {
                return this.m_mainSeries.isInReplay()
            }
            getSymbolString() {
                return this.m_mainSeries.getSymbolString()
            }
            interval() {
                return this.m_mainSeries.interval()
            }
            switchToReplay(e, t) {
                this.m_mainSeries.switchToReplay(e, t)
            }
            switchToRealtime() {
                this.m_mainSeries.switchToRealtime(),
                this._timeScale.resetRightOffset(),
                this.setReplayStatus(0),
                this._scrollingState && (this._scrollingState.deferred.reject(),
                this._scrollingState = null)
            }
            canChangeResolution(e) {
                return this.m_mainSeries.canChangeResolution(e)
            }
            canChangeSymbol(e) {
                return this.m_mainSeries.canChangeSymbol(e)
            }
            getThemeNameIfStdTheme() {
                const e = this.sessions().properties()
                  , t = this.properties()
                  , i = this.mainSeries().properties();
                return e.allThemePropertiesAreDefault(p.StdTheme.Light) && t.allThemePropertiesAreDefault(p.StdTheme.Light) && i.allThemePropertiesAreDefault(p.StdTheme.Light) ? p.StdTheme.Light : e.allThemePropertiesAreDefault(p.StdTheme.Dark) && t.allThemePropertiesAreDefault(p.StdTheme.Dark) && i.allThemePropertiesAreDefault(p.StdTheme.Dark) ? p.StdTheme.Dark : null
            }
            theme() {
                return {
                    chartProperties: this.properties().themeState(),
                    sessions: this.sessions().properties().themeState(),
                    mainSourceProperties: this.mainSeries().properties().themeState(),
                    version: this.version()
                }
            }
            template() {
                return {
                    chartProperties: this.properties().template(),
                    sessions: this.sessions().properties().template(),
                    mainSourceProperties: this.mainSeries().properties().template(),
                    version: this.version()
                }
            }
            onChartThemeLoaded() {
                return this._chartThemeLoaded
            }
            chartThemeLoaded() {
                this._chartThemeLoaded.fire()
            }
            async colorStudiesPropertiesReady() {
                this._recalcColorStudiesImpl(this._recalcVRStudiesParams);
                const e = this.allStudies(!0).filter((e=>e.metaInfo().inputs.filter(M.isStudyInputDependsOnChartColors).length > 0));
                await Promise.all(e.map((e=>e.propertiesPatched())))
            }
            state(e, t, i, s) {
                var o;
                const n = this.publishedChartsTimelineSource()
                  , r = this.properties().childs()
                  , a = r.tradingProperties.state()
                  , l = {
                    panes: this._panes.map((o=>o.state(!0, e, !1, t, i, s))),
                    timeScale: this._timeScale.state(e),
                    chartProperties: {
                        paneProperties: r.paneProperties.state(["horzGridProperties.style", "vertGridProperties.style"]),
                        scalesProperties: r.scalesProperties.state(),
                        publishedChartsTimelineProperties: n ? n.state(e) : void 0,
                        chartEventsSourceProperties: null === (o = r.chartEventsSourceProperties) || void 0 === o ? void 0 : o.state(),
                        tradingProperties: a,
                        priceScaleSelectionStrategyName: r.priceScaleSelectionStrategyName.value()
                    },
                    sessions: this.sessions().state(e),
                    version: this.version(),
                    timezone: this.timezone(),
                    shouldBeSavedEvenIfHidden: this._shouldBeSavedEvenIfHidden,
                    linkingGroup: this._linkingGroupIndex.value()
                };
                return s || (l.lineToolsGroups = this.lineToolsGroupModel().state(t)),
                l
            }
            restoreState(e, t, s) {
                var o;
                it.DeferredStudies.instance(this).reset();
                const n = {};
                if (!e.panes)
                    return void to.logDebug("ChartModel.restoreState: invalid state");
                if (!Array.isArray(e.panes))
                    return void to.logDebug("ChartModel.restoreState: invalid state");
                if (e.panes.length < 1)
                    return void to.logDebug("ChartModel.restoreState: invalid state");
                for (const e of this._barsMarksSources)
                    this.detachSource(e);
                if (this._shouldBeSavedEvenIfHidden = void 0 === e.shouldBeSavedEvenIfHidden || e.shouldBeSavedEvenIfHidden,
                e.chartProperties && !e.chartProperties.timezone && (e.chartProperties.timezone = e.timezone),
                e.chartProperties) {
                    const i = (0,
                    V.factoryDefaults)("chartproperties").scalesProperties;
                    (0,
                    ve.merge)(i, e.chartProperties.scalesProperties),
                    !("showLastValue"in i) || "showSeriesLastValue"in i || "showStudyLastValue"in i || (i.showSeriesLastValueProperty = i.showLastValue,
                    i.showStudyLastValueProperty = i.showLastValue),
                    "showSeriesLastValue"in i && (n.showSeriesLastValueProperty = !0),
                    "showStudyLastValue"in i && (n.showStudyLastValueProperty = !0),
                    (!this.isSnapshot() && !this.readOnly() && "showCurrency"in i || "showUnit"in i) && ((0,
                    K.migrateShowCurrencyAndShowUnitProperties)(i.showCurrency, i.showUnit),
                    delete i.showCurrency,
                    delete i.showUnit);
                    {
                        const {paneProperties: t} = e.chartProperties;
                        t.vertGridProperties = t.vertGridProperties || (0,
                        ve.clone)(t.gridProperties),
                        t.horzGridProperties = t.horzGridProperties || (0,
                        ve.clone)(t.gridProperties),
                        t.horzGridProperties.style = t.vertGridProperties.style = gi.LINESTYLE_SOLID,
                        "backgroundType"in t || (t.backgroundType = Si.ColorType.Solid),
                        "separatorColor"in t || (t.separatorColor = (0,
                        h.getThemedColor)("color-chart-page-bg")),
                        this._properties.childs().paneProperties.mergeAndFire(t)
                    }
                    this._properties.childs().scalesProperties.mergeAndFire(i),
                    e.chartProperties.timezone && this._properties.childs().timezone.setValue(e.chartProperties.timezone),
                    e.chartProperties.chartEventsSourceProperties && this._properties.hasChild("chartEventsSourceProperties") && this._properties.childs().chartEventsSourceProperties.mergeAndFire(e.chartProperties.chartEventsSourceProperties),
                    e.chartProperties.tradingProperties && this._properties.hasChild("tradingProperties") && (void 0 === e.chartProperties.tradingProperties.horizontalAlignment && (e.chartProperties.tradingProperties.horizontalAlignment = (a = e.chartProperties.tradingProperties.lineLength) <= 40 ? b.TradedGroupHorizontalAlignment.Right : a >= 60 ? b.TradedGroupHorizontalAlignment.Left : b.TradedGroupHorizontalAlignment.Center),
                    this._properties.childs().tradingProperties.mergeAndFire(e.chartProperties.tradingProperties)),
                    this._timeScale.restoreState(e.timeScale, t),
                    this._updateDateTimeFormatter()
                }
                var a;
                if (e.timeScale && this._timeScale.restoreState(e.timeScale, t),
                !this.readOnly()) {
                    const t = this._getExceedingChildStudies(e.panes);
                    if (t.length) {
                        for (let i = e.panes.length - 1; i >= 0; --i) {
                            const s = e.panes[i];
                            for (let e = s.sources.length - 1; e >= 0; --e) {
                                const i = s.sources[e];
                                ~t.indexOf(i) && s.sources.splice(e, 1)
                            }
                            s.sources.length || e.panes.splice(i, 1)
                        }
                        {
                            const e = window.user.pro_plan;
                            setTimeout((()=>(0,
                            li.createGoProDialog)({
                                feature: "studyOnStudy",
                                actions: e && "pro_premium_expert" === e ? [{
                                    text: d.t(null, void 0, i(515462)),
                                    action: hi.PredefinedAction.Close
                                }] : void 0
                            })), 500)
                        }
                    }
                }
                const l = e.version || 0
                  , c = e.panes;
                let u = "_seriesId";
                for (const e of c) {
                    const t = e.sources.find((e=>"MainSeries" === e.type));
                    if (t) {
                        u = t.id;
                        break
                    }
                }
                this.panes()[0].restoreState({
                    state: c[0],
                    withData: t,
                    version: l,
                    seriesId: u,
                    settingsMigration: n,
                    contentOverrides: s,
                    restoreSilently: true,
                    reason: 2
                });
                let p = 1;
                for (let i = 1; i < e.panes.length; i++) {
                    const o = e.panes[i];
                    if (0 === o.sources.length) {
                        to.logWarn("Empty pane detected - restoring is skipped. idx=" + i + ", state=" + JSON.stringify(o));
                        continue
                    }
                    const r = this.panes()[p] || this.createPane();
                    r.restoreState({
                        state: o,
                        withData: t,
                        version: l,
                        seriesId: u,
                        settingsMigration: n,
                        contentOverrides: s,
                        restoreSilently: true,
                        reason: 2
                    }),
                    r.mainDataSource() ? p += 1 : this.removePane(r)
                }
                if (this.panes().forEach(((e,t)=>{
                    e.collapsed().value() !== c[t].isCollapsed && (e.collapsed().setValue(c[t].isCollapsed),
                    this.fullUpdate())
                }
                )),
                e.chartProperties && e.chartProperties.publishedChartsTimelineProperties) {
                    const i = this.publishedChartsTimelineSource();
                    i && i.restoreData(e.chartProperties.publishedChartsTimelineProperties, t)
                }
                this._invalidateBarColorerCaches();
                const m = this.dataSources();
                let g = 0;
                for (let e = 0; e < m.length; e++) {
                    const t = m[e];
                    (0,
                    T.isLineTool)(t) && (g++,
                    t.calcIsActualSymbol())
                }
                this.updateTimeScaleBaseIndex(),
                this.recalculateAllPanes((0,
                dt.globalChangeEvent)()),
                this.fullUpdate(),
                this.syncLollipopSources();
                const _ = (0,
                r.ensureNotNull)(this.mainPane());
                for (const e of this._barsMarksSources)
                    this.detachSource(e),
                    _.addDataSource(e, this.m_mainSeries.priceScale(), !0);
                let v = S.TVLocalStorage.getItem("linetools_limit") || 1e3;
                return window.is_authenticated && window.user && window.user.settings && (v = window.user.settings.linetools_limit || v),
                e.sessions && this.sessions().restoreState(e.sessions, t),
                e.lineToolsGroups && (this._lineToolsGroupModel = Kt.fromState(this, e.lineToolsGroups)),
                g > v && g % 100 == 0 ? {
                    lines_limit_exceeded: !0,
                    line_tools_count: g
                } : (this.panes().forEach((e=>this._dataSourceCollectionChanged.fire(e))),
                this._lineToolsGroupModel.fireChangedAll(),
                this._linkingGroupIndex.setValue(null !== (o = e.linkingGroup) && void 0 !== o ? o : null),
                {})
            }
            shouldBeSavedEvenIfHidden() {
                return this._shouldBeSavedEvenIfHidden
            }
            setShouldBeSavedEvenIfHidden(e) {
                this._shouldBeSavedEvenIfHidden = e
            }
            externalTimeStamp(e) {
                const t = this.mainSeries().syncModel();
                return this.timeScale().points().roughTime(e, t && t.projectTime.bind(t))
            }
            syncLollipopSources() {
                var e;
                null === (e = this._lollipopSourcesWatcherLoader) || void 0 === e || e.callFunction((()=>{
                    null !== this._lollipopSourcesWatcher && this._lollipopSourcesWatcher.syncSources()
                }
                ))
            }
            restoreChartEvents(e) {
                var t;
                null === (t = this._lollipopSourcesWatcherLoader) || void 0 === t || t.callFunction((()=>{
                    null !== this._lollipopSourcesWatcher && this._options.chartEventsEnabled && this._lollipopSourcesWatcher.restoreChartEvents(e)
                }
                ))
            }
            recalcVisibleRangeStudies(e) {
                var t;
                if (this._recalcVRStudiesParams.reasons.add(e),
                this.m_mainSeries.isStarted() && this.m_mainSeries.isCompleted()) {
                    const i = (0,
                    r.ensureDefined)(ro.get(e)).adapter
                      , s = Math.min(...Array.from(this._recalcVRStudiesParams.reasons).map((e=>(0,
                    r.ensureDefined)(ro.get(e)))).filter((e=>e.adapter === i)).map((e=>e.timeout)));
                    (0,
                    r.ensureDefined)(null === (t = this._recalcVisibleRangeStudiesImplDebouncedByAdapter.get(i)) || void 0 === t ? void 0 : t.get(s))()
                } else
                    this._recalcVisibleRangeStudiesImpl(this._recalcVRStudiesParams)
            }
            recalcColorStudies(e) {
                this._recalcColorStudiesParams.force = this._recalcColorStudiesParams.force || Boolean(e),
                this._recalcColorStudiesImplDebounced()
            }
            recalcStudyBasedLineTools() {
                this.dataSources().forEach((e=>{
                    (0,
                    T.isStudyLineTool)(e) && e.recalcStudyIfNeeded()
                }
                ))
            }
            alertsWatcher() {
                return this._alertsWatcher
            }
            showLegend() {
                return this._showLegendProperty
            }
            id() {
                return this._id
            }
            selectPointMode() {
                return this._crossHairSelectPointMode
            }
            cancelRequestSelectPoint() {
                this.m_crossHairSource.cancelRequestSelectPoint()
            }
            requestSelectPoint(e) {
                return this.m_crossHairSource.requestSelectPoint(e)
            }
            onPointSelected() {
                return this.m_crossHairSource.onPointSelected()
            }
            recalculatePriceRangeOnce() {
                const e = this.mainSeries();
                for (const t of this._panes)
                    for (const i of t.priceDataSources())
                        i.symbolSource() === e && i.disablePriceRangeReady()
            }
            invalidate(e) {
                var t;
                null === (t = this._invalidateHandler) || void 0 === t || t.call(this, e)
            }
            appliedTimeFrame() {
                return this._appliedTimeFrame.appliedTimeFrame()
            }
            barsMarksSources() {
                return this._barsMarksSources
            }
            createSyncPoint(e, t) {
                return (0,
                Us.getDefault2Lazy)(this._syncPointCache, e.uniqueId, t.uniqueId, (()=>new ei(e,t)))
            }
            isAutoSaveEnabled() {
                return this._isAutoSaveEnabled
            }
            linkingGroupIndex() {
                return this._linkingGroupIndex
            }
            studyAwareDefaultRightOffset() {
                return this._timeScale.usePercentageRightOffset().value() ? this._timeScale.percentsToBarIndexLength(this.studyAwareDefaultRightOffsetPercentage()) : Math.max(this._timeScale.defaultRightOffset().value(), this._cachedStudiesMaxOffset)
            }
            studyAwareDefaultRightOffsetPercentage() {
                return this._timeScale.usePercentageRightOffset().value() ? Math.max(this._timeScale.defaultRightOffsetPercentage().value(), this._timeScale.barIndexLengthToPercents(this._cachedStudiesMaxOffset)) : this._timeScale.barIndexLengthToPercents(this.studyAwareDefaultRightOffset())
            }
            clearAllStudies() {
                this.dataSources().forEach((e=>{
                    var t;
                    return null === (t = e.clearData) || void 0 === t ? void 0 : t.call(e)
                }
                ))
            }
            setTimeScaleAnimation(e, t) {
                const i = X.InvalidationMask.light()
                  , s = this._timeScale;
                i.setTimeScaleAnimation(e, null != t ? t : s.width() - s.indexToCoordinate(s.baseIndex())),
                this.invalidate(i)
            }
            stopTimeScaleAnimation() {
                this._timeScale.endScroll();
                const e = X.InvalidationMask.light();
                e.stopTimeScaleAnimation(),
                this.invalidate(e)
            }
            lollipopSourcesOptions() {
                const e = this._options;
                return {
                    chartEventsEnabled: !this._options.isSnapshot && this._options.chartEventsEnabled,
                    esdEnabled: e.esdEnabled,
                    newsNotificationsEnabled: e.newsNotificationsEnabled,
                    continuousContractSwitchesEnabled: e.continuousContractSwitchesEnabled,
                    futuresContractExpirationEnabled: e.futuresContractExpirationEnabled,
                    latestUpdatesEnabled: e.latestUpdatesEnabled,
                    keyFactsTodayEnabled: e.keyFactsTodayEnabled
                }
            }
            onSymbolIntervalChanged() {
                return this._symbolIntervalChanged
            }
            _initAlertsList() {
                return this._alertsListPromise || (this._alertsListPromise = (0,
                oi.getChartAlertsFacade)().then((e=>{
                    this._alertsList = e.createCollection((()=>this.mainSeries().interval()), (()=>this.mainSeries().actualSymbol())),
                    this._alertsList.alertAdded().subscribe(this, this._addAlertLabelToChart.bind(this)),
                    this._alertsList.alertRemoved().subscribe(this, this._removeAlertLabelFromChart.bind(this)),
                    this._alertsList.alertChanged().subscribe(this, (e=>{
                        this._removeAlertLabelFromChart(e),
                        this._addAlertLabelToChart(e)
                    }
                    )),
                    this._alertsList.sync();
                    const t = e=>{
                        this.mainSeries().dataEvents().symbolResolved()[e](this, i),
                        this.mainSeries().dataEvents().symbolError()[e](this, this._removeAllAlertLabelsFromChart),
                        this.mainSeries().properties().childs().interval[e](this, i)
                    }
                      , i = ()=>{
                        var e;
                        null === (e = this._alertsList) || void 0 === e || e.sync()
                    }
                    ;
                    return window.loginStateChange.subscribe(this, (()=>{
                        var e;
                        null === (e = this._alertsList) || void 0 === e || e.reset(),
                        t(window.is_authenticated ? "subscribe" : "unsubscribe")
                    }
                    )),
                    window.is_authenticated && t("subscribe"),
                    this._alertsList
                }
                ))),
                this._alertsListPromise
            }
            _updateStudiesMaxOffset() {
                const e = Math.max(...this.allStudies().map((e=>e.maxOffset().value())));
                this._cachedStudiesMaxOffset = e;
                const t = this._timeScale.rightOffset();
                if (t < 0)
                    return;
                if (e <= t)
                    return;
                const i = this._timeScale.logicalRange();
                i ? this._timeScale.zoomToBarsRange(i.left(), this._timeScale.baseIndex() + Math.max(this._timeScale.rightOffset(), e)) : this._timeScale.setRightOffset(Math.max(t, e))
            }
            _updateBaseIndex(e, t) {
                const i = this._timeScale
                  , s = i.baseIndex()
                  , o = i.logicalRange();
                if (null !== o && t) {
                    const t = o.contains(s)
                      , n = e - s
                      , r = t ? null : i.rightOffset() - n;
                    if (!this._options.shiftVisibleRangeOnNewBar && t) {
                        const e = i.width() / i.barSpacing()
                          , t = e / (e + n)
                          , s = Math.max(i.minBarSpacing(), i.barSpacing() * t);
                        i.setBarSpacing(s)
                    }
                    null !== r && i.setRightOffset(r)
                }
                i.setBaseIndex(e)
            }
            async _createLollipopSourcesWatcher() {
                {
                    const e = this.lollipopSourcesOptions()
                      , t = [e.esdEnabled, e.continuousContractSwitchesEnabled, e.futuresContractExpirationEnabled, e.latestUpdatesEnabled.minds, e.latestUpdatesEnabled.news, e.keyFactsTodayEnabled, e.chartEventsEnabled]
                      , s = (0,
                    ti.onWidget)()
                      , o = this.isSnapshot();
                    (t.some(Boolean) || !s || o) && (await (0,
                    O.studyMetaInfoRepository)().requestMetaInfo(),
                    this._lollipopSourcesWatcherLoader = new f.AsyncResourceWrapper(Promise.all([i.e(86083), i.e(71745)]).then(i.bind(i, 247815))),
                    this._lollipopSourcesWatcherLoader.callFunction((e=>{
                        this._lollipopSourcesWatcher = new e.LollipopSourcesWatcher(this)
                    }
                    )))
                }
            }
            _updateDateTimeFormatter() {
                const e = qt.dateFormatProperty.value()
                  , t = this.onWidget() ? void 0 : di.withWeekdayProperty.value();
                if (this._dateFormatter = new jt.DateFormatter(e,t),
                this.mainSeries().isDWM())
                    this._dateTimeFormatter = new jt.DateFormatter(e,t),
                    this._timeFormatter = new Dt.TimeFormatter((0,
                    Nt.getHourMinuteFormat)(kt.timeHoursFormatProperty.value()));
                else {
                    const i = L.Interval.parse(this.mainSeries().interval())
                      , s = (0,
                    Nt.getTimeFormatForInterval)(i, kt.timeHoursFormatProperty.value());
                    this._dateTimeFormatter = new Gt.DateTimeFormatter({
                        dateFormat: e,
                        withWeekday: t,
                        timeFormat: s,
                        dateTimeSeparator: "   "
                    }),
                    this._timeFormatter = new Dt.TimeFormatter(s)
                }
            }
            _invalidationMaskForSource(e, t=X.InvalidationLevel.Light) {
                if (e === this.crossHairSource())
                    return X.InvalidationMask.cursor();
                if (this._watermarkSource === e)
                    return this._paneInvalidationMask((0,
                    r.ensureNotNull)(this.paneForSource(this.mainSeries())), t);
                if (-1 !== this._allCustomSources.indexOf(e)) {
                    const e = new X.InvalidationMask;
                    return e.invalidateAll(t),
                    e
                }
                if (!(0,
                y.isDataSource)(e))
                    return null;
                if (e.isMultiPaneEnabled())
                    return new X.InvalidationMask(t);
                const i = this.paneForSource(e);
                return null !== i ? this._paneInvalidationMask(i, t) : null
            }
            _paneInvalidationMask(e, t=X.InvalidationLevel.Light) {
                const i = new X.InvalidationMask
                  , s = this._panes.indexOf(e);
                return i.invalidateAllPane(s, t),
                i
            }
            _invalidationMaskForSourcePriceScale(e, t=X.InvalidationLevel.Light) {
                if (!(0,
                y.isDataSource)(e))
                    return new X.InvalidationMask(t);
                const i = this.paneForSource(e);
                if (null === i)
                    return null;
                let s = e.priceScale();
                if (null === s)
                    return null;
                const o = this._panes.indexOf(i);
                let n = i.priceScalePosition(s);
                if ("overlay" === n) {
                    const e = this._panes[o].defaultPriceScale();
                    s = e,
                    n = i.priceScalePosition(e)
                }
                const r = i.priceScaleIndex(s, n);
                if (void 0 === r)
                    return null;
                const a = new X.InvalidationMask;
                return a.invalidatePriceScale(o, n, r, t),
                a
            }
            _removeCustomSource(e) {
                const t = this._customSourcesMap.get(e);
                if (void 0 === t)
                    return void to.logWarn(`Attempt to remove custom source which does not exist in the model - "${e}"`);
                to.logNormal(`Removing custom source "${e}"`),
                this.selectionMacro((e=>{
                    e.removeSourceFromSelection(t)
                }
                )),
                this._hoveredSource === t && this.setHoveredSource(null),
                this._customSourceBeingMoved === t && this.setMovingCustomSource(null, null);
                const i = io(this._bgCustomSources, t)
                  , s = io(this._fgCustomSources, t)
                  , o = io(this._topmostCustomSources, t)
                  , n = io(this._allCustomSources, t);
                (0,
                r.assert)(i || s || o, "Source should be presented in one of the layers"),
                (0,
                r.assert)(n, "Source should be presented in the array"),
                this._customSourcesMap.delete(e),
                t.destroy()
            }
            _updateShowLegendProperty() {
                const e = this._properties.childs().paneProperties.childs().legendProperties.childs().showLegend
                  , t = this._showLegendProperty;
                if (e.value())
                    t.setValue(!0);
                else {
                    for (const e of this._panes) {
                        let i = 0;
                        for (const s of e.priceDataSources())
                            if (null !== s.statusView() && (i++,
                            i >= 2))
                                return void t.setValue(!1)
                    }
                    t.setValue(!0)
                }
            }
            _pointToPercentPosition(e, t) {
                return {
                    x: e.x / this._timeScale.width(),
                    y: e.y / (0,
                    r.ensureNotNull)((0,
                    r.ensureNotNull)(t.mainDataSource()).priceScale()).height()
                }
            }
            _percentPositionToPoint(e, t) {
                const i = e.x * this._timeScale.width()
                  , s = e.y * (0,
                r.ensureNotNull)((0,
                r.ensureNotNull)(t.mainDataSource()).priceScale()).height();
                return new a.Point(i,s)
            }
            _recalcVisibleRangeStudiesImpl(e) {
                var t, i;
                if (!this.m_mainSeries.isStarted() || !this.m_mainSeries.isCompleted())
                    return void this._visibleRangeStudiesInputs.setValue(null);
                if (this.timeScale().isEmpty())
                    return;
                const s = this.timeScale().visibleBarsStrictRange();
                if (null === s)
                    return;
                const o = this.m_mainSeries.bars()
                  , n = o.search(s.firstBar(), Bt.PlotRowSearchMode.NearestRight)
                  , r = o.search(s.lastBar(), Bt.PlotRowSearchMode.NearestLeft)
                  , a = o.lastIndex()
                  , l = n ? n.index : void 0
                  , c = r ? r.index : void 0
                  , d = l === e.oldStartVisibleIndex
                  , u = c === e.oldEndVisibleIndex
                  , h = [b.RecalcVisibleRangeStudiesReason.SeriesRestart, b.RecalcVisibleRangeStudiesReason.SeriesCompleted, b.RecalcVisibleRangeStudiesReason.StudyCreation].some((t=>e.reasons.has(t)));
                d && u && !h || (e.reasons.clear(),
                e.oldStartVisibleIndex = void 0 !== l ? l : NaN,
                e.oldEndVisibleIndex = void 0 !== c ? c : NaN,
                this._visibleRangeStudiesInputs.setValue({
                    firstVisibleBarTime: 1e3 * (null !== (t = null == n ? void 0 : n.value[0]) && void 0 !== t ? t : 0),
                    lastVisibleBarTime: 1e3 * (null !== (i = null == r ? void 0 : r.value[0]) && void 0 !== i ? i : 0),
                    subscribeRealtime: (null == r ? void 0 : r.index) === a
                }))
            }
            _recalcColorStudiesImpl(e) {
                var t;
                const i = this.backgroundColorAtYPercentFromTop(.5)
                  , s = this.dark().value() ? c.colorsPalette["color-cold-gray-200"] : c.colorsPalette["color-cold-gray-900"]
                  , o = i === e.oldBgColor
                  , n = s === e.oldFgColor;
                if (o && n && !e.force)
                    return;
                e.force = !1,
                e.oldBgColor = i,
                e.oldFgColor = s;
                const r = null !== (t = e.studies) && void 0 !== t ? t : this.priceDataSources();
                e.studies = void 0;
                for (const e of r)
                    if ((0,
                    U.isStudy)(e)) {
                        const t = e.metaInfo().inputs.filter(M.isStudyInputDependsOnChartColors)
                          , o = e.properties().childs().inputs;
                        t.forEach((e=>{
                            const t = e.id === M.ChartColorDependentStudyInputNames.FgColor ? s : i;
                            o.childs()[e.id].setValueSilently(t)
                        }
                        )),
                        t.length > 0 && o.listeners().fire(o, "")
                    }
            }
            _getAllSources(e) {
                const t = [];
                for (const i of this._panes) {
                    const s = i.sourcesByGroup().allWithoutMultipane();
                    for (const i of s)
                        e(i) && t.push(i)
                }
                return t
            }
            _invalidateBarColorerCaches() {
                this.mainSeries().invalidateBarColorerCache()
            }
            _addAlertLabelToChart(e) {
                {
                    const t = e.seriesId();
                    if (null === t)
                        return;
                    (0,
                    r.ensureNotNull)(this.alertsWatcher()).addAlert(e, t)
                }
            }
            _removeAlertLabelFromChart(e) {
                (0,
                r.ensureNotNull)(this.alertsWatcher()).removeAlert(e)
            }
            _removeAllAlertLabelsFromChart() {
                (0,
                r.ensureNotNull)(this.alertsWatcher()).removeAllAlertLabels()
            }
            _updateTimeScale(e) {
                var t, i, s, o;
                const {index: n, zoffset: r, values: a, indexDiffs: l, baseIndex: c, marks: d, clearFlag: u} = e;
                if (u) {
                    this._timeScale.reset();
                    for (const e of this.dataSources())
                        null === (t = e.clearData) || void 0 === t || t.call(e)
                }
                if (l.length > 0)
                    for (const e of this.dataSources())
                        null === (i = e.moveData) || void 0 === i || i.call(e, l);
                const h = this._timeScale.indexToTimePoint(this._timeScale.baseIndex())
                  , p = this._timeScale.canNormalize();
                this._timeScale.update(n, r, a, d);
                const m = this._timeScale.points().range().value();
                let g = "ChartModel.prototype._updateTimeScale(" + n + "," + r + "," + a.length + "," + l.length + "," + d.length + "," + u + ")";
                if (g += "TimeScale: {first:" + (null !== (s = null == m ? void 0 : m.firstIndex) && void 0 !== s ? s : null) + ",last:" + (null !== (o = null == m ? void 0 : m.lastIndex) && void 0 !== o ? o : null) + "}",
                null === c) {
                    this._timeScale.resetBaseIndex();
                    const e = this._timeScale.rightOffset();
                    this._timeScale.setRightOffset(Math.max(e, this._cachedStudiesMaxOffset))
                } else if (void 0 !== c) {
                    const e = this._timeScale.indexToTimePoint(c)
                      , t = null !== h && null !== e && e > h;
                    this._updateBaseIndex(c, t)
                }
                if (to.logDebug(g),
                !p && p !== this._timeScale.canNormalize())
                    for (const e of this.dataSources())
                        !(0,
                        T.isLineTool)(e) || e.isFixed() || e.isSourceHidden() || e.processHibernate();
                for (const e of this.dataSources())
                    e.updateAllViews({
                        type: "data-source-change",
                        sourceId: e.id(),
                        clearData: !0
                    });
                this.recalculateAllPanes((0,
                dt.globalChangeEvent)()),
                this.lightUpdate()
            }
            _getAvailableCurrencies() {
                return !this.currencyConversionEnabled() || this.isSnapshot() ? [] : (0,
                ve.isArray)(this._availableCurrenciesList) ? this._availableCurrenciesList : (null !== this._availableCurrenciesList || (this._availableCurrenciesList = this.chartApi().availableCurrencies(),
                this._availableCurrenciesList.then((e=>{
                    this._destroyed || (this._availableCurrenciesList = e,
                    this.fullUpdate())
                }
                )).catch((e=>{
                    to.logWarn(`An error occurred while getting currencies config: ${e}`)
                }
                ))),
                [])
            }
            _getAvailableUnits() {
                return !this.unitConversionEnabled() || this.isSnapshot() ? {} : this._availableUnitsObject instanceof Promise || null === this._availableUnitsObject ? (null !== this._availableUnitsObject || (this._availableUnitsObject = this.chartApi().availableUnits(),
                this._availableUnitsObject.then((e=>{
                    this._destroyed || (this._availableUnitsObject = e,
                    this.fullUpdate())
                }
                )).catch((e=>{
                    to.logWarn(`An error occurred while getting units config: ${e}`)
                }
                ))),
                {}) : this._availableUnitsObject
            }
            _getAvailablePriceSources(e) {
                const t = this._availablePriceSourcesBySymbol.get(e);
                if (Array.isArray(t))
                    return t;
                if ((0,
                ve.isPromise)(t))
                    return [];
                const i = this.chartApi().availablePriceSources(e);
                return this._availablePriceSourcesBySymbol.set(e, i),
                i.then((t=>{
                    this._destroyed || (this._availablePriceSourcesBySymbol.set(e, t),
                    this.fullUpdate())
                }
                )).catch((e=>{
                    to.logWarn(`An error occurred while getting price sources config: ${e}`)
                }
                )),
                []
            }
            _clearAvailablePriceSources() {
                this._availablePriceSourcesBySymbol.clear()
            }
            _onSymbolIntervalChanged() {
                this._symbolIntervalChanged.fire()
            }
            _getBackgroundColor(e) {
                const t = this._properties.childs().paneProperties.childs();
                if (t.backgroundType.value() === Si.ColorType.Gradient) {
                    const i = t.backgroundGradientStartColor.value()
                      , s = t.backgroundGradientEndColor.value();
                    return function(e, t, i) {
                        if ((0,
                        h.getCurrentTheme)().name === p.StdTheme.Dark && (0,
                        ii.isOnMobileAppPage)("any") && (0,
                        h.isStdThemedDefaultValue)("chartProperties.paneProperties.backgroundGradientStartColor", e, p.StdTheme.Dark) && (0,
                        h.isStdThemedDefaultValue)("chartProperties.paneProperties.backgroundGradientEndColor", t, p.StdTheme.Dark))
                            return si;
                        return i ? e : t
                    }(i, s, Boolean(e))
                }
                const i = t.background.value();
                return function(e) {
                    if ((0,
                    h.getCurrentTheme)().name === p.StdTheme.Dark && (0,
                    ii.isOnMobileAppPage)("any") && (0,
                    h.isStdThemedDefaultValue)("chartProperties.paneProperties.background", e, p.StdTheme.Dark))
                        return si;
                    return e
                }(i)
            }
            _getBackgroundCounterColor() {
                const e = this.backgroundColor().value();
                return "black" === (0,
                l.rgbToBlackWhiteString)((0,
                l.parseRgb)(e), 150) ? "white" : "black"
            }
            _updateBackgroundColor() {
                this._backgroundColor.setValue(this._getBackgroundColor()),
                this._backgroundTopColor.setValue(this._getBackgroundColor(!0))
            }
            _syncCrosshair(e) {
                if (!this._isSettingsExternalPosition) {
                    const t = this._undoModel.mainSeries()
                      , i = t.syncModel()
                      , s = this._undoModel.crossHairSource()
                      , o = s.pane;
                    if (null !== i && null !== o) {
                        const n = {
                            timeStamp: this._timeScale.points().roughTime(s.index, i.projectTime.bind(i)),
                            syncSourceTarget: i.syncSourceTarget()
                        };
                        o.mainDataSource() === t && (n.price = s.price,
                        n.symbol = t.symbol());
                        let r = this._lineBeingCreated || null !== this._linePointBeingEdited || Boolean(this._sourcesBeingMoved.length);
                        r = r && (0,
                        Ge.drawOnAllCharts)().value(),
                        this._undoModel.syncCrosshair(n, r, e)
                    }
                    this._phantomSourceContainer.onCursorPositionUpdated()
                }
            }
            _gotoTimeImpl(e, t) {
                const i = this.timeScale()
                  , s = this.mainSeries();
                let o;
                if (void 0 !== e) {
                    if (this._scrollingState && this._scrollingState.deferred.reject(),
                    o = (0,
                    _.createDeferredPromise)(),
                    o.promise.catch((()=>{}
                    )),
                    !s.isDWM()) {
                        const t = s.symbolInfo();
                        if (null !== t) {
                            const i = (0,
                            r.ensureNotNull)(this.timezoneExceptExchange().value())
                              , o = (0,
                            Yt.cal_to_utc)((0,
                            Yt.get_timezone)(i), new Date(e))
                              , n = (0,
                            Ii.createTimeToBarTimeAligner)(s.interval(), t)(o);
                            e = (0,
                            Yt.utc_to_cal)((0,
                            Yt.get_timezone)(i), n).getTime()
                        }
                    }
                    this._scrollingState = {
                        targetDate: e,
                        deferred: o,
                        centerIfVisible: t.centerIfVisible
                    }
                } else {
                    if (!this._scrollingState)
                        return to.logError("scrollTo called without an argument"),
                        Promise.reject();
                    e = this._scrollingState.targetDate,
                    o = this._scrollingState.deferred
                }
                if (void 0 === i.tickMarks().minIndex)
                    return o.resolve(void 0),
                    o.promise;
                this.stopTimeScaleAnimation();
                let n = ((e,t)=>{
                    if ((e=>(0,
                    r.ensureNotNull)(i.tickMarks().indexToTime((0,
                    r.ensureDefined)(i.tickMarks().minIndex))).valueOf() - e)(t) < 0) {
                        let o = i.tickMarks().nearestIndex(t);
                        const n = s.bars().lastIndex();
                        if (null === n)
                            return null;
                        o = Math.min(o, n);
                        let a = (0,
                        r.ensureNotNull)(i.tickMarks().indexToTime(o)).valueOf();
                        for (; a < t && o < n; )
                            o++,
                            a = (0,
                            r.ensureNotNull)(i.tickMarks().indexToTime(o)).valueOf();
                        const l = (0,
                        r.ensureNotNull)(i.visibleBarsStrictRange());
                        if (e || !l.contains(o)) {
                            const e = i.width()
                              , t = i.indexToCoordinate(o)
                              , s = i.coordinateToFloatIndex(t + e / 2) - .5
                              , n = Math.min(s, i.coordinateToFloatIndex(t - e / 2) + .5);
                            i.zoomToBarsRange(n, s)
                        }
                        return {
                            timestamp: (0,
                            r.ensureNotNull)(i.indexToTimePoint(o))
                        }
                    }
                    return null
                }
                )(this._scrollingState.centerIfVisible, this._scrollingState.targetDate);
                if (!n) {
                    const t = (0,
                    r.ensureDefined)(i.tickMarks().minIndex)
                      , o = (0,
                    r.ensureNotNull)(i.visibleBarsStrictRange())
                      , a = o.lastBar() - o.firstBar();
                    if (s.requestMoreDataAvailable()) {
                        const t = i.tickMarks().estimateLeft(e);
                        i.requestMoreHistoryPoints(Math.ceil(t + a / 2))
                    } else
                        i.zoomToBarsRange(t - a / 2, t + a / 2),
                        n = {
                            timestamp: (0,
                            r.ensureNotNull)(i.indexToTimePoint(t)),
                            eod: !0
                        }
                }
                if (n) {
                    if (this._scrollingState.centerIfVisible) {
                        const e = (0,
                        r.ensureNotNull)(i.visibleBarsStrictRange());
                        for (const t of this.panes()) {
                            for (const i of t.leftPriceScales())
                                i.recalculatePriceRange(e);
                            for (const i of t.rightPriceScales())
                                i.recalculatePriceRange(e)
                        }
                    }
                    this.fullUpdate(),
                    this._scrollingState = null,
                    o.resolve(n)
                }
                return o.promise
            }
            _setCorrectedPositionToCrosshair(e, t, i) {
                this.crossHairSource().setPosition(e, t, i)
            }
            _onSymbolSourceCollectionChanged(e) {
                this._clearAvailablePriceSources(),
                this._recalcAdjustForDividendsAvailability(),
                this._symbolSourceCollectionChanged.fire(e)
            }
            _onPriceSourcesCollectionChanged(e) {
                this._panes.some((e=>e.hasDataSource(this.m_mainSeries))) && (this._studiesWV.setValue(this.allStudies()),
                this._studiesExcludeInternalWV.setValue(this.allStudies(!0)))
            }
            _unmergeAvailable(e) {
                return e === this.m_mainSeries || (0,
                U.isStudy)(e) && !e.isLinkedToSeries() && !(0,
                Ks.isNonSeriesStudy)(e) && e.showInObjectTree()
            }
            _getExceedingChildStudies(e) {
                var t, i;
                let s = [];
                for (let t = 0; t < e.length; ++t)
                    s = s.concat(e[t].sources || []);
                let o = 0
                  , n = 1;
                n = null !== (i = null === (t = (0,
                ci.getConfig)("STUDY_ON_STUDY")) || void 0 === t ? void 0 : t.child_limit) && void 0 !== i ? i : 1;
                const r = []
                  , a = {};
                let l = 0
                  , c = 1e6;
                for (; s.length && --c; ) {
                    const e = s[l];
                    (e.ownerSource && a[e.ownerSource] || !e.ownerSource) && (a[e.id] = e,
                    s.splice(s.indexOf(e), 1),
                    e.ownerSource && (0,
                    Qe.isStudyState)(e) && e.state && e.state.isChildStudy && ++o > n && r.push(e)),
                    l = (l + 1) % s.length
                }
                return r
            }
        }
    }
    ,
    7462: (e,t,i)=>{
        "use strict";
        var s = i(650151).assert
          , o = i(647042).ChartModelBase
          , n = i(465836).isLineTool
          , r = i(638456).CheckMobile
          , a = i(472512).InvalidationLevel;
        i(942634).Delegate;
        const {sourceChangeEvent: l} = i(169532);
        var c = i(434396).isStudy
          , d = i(419283)
          , u = i(866321).MainSeriesScaleRatioProperty
          , h = i(134392).scaleRatio
          , p = i(590250).dateFormatProperty
          , m = i(220003).timeHoursFormatProperty
          , g = i(251954)
          , _ = i(252767).StudyColorRotatorFactory
          , v = i(953297)
          , S = i(436207).AppliedTimeFrame
          , f = v.enabled("fix_left_edge");
        class b extends o {
            constructor(e, t, i, s, o, n, r, a, l, c) {
                super(e, t, i, s, o, n, r, a, l, c);
                var h = this;
                this._mainSeriesScaleRatioProperty = new u(this),
                this.m_mainSeries.dataEvents().completed().subscribe(this, function() {
                    if (this._scrollingState && this.gotoTime(),
                    f && !this.m_mainSeries.requestMoreDataAvailable()) {
                        var e = this.m_mainSeries.bars().first();
                        null !== e && this._timeScale.setLeftEdgeFix(e.index)
                    }
                }
                .bind(this)),
                this.m_mainSeries.onIntervalChanged().subscribe(this, (function() {
                    this._recalcVRStudiesParams.oldStartVisibleIndex = NaN,
                    this._recalcVRStudiesParams.oldEndVisibleIndex = NaN
                }
                )),
                this.m_mainSeries.dataEvents().barReceived().subscribe(this, b.prototype.updateTimeScaleBaseIndex),
                this._readOnly || (this.m_mainSeries.properties().addChild("priceAxisProperties", this.m_mainSeries.priceScale().properties()),
                this._properties.paneProperties.legendProperties.showStudyTitles.listeners().subscribe(this, (function(e) {
                    e.value() || h._properties.paneProperties.legendProperties.showStudyArguments.setValue(!1)
                }
                ))),
                d.hideAllDrawings().subscribe(this, this._onDrawingsVisibilityChanged),
                d.hideAllIndicators().subscribe(this, this._onIndicatorsVisibilityChanged),
                this._properties.scalesProperties.listeners().subscribe(this, b.prototype.fullUpdate),
                this._studyShiftColorStartOffset = void 0,
                p.subscribe(this, this._updateDateTimeFormatter),
                m.subscribe(this, this._updateDateTimeFormatter),
                this.mainSeries().properties().interval.subscribe(this, this._updateDateTimeFormatter),
                this._updateDateTimeFormatter(),
                this._studyColorRotatorFactory = new _(this),
                this._undoModel._chartWidget.onWidget() || this._initAlertsList(),
                this._dataSourceCollectionChanged.subscribe(this, this._updateShowLegendProperty.bind(this)),
                this._properties.paneProperties.legendProperties.showLegend.subscribe(this, this._updateShowLegendProperty),
                this._appliedTimeFrame = new S(this),
                this.mainSeries().onTimeFrameApplied().subscribe(this, (function(e) {
                    var t = null !== e ? {
                        res: this.mainSeries().interval(),
                        val: e
                    } : null;
                    this.appliedTimeFrame().setValue(t)
                }
                ))
            }
            startNotStartedStudies() {
                if (!this.m_mainSeries.isStarted())
                    throw new Error("Cannot start studies: main series is not started");
                for (var e = this.dataSources(), t = 0; t < e.length; t++)
                    c(e[t]) && !e[t].isStarted() && e[t].restart && e[t] !== this.m_mainSeries && e[t].restart()
            }
            _onDrawingsVisibilityChanged(e) {
                for (var t = !1 === e.value(), i = this.dataSources(), s = 0; s < i.length; s++) {
                    var o = i[s]
                      , r = n(o) && o.properties().visible.value();
                    t && r ? g.emit("drawing_event", o.id(), "show") : !t && r && g.emit("drawing_event", o.id(), "hide")
                }
                this.selectionMacro((function(e) {
                    e.clearSelection()
                }
                ))
            }
            _onIndicatorsVisibilityChanged() {
                var e = this.allStudies().filter((function(e) {
                    return e.properties().visible.value() && e.canBeHiddenByGlobalFlag()
                }
                ));
                if (0 !== e.length) {
                    for (var t = !1, i = 0; i < e.length; i++)
                        if (this.selection().isSelected(e[i])) {
                            t = !0;
                            break
                        }
                    t ? this.selectionMacro((function(e) {
                        e.clearSelection()
                    }
                    )) : this.lightUpdate()
                }
            }
            priceScaleSlotsCount() {
                var e = 0
                  , t = 0;
                this._panes.forEach((function(i) {
                    e = Math.max(i.leftPriceScales().length, e),
                    t = Math.max(i.rightPriceScales().length, t)
                }
                ));
                var i = e + t;
                if (r.any()) {
                    var s = this.paneForSource(this.mainSeries())
                      , o = s.priceScalePosition(this.mainSeries().priceScale())
                      , n = "right" === o;
                    return "overlay" === o && (n = s.rightPriceScales().length > 0),
                    n ? {
                        left: 0,
                        right: 1,
                        totallySlots: i
                    } : {
                        left: 1,
                        right: 0,
                        totallySlots: i
                    }
                }
                return {
                    left: e,
                    right: t,
                    totallySlots: e + t
                }
            }
            setPriceAutoScale(e, t, i) {
                e.setPriceAutoScale(t, i),
                this.invalidate(this._paneInvalidationMask(e, a.Light))
            }
            updateScales(e, t) {
                this._undoModel._chartWidget._updateScalesActions()
            }
            mainSeriesScaleRatioProperty() {
                return this._mainSeriesScaleRatioProperty
            }
            mainSeriesScaleRatioPropertyOnChanged() {
                this._mainSeriesScaleRatioProperty.listeners().fire(this._mainSeriesScaleRatioProperty)
            }
            mainSeriesScaleRatio() {
                return h(this._timeScale, this.m_mainSeries.priceScale())
            }
            setMainSeriesScaleRatio(e) {
                this.paneForSource(this.m_mainSeries).applyPriceScaleRatio(this.m_mainSeries.priceScale(), e)
            }
            dataSourceForId(e) {
                for (var t, i = 0; i < this._panes.length; ++i)
                    if (t = this._panes[i].dataSourceForId(e))
                        return t;
                return null
            }
            onSyncScrollNeeded(e) {
                var t = this._undoModel._chartWidget;
                if (t._chartWidgetCollection) {
                    var i = this.mainSeries().syncModel();
                    if (i) {
                        var s = 1e3 * this._timeScale.points().roughTime(e, i.projectTime.bind(i));
                        t._chartWidgetCollection.syncScroll(s, this)
                    }
                }
            }
            calculateDefaultTags() {
                for (var e = [], t = this.dataSources(), i = 0; i < t.length; i++) {
                    var s = t[i];
                    s.tags && (e = e.concat(s.tags()))
                }
                return e
            }
            _sendTo(e, t) {
                var i = {}
                  , s = this;
                for (var o in e.forEach((function(e) {
                    var t = s.paneForSource(e)
                      , o = s._panes.indexOf(t);
                    i[o] || (i[o] = []),
                    i[o].push(e)
                }
                )),
                i) {
                    t(s._panes[o], i[o])
                }
                this.fullUpdate()
            }
            sendToBack(e) {
                this._sendTo(e, (function(e, t) {
                    e.sendToBack(t)
                }
                ))
            }
            bringToFront(e) {
                this._sendTo(e, (function(e, t) {
                    e.bringToFront(t)
                }
                ))
            }
            destroy() {
                this.mainSeries().properties().childs().showCountdown.unsubscribeAll(this),
                this.mainSeries().onTimeFrameApplied().unsubscribeAll(this),
                this.mainSeries().onIntervalChanged().unsubscribeAll(this),
                this._appliedTimeFrame.destroy(),
                this.clearIntervals(),
                d.hideAllDrawings().unsubscribe(this, this._onDrawingsVisibilityChanged),
                d.hideAllIndicators().unsubscribe(this, this._onIndicatorsVisibilityChanged),
                this.resetDeferredStudies(),
                this.allStudies().forEach((e=>this.removeSource(e))),
                Array.from(this._customSourcesMap.keys()).forEach(this._removeCustomSource, this),
                s(0 === this._topmostCustomSources.length),
                s(0 === this._fgCustomSources.length),
                s(0 === this._bgCustomSources.length),
                s(0 === this._allCustomSources.length),
                s(0 === this._customSourcesMap.size);
                for (var e = 0; e < this._panes.length; e++)
                    this._panes[e].destroy();
                this._panes.length = 0,
                this._sessions = null,
                this.m_mainSeries.onStyleChanged().unsubscribe(this._timeScale, this._timeScale.invalidateVisibleBars),
                this._timeScale.visibleBarsStrictRangeChanged().unsubscribe(this.m_mainSeries, this.m_mainSeries.clearHighLowPriceCache),
                this._timeScale.visibleBarsStrictRangeChanged().unsubscribe(this.m_mainSeries, this.m_mainSeries.clearAveragePriceCache),
                this._timeScale.barSpacingChanged().unsubscribeAll(this),
                this._timeScale.onScroll().unsubscribeAll(this),
                this._timeScale.destroy(),
                p.unsubscribe(this, this._updateDateTimeFormatter),
                m.unsubscribe(this, this._updateDateTimeFormatter),
                this.mainSeries().properties().interval.unsubscribe(this, this._updateDateTimeFormatter),
                this._trendLineStatsCache && this._trendLineStatsCache.destroy(),
                this._fibRetracementLabelsCache && this._fibRetracementLabelsCache.destroy(),
                this._properties.paneProperties.legendProperties.showLegend.unsubscribeAll(this),
                this._dataSourceCollectionChanged.unsubscribeAll(this),
                this.m_crossHairSource.destroy(),
                super.destroy()
            }
            restoreSource(e, t, i, s, o) {
                var n, r;
                n = e ? this.createPane(t) : this.panes()[t];
                var a = s.type.toLowerCase().startsWith("study");
                if (!(r = a ? n.restoreStudy(s) : n.restoreLineTool(s)))
                    return null;
                var c = null;
                if (o ? c = n.getPriceScaleById(o.id) : r.ownerSource() && (c = r.ownerSource().priceScale()),
                c)
                    r.setPriceScale(c),
                    c.addDataSource(r);
                else {
                    c = n.createPriceScaleAtPosition(o.position, o.priceScaleIndex);
                    o && o.id && c.setId(o.id),
                    r.setPriceScale(c),
                    c.addDataSource(r)
                }
                if (!e && i && i.overlayPriceScales) {
                    var d = this.dataSources().filter((function(e) {
                        return void 0 !== i.overlayPriceScales[e.id()]
                    }
                    ));
                    d.forEach(n.removeSourceFromPriceScale.bind(n));
                    var u = new Map;
                    d.forEach((function(e) {
                        var t, s = i.overlayPriceScales[e.id()];
                        u.has(s.id) ? t = u.get(s.id) : ((t = n.createPriceScaleAtPosition("overlay")).restoreState(s),
                        u.set(s.id, t)),
                        t.addDataSource(e),
                        e.setPriceScale(t)
                    }
                    ))
                }
                return r.start(),
                r.restore && r.restore(),
                e && n.restoreState({
                    state: i,
                    withData: !1,
                    version: this.version()
                }),
                a && (this.recalculateAllPanes(l(r.id())),
                this.mainSeries().invalidateBarColorerCache(),
                this.fullUpdate()),
                a && this.alertsWatcher().syncSourceAlertLabels(r),
                r
            }
            getStudyShiftColorStartOffset() {
                return this._studyShiftColorStartOffset
            }
            setStudyShiftColorStartOffset(e) {
                this._studyShiftColorStartOffset = e
            }
            onInReplayStateChanged() {
                return this.m_mainSeries.onInReplayStateChanged()
            }
            isPriceScaleVisible(e) {
                var t = this.paneForSource(e.mainSource())
                  , i = t.priceScalePosition(e);
                if ("overlay" === i)
                    return !0;
                var s = this.priceScaleSlotsCount();
                return t.priceScaleIndex(e, i) < s[i]
            }
            studiesColorRotatorFactory() {
                return this._studyColorRotatorFactory
            }
        }
        e.exports = b
    }
    ,
    615914: (e,t,i)=>{
        "use strict";
        i.d(t, {
            sourceNewCurrencyOnPinningToPriceScale: ()=>o
        });
        var s = i(487945);
        function o(e, t, i, o) {
            let n = null;
            if (i.currencyConversionEnabled() && (0,
            s.isActingAsSymbolSource)(e)) {
                const s = i.availableCurrencies()
                  , r = t.currency(s)
                  , a = e.currency();
                null !== r && null !== r.selectedCurrency && !r.allCurrenciesAreOriginal && r.selectedCurrency !== a && (o && null === a || null !== a && s.convertible(a)) && (n = r.selectedCurrency)
            }
            return n
        }
    }
    ,
    590250: (e,t,i)=>{
        "use strict";
        i.d(t, {
            dateFormatProperty: ()=>l,
            restoreDateFormatSettingsValue: ()=>c
        });
        var s = i(62802)
          , o = i(998418)
          , n = i(246125);
        const r = "date_format";
        function a() {
            return s.getValue(r, (0,
            n.defaultDateFormat)())
        }
        const l = (0,
        o.createPrimitiveProperty)(a());
        function c() {
            l.setValue((0,
            n.defaultDateFormat)()),
            s.remove(r)
        }
        s.onSync.subscribe(null, (()=>l.setValue(a()))),
        l.subscribe(null, (()=>s.setValue(r, l.value())))
    }
    ,
    336068: (e,t,i)=>{
        "use strict";
        i.d(t, {
            DeferredStudies: ()=>r
        });
        var s = i(955273);
        const o = []
          , n = [];
        class r {
            constructor(e) {
                this._studies = {},
                this._deferreds = {},
                this._container = e,
                o.push(e),
                n.push(this)
            }
            add(e, t) {
                this._deferreds[e] && (this._deferreds[e].resolve(t),
                delete this._deferreds[e]),
                this._studies[e] = t
            }
            get(e) {
                return this._studies[e] ? Promise.resolve(this._studies[e]) : (this._deferreds[e] || (this._deferreds[e] = (0,
                s.createDeferredPromise)()),
                this._deferreds[e].promise)
            }
            delete(e) {
                delete this._studies[e],
                delete this._deferreds[e]
            }
            reset() {
                const e = o.indexOf(this._container);
                ~e && (o.splice(e, 1),
                n.splice(e, 1))
            }
            static instance(e) {
                const t = o.indexOf(e);
                return ~t ? n[t] : new r(e)
            }
            static ready() {
                for (const e of n)
                    if (Object.keys(e._deferreds).length > 0)
                        return !1;
                return !0
            }
        }
    }
    ,
    970427: (e,t,i)=>{
        "use strict";
        i.d(t, {
            EnvironmentState: ()=>o
        });
        var s = i(638456);
        class o {
            constructor(e, t=!1) {
                this._shift = !1,
                this._mod = !1,
                this._alt = !1,
                void 0 !== e && (this._shift = Boolean(e.shiftKey),
                this._mod = Boolean((0,
                s.isMac)() ? e.metaKey : e.ctrlKey),
                this._alt = Boolean(e.altKey)),
                this._isApiEvent = t
            }
            shift() {
                return this._shift
            }
            mod() {
                return this._mod
            }
            alt() {
                return this._alt
            }
            shiftOnly() {
                return this._shift && !this._mod && !this._alt
            }
            modOnly() {
                return this._mod && !this._shift && !this._alt
            }
            altOnly() {
                return this._alt && !this._shift && !this._mod
            }
            modShift() {
                return this._shift && this._mod && !this._alt
            }
            isApiEvent() {
                return this._isApiEvent
            }
            static create(e=!1, t=!1, i=!1) {
                return new o({
                    shiftKey: e,
                    ctrlKey: t,
                    metaKey: t,
                    altKey: i
                })
            }
        }
    }
    ,
    319448: (e,t,i)=>{
        "use strict";
        i.d(t, {
            DateTimeFormatter: ()=>r
        });
        var s = i(662445)
          , o = i(553220);
        const n = {
            dateFormat: "yyyy-MM-dd",
            withWeekday: !1,
            timeFormat: s.hourMinuteSecondFormat,
            dateTimeSeparator: " "
        };
        class r {
            constructor(e={}) {
                const t = Object.assign({}, n, e);
                this._dateFormatter = new o.DateFormatter(t.dateFormat,t.withWeekday),
                this._timeFormatter = new s.TimeFormatter(t.timeFormat),
                this._separator = t.dateTimeSeparator
            }
            format(e) {
                return `${this._dateFormatter.format(e)}${this._separator}${this._timeFormatter.format(e)}`
            }
            formatLocal(e) {
                return `${this._dateFormatter.formatLocal(e)}${this._separator}${this._timeFormatter.formatLocal(e)}`
            }
        }
    }
    ,
    430719: (e,t,i)=>{
        "use strict";
        i.d(t, {
            DateTimeWithTzFormatter: ()=>c
        });
        var s = i(601526)
          , o = i(870045)
          , n = i(662445)
          , r = i(319448)
          , a = i(553220);
        const l = {
            dateFormat: "MMM dd",
            timeFormat: n.hourMinuteFormat
        };
        class c {
            constructor(e={}) {
                const {dateFormat: t, timeFormat: i, timezone: s} = {
                    ...l,
                    ...e
                };
                t && i ? this._dateFormatter = new r.DateTimeFormatter({
                    dateFormat: t,
                    timeFormat: i
                }) : t ? this._dateFormatter = new a.DateFormatter(t) : i && (this._dateFormatter = new n.TimeFormatter(i)),
                this._timezone = (0,
                o.get_timezone)(null != s ? s : "Etc/UTC")
            }
            format(e) {
                const t = 1e3 * e
                  , i = (0,
                s.parseTzOffset)(this._timezone.name(), t).string;
                return void 0 === this._dateFormatter ? i : `${this._dateFormatter.format((0,
                o.utc_to_cal)(this._timezone, t))} ${i}`
            }
            setTimezone(e) {
                this._timezone = (0,
                o.get_timezone)(e)
            }
        }
    }
    ,
    212642: (e,t,i)=>{
        "use strict";
        i.d(t, {
            TimeSpanFormatter: ()=>r
        });
        var s = i(444372)
          , o = i(676323)
          , n = i(96900);
        class r {
            format(e, t) {
                const r = e < 0;
                e = Math.abs(e);
                const a = Math.floor(e / 86400);
                e -= 86400 * a;
                const l = Math.floor(e / 3600);
                e -= 3600 * l;
                const c = Math.floor(e / 60);
                e -= 60 * c;
                let d = "";
                if (a) {
                    const e = (0,
                    n.getNumberFormat)(null == t ? void 0 : t.ignoreLocaleNumberFormat);
                    d += (0,
                    o.formatNumber)(a, e) + s.t(null, {
                        context: "dates"
                    }, i(585886)) + " "
                }
                return l && (d += l + s.t(null, {
                    context: "dates"
                }, i(244634)) + " "),
                c && (d += c + s.t(null, {
                    context: "dates"
                }, i(105977)) + " "),
                e && (d += e + s.t(null, {
                    context: "dates"
                }, i(21492)) + " "),
                r && (d = "-" + d),
                d.trim()
            }
        }
    }
    ,
    147117: (e,t,i)=>{
        "use strict";
        i.d(t, {
            FuturesContractExpiration: ()=>O,
            isFuturesContractExpiration: ()=>B
        });
        var s = i(650151)
          , o = i(903424)
          , n = i(343272)
          , r = i(154834)
          , a = i(166770)
          , l = i(86441)
          , c = i(444372)
          , d = i(432059)
          , u = i(694852)
          , h = i(528474)
          , p = i(666574)
          , m = i(511275)
          , g = i(483445)
          , _ = i(509078)
          , v = i(665798)
          , S = i(528390);
        const f = new Path2D("M.18.24a4.78 4.78 0 0 0 .9 4.36c.15.18.32.34.51.5l.52.4-.52.4a3.8 3.8 0 0 0-.52.5 4.78 4.78 0 0 0-.89 4.36c.04.14.16.24.29.24h6.06c.13 0 .25-.1.29-.24a4.78 4.78 0 0 0-.9-4.36 3.8 3.8 0 0 0-.51-.5l-.52-.4.52-.4c.19-.16.36-.32.52-.5A4.78 4.78 0 0 0 6.82.24C6.78.1 6.66 0 6.53 0H.47C.34 0 .22.1.18.24ZM3.5 4.88l1.23-.97a3 3 0 0 0 1.05-2.48H1.22a3 3 0 0 0 1.05 2.48l1.23.97Z");
        class b extends S.LollipopRenderer {
            _drawLollipop(e, t, i) {
                const s = this._data.style;
                e.save(),
                e.translate(t.x, t.y),
                e.scale(i.horizontalPixelRatio, i.verticalPixelRatio),
                e.beginPath(),
                e.strokeStyle = s.outerBorderColor,
                e.lineWidth = 1,
                e.arc(0, 0, 11, 0, 2 * Math.PI),
                e.stroke(),
                e.fillStyle = s.backgroundColor,
                e.beginPath(),
                e.arc(0, 0, 10.5, 0, 2 * Math.PI),
                e.fill(),
                e.translate(-3.5, -5.5),
                e.fillStyle = s.iconColor,
                e.fill(f, "evenodd"),
                e.translate(3.5, 5.5),
                s.borderColor && (e.strokeStyle = s.borderColor,
                e.lineWidth = 1.5,
                (0,
                v.setLineStyle)(e, p.LINESTYLE_SOLID),
                e.beginPath(),
                e.arc(0, 0, 9.75, 0, 2 * Math.PI),
                e.stroke()),
                e.restore()
            }
        }
        var y = i(205144);
        const C = c.t(null, void 0, i(289407))
          , w = c.t(null, void 0, i(260657))
          , T = {
            dark: {
                background: (0,
                a.getHexColorByName)("color-cold-gray-900"),
                foreground: (0,
                a.getHexColorByName)("color-cold-gray-450"),
                foregroundExpired: (0,
                a.getHexColorByName)("color-ripe-red-500")
            },
            light: {
                background: (0,
                a.getHexColorByName)("color-white"),
                foreground: (0,
                a.getHexColorByName)("color-cold-gray-550"),
                foregroundExpired: (0,
                a.getHexColorByName)("color-ripe-red-500")
            }
        }
          , P = {
            barLine: {
                lineStyle: p.LINESTYLE_DASHED,
                lineWidth: 1,
                strokeStyle: ""
            },
            lollipop: {
                width: 21,
                height: 21,
                bottom: 2,
                lineWidth: 1.5,
                strokeStyle: "",
                backgroundColor: "",
                fillCircle: !0,
                fillStyle: "",
                text: {
                    label: "",
                    strokeStyle: "",
                    font: (0,
                    u.makeFont)(12, m.CHART_FONT_FAMILY, "bold")
                }
            },
            iconColor: "",
            backgroundColor: "",
            outerBorderColor: ""
        };
        class x extends g.LollipopPaneView {
            constructor() {
                super(...arguments),
                this._style = (0,
                r.default)(P)
            }
            renderer(e) {
                return this._invalidated && (this._createLollipops(e),
                this._invalidated = !1),
                this._renderer
            }
            getStyle(e) {
                const t = this._model.dark().value() ? T.dark : T.light
                  , i = e.expired ? t.foregroundExpired : t.foreground
                  , s = t.background
                  , o = this._style;
                return e.active ? (o.backgroundColor = i,
                o.iconColor = s,
                o.borderColor = void 0) : (o.iconColor = i,
                o.borderColor = i,
                o.backgroundColor = e.hovered ? (0,
                h.blendColors)(s, (0,
                d.applyAlpha)(i, .15)) : s),
                o.outerBorderColor = s,
                o.barLine.strokeStyle = i,
                o
            }
            _createTooltipContent(e) {
                const t = this._model.dark().value() ? T.dark : T.light
                  , i = e.expired ? t.foregroundExpired : t.foreground;
                return [{
                    type: "common",
                    title: e.expired ? w : C,
                    subTitle: e.expiration,
                    tooltipIcon: y.replace(/currentColor/g, i),
                    style: {
                        color: i
                    }
                }]
            }
            _createRendererForLollipop(e, t) {
                return new b(e,new _.HitTestResult(_.HitTarget.Custom,t),this._textWidthCache)
            }
            _createLollipops(e) {
                const t = this._source.data();
                if (null === t || void 0 === t.index)
                    return;
                const i = this._model.timeScale()
                  , s = super._getY()
                  , o = this._model.hoveredSource() === this._source
                  , n = null !== this.getLastClickedLollipopId()
                  , r = {
                    id: 0,
                    itemIndex: 0,
                    basePoint: (0,
                    l.point)(i.indexToCoordinate(t.index), s),
                    hovered: o,
                    active: n,
                    expiration: t.formattedDate,
                    expired: t.expired,
                    visible: !0
                };
                this._lollipops[0] = r,
                super._createRenderers(e)
            }
        }
        var M = i(870045)
          , I = i(813442)
          , A = i(338619)
          , L = i(658843)
          , E = i(850599);
        const k = (0,
        A.getLogger)("FutureContractExpiration");
        let D = 0;
        let N = 0;
        function B(e) {
            return e instanceof O
        }
        const R = {
            visible: !0
        };
        class O extends o.DataSource {
            constructor(e) {
                super("futures_contract_expiration"),
                this._data = null,
                this._pointsetId = (D += 1,
                `future_expiration_${D}`),
                this._pointsetTurnaround = null,
                this._properties = new L.Property(R),
                this._onConnectionStateChanged = e=>{
                    e ? this._updateData() : this._removePointset()
                }
                ,
                this.setOwnerSource(e.mainSeries()),
                this._model = e,
                this._paneView = new x(e,this,this._showTooltip.bind(this));
                const t = (0,
                s.ensureNotNull)(e.mainSeries().marketStatusModel().futuresContractExpirationTime());
                this._expirationUTCTime = t.utcTime().spawn(),
                this._expired = t.expired().spawn(),
                this._sessionSpec = t.sessionSpec().spawn(),
                this._formattedExpirationDate = ()=>e.dateFormatter().format(t.utcDayStart()),
                this._expirationUTCTime.subscribe((()=>{
                    this._removePointset(),
                    this._updateData(),
                    this._paneView.update(),
                    this._model.updateSource(this)
                }
                )),
                this._expired.subscribe((()=>{
                    null !== this._data && (this._data.expired = this._expired.value(),
                    this._paneView.update(),
                    this._model.updateSource(this))
                }
                ));
                const i = ()=>{
                    this._removePointset(),
                    this._createPointset()
                }
                ;
                this._destroyPropertyBinder = (0,
                E.bindProperties)(e.mainSeries().properties().childs().showFuturesContractExpiration, this._properties.childs().visible),
                e.mainSeries().onIntervalChanged().subscribe(this, i),
                this._sessionSpec.subscribe(i),
                e.chartApi().isConnected().subscribe(this._onConnectionStateChanged),
                this._updateData()
            }
            destroy() {
                this._removePointset(),
                this._model.mainSeries().onIntervalChanged().unsubscribeAll(this),
                this._model.chartApi().isConnected().unsubscribe(this._onConnectionStateChanged),
                this._paneView.destroy(),
                this._expirationUTCTime.destroy(),
                this._expired.destroy(),
                this._sessionSpec.destroy(),
                this._destroyPropertyBinder(),
                super.destroy()
            }
            lollipopsAtIndex(e) {
                return null === this._data || this._data.index !== e ? 0 : 1
            }
            name() {
                return "FuturesContractExpiration"
            }
            properties() {
                return this._properties
            }
            state(e) {
                return null
            }
            paneViews(e) {
                return [this._paneView]
            }
            updateAllViews(e) {
                this._paneView.update()
            }
            data() {
                return this._data
            }
            zorder() {
                return n.sortSourcesPreOrdered.FutureContractExpiration
            }
            onClickOutside(e, t) {
                this._paneView.processClickOutside(e, t)
            }
            preferNoScale() {
                return !0
            }
            showInObjectTree() {
                return !1
            }
            isSavedInStudyTemplates() {
                return !1
            }
            isRemovedByStudyTemplates() {
                return !1
            }
            copiable() {
                return !1
            }
            hasStateForAlert() {
                return !1
            }
            isSavedInChart(e) {
                return !1
            }
            isSpeciallyZOrderedSource() {
                return !0
            }
            isUserDeletable() {
                return !1
            }
            canHaveChildren() {
                return !1
            }
            isIncludedInAutoScale() {
                return !1
            }
            async _showTooltip(e, t, o) {
                const n = this._model
                  , r = this._model.timeScale()
                  , a = [r.onScroll(), r.barSpacingChanged(), n.mainSeries().onSymbolIntervalChanged(), (0,
                s.ensureNotNull)(n.paneForSource(this)).onSizeChanged()]
                  , l = this._paneView.processClickOutside.bind(this._paneView, e)
                  , c = this._paneView.clearLastClicked.bind(this._paneView)
                  , d = o();
                if (null === d)
                    return;
                const {showLollipopTooltip: u} = await Promise.all([i.e(31141), i.e(46445), i.e(93703), i.e(49481), i.e(65857), i.e(36010), i.e(53953), i.e(73399), i.e(2520), i.e(22164), i.e(62564), i.e(58985), i.e(88488), i.e(75826), i.e(40528), i.e(16190), i.e(92115), i.e(67661), i.e(21251), i.e(55057), i.e(52017), i.e(46879), i.e(87393), i.e(18488), i.e(90698), i.e(99693), i.e(66764), i.e(7647), i.e(610), i.e(65642), i.e(18973), i.e(83579), i.e(5820), i.e(25326), i.e(32887), i.e(58156), i.e(32227), i.e(1563), i.e(41282), i.e(91795), i.e(98451), i.e(62316), i.e(64074), i.e(49039)]).then(i.bind(i, 652099));
                u({
                    items: d,
                    position: t,
                    customCloseSubscriptions: a,
                    onClickOutside: l,
                    onCustomClose: c,
                    showScrollFades: !0
                })
            }
            _updateData() {
                const e = this._expirationUTCTime.value();
                if (null === e)
                    return this._data = null,
                    void this._removePointset();
                this._data = {
                    time: e,
                    expired: this._expired.value(),
                    formattedDate: this._formattedExpirationDate()
                },
                this._createPointset()
            }
            _removePointset() {
                if (null !== this._pointsetTurnaround) {
                    const e = this._model.chartApi();
                    e.isConnected().value() && e.removePointset(this._pointsetId),
                    this._pointsetTurnaround = null
                }
            }
            _createPointset() {
                if (null !== this._pointsetTurnaround)
                    return;
                const e = this._model
                  , t = e.chartApi()
                  , i = this._sessionSpec.value();
                if (null === this._data || null === i || !t.isConnected().value())
                    return;
                const o = e.mainSeries();
                if (null === o.symbolInfo())
                    return;
                const n = (0,
                s.ensureNotNull)(e.timezoneExceptExchange().value())
                  , r = M.get_timezone(n);
                this._pointsetTurnaround = (N += 1,
                `t${N}`);
                const a = (0,
                s.ensureNotNull)(o.seriesSource().symbolInstanceId())
                  , l = (0,
                I.getServerInterval)(o.interval());
                let c;
                const d = this._data.time;
                if (o.isDWM()) {
                    const e = new Date(d);
                    i.alignToSessionStart(e),
                    c = [[M.cal_to_utc(r, e) / 1e3, 0]]
                } else
                    c = [[d / 1e3, 0]];
                t.createPointset(this._pointsetId, this._pointsetTurnaround, a, l, c, this._onPointsetResponse.bind(this))
            }
            _onPointsetResponse(e) {
                if ("pointset_error" === e.method) {
                    const [t,i] = e.params;
                    return void (t === this._pointsetId && i === this._pointsetTurnaround && k.logError("Pointset error"))
                }
                const t = e.params;
                t.customId === this._pointsetId && null !== this._data && (this._data.index = 0 === t.plots.length ? void 0 : t.plots[0].value[0],
                this._paneView.update(),
                this._model.updateSource(this))
            }
        }
    }
    ,
    862954: (e,t,i)=>{
        "use strict";
        function s(e) {
            return e && e.lollipopsAtIndex
        }
        i.d(t, {
            isLollipopDataSource: ()=>s
        })
    }
    ,
    803279: (e,t,i)=>{
        "use strict";
        function s(e) {
            return Boolean(e.showInObjectTree)
        }
        i.d(t, {
            isDataSource: ()=>s
        })
    }
    ,
    381350: (e,t,i)=>{
        "use strict";
        i.d(t, {
            KeyFactsTodaySource: ()=>k,
            isKeyFactsTodaySource: ()=>L
        });
        var s = i(650151)
          , o = i(338619)
          , n = i(903424)
          , r = i(658843)
          , a = i(343272)
          , l = i(154834)
          , c = i(166770)
          , d = i(86441)
          , u = i(444372)
          , h = i(528474)
          , p = i(137674)
          , m = i(432059)
          , g = i(694852)
          , _ = i(666574)
          , v = i(511275)
          , S = i(483445)
          , f = i(509078)
          , b = i(665798)
          , y = i(528390);
        const C = new Path2D("M9.18 4.72c.11-.3.53-.3.64 0l.66 1.8a3.38 3.38 0 0 0 2 2l1.8.66c.3.11.3.53 0 .64l-1.8.66a3.38 3.38 0 0 0-2 2l-.66 1.8c-.11.3-.53.3-.64 0l-.66-1.8a3.38 3.38 0 0 0-2-2l-1.8-.66a.34.34 0 0 1 0-.64l1.8-.66a3.38 3.38 0 0 0 2-2l.66-1.8Z");
        class w extends y.LollipopRenderer {
            _drawLollipop(e, t, i) {
                const s = this._data.style;
                e.save(),
                e.translate(t.x, t.y),
                e.scale(i.horizontalPixelRatio, i.verticalPixelRatio),
                e.beginPath(),
                e.strokeStyle = s.outerBorderColor,
                e.lineWidth = 1,
                e.arc(0, 0, 11, 0, 2 * Math.PI),
                e.stroke(),
                e.fillStyle = s.backgroundColor,
                e.beginPath(),
                e.arc(0, 0, 10.5, 0, 2 * Math.PI),
                e.fill(),
                e.translate(-9.5, -9.5),
                e.fillStyle = s.iconColor,
                e.fill(C, "evenodd"),
                e.translate(9.5, 9.5),
                s.borderColor && (e.strokeStyle = s.borderColor,
                e.lineWidth = 1.5,
                (0,
                b.setLineStyle)(e, _.LINESTYLE_SOLID),
                e.beginPath(),
                e.arc(0, 0, 9.75, 0, 2 * Math.PI),
                e.stroke()),
                e.restore()
            }
        }
        var T = i(600459);
        const P = {
            dark: {
                background: (0,
                c.getHexColorByName)("color-cold-gray-900"),
                foreground: (0,
                c.getHexColorByName)("color-deep-blue-a200"),
                activeIcon: (0,
                c.getHexColorByName)("color-deep-blue-50"),
                border: (0,
                c.getHexColorByName)("color-cold-gray-850")
            },
            light: {
                background: (0,
                c.getHexColorByName)("color-white"),
                foreground: (0,
                c.getHexColorByName)("color-deep-blue-a200"),
                activeIcon: (0,
                c.getHexColorByName)("color-deep-blue-50"),
                border: (0,
                c.getHexColorByName)("color-white")
            }
        }
          , x = {
            barLine: {
                lineStyle: _.LINESTYLE_DASHED,
                lineWidth: 1,
                strokeStyle: ""
            },
            lollipop: {
                width: 21,
                height: 21,
                bottom: 2,
                lineWidth: 1.5,
                strokeStyle: "",
                backgroundColor: "",
                fillCircle: !0,
                fillStyle: "",
                text: {
                    label: "",
                    strokeStyle: "",
                    font: (0,
                    g.makeFont)(12, v.CHART_FONT_FAMILY, "bold")
                }
            },
            iconColor: "",
            backgroundColor: "",
            outerBorderColor: ""
        };
        class M extends S.LollipopPaneView {
            constructor() {
                super(...arguments),
                this._style = (0,
                l.default)(x)
            }
            renderer(e) {
                return this._invalidated && (this._createLollipops(e),
                this._invalidated = !1),
                this._renderer
            }
            getStyle(e) {
                const t = this._model.dark().value() ? P.dark : P.light
                  , i = t.foreground
                  , s = t.background
                  , o = this._style;
                return e.active ? (o.backgroundColor = i,
                o.iconColor = t.activeIcon,
                o.borderColor = void 0) : (o.iconColor = i,
                o.borderColor = i,
                o.backgroundColor = e.hovered ? (0,
                h.blendColors)(s, (0,
                m.applyAlpha)(i, .15)) : s),
                o.outerBorderColor = s,
                o.barLine.strokeStyle = i,
                o
            }
            _createTooltipContent(e) {
                var t, s;
                const o = this._model.mainSeries().symbol()
                  , n = this._model.dark().value() ? P.dark : P.light
                  , r = n.foreground
                  , a = n.border;
                return [{
                    type: "keyFacts",
                    title: u.t(null, void 0, i(809355)),
                    root: e.root,
                    tooltipIcon: T.replace(/currentColor/g, r),
                    style: {
                        color: a
                    },
                    anchor: (null === (s = null === (t = window.widgetbar) || void 0 === t ? void 0 : t.layout) || void 0 === s ? void 0 : s.canOpen()) ? {
                        text: u.t(null, void 0, i(447251)),
                        onClick: ()=>{
                            var e;
                            this._source.hideTooltip(),
                            null === (e = window.widgetbar) || void 0 === e || e.setPage("base"),
                            (0,
                            p.showSymbolNews)(o)
                        }
                        ,
                        hideInMobileMode: !0
                    } : void 0
                }]
            }
            _createRendererForLollipop(e, t) {
                return new w(e,new f.HitTestResult(f.HitTarget.Custom,t),this._textWidthCache)
            }
            _createLollipops(e) {
                const t = this._source.data();
                if (null === t)
                    return;
                const i = this._model.timeScale()
                  , s = super._getY()
                  , o = this._model.hoveredSource() === this._source
                  , n = null !== this.getLastClickedLollipopId()
                  , r = {
                    id: 0,
                    itemIndex: 0,
                    basePoint: (0,
                    d.point)(i.indexToCoordinate(t.index), s),
                    hovered: o,
                    active: n,
                    visible: !0,
                    root: t.root
                };
                this._lollipops[0] = r,
                super._createRenderers(e)
            }
        }
        var I = i(850599);
        const A = (0,
        o.getLogger)("Chart.KeyFactsToday");
        function L(e) {
            return e instanceof k
        }
        const E = {
            visible: !0
        };
        class k extends n.DataSource {
            constructor(e) {
                super("keyFactsToday"),
                this._root = null,
                this._rawKeyFacts = null,
                this._properties = new r.Property(E),
                this._hideLollipopTooltipFn = null,
                this.setOwnerSource(e.mainSeries()),
                this._model = e,
                this._series = e.mainSeries(),
                this._paneView = new M(e,this,this._showTooltip.bind(this)),
                this._series.quotesProvider().quotesUpdate().subscribe(this, this._onQuoteSymbolDataUpdated),
                this._destroyPropertyBinder = (0,
                I.bindProperties)(e.mainSeries().properties().childs().showKeyFactsToday, this._properties.childs().visible)
            }
            destroy() {
                this._paneView.destroy(),
                this._series.quotesProvider().quotesUpdate().unsubscribeAll(this),
                this._destroyPropertyBinder(),
                super.destroy()
            }
            name() {
                return "KeyFactsTodaySource"
            }
            data() {
                var e, t;
                if (!this._root)
                    return null;
                const i = null !== (t = null === (e = this._series.data().last()) || void 0 === e ? void 0 : e.index) && void 0 !== t ? t : null;
                return null === i ? null : {
                    root: this._root,
                    index: i
                }
            }
            hideTooltip() {
                var e;
                null === (e = this._hideLollipopTooltipFn) || void 0 === e || e.call(this),
                this._hideLollipopTooltipFn = null
            }
            properties() {
                return this._properties
            }
            lollipopsAtIndex(e) {
                var t;
                return null !== this._rawKeyFacts && e === (null === (t = this._series.data().last()) || void 0 === t ? void 0 : t.index) ? 1 : 0
            }
            state(e) {
                return null
            }
            paneViews(e) {
                return [this._paneView]
            }
            updateAllViews(e) {
                this._paneView.update()
            }
            zorder() {
                return a.sortSourcesPreOrdered.KeyFactsToday
            }
            onClickOutside(e, t) {
                this._paneView.processClickOutside(e, t)
            }
            preferNoScale() {
                return !0
            }
            showInObjectTree() {
                return !1
            }
            isSavedInStudyTemplates() {
                return !1
            }
            isRemovedByStudyTemplates() {
                return !1
            }
            copiable() {
                return !1
            }
            hasStateForAlert() {
                return !1
            }
            isSavedInChart(e) {
                return !1
            }
            isSpeciallyZOrderedSource() {
                return !0
            }
            isUserDeletable() {
                return !1
            }
            canHaveChildren() {
                return !1
            }
            isIncludedInAutoScale() {
                return !1
            }
            _onQuoteSymbolDataUpdated() {
                var e, t;
                const i = null !== (t = null === (e = this._series.quotes()) || void 0 === e ? void 0 : e["daily-summary-ast"]) && void 0 !== t ? t : null;
                if (i !== this._rawKeyFacts) {
                    this._rawKeyFacts = i;
                    try {
                        this._root = this._rawKeyFacts ? JSON.parse(this._rawKeyFacts) : null,
                        this._paneView.update(),
                        this._model.updateSource(this)
                    } catch (e) {
                        A.logWarn(`An error ocurred while parsing facts: ${e}`),
                        this._root = null
                    }
                }
            }
            async _showTooltip(e, t, o) {
                const n = this._model
                  , r = this._model.timeScale()
                  , a = [r.onScroll(), r.barSpacingChanged(), n.mainSeries().onSymbolIntervalChanged(), (0,
                s.ensureNotNull)(n.paneForSource(this)).onSizeChanged()]
                  , l = this._paneView.processClickOutside.bind(this._paneView, e)
                  , c = this._paneView.clearLastClicked.bind(this._paneView)
                  , d = o();
                if (null === d)
                    return;
                const {showLollipopTooltip: u} = await Promise.all([i.e(31141), i.e(46445), i.e(93703), i.e(49481), i.e(65857), i.e(36010), i.e(53953), i.e(73399), i.e(2520), i.e(22164), i.e(62564), i.e(58985), i.e(88488), i.e(75826), i.e(40528), i.e(16190), i.e(92115), i.e(67661), i.e(21251), i.e(55057), i.e(52017), i.e(46879), i.e(87393), i.e(18488), i.e(90698), i.e(99693), i.e(66764), i.e(7647), i.e(610), i.e(65642), i.e(18973), i.e(83579), i.e(5820), i.e(25326), i.e(32887), i.e(58156), i.e(32227), i.e(1563), i.e(41282), i.e(91795), i.e(98451), i.e(62316), i.e(64074), i.e(49039)]).then(i.bind(i, 652099));
                this._hideLollipopTooltipFn = u({
                    items: d,
                    position: t,
                    customCloseSubscriptions: a,
                    onClickOutside: l,
                    onCustomClose: c,
                    showScrollFades: !0
                })
            }
        }
    }
    ,
    599344: (e,t,i)=>{
        "use strict";
        i.d(t, {
            LatestUpdatesSource: ()=>q,
            isLatestUpdatesSource: ()=>G
        });
        var s = i(650151)
          , o = i(338619)
          , n = i(903424)
          , r = i(343272)
          , a = i(658843)
          , l = i(850599)
          , c = i(203918)
          , d = i(125226)
          , u = i(154834)
          , h = i(166770)
          , p = i(86441)
          , m = i(444372)
          , g = i(887357)
          , _ = i(207678)
          , v = i(528474)
          , S = i(638456)
          , f = i(345848)
          , b = i(137674)
          , y = i(432059)
          , C = i(694852)
          , w = i(666574)
          , T = i(511275)
          , P = i(483445)
          , x = i(509078)
          , M = i(665798)
          , I = i(528390);
        const A = new Path2D("m7.06 0 .87.77-3.4 4.17H9L1.94 11l-.87-.77 3.4-4.17H0L7.06 0Z");
        class L extends I.LollipopRenderer {
            _drawLollipop(e, t, i) {
                const s = this._data.style;
                e.save(),
                e.translate(t.x, t.y),
                e.scale(i.horizontalPixelRatio, i.verticalPixelRatio),
                e.beginPath(),
                e.strokeStyle = s.outerBorderColor,
                e.lineWidth = 1,
                e.arc(0, 0, 11, 0, 2 * Math.PI),
                e.stroke(),
                e.fillStyle = s.backgroundColor,
                e.beginPath(),
                e.arc(0, 0, 10.5, 0, 2 * Math.PI),
                e.fill(),
                e.translate(-4.5, -5.5),
                e.fillStyle = s.iconColor,
                e.fill(A, "evenodd"),
                e.translate(4.5, 5.5),
                s.borderColor && (e.strokeStyle = s.borderColor,
                e.lineWidth = 1.5,
                (0,
                M.setLineStyle)(e, w.LINESTYLE_SOLID),
                e.beginPath(),
                e.arc(0, 0, 9.75, 0, 2 * Math.PI),
                e.stroke()),
                s.hasUpdatesCircle && (e.fillStyle = s.hasUpdatesCircle.color,
                e.strokeStyle = s.hasUpdatesCircle.borderColor,
                e.lineWidth = 2,
                e.beginPath(),
                e.arc(9.75 * Math.cos(Math.PI / 4), 9.75 * -Math.sin(Math.PI / 4), 3.5, 0, 2 * Math.PI),
                e.closePath(),
                e.fill(),
                e.stroke()),
                e.restore()
            }
        }
        var E = i(707491);
        const k = (0,
        o.getLogger)("LatestUpdatesProvider")
          , D = {
            dark: {
                background: (0,
                h.getHexColorByName)("color-cold-gray-900"),
                foreground: (0,
                h.getHexColorByName)("color-grapes-purple-400"),
                hasUpdatesCircle: (0,
                h.getHexColorByName)("color-ripe-red-500"),
                lightningActiveColor: (0,
                h.getHexColorByName)("color-deep-blue-50")
            },
            light: {
                background: (0,
                h.getHexColorByName)("color-white"),
                foreground: (0,
                h.getHexColorByName)("color-grapes-purple-500"),
                hasUpdatesCircle: (0,
                h.getHexColorByName)("color-ripe-red-500"),
                lightningActiveColor: (0,
                h.getHexColorByName)("color-white")
            }
        }
          , N = {
            barLine: {
                lineStyle: w.LINESTYLE_DASHED,
                lineWidth: 1,
                strokeStyle: ""
            },
            lollipop: {
                width: 21,
                height: 21,
                bottom: 2,
                lineWidth: 1.5,
                strokeStyle: "",
                backgroundColor: "",
                fillCircle: !0,
                fillStyle: "",
                text: {
                    label: "",
                    strokeStyle: "",
                    font: (0,
                    C.makeFont)(12, T.CHART_FONT_FAMILY, "bold")
                }
            },
            iconColor: "",
            backgroundColor: "",
            outerBorderColor: ""
        };
        async function B(e, t, s) {
            const {openMindsPage: o} = await i.e(20603).then(i.bind(i, 732246));
            o(e, t, s)
        }
        const R = m.t(null, void 0, i(214312))
          , O = m.t(null, void 0, i(338333))
          , V = m.t(null, void 0, i(505393))
          , W = m.t(null, void 0, i(447251))
          , F = m.t(null, void 0, i(791937));
        class H extends P.LollipopPaneView {
            constructor() {
                super(...arguments),
                this._style = (0,
                u.default)(N)
            }
            renderer(e) {
                return this._source.hideLollipop() ? null : (this._invalidated && (this._createLollipops(e),
                this._invalidated = !1),
                this._renderer)
            }
            getStyle(e) {
                const t = this._model.dark().value() ? D.dark : D.light
                  , i = t.foreground
                  , s = t.background
                  , o = this._style;
                return e.active ? (o.backgroundColor = i,
                o.iconColor = t.lightningActiveColor,
                o.borderColor = void 0) : (o.iconColor = i,
                o.borderColor = i,
                o.backgroundColor = e.hovered ? (0,
                v.blendColors)(s, (0,
                y.applyAlpha)(i, .15)) : s),
                o.outerBorderColor = s,
                o.barLine.strokeStyle = i,
                o.lollipop.incHeight = void 0 === e.stack ? void 0 : 25 * e.stack,
                o.hasUpdatesCircle = e.data.hasNewItems ? {
                    color: t.hasUpdatesCircle,
                    borderColor: s
                } : void 0,
                o
            }
            _createTooltipContent(e) {
                var t, s, o, n, r;
                const a = this._model.mainSeries().symbol()
                  , l = (this._model.dark().value() ? D.dark : D.light).foreground
                  , c = e.data.newsData
                  , d = e.data.mindsData
                  , u = c && c.items.length > 0
                  , h = d && d.items.length > 0;
                if (!u && !h)
                    return null;
                const p = null !== (t = a.split(":")[1]) && void 0 !== t ? t : a
                  , v = {
                    title: u && h ? R : u && m.t(null, {
                        replace: {
                            symbol: p
                        }
                    }, i(900945)) || h && m.t(null, {
                        replace: {
                            symbol: p
                        }
                    }, i(690441)) || "",
                    tabs: [],
                    tooltipIcon: E.replace(/currentColor/g, l),
                    style: {
                        color: l
                    }
                };
                return u && v.tabs.push({
                    id: "news",
                    name: O,
                    content: {
                        type: "news",
                        items: c.items,
                        clickHandler: (e,t)=>{
                            S.CheckMobile.any() && this._source.hideTooltip(),
                            async function(e, t, s) {
                                e.isExternal || s.preventDefault();
                                try {
                                    const o = {
                                        ...e,
                                        analyticsData: t.analyticsData
                                    }
                                      , [{TradingViewNewsProviderFetcher: n},{onNewsCardAction: r}] = await Promise.all([i.e(56370).then(i.bind(i, 619008)), i.e(56370).then(i.bind(i, 458468))]);
                                    r({
                                        newsItem: o,
                                        newsItems: (await n.instance().fetch({
                                            ...t.requestProps,
                                            client: "web"
                                        }, 3e5)).items,
                                        placement: g.NewsWidgetPlacement.Chart
                                    })(s)
                                } catch (s) {
                                    k.logWarn(`An error ocurred while loading news: ${s}`)
                                }
                            }(e, c, t)
                        }
                    },
                    anchor: (null === (o = null === (s = window.widgetbar) || void 0 === s ? void 0 : s.layout) || void 0 === o ? void 0 : o.canOpen()) ? {
                        text: W,
                        onClick: ()=>{
                            var e;
                            this._source.hideTooltip(),
                            null === (e = window.widgetbar) || void 0 === e || e.setPage("base"),
                            (0,
                            b.showSymbolNews)(a)
                        }
                        ,
                        hideInMobileMode: !0
                    } : void 0
                }),
                h && v.tabs.push({
                    id: "minds",
                    name: V,
                    content: {
                        type: "minds",
                        symbol: a,
                        items: d.items,
                        clickHandler: (e,t,i)=>{
                            this._source.hideTooltip(),
                            function(e, t, i, s) {
                                var o;
                                window.innerWidth < _.mobileFirstBreakpoints["media-mf-tablet-vertical"] && (null === (o = window.widgetbar) || void 0 === o || o.resizerBridge.requestFullscreen()),
                                B(i, e[t].uid, s)
                            }(e, t, a, i)
                        }
                    },
                    anchor: (null === (r = null === (n = window.widgetbar) || void 0 === n ? void 0 : n.layout) || void 0 === r ? void 0 : r.canOpen()) ? {
                        text: F,
                        onClick: ()=>{
                            this._source.hideTooltip(),
                            function(e) {
                                var t;
                                window.innerWidth < _.mobileFirstBreakpoints["media-mf-tablet-vertical"] && (null === (t = window.widgetbar) || void 0 === t || t.resizerBridge.requestFullscreen()),
                                B(e)
                            }(a)
                        }
                        ,
                        hideInMobileMode: !0
                    } : void 0
                }),
                v
            }
            _lollipopMouseClickHandler(e, t, i, s) {
                super._lollipopMouseClickHandler(e, t, i, s),
                (0,
                f.trackEvent)("Lollipops", "Click on lightning")
            }
            _createRendererForLollipop(e, t) {
                return new L(e,new x.HitTestResult(x.HitTarget.Custom,t),this._textWidthCache)
            }
            _createLollipops(e) {
                const t = this._source.data();
                if (null === t || (void 0 === t.newsData || 0 === t.newsData.items.length) && (void 0 === t.mindsData || 0 === t.mindsData.items.length))
                    return;
                const i = this._model.mainPane();
                if (!i)
                    return;
                const s = this._model.timeScale()
                  , o = super._getY()
                  , n = this._model.hoveredSource() === this._source
                  , r = null !== this.getLastClickedLollipopId()
                  , a = this._source.zorder();
                let l = 0;
                for (const e of i.lollipopDataSources())
                    e !== this._source && e.zorder() > a && e.isVisible() && (l += e.lollipopsAtIndex(t.index));
                const c = {
                    id: 0,
                    itemIndex: 0,
                    basePoint: (0,
                    p.point)(s.indexToCoordinate(t.index), o),
                    hovered: n,
                    active: r,
                    visible: !0,
                    stack: l,
                    data: t
                };
                this._lollipops[0] = c,
                super._createRenderers(e)
            }
        }
        const z = (0,
        o.getLogger)("Chart.LatestUpdate")
          , U = {
            visible: !0
        };
        function G(e) {
            return e instanceof q
        }
        function j(e) {
            return !e.isSeconds() && !e.isTicks()
        }
        class q extends n.DataSource {
            constructor(e, t) {
                super("latestUpdates"),
                this._properties = new a.Property(U),
                this._items = {},
                this._hasNewItems = !1,
                this._newsThread = null,
                this._mindsThread = null,
                this._hideLollipopTooltipFn = null,
                this._onMindsHistoryReady = this._onMindsItems.bind(this, void 0),
                this._onNewsHistoryReady = this._onNewsItems.bind(this, void 0),
                this.setOwnerSource(e.mainSeries()),
                this._latestUpdatesDataEnabled = t,
                this._model = e,
                this._series = e.mainSeries(),
                this._paneView = new H(e,this,this._showTooltip.bind(this)),
                this._series.symbolResolved().subscribe(this, this._onSymbolResolved);
                const i = this._series.intervalObj();
                this._isAvailableOnCurrentInterval = j(i),
                this._series.onIntervalChanged().subscribe(this, this._recalculateAvailabilityOnCurrentInterval),
                this._destroyPropertyBinder = (0,
                l.bindProperties)(e.mainSeries().properties().childs().showLastNews, this._properties.childs().visible),
                this._initializeNewsAndMindsThreads(),
                this._hideLollipop = (0,
                c.createWVFromGetterAndSubscriptions)((()=>this._model.isInReplay().value() || !j(this._series.intervalObj())), [this._model.onInReplayStateChanged(), this._series.onIntervalChanged()]),
                this._hideLollipop.subscribe((()=>this._model.updateSource(this)))
            }
            destroy() {
                this._destroyNewsThread(),
                this._destroyMindsThread(),
                this._paneView.destroy(),
                this._series.symbolResolved().unsubscribeAll(this),
                this._series.onIntervalChanged().unsubscribeAll(this),
                this._destroyPropertyBinder(),
                this._hideLollipop.destroy(),
                super.destroy()
            }
            hideLollipop() {
                return this._hideLollipop.value()
            }
            lollipopsAtIndex(e) {
                var t;
                return Object.keys(this._items).length > 0 && e === (null === (t = this._series.data().last()) || void 0 === t ? void 0 : t.index) ? 1 : 0
            }
            name() {
                return "LatestUpdatesSource"
            }
            data() {
                const e = this._series.data().last();
                if (null === e || void 0 === Object.keys(this._items).length)
                    return null;
                const t = {
                    index: e.index,
                    hasNewItems: this._hasNewItems
                };
                return this._items[0] && void 0 !== this._requestNewsProps && void 0 !== this._newsAnalyticsData && (t.newsData = {
                    items: this._items[0],
                    requestProps: this._requestNewsProps,
                    analyticsData: this._newsAnalyticsData
                }),
                this._items[1] && (t.mindsData = {
                    items: this._items[1]
                }),
                t
            }
            properties() {
                return this._properties
            }
            state(e) {
                return null
            }
            paneViews(e) {
                return [this._paneView]
            }
            updateAllViews(e) {
                this._paneView.update()
            }
            zorder() {
                return r.sortSourcesPreOrdered.LatestUpdates
            }
            onClickOutside(e, t) {
                this._paneView.processClickOutside(e, t)
            }
            preferNoScale() {
                return !0
            }
            showInObjectTree() {
                return !1
            }
            isSavedInStudyTemplates() {
                return !1
            }
            isRemovedByStudyTemplates() {
                return !1
            }
            copiable() {
                return !1
            }
            hasStateForAlert() {
                return !1
            }
            isSavedInChart(e) {
                return !1
            }
            isSpeciallyZOrderedSource() {
                return !0
            }
            isUserDeletable() {
                return !1
            }
            canHaveChildren() {
                return !1
            }
            isIncludedInAutoScale() {
                return !1
            }
            hideTooltip() {
                var e;
                null === (e = this._hideLollipopTooltipFn) || void 0 === e || e.call(this),
                this._hideLollipopTooltipFn = null
            }
            async _showTooltip(e, t, o) {
                const n = this._model.timeScale()
                  , r = [n.onScroll(), n.barSpacingChanged(), this._series.onSymbolIntervalChanged(), (0,
                s.ensureNotNull)(this._model.paneForSource(this)).onSizeChanged()]
                  , a = this._paneView.processClickOutside.bind(this._paneView, e)
                  , l = this._paneView.clearLastClicked.bind(this._paneView)
                  , c = o();
                if (null === c)
                    return;
                this._hasNewItems = !1;
                const {showLollipopTooltipWithTabs: d} = await Promise.all([i.e(31141), i.e(46445), i.e(93703), i.e(49481), i.e(65857), i.e(36010), i.e(53953), i.e(73399), i.e(2520), i.e(22164), i.e(62564), i.e(58985), i.e(88488), i.e(75826), i.e(40528), i.e(16190), i.e(92115), i.e(67661), i.e(21251), i.e(55057), i.e(52017), i.e(46879), i.e(87393), i.e(18488), i.e(90698), i.e(99693), i.e(66764), i.e(7647), i.e(610), i.e(65642), i.e(18973), i.e(83579), i.e(5820), i.e(25326), i.e(32887), i.e(58156), i.e(32227), i.e(1563), i.e(41282), i.e(91795), i.e(98451), i.e(62316), i.e(64074), i.e(49039)]).then(i.bind(i, 395597));
                this._hideLollipopTooltipFn = d({
                    content: c,
                    position: t,
                    customCloseSubscriptions: r,
                    onClickOutside: a,
                    doNotCloseOn: ()=>[document.querySelector('[data-name="news-dialog"]'), document.querySelector('[data-dialog-name="image-dialog"]')].filter((e=>null !== e)),
                    onCustomClose: l,
                    showScrollFades: !0
                })
            }
            async _initializeNewsAndMindsThreads() {
                if (!this._isAvailableOnCurrentInterval)
                    return void (this._items = {});
                null !== this._series.symbolInfo() && (this._initializeNewsThread(),
                this._initializeMindsThread())
            }
            async _initializeMindsThread() {
                if (!this._latestUpdatesDataEnabled.minds)
                    return;
                const e = (0,
                s.ensureNotNull)(this._series.symbolInfo());
                try {
                    const {popularMindsThread: t} = await i.e(12127).then(i.bind(i, 316608));
                    this._mindsThread = t({
                        symbol: e.pro_name,
                        limit: 3
                    }, 3e5, 3e5),
                    this._mindsThread.newItems().subscribe(this, this._onMindsItems.bind(this, !0)),
                    this._mindsThread.historyReady().value() ? this._onMindsItems() : this._mindsThread.historyReady().subscribe(this._onMindsHistoryReady, {
                        once: !0
                    })
                } catch (e) {
                    z.logWarn(`An error ocurred while loading minds: ${e}`)
                }
            }
            async _initializeNewsThread() {
                if (!this._latestUpdatesDataEnabled.news)
                    return;
                const e = (0,
                s.ensureNotNull)(this._series.symbolInfo());
                try {
                    const [{getIsoLanguageCodeFromLanguage: t},{getCardsAnalyticsData: s},{handleNewsProName: o},{newsThread: n}] = await Promise.all([i.e(56370).then(i.bind(i, 39654)), i.e(56370).then(i.bind(i, 104683)), i.e(56370).then(i.bind(i, 470598)), i.e(56370).then(i.bind(i, 603326))])
                      , r = !!(window.is_authenticated && (0,
                    d.isFeatureEnabled)("move_chart_news_to_streaming") && (0,
                    d.isFeatureEnabled)("news_enable_streaming")) || void 0;
                    this._requestNewsProps = {
                        lang: t(window.language),
                        symbol: o(e.pro_name, e.type),
                        client: "chart",
                        streaming: r
                    },
                    this._newsAnalyticsData = s(this._requestNewsProps),
                    this._newsThread = n(this._requestNewsProps, 3e5, 3e5),
                    this._newsThread.newItems().subscribe(this, this._onNewsItems.bind(this, !0)),
                    this._newsThread.historyReady().value() ? this._onNewsItems() : this._newsThread.historyReady().subscribe(this._onNewsHistoryReady, {
                        once: !0
                    })
                } catch (e) {
                    z.logWarn(`An error ocurred while loading news: ${e}`)
                }
            }
            _onNewsItems(e) {
                const t = this._series.symbolInfo();
                if (this._isDestroyed || null === t)
                    return;
                let i = (0,
                s.ensureNotNull)(this._newsThread).history().slice();
                i.length > 0 && Date.now() - i[0].published >= 26784e5 && (i = []),
                this._items[0] = i,
                e && (this._hasNewItems = !0),
                Object.keys(this._items).length && (this._paneView.update(),
                this._model.updateSource(this))
            }
            _onMindsItems(e) {
                const t = this._series.symbolInfo();
                if (this._isDestroyed || null === t)
                    return;
                const i = (0,
                s.ensureNotNull)(this._mindsThread).history().slice();
                this._items[1] = i,
                e && (this._hasNewItems = !0),
                Object.keys(this._items).length && (this._paneView.update(),
                this._model.updateSource(this))
            }
            _destroyNewsThread() {
                this._newsThread && (this._newsThread.historyReady().unsubscribe(this._onNewsHistoryReady),
                this._newsThread.newItems().unsubscribeAll(this),
                this._newsThread.destroy(),
                this._newsThread = null)
            }
            _destroyMindsThread() {
                this._mindsThread && (this._mindsThread.historyReady().unsubscribe(this._onMindsHistoryReady),
                this._mindsThread.newItems().unsubscribeAll(this),
                this._mindsThread.destroy(),
                this._mindsThread = null)
            }
            _onSymbolResolved() {
                this._items = {},
                this._destroyNewsThread(),
                this._destroyMindsThread(),
                this._initializeNewsAndMindsThreads()
            }
            _recalculateAvailabilityOnCurrentInterval() {
                const e = j(this._series.intervalObj());
                e !== this._isAvailableOnCurrentInterval && (this._isAvailableOnCurrentInterval = e,
                e ? this._initializeNewsAndMindsThreads() : (this._destroyNewsThread(),
                this._destroyMindsThread(),
                this._paneView.update(),
                this._model.updateSource(this)))
            }
        }
    }
    ,
    684634: (e,t,i)=>{
        "use strict";
        i.d(t, {
            LineToolsGroup: ()=>l
        });
        var s = i(942634)
          , o = i(978296)
          , n = i(79342);
        function r(e) {
            return e.properties().visible.value()
        }
        function a(e) {
            return !r(e)
        }
        class l {
            constructor(e, t, i) {
                this._instanceId = (0,
                n.randomHashN)(6),
                this._onChanged = new s.Delegate,
                this._lineToolsSet = new Set,
                this._lineTools = [...e],
                this._lineToolsSet = new Set(this._lineTools),
                this._name = new o.WatchedValue(t),
                this.id = i || (0,
                n.randomHashN)(6)
            }
            instanceId() {
                return this._instanceId
            }
            lineTools() {
                return this._lineTools
            }
            name() {
                return this._name
            }
            setName(e) {
                this._doAndFireOnChange((()=>{
                    this._name.setValue(e)
                }
                ))
            }
            isActualSymbol() {
                return this._lineTools.length > 0 && this._lineTools[0].isActualSymbol() && this._lineTools[0].isActualCurrency() && this._lineTools[0].isActualUnit()
            }
            symbol() {
                return this._lineTools[0].symbol()
            }
            currencyId() {
                var e;
                return null !== (e = this._lineTools[0].properties().childs().currencyId.value()) && void 0 !== e ? e : null
            }
            unitId() {
                var e;
                return null !== (e = this._lineTools[0].properties().childs().unitId.value()) && void 0 !== e ? e : null
            }
            sharingMode() {
                return this._lineTools[0].sharingMode()
            }
            share(e) {
                this._lineTools.forEach((t=>t.share(e)))
            }
            containsLineTool(e) {
                return this._lineToolsSet.has(e)
            }
            addLineTools(e) {
                this._doAndFireOnChange((t=>{
                    e.forEach((e=>this._lineToolsSet.add(e))),
                    this._lineTools.push(...e),
                    t.push(...e.map((e=>e.id())))
                }
                ))
            }
            excludeLineTool(e) {
                this._doAndFireOnChange((t=>{
                    this._lineToolsSet.delete(e);
                    const i = this._lineTools.indexOf(e);
                    this._lineTools.splice(i, 1),
                    t.push(e.id())
                }
                ))
            }
            excludeLineTools(e) {
                this._doAndFireOnChange((t=>{
                    const i = new Set(e);
                    e.forEach((e=>this._lineToolsSet.delete(e))),
                    this._lineTools = this._lineTools.filter((e=>!i.has(e))),
                    t.push(...e.map((e=>e.id())))
                }
                ))
            }
            state() {
                return {
                    id: this.id,
                    name: this._name.value(),
                    tools: this._lineTools.map((e=>e.id()))
                }
            }
            visibility() {
                const e = this._lineTools.some(r)
                  , t = this._lineTools.some(a);
                return e && !t ? "Visible" : t && !e ? "Invisible" : "Partial"
            }
            locked() {
                const e = this._lineTools.some((e=>e.properties().frozen.value()))
                  , t = this._lineTools.some((e=>!e.properties().frozen.value()));
                return e && !t ? "Locked" : t && !e ? "Unlocked" : "Partial"
            }
            isActualInterval() {
                const e = this._lineTools.some((e=>e.isActualInterval()))
                  , t = this._lineTools.some((e=>!e.isActualInterval()));
                return e && !t ? "IsActualInterval" : t && !e ? "IsNotActualInterval" : "Partial"
            }
            onChanged() {
                return this._onChanged
            }
            static fromState(e, t) {
                const i = [];
                for (const s of t.tools) {
                    const t = e.dataSourceForId(s);
                    null !== t && i.push(t)
                }
                return i.length > 0 ? new l(i,t.name,t.id) : null
            }
            _doAndFireOnChange(e) {
                const t = []
                  , i = this.visibility()
                  , s = this.locked()
                  , o = this.isActualInterval();
                e(t),
                this._onChanged.fire({
                    affectedLineTools: t,
                    visibilityChanged: i !== this.visibility(),
                    lockedChanged: s !== this.locked(),
                    isActualIntervalChanged: o !== this.isActualInterval()
                })
            }
        }
    }
    ,
    55907: (e,t,i)=>{
        "use strict";
        i.d(t, {
            blobImageFilter: ()=>a,
            checkImageSize: ()=>h,
            generateLink: ()=>u,
            imageIsOversized: ()=>c,
            uploadImage: ()=>p
        });
        var s = i(327714)
          , o = i(702598)
          , n = i(444372)
          , r = i(338619);
        function a(e) {
            return "image/png" === e.type || "image/jpeg" === e.type
        }
        const l = (0,
        s.size)({
            width: 2e3,
            height: 2e3
        });
        function c(e) {
            return e.width > l.width || e.height > l.height
        }
        const d = (0,
        r.getLogger)("Chart.Uploader");
        async function u(e) {
            const t = new FormData
              , i = "name"in e ? e.name : "image.png";
            t.append("content_type", e.type),
            t.append("filename", i),
            t.append("size", "" + e.size);
            try {
                const e = await (0,
                o.fetch)("/charts/uploads/generate-link/", {
                    method: "POST",
                    body: t
                });
                if (!e.ok)
                    throw new Error(`Error generating upload link: ${e.status}`);
                return e.json()
            } catch (t) {
                throw d.logError(`Error generating upload link: ${t}. blob.type: ${e.type} blob.size: ${e.size} filename: ${i}`),
                t
            }
        }
        async function h(e) {
            return new Promise(((t,i)=>{
                const s = new FileReader;
                s.onload = e=>{
                    var s;
                    const o = new Image;
                    o.src = null === (s = e.target) || void 0 === s ? void 0 : s.result,
                    o.onload = ()=>{
                        t(!c(o))
                    }
                    ,
                    o.onerror = i
                }
                ,
                s.onerror = i,
                s.readAsDataURL(e)
            }
            ))
        }
        async function p(e) {
            if (!await h(e))
                throw new Error(n.t(null, void 0, i(73007)));
            try {
                const t = await u(e)
                  , i = t.data.fields
                  , s = new FormData;
                for (const e of Object.keys(i))
                    s.append(e, i[e]);
                s.append("file", e);
                const n = await (0,
                o.fetch)(t.data.url, {
                    method: "POST",
                    body: s
                });
                if (n.ok)
                    return t.data.url + t.filepath;
                throw new Error(`Upload response is not ok: ${n.status}`)
            } catch (e) {
                throw new Error(`Error uploading image: ${e.message}`)
            }
        }
    }
    ,
    281090: (e,t,i)=>{
        "use strict";
        i.d(t, {
            drawSelection: ()=>r,
            getSymbolCoordinatesInfo: ()=>n
        });
        var s = i(881025)
          , o = i(631088);
        function n(e) {
            const {symbolPosition: t, textWidth: i, textByLines: n, lineHeight: r, font: a, textAlign: l, lineSpacing: c=0} = e;
            let d = -c
              , u = 0;
            const h = (0,
            s.isRtl)()
              , p = r + c;
            let m = 0
              , g = 0
              , _ = "";
            for (let e = 0; e < n.length; e++) {
                let s = t - m;
                const {wrappedLinePart: r, wrappedLineEnd: c, hidden: v, text: S} = n[e]
                  , f = e < n.length - 1 ? n[e + 1] : null;
                if (v || (_ = S),
                f && s > S.length) {
                    m += S.length + (r && !c ? 0 : 1),
                    v || (d += p);
                    continue
                }
                v && (d -= p);
                const b = r && !c && S.length === s && f && !f.hidden;
                if (v && (_ += " ",
                s = _.length),
                "center" === l)
                    if (b)
                        u = i / 2;
                    else {
                        const e = (0,
                        o.measureText)(_, a).width
                          , t = (0,
                        o.measureText)(_.slice(0, s), a).width
                          , n = i / 2;
                        u = h ? n + e / 2 - t : n - e / 2 + t
                    }
                else if ("right" === l && !h || "left" === l && h || "end" === l)
                    if (b)
                        u = i;
                    else {
                        const e = (0,
                        o.measureText)(_.slice(s), a).width;
                        u = h ? e : i - e
                    }
                else if (b)
                    u = 0;
                else {
                    const e = (0,
                    o.measureText)(_.slice(0, s), a).width;
                    u = h ? i - e : e
                }
                b ? (g = e + 1,
                d += p) : g = e;
                break
            }
            return {
                x: u,
                y: d,
                lineNumber: g
            }
        }
        function r(e, t, i) {
            const {lines: n, selectionStart: r, selectionEnd: l, left: c, right: d, color: u, font: h, lineHeight: p, lineSpacing: m=0} = i;
            e.save();
            const g = (c + d) / 2
              , _ = p + m
              , v = (0,
            s.isRtl)();
            e.fillStyle = u;
            const {horizontalPixelRatio: S, verticalPixelRatio: f} = t;
            if (r.lineNumber === l.lineNumber) {
                const t = Math.round(r.x * S)
                  , i = Math.round(r.y * f)
                  , s = Math.round(l.x * S);
                e.fillRect(Math.min(t, s), i, Math.abs(t - s), Math.round(_ * f))
            } else {
                const t = (0,
                o.measureText)(" ", h).width;
                let i = 0;
                for (let s = r.lineNumber; s <= l.lineNumber; s += 1) {
                    const o = s === r.lineNumber
                      , u = s === l.lineNumber
                      , p = n[s];
                    if (p.hidden)
                        continue;
                    const m = a(p.text, h);
                    let b, y, C = !1;
                    "center" === e.textAlign ? (b = o ? r.x : v ? g + m / 2 : g - m / 2,
                    y = u ? l.x : v ? g - m / 2 : g + m / 2) : "right" === e.textAlign || v && "start" === e.textAlign || !v && "end" === e.textAlign ? (b = o ? r.x : d - m,
                    y = u ? l.x : d,
                    C = !0) : (b = o ? r.x : c,
                    y = u ? l.x : c + m);
                    let w = Math.min(b, y)
                      , T = Math.max(b, y);
                    u || p.wrappedLinePart && !p.wrappedLineEnd || (C ? w -= t : T += t);
                    const P = Math.round(w * S)
                      , x = Math.round(T * S)
                      , M = Math.round((r.y + i * _) * f)
                      , I = Math.round((r.y + (i + 1) * _) * f);
                    e.fillRect(P, M, x - P, I - M),
                    i += 1
                }
            }
            e.restore()
        }
        function a(e, t) {
            return (0,
            o.measureText)(e, t).width
        }
    }
    ,
    764921: (e,t,i)=>{
        "use strict";
        i.d(t, {
            LogicalRange: ()=>o
        });
        var s = i(650151);
        class o {
            constructor(e, t) {
                (0,
                s.assert)(e <= t, "The left value should be greater than or equal to the right value"),
                this._left = e,
                this._right = t
            }
            left() {
                return this._left
            }
            right() {
                return this._right
            }
            length() {
                return this._right - this._left + 1
            }
            contains(e, t) {
                return e < this._left - .5 ? !0 === t && 1 : e > this._right + .5 ? !0 === t && 2 : !0 !== t || 0
            }
            before(e) {
                return e < this._left - .5
            }
            after(e) {
                return e > this._right + .5
            }
            intersects(e) {
                return !(this.after(e.left()) || this.before(e.right()))
            }
            equals(e) {
                return this._left === e.left() && this._right === e.right()
            }
            static compare(e, t) {
                return null === e || null === t ? e === t : e.equals(t)
            }
        }
    }
    ,
    195121: (e,t,i)=>{
        "use strict";
        i.d(t, {
            magnetEnabled: ()=>m,
            magnetMode: ()=>g,
            setIsMagnetEnabled: ()=>_,
            setMagnetMode: ()=>v
        });
        var s = i(262624)
          , o = i(978296)
          , n = i(205899)
          , r = i(419283)
          , a = i(627620)
          , l = i(895366);
        const c = new o.WatchedValue(!1)
          , d = new o.WatchedValue(n.MagnetMode.WeakMagnet)
          , u = (0,
        l.modifierPressed)()
          , h = (0,
        l.shiftPressed)();
        function p() {
            const e = u.value();
            if (h.value() && (r.isToolEditingNow.value() || r.isToolCreatingNow.value()))
                return void c.setValue(!1);
            let t, i;
            if (r.activePointSelectionMode.value() === r.SelectPointMode.Replay)
                t = i = !1;
            else {
                const s = r.tool.value()
                  , o = r.isStudyEditingNow.value() || r.activePointSelectionMode.value() === r.SelectPointMode.Study;
                t = e && ((0,
                a.isLineToolName)(s) || r.isToolEditingNow.value() || (0,
                r.toolIsMeasure)(s) || o),
                i = (0,
                r.properties)().childs().magnet.value()
            }
            d.setValue(!i && t ? n.MagnetMode.StrongMagnet : (0,
            r.properties)().childs().magnetMode.value()),
            c.setValue(t ? !i : i)
        }
        function m() {
            return c
        }
        function g() {
            return d
        }
        function _(e) {
            (0,
            s.allowSavingDefaults)(!0),
            (0,
            r.properties)().childs().magnet.setValue(e),
            (0,
            s.allowSavingDefaults)(!1)
        }
        function v(e) {
            (0,
            s.allowSavingDefaults)(!0),
            (0,
            r.properties)().childs().magnetMode.setValue(e),
            (0,
            r.properties)().childs().magnet.setValue(!0),
            (0,
            s.allowSavingDefaults)(!1)
        }
        (0,
        r.runOnDrawingStateReady)((()=>{
            (0,
            r.properties)().childs().magnet.subscribe(null, p),
            (0,
            r.properties)().childs().magnetMode.subscribe(null, p),
            u.subscribe(p),
            h.subscribe(p),
            r.tool.subscribe(p),
            r.isToolEditingNow.subscribe(p),
            p()
        }
        ))
    }
    ,
    866321: (e,t,i)=>{
        "use strict";
        i.d(t, {
            MainSeriesScaleRatioProperty: ()=>n
        });
        var s = i(942634)
          , o = i(805578);
        class n {
            constructor(e) {
                this._changed = new s.Delegate,
                this._model = e
            }
            destroy() {
                this._changed.destroy()
            }
            getStepChangeValue() {
                return .1
            }
            getMinValue() {
                return 1e-7
            }
            getMaxValue() {
                return 99999999
            }
            value() {
                return this._model.mainSeriesScaleRatio()
            }
            setValue(e, t) {
                (e !== this.value() || t) && (this._model.setMainSeriesScaleRatio(e),
                this._onChanged())
            }
            state() {
                return null
            }
            clone() {
                return new n(this._model)
            }
            listeners() {
                return this._changed
            }
            subscribe(e, t) {
                this._changed.subscribe(e, t)
            }
            unsubscribe(e, t) {
                this._changed.unsubscribe(e, t)
            }
            unsubscribeAll(e) {
                this._changed.unsubscribeAll(e)
            }
            storeStateIfUndefined() {
                return !0
            }
            weakReference() {
                return (0,
                o.weakReference)(this)
            }
            ownership() {
                return (0,
                o.ownership)(this)
            }
            _onChanged() {
                this._changed.fire(this, "")
            }
        }
    }
    ,
    809137: (e,t,i)=>{
        "use strict";
        i.d(t, {
            RectangleRenderer: ()=>h
        });
        var s = i(650151)
          , o = i(86441)
          , n = i(934026)
          , r = i(204652)
          , a = i(432059)
          , l = i(666574)
          , c = i(509078)
          , d = i(665798)
          , u = i(961970);
        class h extends u.BitmapCoordinatesPaneRenderer {
            constructor(e) {
                super(),
                this._data = null,
                this._forceOverrideTransparency = Boolean(e)
            }
            setData(e) {
                this._data = e
            }
            hitTest(e, t) {
                if (null === this._data || this._data.points.length < 2 || this._data.nohittest)
                    return null;
                const i = t.mediaSize.width
                  , s = (0,
                o.box)(...this._data.points)
                  , n = s.min
                  , a = s.max
                  , l = new o.Point(a.x,n.y)
                  , d = new o.Point(n.x,a.y)
                  , u = this._extendAndHitTestLineSegment(e, n, l, i);
                if (null !== u)
                    return u;
                const h = this._extendAndHitTestLineSegment(e, d, a, i);
                if (null !== h)
                    return h;
                let p = (0,
                r.distanceToSegment)(l, a, e);
                if (p.distance <= 3)
                    return new c.HitTestResult(c.HitTarget.MovePoint);
                if (p = (0,
                r.distanceToSegment)(n, d, e),
                p.distance <= 3)
                    return new c.HitTestResult(c.HitTarget.MovePoint);
                if (this._data.middleLine) {
                    const t = s.min.add(s.max).scaled(.5)
                      , n = this._extendAndHitTestLineSegment(e, new o.Point(s.min.x,t.y), new o.Point(s.max.x,t.y), i);
                    if (null !== n)
                        return n
                }
                return this._data.fillBackground ? this._hitTestBackground(e, n, a, i) : null
            }
            getColor() {
                const e = (0,
                s.ensure)(this._data);
                return void 0 === e.transparency ? e.backcolor : (0,
                a.generateColor)(e.backcolor, e.transparency, this._forceOverrideTransparency)
            }
            _drawImpl(e) {
                if (null === this._data || this._data.points.length < 2 || this._data.linewidth <= 0 && !this._data.fillBackground)
                    return;
                const {horizontalPixelRatio: t, verticalPixelRatio: i, bitmapSize: s} = e
                  , {extendLeft: n, extendRight: r, linewidth: a, middleLine: c} = this._data
                  , u = (0,
                o.box)(...this._data.points)
                  , h = this._data.linewidth ? Math.max(1, Math.floor(this._data.linewidth * t)) : 0
                  , p = this._data.fillBackground ? this.getColor() : void 0
                  , m = Math.max(1, Math.floor(t))
                  , g = n ? -a : Math.round(u.min.x * t)
                  , _ = r ? s.width + a : Math.round(u.max.x * t)
                  , v = Math.round(u.min.y * i)
                  , S = Math.round(u.max.y * i);
                (0,
                d.fillRectWithBorder)(e, g, v, _, S, m, void 0 === p ? void 0 : {
                    color: p
                }, 0 === h ? void 0 : {
                    color: this._data.color,
                    lineStyle: l.LINESTYLE_SOLID,
                    borderWidth: h,
                    borderMode: "center"
                }, c ? {
                    ...c,
                    lineWidth: Math.max(1, Math.floor(c.lineWidth * i))
                } : void 0)
            }
            _extendAndHitTestLineSegment(e, t, i, s) {
                const o = this._extendAndClipLineSegment(t, i, s);
                if (null !== o) {
                    if ((0,
                    r.distanceToSegment)(o[0], o[1], e).distance <= 3)
                        return new c.HitTestResult(c.HitTarget.MovePoint)
                }
                return null
            }
            _extendAndClipLineSegment(e, t, i) {
                const n = (0,
                s.ensureNotNull)(this._data);
                if ((0,
                o.equalPoints)(e, t) && !n.extendLeft && !n.extendRight)
                    return null;
                const r = Math.min(e.x, t.x)
                  , a = Math.max(e.x, t.x)
                  , l = n.extendLeft ? 0 : Math.max(r, 0)
                  , c = n.extendRight ? i : Math.min(a, i);
                return l > c || c <= 0 || l >= i ? null : [new o.Point(l,e.y), new o.Point(c,t.y)]
            }
            _hitTestBackground(e, t, i, s) {
                var r, a;
                const l = this._extendAndClipLineSegment(t, i, s);
                return null !== l && (0,
                n.pointInBox)(e, (0,
                o.box)(l[0], l[1])) ? new c.HitTestResult(null !== (a = null === (r = this._data) || void 0 === r ? void 0 : r.backgroundHitTarget) && void 0 !== a ? a : c.HitTarget.MovePointBackground) : null
            }
        }
    }
    ,
    539040: (e,t,i)=>{
        "use strict";
        i.d(t, {
            TextRenderer: ()=>k,
            calculateLabelPosition: ()=>g,
            fontSize: ()=>A,
            getTextBoundaries: ()=>_,
            lineSpacing: ()=>I,
            needTextExclusionPath: ()=>v,
            wordWrap: ()=>b
        });
        var s = i(86441)
          , o = i(650151)
          , n = i(934026)
          , r = i(881025)
          , a = i(509078)
          , l = i(665798)
          , c = i(281090)
          , d = i(124829)
          , u = i(631088)
          , h = i(666574)
          , p = i(828473)
          , m = i(5486);
        function g(e, t, i, o, n) {
            const r = .5 * (t.x + i.x);
            let a = i.y;
            return t.y > i.y ? (a -= e.height / 2 + o.y,
            a = Math.max(e.height / 2, a)) : (a += e.height / 2 + o.y,
            a = Math.min(n - e.height / 2, a)),
            new s.Point(r,a)
        }
        function _(e, t, i) {
            if (e.isOutOfScreen(t, i))
                return null;
            const s = e.getPolygonPoints();
            return 0 === s.length ? null : s
        }
        function v(e) {
            const t = e.getLinesInfo().lines;
            if (t.length % 2 == 0)
                return !1;
            if ("" === t[Math.floor(t.length / 2)].text.trim())
                return !1;
            return !0
        }
        function S(e) {
            const t = [];
            do {
                const i = e.match(/\s+/);
                if (!i || void 0 === i.index || -1 === i.index) {
                    t.push({
                        word: e,
                        spaces: ""
                    });
                    break
                }
                t.push({
                    word: e.slice(0, i.index),
                    spaces: i[0]
                }),
                e = e.slice(i.index + i[0].length)
            } while (e.length);
            return t
        }
        function f(e, t, i, s) {
            const o = []
              , n = [];
            for (let t = 0; t < e.length; ++t)
                n.push(t);
            for (; e.length; ) {
                const r = Math.max(1, (0,
                p.upperbound)(n, s, ((s,o)=>(0,
                u.measureText)(e.slice(0, o + 1), t, i).width > s), 0, e.length));
                o.push(e.slice(0, r)),
                e = e.slice(r)
            }
            return o
        }
        function b(e, t, i, s=!0, o) {
            o = (0,
            d.isString)(o) ? parseInt(o) : o;
            const n = (e += "").split(/\r\n|\r|\n|$/).map((e=>({
                text: e,
                hidden: !1,
                wrappedLinePart: !1,
                wrappedLineEnd: !1
            })));
            if (!(0,
            d.isNumber)(o) || !isFinite(o) || o <= 0)
                return n;
            if ((0,
            u.measureText)("x", t, i).width > o)
                return n;
            const r = [];
            for (let e = 0; e < n.length; e++) {
                const a = n[e];
                if ((0,
                u.measureText)(a.text, t, i).width <= o) {
                    r.push(a);
                    continue
                }
                const l = S(a.text)
                  , c = !0;
                let d = ""
                  , h = 0;
                for (; h < l.length; ) {
                    const e = l[h];
                    let n = `${d}${e.word}`
                      , a = (0,
                    u.measureText)(n, t, i).width;
                    if (a > o) {
                        if ("" !== d)
                            r.push({
                                text: d,
                                hidden: !1,
                                wrappedLinePart: c,
                                wrappedLineEnd: !1
                            }),
                            d = "";
                        else if (1 === n.length)
                            r.push({
                                text: n,
                                hidden: !1,
                                wrappedLinePart: c,
                                wrappedLineEnd: !0
                            }),
                            e.word = "";
                        else {
                            const s = f(n, t, i, o);
                            for (let e = 0; e < s.length - 1; e += 1)
                                r.push({
                                    text: s[e],
                                    hidden: !1,
                                    wrappedLinePart: c,
                                    wrappedLineEnd: !1
                                });
                            e.word = s[s.length - 1]
                        }
                        continue
                    }
                    let p = n.length;
                    if (n = `${d}${e.word}${e.spaces}`,
                    a = (0,
                    u.measureText)(n, t, i).width,
                    a < o) {
                        d = n,
                        h += 1;
                        continue
                    }
                    const m = f(n, t, i, o);
                    for (let e = 0; e < m.length; e += 1) {
                        const t = m[e];
                        p -= t.length;
                        const i = {
                            text: t,
                            hidden: e > 0,
                            wrappedLinePart: c,
                            wrappedLineEnd: h === l.length - 1 && e === m.length - 1
                        };
                        i.hidden && s || r.push(i)
                    }
                    d = "",
                    h += 1
                }
                "" !== d && r.push({
                    text: d,
                    wrappedLinePart: c,
                    hidden: !1,
                    wrappedLineEnd: !0
                })
            }
            return r
        }
        function y(e, t, i) {
            if (0 === i)
                return e.clone();
            const o = (e.x - t.x) * Math.cos(i) - (e.y - t.y) * Math.sin(i) + t.x
              , n = (e.x - t.x) * Math.sin(i) + (e.y - t.y) * Math.cos(i) + t.y;
            return new s.Point(o,n)
        }
        function C(e, t) {
            var i, s, o;
            const n = null === (i = e.decorator) || void 0 === i ? void 0 : i.geometry(e)
              , r = Math.round(t + x(e) + M(e) + (null !== (s = null == n ? void 0 : n.width) && void 0 !== s ? s : 0) + (0 === e.text.length ? 0 : null !== (o = null == n ? void 0 : n.decoratorAndTextMargin) && void 0 !== o ? o : 0));
            return r % 2 ? r + 1 : r
        }
        function w(e, t) {
            return A(e) * t + I(e) * (t - 1) + 2 * T(e)
        }
        function T(e) {
            return void 0 !== e.boxPaddingVert ? e.boxPaddingVert * E(e) : void 0 !== e.boxPadding ? e.boxPadding * E(e) : A(e) / 3
        }
        function P(e) {
            return void 0 !== e.boxPaddingHorz ? e.boxPaddingHorz * E(e) : void 0 !== e.boxPadding ? e.boxPadding * E(e) : A(e) / 3
        }
        function x(e) {
            return void 0 !== e.boxPaddingLeft ? e.boxPaddingLeft * E(e) : P(e)
        }
        function M(e) {
            return void 0 !== e.boxPaddingRight ? e.boxPaddingRight * E(e) : P(e)
        }
        function I(e) {
            return (e.padding || 0) * E(e)
        }
        function A(e) {
            return Math.ceil(L(e) * E(e))
        }
        function L(e) {
            return e.fontsize || e.fontSize || 30
        }
        function E(e) {
            const t = Math.min(1, Math.max(.2, e.scale || 1));
            if (1 === t)
                return t;
            const i = L(e);
            return Math.ceil(t * i) / i
        }
        class k {
            constructor(e, t) {
                this._data = null,
                this._textWidthCache = new m.TextWidthCache,
                this._internalData = null,
                this._boxSize = null,
                this._polygonPoints = null,
                this._linesInfo = null,
                this._fontInfo = null,
                this._centerTextRotationPoint = null,
                this._rotationPoint = null,
                this._hitTest = t || new a.HitTestResult(a.HitTarget.MovePoint,{
                    areaName: a.AreaName.Text
                }),
                void 0 !== e && this.setData(e)
            }
            setHitTest(e) {
                this._hitTest = e
            }
            data() {
                return this._data
            }
            updateData(e) {
                this.setData({
                    ...(0,
                    o.ensureNotNull)(this._data),
                    ...e
                })
            }
            setData(e) {
                null !== e ? ((0,
                o.assert)(!e.decorator || void 0 === e.wordWrapWidth, "Decorator is not supported with wordWrapWidth"),
                void 0 === e.text && (e.text = ""),
                e.horzTextAlign || (e.horzTextAlign = e.horzAlign),
                !function(e, t) {
                    if (null === e || null === t)
                        return null === e == (null === t);
                    if (void 0 === e.points != (void 0 === t.points))
                        return !1;
                    if (void 0 !== e.points && void 0 !== t.points) {
                        if (e.points.length !== t.points.length)
                            return !1;
                        for (let o = 0; o < e.points.length; ++o)
                            if (i = e.points[o],
                            s = t.points[o],
                            i.x !== s.x || i.y !== s.y)
                                return !1
                    }
                    var i, s;
                    return e.text === t.text && e.decorator === t.decorator && e.vertAlign === t.vertAlign && e.horzAlign === t.horzAlign && e.horzTextAlign === t.horzTextAlign && e.font === t.font && e.offsetX === t.offsetX && e.offsetY === t.offsetY && e.bold === t.bold && e.italic === t.italic && e.fontsize === t.fontsize && e.fontSize === t.fontSize && e.backgroundRoundRect === t.backgroundRoundRect && e.forceTextAlign === t.forceTextAlign && e.wordWrapWidth === t.wordWrapWidth && e.forceCalculateMaxLineWidth === t.forceCalculateMaxLineWidth && e.padding === t.padding && e.scale === t.scale && e.highlightBorder === t.highlightBorder && e.boxPadding === t.boxPadding && e.boxPaddingVert === t.boxPaddingVert && e.boxPaddingLeft === t.boxPaddingLeft && e.boxPaddingRight === t.boxPaddingRight && e.boxPaddingHorz === t.boxPaddingHorz && e.angle === t.angle && e.maxHeight === t.maxHeight && (0,
                    d.deepEquals)(e.boxShadow, t.boxShadow)[0]
                }(this._data, e) ? (this._data = e,
                this._internalData = null,
                this._boxSize = null,
                this._polygonPoints = null,
                this._centerTextRotationPoint = null,
                this._rotationPoint = null,
                this._linesInfo = null,
                this._fontInfo = null) : this._data = e) : this._data = null
            }
            hitTest(e) {
                return null === this._data || void 0 === this._data.points || 0 === this._data.points.length ? null : (0,
                n.pointInPolygon)(e, this.getPolygonPoints()) ? this._hitTest : null
            }
            doesIntersectWithBox(e) {
                return null !== this._data && void 0 !== this._data.points && 0 !== this._data.points.length && (0,
                n.pointInBox)(this._data.points[0], e)
            }
            measure() {
                if (null === this._data)
                    return {
                        width: 0,
                        height: 0
                    };
                const e = this._getBoxSize();
                return {
                    width: e.boxWidth,
                    height: e.boxHeight
                }
            }
            rect() {
                if (null === this._data)
                    return {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    };
                const e = this._getInternalData();
                return {
                    x: e.boxLeft,
                    y: e.boxTop,
                    width: e.boxWidth,
                    height: e.boxHeight
                }
            }
            isOutOfScreen(e, t) {
                if (null === this._data || void 0 === this._data.points || 0 === this._data.points.length)
                    return !0;
                const i = this._getInternalData();
                if (i.boxLeft + i.boxWidth < 0 || i.boxLeft > e) {
                    const i = (0,
                    s.box)(new s.Point(0,0), new s.Point(e,t));
                    return this.getPolygonPoints().every((e=>!(0,
                    n.pointInBox)(e, i)))
                }
                return !1
            }
            setPoints(e, t) {
                (0,
                o.ensureNotNull)(this._data).points = e,
                this._hitTest = t || new a.HitTestResult(a.HitTarget.MovePoint)
            }
            setPoint(e, t, i) {
                const s = (0,
                o.ensureNotNull)(this._data);
                this.setData({
                    ...s,
                    points: [e],
                    offsetX: null != t ? t : s.offsetX,
                    offsetY: null != i ? i : s.offsetY
                })
            }
            point() {
                var e, t, i;
                return null !== (i = null === (t = null === (e = this._data) || void 0 === e ? void 0 : e.points) || void 0 === t ? void 0 : t[0]) && void 0 !== i ? i : null
            }
            fontStyle(e) {
                return null === this._data ? "" : this._getFontInfo().fontStyle
            }
            lineHeight() {
                return null === this._data ? 0 : A(this._data)
            }
            lineSpacing() {
                return null === this._data ? 0 : I(this._data)
            }
            draw(e, t) {
                var i;
                if (null === this._data || void 0 === this._data.points || 0 === this._data.points.length)
                    return;
                const {mediaSize: n, horizontalPixelRatio: r, verticalPixelRatio: a} = t;
                if (this.isOutOfScreen(n.width, n.height))
                    return;
                const c = this._getInternalData()
                  , d = (0,
                o.ensureNotNull)(this.rotation())
                  , p = (0,
                s.point)(d.x * r, d.y * a);
                e.save(),
                0 !== d.angle && (e.translate(p.x, p.y),
                e.rotate(d.angle),
                e.translate(-p.x, -p.y));
                const m = this._getFontInfo().fontSize;
                e.textBaseline = c.textBaseLine,
                e.textAlign = c.textAlign,
                e.font = this.fontStyle();
                const {scaledLeft: g, scaledRight: _, scaledTop: v, scaledBottom: S} = function(e, t) {
                    const {horizontalPixelRatio: i, verticalPixelRatio: s} = t
                      , o = Math.round(e.boxLeft * i)
                      , n = Math.round(e.boxTop * s);
                    return {
                        scaledLeft: o,
                        scaledRight: o + Math.round(e.boxWidth * i),
                        scaledTop: n,
                        scaledBottom: n + Math.round(e.boxHeight * s)
                    }
                }(c, t);
                if (this._data.backgroundColor || this._data.borderColor || this._data.highlightBorder && this._data.wordWrapWidth) {
                    const t = this._data.borderWidth || Math.max(m / 12, 1)
                      , i = Math.round(t * r)
                      , s = i / 2;
                    let o = !1;
                    if (this._data.boxShadow) {
                        e.save();
                        const {shadowColor: t, shadowBlur: i, shadowOffsetX: s=0, shadowOffsetY: n=0} = this._data.boxShadow;
                        e.shadowColor = t,
                        e.shadowBlur = i,
                        e.shadowOffsetX = s,
                        e.shadowOffsetY = n,
                        o = !0
                    }
                    if (this._data.backgroundRoundRect)
                        this._data.backgroundColor && ((0,
                        l.drawRoundRect)(e, g, v, _ - g, S - v, this._data.backgroundRoundRect * r),
                        e.fillStyle = this._data.backgroundColor,
                        e.fill(),
                        o && (e.restore(),
                        o = !1)),
                        this._data.borderColor && ((0,
                        l.drawRoundRect)(e, g - s, v - s, _ - g + i, S - v + i, this._data.backgroundRoundRect * r + i),
                        e.strokeStyle = this._data.borderColor,
                        e.lineWidth = i,
                        e.stroke(),
                        o && (e.restore(),
                        o = !1));
                    else if (this._data.backgroundColor && (e.fillStyle = this._data.backgroundColor,
                    e.fillRect(g, v, _ - g, S - v),
                    o && (e.restore(),
                    o = !1)),
                    this._data.borderColor || this._data.highlightBorder) {
                        let t;
                        this._data.borderColor ? (e.strokeStyle = this._data.borderColor,
                        t = i) : (e.strokeStyle = this._data.highlightBorderColor || this._data.color,
                        (0,
                        l.setLineStyle)(e, h.LINESTYLE_DASHED),
                        t = Math.max(1, Math.floor(r))),
                        e.lineWidth = t,
                        e.beginPath(),
                        e.moveTo(g - t / 2, v - t / 2),
                        e.lineTo(g - t / 2, S + t / 2),
                        e.lineTo(_ + t / 2, S + t / 2),
                        e.lineTo(_ + t / 2, v - t / 2),
                        e.lineTo(g - t / 2, v - t / 2),
                        e.stroke(),
                        o && e.restore()
                    }
                }
                this._drawSelectionIfNeeded(e, t),
                e.fillStyle = this._data.color;
                const f = (g + Math.round(c.textHorizStart * r)) / r
                  , b = .05 * m;
                let y = (v + Math.round((c.textVertStart + b) * a)) / a;
                const C = I(this._data)
                  , w = this.getLinesInfo();
                for (const t of w.lines)
                    (0,
                    u.drawScaled)(e, r, a, (()=>e.fillText(t.text, f, y))),
                    y += m + C;
                null === (i = this._data.decorator) || void 0 === i || i.draw(e, t, this._data, c),
                e.restore()
            }
            getPolygonPoints() {
                if (null !== this._polygonPoints)
                    return this._polygonPoints;
                if (null === this._data)
                    return [];
                const e = this._data.angle || 0
                  , {boxLeft: t, boxTop: i, boxWidth: o, boxHeight: n} = this._getInternalData()
                  , r = this._getRotationPoint();
                return this._polygonPoints = [y(new s.Point(t,i), r, e), y(new s.Point(t + o,i), r, e), y(new s.Point(t + o,i + n), r, e), y(new s.Point(t,i + n), r, e)],
                this._polygonPoints
            }
            centerTextRotation() {
                var e;
                if (null === this._centerTextRotationPoint && null !== this._data) {
                    const t = null !== (e = this._data.angle) && void 0 !== e ? e : 0
                      , i = this._getRotationPoint()
                      , {textLeft: o, textTop: n, textRight: r, textBottom: a} = this._getInternalData()
                      , l = y(new s.Point((o + r) / 2,(n + a) / 2), i, t);
                    this._centerTextRotationPoint = {
                        x: l.x,
                        y: l.y,
                        angle: t
                    }
                }
                return this._centerTextRotationPoint
            }
            rotation() {
                var e;
                if (null === this._rotationPoint && null !== this._data) {
                    const t = null !== (e = this._data.angle) && void 0 !== e ? e : 0
                      , i = this._getRotationPoint();
                    this._rotationPoint = {
                        x: i.x,
                        y: i.y,
                        angle: t
                    }
                }
                return this._rotationPoint
            }
            getLinesInfo() {
                if (null === this._linesInfo) {
                    const e = (0,
                    o.ensureNotNull)(this._data)
                      , t = b(e.text, this.fontStyle(), this._textWidthCache, !1, e.wordWrapWidth);
                    let i = t.filter((e=>!e.hidden));
                    if (void 0 !== e.maxHeight) {
                        const t = function(e) {
                            const t = (0,
                            o.ensureDefined)(e.maxHeight)
                              , i = A(e)
                              , s = I(e);
                            return Math.floor((t + s) / (i + s))
                        }(e);
                        i.length > t && (i = i.slice(0, t))
                    }
                    this._linesInfo = {
                        linesMaxWidth: this._getLinesMaxWidth(i),
                        linesIncludingHidden: t,
                        lines: i
                    }
                }
                return this._linesInfo
            }
            positionToCoordinate(e) {
                const t = (0,
                o.ensureNotNull)(this._data)
                  , i = this._getInternalData()
                  , s = this.getLinesInfo()
                  , {x: n, y: r, lineNumber: a} = (0,
                c.getSymbolCoordinatesInfo)({
                    symbolPosition: e,
                    textWidth: i.textRight - i.textLeft,
                    textByLines: s.linesIncludingHidden,
                    lineHeight: A(t),
                    font: this.fontStyle(),
                    textAlign: i.textAlign,
                    lineSpacing: this.lineSpacing()
                });
                return {
                    x: n + i.textLeft,
                    y: r + i.textTop,
                    lineNumber: a
                }
            }
            _getInternalData() {
                var e, t, i;
                if (null !== this._internalData)
                    return this._internalData;
                const s = (0,
                o.ensureNotNull)(this._data)
                  , n = this._getBoxSize()
                  , a = n.boxWidth
                  , l = n.boxHeight
                  , c = (0,
                o.ensureDefined)(s.points)[0];
                let d = c.y;
                switch (s.vertAlign) {
                case "bottom":
                    d -= l + s.offsetY;
                    break;
                case "middle":
                    d -= l / 2;
                    break;
                case "top":
                    d += s.offsetY
                }
                let u = c.x;
                const h = x(s)
                  , p = M(s)
                  , m = T(s)
                  , g = null === (e = s.decorator) || void 0 === e ? void 0 : e.geometry(s)
                  , _ = null !== (t = null == g ? void 0 : g.width) && void 0 !== t ? t : 0
                  , v = 0 === s.text.length ? 0 : null !== (i = null == g ? void 0 : g.decoratorAndTextMargin) && void 0 !== i ? i : 0
                  , S = null == g ? void 0 : g.ignoreRtl
                  , f = _ + v;
                let b;
                const y = d + m + A(s) / 2;
                let C;
                switch (s.horzAlign) {
                case "left":
                    u += s.offsetX;
                    break;
                case "center":
                    u -= a / 2;
                    break;
                case "right":
                    u -= a + s.offsetX
                }
                const w = (0,
                r.isRtl)()
                  , P = w && !S
                  , I = P ? u + a - p - _ : u + h;
                switch ((0,
                o.ensureDefined)(s.horzTextAlign)) {
                case "left":
                    C = "start",
                    b = I + f,
                    w && (s.forceTextAlign ? C = "left" : (b = P ? I - v : u + a - p,
                    C = "right"));
                    break;
                case "center":
                    C = "center";
                    const e = a - h - p - f;
                    b = P ? I - v - e / 2 : I + f + e / 2;
                    break;
                case "right":
                    C = "end",
                    b = P ? I - v : u + a - p,
                    w && s.forceTextAlign && (C = "right")
                }
                return this._internalData = {
                    boxLeft: u,
                    boxTop: d,
                    boxWidth: a,
                    boxHeight: l,
                    textLeft: u + h + (P ? 0 : f),
                    textRight: u + a - p - (P ? f : 0),
                    textTop: d + m,
                    textBottom: d + l - m,
                    textHorizStart: b - u,
                    textVertStart: y - d,
                    textAlign: C,
                    textBaseLine: "middle",
                    decoratorLeft: I,
                    decoratorWidth: _
                },
                this._internalData
            }
            _getFontInfo() {
                if (null === this._fontInfo) {
                    const e = (0,
                    o.ensureNotNull)(this._data)
                      , t = A(e)
                      , i = (e.bold ? "bold " : "") + (e.italic ? "italic " : "") + t + "px " + e.font;
                    this._fontInfo = {
                        fontStyle: i,
                        fontSize: t
                    }
                }
                return this._fontInfo
            }
            _drawSelectionIfNeeded(e, t) {
                const i = (0,
                o.ensureNotNull)(this._data)
                  , s = A((0,
                o.ensureNotNull)(this._data));
                if (i.selectionHighlight) {
                    const o = this.positionToCoordinate(i.selectionHighlight.start)
                      , n = this.positionToCoordinate(i.selectionHighlight.end)
                      , r = this._getInternalData();
                    (0,
                    c.drawSelection)(e, t, {
                        lines: this.getLinesInfo().linesIncludingHidden,
                        selectionStart: o,
                        selectionEnd: n,
                        left: r.textLeft,
                        right: r.textRight,
                        color: i.selectionHighlight.color,
                        font: this.fontStyle(),
                        lineHeight: s,
                        lineSpacing: this.lineSpacing()
                    })
                }
            }
            _getLinesMaxWidth(e) {
                const t = this.fontStyle();
                if (null !== this._data && this._data.wordWrapWidth && !this._data.forceCalculateMaxLineWidth)
                    return this._data.wordWrapWidth * E(this._data);
                let i = 0;
                for (const s of e)
                    i = Math.max(i, (0,
                    u.measureText)(s.text, t, this._textWidthCache).width);
                return i
            }
            _getBoxSize() {
                if (null === this._boxSize) {
                    const e = this.getLinesInfo()
                      , t = (0,
                    o.ensureNotNull)(this._data);
                    this._boxSize = {
                        boxWidth: C(t, e.linesMaxWidth),
                        boxHeight: w(t, e.lines.length)
                    }
                }
                return this._boxSize
            }
            _getRotationPoint() {
                const {boxLeft: e, boxTop: t, boxWidth: i, boxHeight: n} = this._getInternalData()
                  , {horzAlign: r, vertAlign: a} = (0,
                o.ensureNotNull)(this._data);
                let l, c;
                switch (r) {
                case "center":
                    l = e + i / 2;
                    break;
                case "left":
                    l = e;
                    break;
                case "right":
                    l = e + i
                }
                switch (a) {
                case "middle":
                    c = t + n / 2;
                    break;
                case "top":
                    c = t;
                    break;
                case "bottom":
                    c = t + n
                }
                return new s.Point(l,c)
            }
        }
    }
    ,
    954384: (e,t,i)=>{
        "use strict";
        i.d(t, {
            PrePostMarket: ()=>S,
            defaultPrePostMarketPreferences: ()=>v
        });
        var s = i(166770)
          , o = i(666574)
          , n = i(95370)
          , r = i(129968)
          , a = i(336928);
        class l extends a.PriceLineAxisView {
            constructor(e, t) {
                super(),
                this._model = e,
                this._source = t
            }
            _value() {
                const e = this._model.mainSeries()
                  , t = e.priceScale()
                  , i = e.firstValue();
                if (null === i)
                    return {
                        noData: !0
                    };
                const s = this._source.price()
                  , o = this._source.currentSession();
                if (null === s || "pre_market" !== o && "post_market" !== o)
                    return {
                        noData: !0
                    };
                const n = t.priceToCoordinate(s, i);
                return {
                    noData: !1,
                    floatCoordinate: n,
                    coordinate: n,
                    color: "",
                    formattedPricePercentage: "",
                    formattedPriceAbsolute: "",
                    formattedPriceIndexedTo100: "",
                    text: "",
                    index: 0
                }
            }
            _priceLineColor(e) {
                const t = this._source.properties().childs();
                return "pre_market" === this._source.currentSession() ? t.preMarketColor.value() : t.postMarketColor.value()
            }
            _lineWidth() {
                return this._source.properties().childs().lineWidth.value()
            }
            _lineStyle() {
                return this._source.properties().childs().lineStyle.value()
            }
            _isVisible() {
                if (!this._source.canBeVisibleOnSymbolAndInterval() || !this._model.properties().childs().scalesProperties.childs().showPrePostMarketPriceLabel.value())
                    return !1;
                const e = this._source.price()
                  , t = this._source.currentSession();
                return null !== e && ("pre_market" === t || "post_market" === t)
            }
        }
        var c = i(444372)
          , d = i(347808)
          , u = i(432059);
        class h extends d.PriceAxisView {
            constructor(e, t) {
                super(),
                this._model = e,
                this._source = t
            }
            _updateRendererData(e, t, s) {
                if (e.visible = !1,
                t.visible = !1,
                !this._model.properties().childs().scalesProperties.childs().showPrePostMarketPriceLabel.value())
                    return;
                const o = this._model.mainSeries()
                  , n = o.priceScale()
                  , r = o.firstValue();
                if (null === r)
                    return;
                if (!this._source.canBeVisibleOnSymbolAndInterval())
                    return;
                const a = this._source.price()
                  , l = this._source.currentSession();
                if (null == a || "pre_market" !== l && "post_market" !== l)
                    return;
                const d = this._source.properties().childs()
                  , h = "pre_market" === l ? (0,
                u.resetTransparency)(d.preMarketColor.value()) : (0,
                u.resetTransparency)(d.postMarketColor.value());
                e.visible = !0,
                t.visible = !0,
                e.text = n.formatPriceAbsolute(a),
                t.text = "pre_market" === l ? c.t(null, {
                    context: "market_status"
                }, i(293866)) : c.t(null, {
                    context: "market_status"
                }, i(35359)),
                s.coordinate = n.priceToCoordinate(a, r),
                s.background = h,
                s.textColor = this.generateTextColor(h)
            }
        }
        var p = i(345159)
          , m = i(509078);
        class g extends p.HorizontalLinePaneView {
            constructor(e, t, i) {
                super(),
                this._model = e,
                this._source = t;
                const s = {
                    doubleClickHandler: i,
                    doubleTapHandler: i
                };
                this._lineRenderer.setHitTest(new m.HitTestResult(m.HitTarget.Regular,s))
            }
            _updateImpl() {
                const e = this._lineRendererData;
                e.visible = !1;
                const t = this._model.mainSeries()
                  , i = this._source.properties().childs();
                if (!i.visible.value() || !t.isVisible())
                    return;
                const s = t.priceScale()
                  , o = t.firstValue();
                if (null === o)
                    return;
                if (!this._source.canBeVisibleOnSymbolAndInterval())
                    return;
                const n = this._source.price()
                  , r = this._source.currentSession();
                null === n || "pre_market" !== r && "post_market" !== r || (e.visible = !0,
                e.y = s.priceToCoordinate(n, o),
                e.linestyle = i.lineStyle.value(),
                e.linewidth = i.lineWidth.value(),
                e.color = "pre_market" === r ? i.preMarketColor.value() : i.postMarketColor.value())
            }
        }
        var _ = i(169532);
        const v = {
            visible: !0,
            lineStyle: o.LINESTYLE_DOTTED,
            lineWidth: 1,
            preMarketColor: "#fb8c00",
            postMarketColor: s.colorsPalette["color-tv-blue-500"]
        };
        class S extends r.CustomSourceBase {
            constructor(e, t, i) {
                super(e, t),
                this._extraHoursPrice = null,
                this._currentSession = "holiday",
                this._quotesProvider = t.mainSeries().quotesProvider(),
                this._prePostMarketLinePaneView = new g(t,this,i),
                this._prePostPriceAxisView = new h(t,this),
                this._prePostLabelPaneView = new n.PanePriceAxisView(this._prePostPriceAxisView,t.mainSeries(),t),
                this._prePostPriceLineAxisView = new l(t,this),
                this._quotesProvider.quotesUpdate().subscribe(this, this._updateQuotes),
                this._updateQuotes()
            }
            destroy() {
                this._quotesProvider.quotesUpdate().unsubscribeAll(this)
            }
            paneViews(e) {
                return this._areViewsAvailableForPane(e) ? [this._prePostMarketLinePaneView] : []
            }
            labelPaneViews(e) {
                return this._areViewsAvailableForPane(e) ? [this._prePostLabelPaneView] : []
            }
            priceAxisViews(e, t) {
                return this._areViewsAvailableForPane(e) ? e.findTargetPriceAxisViews(this, t, [this._prePostPriceAxisView], [this._prePostPriceLineAxisView]) : []
            }
            priceScale() {
                return this._model.mainSeries().priceScale()
            }
            updateAllViews(e) {
                this._prePostMarketLinePaneView.update(e),
                this._prePostPriceAxisView.update(e),
                this._prePostPriceLineAxisView.update(e),
                this._prePostLabelPaneView.update(e)
            }
            price() {
                return this._extraHoursPrice
            }
            currentSession() {
                return this._currentSession
            }
            canBeVisibleOnSymbolAndInterval() {
                return this._model.mainSeries().isPrePostMarketPricesAvailableProperty().value()
            }
            properties() {
                return this._model.mainSeries().properties().childs().prePostMarket
            }
            _updateQuotes() {
                const e = this._quotesProvider.quotes();
                null === e ? this._extraHoursPrice = null : (this._extraHoursPrice = e.rtc,
                void 0 !== e.current_session && (this._currentSession = e.current_session));
                const t = this._model.mainSeries().properties().childs().prePostMarket.childs().visible.value()
                  , i = this._model.properties().childs().scalesProperties.childs().showPrePostMarketPriceLabel.value();
                this.canBeVisibleOnSymbolAndInterval() && (t || i) && (this.updateAllViews((0,
                _.sourceChangeEvent)(this.id())),
                this._model.updateSource(this))
            }
            _areViewsAvailableForPane(e) {
                return !this._model.isSnapshot() && this._model.paneForSource(this._model.mainSeries()) === e
            }
        }
    }
    ,
    383557: (e,t,i)=>{
        "use strict";
        var s;
        i.d(t, {
            PublishedChartsFilter: ()=>s
        }),
        function(e) {
            e.None = "all",
            e.Following = "following",
            e.Private = "private"
        }(s || (s = {}))
    }
    ,
    622429: (e,t,i)=>{
        "use strict";
        i.d(t, {
            PublishedChartsTimeline: ()=>R
        });
        var s = i(444372)
          , o = i(62802)
          , n = i.n(o)
          , r = i(443874)
          , a = i(262078)
          , l = i(383557)
          , c = i(338619)
          , d = i(345848)
          , u = i(638456)
          , h = i(523863)
          , p = i(702598)
          , m = i(223124)
          , g = i(262624)
          , _ = i(650151)
          , v = i(166770)
          , S = i(542682)
          , f = i(934026)
          , b = i(86441)
          , y = i(509078)
          , C = i(631088);
        function w(e, t) {
            const {horizontalPixelRatio: i, verticalPixelRatio: s} = t
              , o = Math.max(1, Math.floor(i))
              , n = Math.round(e.x * i) + o % 2 / 2;
            let r = Math.round(e.size * i);
            (n + r / 2) % 1 != 0 && (r += 1);
            const a = Math.min(Math.max(1, Math.round(i * e.borderWidth)), r / 2);
            let l;
            const c = ("up" === e.direction ? -1 : 1) * (e.yInverted ? -1 : 1)
              , d = c * (Math.round(e.size * s / 2) + o % 2);
            if (void 0 !== e.fixedSpaceYPosition) {
                const t = Math.round(e.fixedSpaceYPosition.itemSpacing * s)
                  , i = e.fixedSpaceYPosition.order
                  , o = c * (r * i + t * (i + 1));
                l = Math.round(e.fixedSpaceYPosition.basePosition * s) + o + d
            } else
                l = Math.round(e.y * s) + d;
            return {
                x: n,
                y: l,
                size: r,
                borderWidth: a,
                tickSize: o
            }
        }
        function T(e, t, i, s) {
            var o;
            if (e.save(),
            i && !s.highlightByAuthor && (e.globalAlpha = .4),
            s.mine)
                !function(e, t, i) {
                    const {borderColor: s, backgroundColor: o, doNotFill: n, direction: r, yInverted: a} = i
                      , {x: l, y: c, borderWidth: d, size: u, tickSize: h} = w(i, t);
                    e.strokeStyle = s,
                    e.fillStyle = o,
                    e.lineWidth = d;
                    const p = "up" === r !== a ? -1 : 1;
                    let m = Math.round(u / 2 / Math.tan(Math.PI / 6)) + h % 2 / 2;
                    (l + m / 2) % 1 != 0 && (m -= 1);
                    e.translate(l, c + m / 2 * p),
                    e.beginPath();
                    const g = d / 2;
                    e.moveTo(0, -p * (m - g)),
                    e.lineTo(u / 2 - g, d / 2),
                    e.lineTo(-u / 2 + g, d / 2),
                    e.lineTo(0, -p * (m - d / 2)),
                    e.closePath(),
                    n || e.fill();
                    e.stroke()
                }(e, t, s);
            else {
                0,
                function(e, t, i, s, o) {
                    const {borderColor: n, backgroundColor: r, label: a} = i
                      , {x: l, y: c, borderWidth: d, size: u} = w(i, t);
                    e.strokeStyle = n,
                    e.fillStyle = r,
                    e.lineWidth = d,
                    e.beginPath();
                    const h = u / 2 - d / 2;
                    e.arc(l, c, h, 0, 2 * Math.PI, !0),
                    e.closePath(),
                    e.fill(),
                    !1;
                    e.stroke(),
                    !s && a && u / 2 >= 7 && (e.textAlign = "center",
                    e.textBaseline = "middle",
                    e.font = a.font,
                    e.fillStyle = a.fontColor,
                    (0,
                    C.drawScaled)(e, t.horizontalPixelRatio, t.verticalPixelRatio, (()=>{
                        e.fillText(a.text, l / t.horizontalPixelRatio, c / t.verticalPixelRatio)
                    }
                    )))
                }(e, t, s, !1, null === (o = s.image) || void 0 === o ? void 0 : o.imageElement)
            }
            e.restore()
        }
        class P {
            constructor(e, t, i, s) {
                this._canvas = null,
                this._clickHandler = e,
                this._enterHandler = t,
                this._leaveHandler = i,
                this._data = null != s ? s : null
            }
            setData(e) {
                this._data = e
            }
            hitTest(e, t) {
                if (null === this._data)
                    return null;
                for (let i = this._data.items.length - 1; i >= 0; --i) {
                    const s = this._hitTestDot(this._data.items[i], e, t);
                    if (s)
                        return s
                }
                return null
            }
            draw(e, t) {
                this._canvas = e.canvas,
                null !== this._data && this._data.items.forEach(T.bind(null, e, t, this._data.highlightByAuthor))
            }
            _hitTestDot(e, t, i) {
                const s = new b.Point(e.x,w(e, i).y / i.verticalPixelRatio);
                if ((0,
                f.pointInCircle)(t, s, Math.max(e.size / 2, 8))) {
                    const t = this._canvas
                      , i = null === t ? void 0 : {
                        mouseEnterHandler: ()=>this._enterHandler(e, s.y, t),
                        mouseLeaveHandler: ()=>this._leaveHandler(),
                        clickHandler: i=>this._clickHandler(e, s.y, t, i),
                        tapHandler: i=>this._clickHandler(e, s.y, t, i)
                    };
                    return new y.HitTestResult(y.HitTarget.Regular,{
                        activeItem: e.originalItem.id,
                        ...i
                    })
                }
                return null
            }
        }
        var x = i(694852)
          , M = i(511275)
          , I = i(188035);
        const A = {
            green: {
                border: (0,
                v.getHexColorByName)("color-minty-green-700"),
                background: (0,
                v.getHexColorByName)("color-minty-green-a600")
            },
            red: {
                border: (0,
                v.getHexColorByName)("color-ripe-red-700"),
                background: (0,
                v.getHexColorByName)("color-ripe-red-500")
            },
            neutral: {
                border: (0,
                v.getHexColorByName)("color-tan-orange-700"),
                background: (0,
                v.getHexColorByName)("color-tan-orange-500")
            },
            yellow: {
                border: "#EAC300",
                background: "#FFD400"
            },
            blue: {
                border: "#047ACE",
                background: "#0496FF"
            }
        };
        function L(e) {
            var t, i, s, o;
            return e.hovered || e.highlightByAuthor ? null !== (i = null === (t = e.overrideBorderWidth) || void 0 === t ? void 0 : t.hoveredWidth) && void 0 !== i ? i : 4 : null !== (o = null === (s = e.overrideBorderWidth) || void 0 === s ? void 0 : s.width) && void 0 !== o ? o : 2
        }
        const E = (0,
        c.getLogger)("Chart.PublishedChartsTimeline");
        class k extends class {
            constructor(e, t) {
                this._tooltip = null,
                this._hoveredBarsMarkData = null,
                this._destroyed = !1,
                this._invalidated = !0,
                this._originalData = [],
                this._source = e,
                this._model = t,
                this._renderer = new P(this._onItemClicked.bind(this),this._showItem.bind(this),this._hideItem.bind(this)),
                this._createTooltipRenderer().then((e=>{
                    this._destroyed ? null == e || e.destroy() : this._tooltip = e
                }
                )),
                e.properties().childs().visible.subscribe(null, (()=>{
                    var e;
                    null === (e = this._tooltip) || void 0 === e || e.hide(!0)
                }
                ))
            }
            destroy() {
                var e;
                this._destroyed = !0,
                null === (e = this._tooltip) || void 0 === e || e.destroy()
            }
            source() {
                return this._source
            }
            update() {
                this._invalidated = !0
            }
            renderer() {
                return this._invalidated && (this._updateImpl(),
                this._invalidated = !1),
                this._renderer
            }
            onClickOutside(e, t) {
                t && ((0,
                I.isTouchMouseEvent)(t) ? t.isTouch : (0,
                S.isTouchEvent)(t)) && null !== this._tooltip && !this._tooltip.contains(t.target) && this._tooltip.hide(!0)
            }
            _extractBarMarksRendererItemData(e, t) {
                var i, s;
                const o = null !== (i = t.overridedTheme) && void 0 !== i ? i : A[t.theme]
                  , n = this._calculateSize(e, t)
                  , r = this._calculateY(e, n, t);
                return null === this._hoveredBarsMarkData || this._hoveredBarsMarkData.id !== t.id || this._hoveredBarsMarkData.x === t.x && this._hoveredBarsMarkData.y === Math.round(r) || (null === (s = this._tooltip) || void 0 === s || s.hide(!0),
                this._hoveredBarsMarkData = null),
                {
                    x: t.x,
                    y: this._calculateY(e, n, t),
                    direction: t.direction,
                    borderColor: o.border,
                    borderWidth: L(t),
                    backgroundColor: o.background,
                    size: n,
                    doNotFill: !t.public,
                    yInverted: t.yInverted,
                    label: void 0 === t.label ? void 0 : {
                        text: t.label,
                        fontColor: t.labelFontColor,
                        font: (0,
                        x.makeFont)(Math.ceil(Math.max(10, Math.min(n / 2, 20))), M.CHART_FONT_FAMILY, "bold")
                    },
                    originalItem: t
                }
            }
            _onItemClicked(e, t, i, s) {
                s.isTouch && this._showItem(e, t, i)
            }
            async _showItem(e, t, i) {
                var s;
                const o = await this._tooltipProps(e);
                if (null === o)
                    return;
                const n = this._model.timeScale().barSpacing()
                  , r = this._calculateSize(n, e.originalItem);
                this._hoveredBarsMarkData = {
                    x: e.x,
                    y: Math.round(this._calculateY(n, r, e.originalItem)),
                    id: e.originalItem.id
                },
                null === (s = this._tooltip) || void 0 === s || s.show({
                    itemSize: r,
                    container: (0,
                    _.ensureNotNull)(i.parentElement),
                    x: e.x,
                    y: t,
                    factoryProps: o,
                    onClickOutside: ()=>{
                        var e;
                        return null === (e = this._tooltip) || void 0 === e ? void 0 : e.hide(!0)
                    }
                })
            }
            _hideItem() {
                var e;
                null === (e = this._tooltip) || void 0 === e || e.hide()
            }
            _calculateSize(e, t) {
                return Math.min(553, Math.max(7, t.minSize, .8 * e))
            }
            _updateImpl() {
                this._originalData = this._source.getPlatesViewData();
                const e = this._model.timeScale().barSpacing()
                  , t = this._originalData.map(this._extractBarMarksRendererItemData.bind(this, e));
                this._renderer.setData({
                    items: t,
                    barSpacing: e,
                    highlightByAuthor: !1
                })
            }
        }
        {
            constructor() {
                super(...arguments),
                this._profileDataCache = new Map
            }
            _extractBarMarksRendererItemData(e, t) {
                const i = super._extractBarMarksRendererItemData(e, t);
                return {
                    ...i,
                    fixedSpaceYPosition: {
                        basePosition: t.y,
                        order: t.order,
                        itemSpacing: .2857142857142857 * e
                    },
                    mine: t.mine,
                    borderWidth: t.hovered ? i.borderWidth : t.public ? 1 : 2,
                    doNotFill: !t.public,
                    direction: t.direction
                }
            }
            async _createTooltipRenderer() {
                const [{TooltipRenderer: e},{PublishedChartsTimelineTooltip: t}] = await Promise.all([Promise.all([i.e(22164), i.e(87393), i.e(58685), i.e(32227), i.e(70354)]).then(i.bind(i, 410842)), Promise.all([i.e(22164), i.e(87393), i.e(58685), i.e(32227), i.e(70354)]).then(i.bind(i, 319824))]);
                return new e(t)
            }
            _calculateY(e, t, i) {
                const s = ("up" === i.direction ? -1 : 1) * (i.yInverted ? -1 : 1)
                  , o = s * (t * i.order + .2857142857142857 * t * (i.order + 1));
                return i.y + t / 2 * s + o
            }
            _onItemClicked(e, t, i, s) {
                super._onItemClicked(e, t, i, s),
                s.isTouch || this.source().showIdea(e.originalItem.id, !1)
            }
            async _tooltipProps(e) {
                var t;
                const i = (0,
                _.ensureDefined)(e.originalItem.username);
                let s = this._profileDataCache.get(i);
                if (void 0 === s) {
                    try {
                        s = await function(e) {
                            return fetch(`/api/v1/user/profile/${e}/?avatars_fallback=true&by=username`).then((e=>e.json()))
                        }(i)
                    } catch (e) {
                        return E.logWarn(`An error ocurred while loading profile data: ${e}`),
                        null
                    }
                    this._profileDataCache.set(i, s)
                }
                return Promise.resolve({
                    avatarUrl: null === (t = s.avatars) || void 0 === t ? void 0 : t.mid,
                    badges: s.badges,
                    title: (0,
                    _.ensureDefined)(e.originalItem.title),
                    username: i,
                    onTitleClicked: ()=>this.source().showIdea(e.originalItem.id, !1)
                })
            }
        }
        var D = i(343272)
          , N = i(314802);
        const B = (0,
        c.getLogger)("Chart.PublishedChartsTimeLine");
        class R extends r.BarsMarksContainer {
            constructor(e, t) {
                let i = n().getValue("PublishedChartsTimeline.filter", l.PublishedChartsFilter.None);
                window.is_authenticated || (i = l.PublishedChartsFilter.None);
                const s = new g.DefaultProperty({
                    defaultName: "publishedchartstimeline",
                    state: {
                        filter: i
                    }
                });
                super(e, s),
                this.setId("PublishedChartsTimeline"),
                this._paneView = new k(this,e),
                this._paneViews = [this._paneView],
                this._currentRange = null,
                this._properties.childs().visible.subscribe(this, (()=>{
                    this._getData(this._currentRange)
                }
                )),
                s.childs().filter.subscribe(this, (e=>{
                    n().setValue("PublishedChartsTimeline.filter", e.value()),
                    this.clearMarks(),
                    this._getData(this._currentRange)
                }
                )),
                this._containsData = e.isSnapshot(),
                this._containsData && this._properties.childs().visible.setValue(!0),
                this.setUserEditEnabled(!1),
                this._onIdeaClickedHandler = t
            }
            destroy() {
                this._onIdeaClickedHandler = null,
                this._boundOnMessage && (a.pushStreamMultiplexer.off("ideas", this._boundOnMessage),
                a.pushStreamMultiplexer.off("ideas.post", this._boundOnMessage),
                this._boundOnMessage = null),
                this._paneView.destroy(),
                super.destroy()
            }
            name() {
                return "Ideas on chart"
            }
            title() {
                return s.t(null, void 0, i(958757))
            }
            zorder() {
                return D.sortSourcesPreOrdered.BarMarks
            }
            paneViews() {
                return this._model.isInReplay().value() || !this._properties.childs().visible.value() ? [] : this._paneViews
            }
            showIdea(e, t) {
                var i;
                const s = this._marks[e];
                s ? ((0,
                d.trackEvent)("GUI", "View published idea"),
                t && (0,
                d.trackEvent)("GUI", "Ideas navigation arrow"),
                (0,
                u.onWidget)() || this._containsData || (0,
                N.isOnMobileAppPage)("any") ? window.open(`${this._getBaseUrl()}${s.published_chart_url || "/v/" + s.image_url + "/"}`) : s.image_url && (null === (i = this._onIdeaClickedHandler) || void 0 === i || i.call(this, {
                    uid: s.image_url,
                    url: s.published_chart_url
                }))) : B.logDebug("PublishedChartsTimeline.showIdea: unexpected published chart id")
            }
            state(e) {
                const t = {
                    type: "BarsMarksContainer",
                    id: this.id(),
                    zorder: this.zorder(),
                    pinnedTooltips: this._pinnedTooltips
                };
                return e && this._properties.childs().visible.value() && (t.marks = this.getPublishedPlates()),
                t
            }
            restoreData(e, t) {
                null != e.pinnedTooltips && (this._pinnedTooltips = e.pinnedTooltips),
                t && void 0 !== e.marks && (this._marks = e.marks)
            }
            onClickOutside(e, t) {
                this._paneView.onClickOutside(e, t)
            }
            _getIndex(e) {
                return this.timeScale().timePointToIndex(e, 1)
            }
            _initialize() {
                a.pushStreamMultiplexer && (this._boundOnMessage = this._onMessage.bind(this),
                a.pushStreamMultiplexer.on("ideas", this._boundOnMessage),
                a.pushStreamMultiplexer.on("ideas.post", this._boundOnMessage))
            }
            _plateViewData(e) {
                return {
                    title: e.title,
                    user_id: e.user__id,
                    username: e.username,
                    suggested: e.is_hot,
                    mine: e.user__id === window.user.id,
                    public: e.is_public
                }
            }
            _getData(e, t) {
                const i = this._model.mainSeries().properties().childs()
                  , s = this._model.mainSeries().symbolInfo();
                if (this._currentRange = e,
                !s || !this._properties.childs().visible.value() && !t)
                    return Promise.resolve([]);
                let o = s.base_name.length > 1 ? s.base_name : [s.pro_name];
                const n = this.roundRange(this._rangeDifference(e));
                o = (0,
                h.uniq)(o),
                o = o.sort();
                const r = new FormData;
                r.append("interval", i.interval.value()),
                r.append("legs", JSON.stringify(o)),
                r.append("startTickmark", n.start.toString()),
                r.append("endTickmark", n.end.toString()),
                r.append("filter", this.properties().childs().filter.value());
                const a = (0,
                m.makeCancelable)(new Promise(((e,t)=>{
                    (0,
                    p.fetch)("/charttimeline/", {
                        method: "POST",
                        body: r,
                        headers: new Headers({
                            acccept: "application/json",
                            "X-Requested-With": "XMLHttpRequest"
                        })
                    }).then((i=>{
                        i.ok ? i.json().then(e) : t()
                    }
                    )).catch(t)
                }
                )));
                return a.promise.then((t=>{
                    t.forEach((e=>{
                        this._marks[e.id] = e
                    }
                    )),
                    this._loadedRange = this._rangeUnion(e, this._loadedRange);
                    const i = this._requests.indexOf(a);
                    ~i && this._requests.splice(i, 1),
                    this.updateAllViewsAndRepaint()
                }
                )),
                this._requests.push(a),
                a.promise
            }
            _onMessage(e, t, i, s) {
                if (this._containsData)
                    return;
                const o = this._model.mainSeries()
                  , n = o.symbolInfo()
                  , r = n && n.base_name;
                if (!r)
                    return;
                const a = o.properties().childs();
                e.interval === a.interval.value() && ~r.indexOf(e.pro_symbol) && (this._marks[e.id] = e,
                this.updateAllViewsAndRepaint())
            }
            _getBaseUrl() {
                if ((0,
                u.onWidget)() && window.locale_domains) {
                    const e = window.locale || "en"
                      , t = window.locale_domains[e] ? window.locale_domains[e] : window.locale_domains.en;
                    return t ? document.location.protocol + "//" + t : ""
                }
                return ""
            }
        }
    }
    ,
    907256: (e,t,i)=>{
        "use strict";
        i.d(t, {
            replayModeProperty: ()=>l
        });
        var s = i(62802)
          , o = i(638456)
          , n = i(998418);
        const r = "replay_mode";
        function a() {
            return o.CheckMobile.any() ? "ActiveChart" : s.getValue(r, "ActiveChart")
        }
        const l = (0,
        n.createPrimitiveProperty)(a());
        s.onSync.subscribe(null, (()=>l.setValue(a()))),
        l.subscribe(null, (()=>s.setValue(r, l.value())))
    }
    ,
    128011: (e,t,i)=>{
        "use strict";
        i.d(t, {
            allPriceScaleSelectionStrategyInfo: ()=>c,
            createPriceScaleSelectionStrategy: ()=>l
        });
        var s = i(650151)
          , o = i(444372)
          , n = i(434396);
        class r {
            constructor(e) {
                this._priceScalesLimit = 8,
                this._metaInfo = e
            }
            metaInfo() {
                return this._metaInfo
            }
            findSuitableScale(e, t, i, s) {
                if (void 0 !== s)
                    return this._tryToGetDesiredPriceScale(e, t, s, i);
                if ((0,
                n.isStudy)(t)) {
                    const s = t.metaInfo();
                    if ("Volume" === s.shortId && e.containsMainSeries())
                        return e.createPriceScaleAtPosition("overlay");
                    const o = t.desiredPriceScalePosition();
                    if (null !== o)
                        return this._tryToGetDesiredPriceScale(e, t, o, i);
                    if (void 0 !== i && ((0,
                    n.isStudy)(i) || e.isMainPane()) && s.is_price_study)
                        return this._getPriceScaleTheSameAsForSource(i, e)
                }
                let o = !1;
                if ((0,
                n.isStudy)(t)) {
                    const i = t.metaInfo().groupingKey;
                    if (void 0 !== i) {
                        const t = e.model().findNonOverlayStudyWithGroupingKey(i, e);
                        if (null !== t)
                            return this._getPriceScaleTheSameAsForSource(t.study, t.pane)
                    }
                    o = Boolean(t.metaInfo().is_price_study)
                } else
                    t === e.model().mainSeries() && (o = !0);
                if (o) {
                    const t = this._findFirstScaleForPriceStudy(e);
                    if (null !== t)
                        return t
                }
                return this.createNewPriceScaleIfPossible(e)
            }
            canCreateNewPriceScale(e) {
                return e.leftPriceScales().length + e.rightPriceScales().length < this._priceScalesLimit
            }
            _getPriceScaleTheSameAsForSource(e, t) {
                return t.isOverlay(e) ? t.createPriceScaleAtPosition("overlay") : (0,
                s.ensureNotNull)(e.priceScale())
            }
            _priceScaleIsPrice(e, t) {
                const i = e.mainSource();
                return !!i && (i === t.mainSeries() || !!(0,
                n.isStudy)(i) && Boolean(i.metaInfo().is_price_study))
            }
            _findFirstScaleForPriceStudy(e) {
                const t = e.model();
                for (let i = 0; i < this._priceScalesLimit; i++) {
                    if (e.rightPriceScales().length > i && this._priceScaleIsPrice(e.rightPriceScales()[i], t))
                        return e.rightPriceScales()[i];
                    if (e.leftPriceScales().length > i && this._priceScaleIsPrice(e.leftPriceScales()[i], t))
                        return e.leftPriceScales()[i]
                }
                return null
            }
            _targetPriceScaleIndex(e, t) {
                if (e.mainSource() === t.mainSeries())
                    return 0
            }
            _tryToGetDesiredPriceScale(e, t, i, o) {
                switch (i) {
                case "left":
                    return this.canCreateNewPriceScale(e) ? e.createPriceScaleAtPosition("left") : e.createPriceScaleAtPosition("overlay");
                case "right":
                    return this.canCreateNewPriceScale(e) ? e.createPriceScaleAtPosition("right") : e.createPriceScaleAtPosition("overlay");
                case "as-series":
                    return void 0 !== o ? (0,
                    s.ensureNotNull)(o.priceScale()) : e.isMainPane() ? (0,
                    s.ensureNotNull)((0,
                    s.ensureNotNull)(e.mainDataSource()).priceScale()) : this.createNewPriceScaleIfPossible(e);
                case "overlay":
                    return e.createPriceScaleAtPosition("overlay")
                }
            }
        }
        const a = [{
            name: "left",
            title: o.t(null, void 0, i(561507)),
            ctor: class extends r {
                constructor(e) {
                    super(e)
                }
                apply(e) {
                    const t = e.model();
                    e.rightPriceScales().slice(0).forEach((i=>e.movePriceScale(i, "left", this._targetPriceScaleIndex(i, t))))
                }
                createNewPriceScaleIfPossible(e) {
                    return this.canCreateNewPriceScale(e) ? e.createPriceScaleAtPosition("left") : e.createPriceScaleAtPosition("overlay")
                }
            }
        }, {
            name: "right",
            title: o.t(null, void 0, i(597800)),
            ctor: class extends r {
                constructor(e) {
                    super(e)
                }
                apply(e) {
                    const t = e.model();
                    e.leftPriceScales().slice(0).forEach((i=>e.movePriceScale(i, "right", this._targetPriceScaleIndex(i, t))))
                }
                createNewPriceScaleIfPossible(e) {
                    return this.canCreateNewPriceScale(e) ? e.createPriceScaleAtPosition("right") : e.createPriceScaleAtPosition("overlay")
                }
            }
        }, {
            name: "auto",
            title: o.t(null, void 0, i(221469)),
            ctor: class extends r {
                constructor(e) {
                    super(e)
                }
                apply(e) {
                    if (e.containsMainSeries()) {
                        const t = (0,
                        s.ensureNotNull)((0,
                        s.ensureNotNull)(e.mainDataSource()).priceScale());
                        e.movePriceScale(t, "right", 0)
                    }
                    const t = e.model();
                    for (; e.leftPriceScales().length > e.rightPriceScales().length; ) {
                        const i = e.leftPriceScales()[e.leftPriceScales().length - 1];
                        e.movePriceScale(i, "right", this._targetPriceScaleIndex(i, t))
                    }
                    for (; e.rightPriceScales().length - e.leftPriceScales().length > 1; ) {
                        const i = e.rightPriceScales()[e.rightPriceScales().length - 1];
                        e.movePriceScale(i, "left", this._targetPriceScaleIndex(i, t))
                    }
                }
                createNewPriceScaleIfPossible(e) {
                    if (!this.canCreateNewPriceScale(e))
                        return e.createPriceScaleAtPosition("overlay");
                    const t = e.leftPriceScales().length < e.rightPriceScales().length ? "left" : "right";
                    return e.createPriceScaleAtPosition(t)
                }
            }
        }];
        function l(e) {
            const t = (0,
            s.ensureDefined)(a.find((t=>t.name === e)));
            return new t.ctor(t)
        }
        function c() {
            return a
        }
    }
    ,
    607016: (e,t,i)=>{
        "use strict";
        i.d(t, {
            Session: ()=>l
        });
        var s = i(650151)
          , o = i(978296)
          , n = i(942634)
          , r = i(79342);
        const a = (0,
        i(338619).getLogger)("ChartApi.AbstractSession");
        class l {
            constructor(e, t, i) {
                this._isConnected = new o.WatchedValue(!1),
                this._state = 0,
                this._isConnectForbidden = !1,
                this._sessionId = "",
                this._sessionIdChanged = new n.Delegate,
                this._chartApi = e,
                this._sessionPrefix = t,
                this._shouldReconnectAfterCriticalError = i
            }
            destroy() {
                this._logNormal("Destroying session"),
                this._isConnected.unsubscribe(),
                this.disconnect(),
                this._sessionIdChanged.destroy(),
                delete this._chartApi,
                this._logNormal("Session has been destroyed")
            }
            isConnected() {
                return this._isConnected
            }
            sessionId() {
                return this._sessionId
            }
            onSessionIdChanged() {
                return this._sessionIdChanged
            }
            connect() {
                0 === this._state && ((0,
                s.assert)(!this._isConnectForbidden, "Cannot call connect because it is forbidden at this moment"),
                this._setSessionId(`${this._sessionPrefix}_${(0,
                r.randomHash)()}`),
                this._logNormal("Connecting session - wait until transport stay connected"),
                this._state = 1,
                this._chartApi.createSession(this._sessionId, this))
            }
            disconnect() {
                0 !== this._state && ((0,
                s.assert)("" !== this._sessionId, "sessionId must not be invalid"),
                this._logNormal("Disconnecting session..."),
                this._forbidConnectWhile((()=>{
                    this._chartApi.connected() && this._sendRemoveSession(),
                    this._processDestroyingOnServer()
                }
                )))
            }
            onMessage(e) {
                switch (e.method) {
                case "connected":
                    return void this._onChartApiConnected();
                case "disconnected":
                    return void this._onChartApiDisconnected();
                case "critical_error":
                    const t = String(e.params[0])
                      , i = String(e.params[1]);
                    return void this._onCriticalError(t, i)
                }
                this._onMessage(e)
            }
            serverTime() {
                return this._chartApi.serverTime()
            }
            _getChartApi() {
                return this._chartApi
            }
            _generateLogMessage(e) {
                return `[${this._sessionId}] ${e}`
            }
            _onCriticalError(e, t) {
                this._logError(`Critical error. Reason=${e}, info=${t}.`),
                this._forbidConnectWhile((()=>{
                    this._processDestroyingOnServer()
                }
                )),
                this._shouldReconnectAfterCriticalError ? (this._logNormal("Reconnecting after critical error..."),
                this.connect()) : this._logNormal("Reconnecting after critical error skipped")
            }
            _onChartApiConnected() {
                (0,
                s.assert)(1 === this._state, "Session is not registered"),
                this._logNormal("Transport is connected. Creating session on the server"),
                this._sendCreateSession(),
                this._state = 2,
                this._isConnected.setValue(!0)
            }
            _onChartApiDisconnected() {
                this._logNormal("Transport is disconnected. Reconnecting..."),
                this._forbidConnectWhile((()=>{
                    this._processDestroyingOnServer()
                }
                )),
                this.connect()
            }
            _setSessionId(e) {
                const t = this._sessionId;
                this._logNormal(`Changing sessionId: old=${t}, new=${e}`),
                this._sessionId = e,
                this._sessionIdChanged.fire(e, t)
            }
            _logNormal(e) {
                a.logNormal(this._generateLogMessage(e))
            }
            _logError(e) {
                a.logError(this._generateLogMessage(e))
            }
            _processDestroyingOnServer() {
                this._state = 0,
                this._isConnected.setValue(!1),
                this._chartApi.removeSession(this._sessionId),
                this._setSessionId("")
            }
            _forbidConnectWhile(e) {
                this._isConnectForbidden = !0,
                e(),
                this._isConnectForbidden = !1
            }
        }
    }
    ,
    373313: (e,t,i)=>{
        "use strict";
        i.d(t, {
            restoreShowNewsNotificationSettingsValue: ()=>l,
            showNewsNotificationsProperty: ()=>a
        });
        var s = i(62802)
          , o = i(998418);
        const n = "show_news_upd_notif";
        function r() {
            return s.getBool(n, !1)
        }
        const a = (0,
        o.createPrimitiveProperty)(r());
        function l() {
            a.setValue(!1),
            s.remove(n)
        }
        a.subscribe(null, (()=>s.setValue(n, a.value()))),
        s.onSync.subscribe(null, (()=>a.setValue(r())))
    }
    ,
    375308: (e,t,i)=>{
        "use strict";
        i.d(t, {
            sourcesAffectState: ()=>n
        });
        var s = i(465836)
          , o = i(469805);
        function n(e) {
            return !o.lineToolsDoNotAffectChartInvalidation || e.some((e=>!(0,
            s.isLineTool)(e)))
        }
    }
    ,
    438036: (e,t,i)=>{
        "use strict";
        var s;
        i.d(t, {
            InsertionErrorCode: ()=>s
        }),
        function(e) {
            e.StudyCannotBeChild = "cannot_be_child",
            e.StubWasRemoved = "stub_was_removed",
            e.CannotGetMetainfo = "cannot_get_metainfo",
            e.CannotCompilePub = "cannot_compile_pub",
            e.Cancelled = "cancelled",
            e.Unknown = "unknown"
        }(s || (s = {}))
    }
    ,
    540975: (e,t,i)=>{
        "use strict";
        i.d(t, {
            getReplayStrategyMetaInfo: ()=>n
        });
        var s = i(625611)
          , o = i(850723);
        function n() {
            return (0,
            o.studyMetaInfoRepository)().findById({
                type: "java",
                studyId: s.replayStrategyStudyId
            })
        }
    }
    ,
    252767: (e,t,i)=>{
        "use strict";
        i.d(t, {
            StudyColorRotatorFactory: ()=>u
        });
        var s = i(166770)
          , o = i(724377)
          , n = i(432059)
          , r = i(434396);
        const a = ["color-sky-blue-400", "color-banana-yellow-700", "color-deep-blue-500", "color-grapes-purple-a700", "color-iguana-green-500", "color-minty-green-a600", "color-ripe-red-a200", "color-berry-pink-200", "color-tv-blue-a100", "color-tan-orange-a200", "color-sky-blue-a400", "color-deep-blue-a100", "color-grapes-purple-400", "color-iguana-green-a700", "color-minty-green-200", "color-ripe-red-200", "color-berry-pink-a200", "color-ripe-red-500", "color-grapes-purple-500", "color-deep-blue-400", "color-tv-blue-a200", "color-sky-blue-500", "color-iguana-green-400", "color-minty-green-400", "color-banana-yellow-600", "color-tan-orange-500", "color-berry-pink-400", "color-ripe-red-300", "color-grapes-purple-300", "color-deep-blue-300", "color-tv-blue-300", "color-sky-blue-300", "color-iguana-green-300", "color-minty-green-300", "color-banana-yellow-400", "color-tan-orange-300", "color-berry-pink-300", "color-tan-orange-a700"]
          , l = ["color-berry-pink-a700", "color-grapes-purple-a700", "color-deep-blue-a400", "color-iguana-green-a700", "color-ripe-red-a400", "color-minty-green-a400", "color-berry-pink-a200", "color-tv-blue-a100", "color-tan-orange-a200", "color-sky-blue-a400", "color-deep-blue-a200", "color-grapes-purple-a100", "color-iguana-green-a400", "color-ripe-red-a100"];
        class c {
            constructor(e, t=a, i=!1) {
                this._offset = 0,
                this._offset = e,
                this._colors = t,
                this._ignoreBaseColor = i
            }
            getColor(e) {
                if (0 === this._offset && !this._ignoreBaseColor)
                    return e;
                const t = this._colors[(this._offset - (this._ignoreBaseColor ? 0 : 1)) % this._colors.length]
                  , i = s.colorsPalette[t]
                  , r = (0,
                n.isHexColor)(e) ? 1 : (0,
                o.parseRgba)(e)[3];
                return (0,
                n.generateColor)(i, (0,
                n.alphaToTransparency)(r))
            }
        }
        class d {
            constructor(e, t) {
                this._offset = e,
                this._modelStartOffset = t
            }
            getColor(e) {
                if ((0,
                n.isHexColor)(e)) {
                    const t = (0,
                    o.parseRgb)(e);
                    return (0,
                    o.rgbToHexString)((0,
                    o.shiftRgb)(t, this._offset, this._modelStartOffset))
                }
                {
                    const t = (0,
                    o.parseRgba)(e);
                    return (0,
                    o.rgbaToString)((0,
                    o.shiftRgba)(t, this._offset, this._modelStartOffset))
                }
            }
        }
        class u {
            constructor(e) {
                this._chartModel = e
            }
            getColorRotator(e) {
                const t = (0,
                r.studyColorRotationMode)(e);
                if (null === t)
                    return null;
                const i = this._calcDefaultColorsOffset(e);
                switch (t) {
                case "sexyColors":
                    return new c(i,l,!0);
                case "loop":
                    return new c(i);
                case "shift":
                    {
                        const e = this._chartModel.getStudyShiftColorStartOffset();
                        return new d(i,e)
                    }
                }
            }
            _calcDefaultColorsOffset(e) {
                let t = 0;
                const i = (0,
                r.useSameColorRotationComparator)(e);
                return this._chartModel.dataSources().filter(r.isStudy).forEach((s=>{
                    i(e, s.metaInfo()) && t++
                }
                )),
                t
            }
        }
    }
    ,
    348065: (e,t,i)=>{
        "use strict";
        i.d(t, {
            StudyInserter: ()=>p
        });
        var s = i(283873)
          , o = i(637761)
          , n = i(124829)
          , r = i(850723)
          , a = i(211183)
          , l = i(438036)
          , c = i(338619)
          , d = i(757402);
        const u = (0,
        c.getLogger)("Chart.Studies.StudyInserter")
          , h = /^PUB;.*/;
        class p {
            constructor(e, t) {
                this._parentSources = [],
                this._propsState = void 0,
                this._preferredPriceScale = void 0,
                this._allowChangeCurrency = !1,
                this._allowChangeUnit = !1,
                this._paneSize = void 0,
                this._forceOverlay = !1,
                this._inserterImpl = t,
                this._studyDescriptor = e
            }
            setParentSources(e) {
                this._parentSources = e
            }
            setPaneSize(e) {
                this._paneSize = e
            }
            setPreferredPriceScale(e) {
                this._preferredPriceScale = e
            }
            setAllowChangeCurrency(e) {
                this._allowChangeCurrency = e
            }
            setAllowChangeUnit(e) {
                this._allowChangeUnit = e
            }
            setForceOverlay(e) {
                this._forceOverlay = e
            }
            setPropertiesState(e) {
                this._propsState = e
            }
            setTargetPriceScaleMode(e) {
                this._targetPriceScaleMode = e
            }
            async insert(e, t, i) {
                var c, p;
                let m = null;
                var g;
                i || (m = void 0 !== (g = this._inserterImpl).createStub && void 0 !== g.removeStub ? this._inserterImpl.createStub() : null);
                const _ = e=>{
                    if (i) {
                        const t = (0,
                        s.default)(e) ? {
                            error: e
                        } : {
                            error: e.message,
                            editorError: e
                        };
                        i.setStatus({
                            type: d.StudyStatusType.Error,
                            errorDescription: t
                        }),
                        this._inserterImpl.storeFailedStub(i)
                    }
                }
                ;
                let v, S = !0;
                try {
                    v = await (0,
                    r.studyMetaInfoRepository)().findById(this._studyDescriptor)
                } catch (e) {
                    u.logWarn(`Cannot get study ${JSON.stringify(this._studyDescriptor)}`);
                    const t = this._studyDescriptor.pineId
                      , i = h.test(t)
                      , s = !!(null === (c = null == e ? void 0 : e.errors) || void 0 === c ? void 0 : c.length);
                    return _(s ? {
                        id: t,
                        ...e.errors[0]
                    } : "Error: cannot compile script"),
                    i && s ? Promise.reject(l.InsertionErrorCode.CannotCompilePub) : Promise.reject(l.InsertionErrorCode.CannotGetMetainfo)
                } finally {
                    null !== m && (S = this._inserterImpl.removeStub(m))
                }
                if (!S)
                    return Promise.reject(l.InsertionErrorCode.StubWasRemoved);
                if (void 0 !== t && t.cancelled)
                    return Promise.reject(l.InsertionErrorCode.Cancelled);
                if (!this._canApplyStudyToParent(v))
                    return _("Error: cannot be child"),
                    Promise.reject(l.InsertionErrorCode.StudyCannotBeChild);
                const f = {
                    ...v.defaults.inputs
                };
                let b = {};
                if (void 0 !== e) {
                    const t = o.StudyMetaInfo.getStudyPropertyRootName(v)
                      , i = (0,
                    n.clone)((0,
                    a.defaults)(t));
                    (0,
                    n.merge)(f, i.inputs);
                    const s = await e(f, v.inputs, v);
                    b = s.inputs,
                    this._parentSources = null !== (p = s.parentSources) && void 0 !== p ? p : []
                }
                if (void 0 !== t && t.cancelled)
                    return Promise.reject(l.InsertionErrorCode.Cancelled);
                const y = this._insertStudy(v, b, i);
                return null === y ? (_("Error: unknown error"),
                Promise.reject(l.InsertionErrorCode.Unknown)) : (await y.startPromise,
                y.study)
            }
            _insertStudy(e, t, i) {
                return this._inserterImpl.createStudy(e, t, null, i, this._propsState, this._forceOverlay, this._parentSources, this._preferredPriceScale, this._allowChangeCurrency, this._allowChangeUnit, this._paneSize, this._targetPriceScaleMode)
            }
            _canApplyStudyToParent(e) {
                return 0 === this._parentSources.length || o.StudyMetaInfo.canBeChild(e)
            }
        }
    }
    ,
    283323: (e,t,i)=>{
        "use strict";
        i.d(t, {
            StudyLineToolStub: ()=>r,
            isStudyLineToolStub: ()=>n
        });
        var s = i(978296)
          , o = i(872842);
        function n(e) {
            return e instanceof r
        }
        class r extends o.StudyStub {
            constructor(e, t, i) {
                var o;
                super(e, {
                    ...t,
                    ownFirstValue: null
                }, i),
                this._linkKey = new s.WatchedValue(null !== (o = t.linkKey) && void 0 !== o ? o : null)
            }
            linkKey() {
                return this._linkKey
            }
        }
    }
    ,
    944843: (e,t,i)=>{
        "use strict";
        var s = i(942634).Delegate;
        function o() {
            this._marksByIndex = new Map,
            this._marksBySpan = [],
            this.changed = new s,
            this.minIndex = void 0,
            this.maxIndex = void 0
        }
        o.prototype.reset = function() {
            this._resetImpl(),
            this.changed.fire()
        }
        ,
        o.prototype._resetImpl = function() {
            this._marksByIndex = new Map,
            this._marksBySpan = [],
            this.minIndex = void 0,
            this.maxIndex = void 0,
            this._cache = void 0
        }
        ,
        o.prototype.merge = function(e) {
            if (0 !== e.length) {
                var t = e[0].index
                  , i = e[e.length - 1].index;
                t <= this.minIndex && i >= this.maxIndex && this._resetImpl();
                for (var s = this._marksBySpan, o = new Set, n = 0; n < e.length; n++) {
                    var r = (c = e[n]).index
                      , a = c.span
                      , l = this._marksByIndex.get(c.index);
                    if (l) {
                        if (l.index === c.index && l.span === c.span) {
                            l.time = c.time;
                            continue
                        }
                        this._removeTickmark(l)
                    }
                }
                for (n = 0; n < e.length; n++) {
                    var c;
                    r = (c = e[n]).index,
                    a = c.span;
                    if (!this._marksByIndex.has(c.index)) {
                        this._marksByIndex.set(r, c);
                        var d = s[a];
                        void 0 === d && (d = [],
                        s[a] = d);
                        var u = 0 === d.length || d[d.length - 1].index < c.index;
                        s[a].push(c),
                        u || o.add(a)
                    }
                }
                this.minIndex = void 0 === this.minIndex ? t : Math.min(this.minIndex, t),
                this.maxIndex = void 0 === this.maxIndex ? i : Math.max(this.maxIndex, i);
                for (a = s.length; a--; )
                    s[a] && (s[a].length || delete s[a],
                    o.has(a) && s[a].sort(this._sortByIndexAsc));
                this._cache = void 0,
                this.changed.fire()
            }
        }
        ,
        o.prototype._removeTickmark = function(e) {
            var t = e.index;
            if (this._marksByIndex.get(t) === e) {
                this._marksByIndex.delete(t),
                t <= this.minIndex && this.minIndex++,
                t >= this.maxIndex && this.maxIndex--,
                this.maxIndex < this.minIndex && (this.minIndex = void 0,
                this.maxIndex = void 0);
                var i = this._marksBySpan[e.span]
                  , s = i.indexOf(e);
                -1 !== s && i.splice(s, 1)
            }
        }
        ,
        o.prototype._sortByIndexAsc = function(e, t) {
            return e.index - t.index
        }
        ,
        o.prototype.removeTail = function(e) {
            var t = new Map;
            this.maxIndex = this.minIndex,
            this._marksByIndex.forEach(function(i, s) {
                i.time < e && (t.set(s, i),
                this.maxIndex = Math.max(this.maxIndex, s))
            }
            .bind(this)),
            this._marksByIndex = t
        }
        ,
        o.prototype.addTail = function(e) {
            for (var t = 0; t < e.length; t++)
                e[t].index = this.maxIndex + t + 1;
            this.merge(e)
        }
        ,
        o.prototype.indexToTime = function(e) {
            var t = this._marksByIndex.get(e);
            return t ? new Date(1e3 * t.time) : null
        }
        ,
        o.prototype.density = function() {
            var e = this.maxIndex - this.minIndex;
            if (0 !== e)
                return 1e3 * (this._marksByIndex.get(this.maxIndex).time - this._marksByIndex.get(this.minIndex).time) / e
        }
        ,
        o.prototype.estimateLeft = function(e) {
            var t = this.density();
            if (t)
                return (1e3 * this._marksByIndex.get(this.minIndex).time - e) / t
        }
        ,
        o.prototype.nearestIndex = function(e) {
            for (var t = this.minIndex, i = this.maxIndex; i - t > 2; ) {
                if (1e3 * this._marksByIndex.get(t).time === e)
                    return t;
                if (1e3 * this._marksByIndex.get(i).time === e)
                    return i;
                var s = Math.round((t + i) / 2);
                1e3 * this._marksByIndex.get(s).time > e ? i = s : t = s
            }
            return t
        }
        ,
        o.prototype.build = function(e, t) {
            var i = Math.ceil(t / e);
            if (this._maxbar === i && this._cache)
                return this._cache;
            this._maxbar = i;
            for (var s = [], o = this._marksBySpan.length; o--; )
                if (this._marksBySpan[o]) {
                    var n = s;
                    s = [];
                    for (var r = n.length, a = 0, l = this._marksBySpan[o], c = l.length, d = 1 / 0, u = -1 / 0, h = 0; h < c; h++) {
                        for (var p = l[h], m = p.index; a < r; ) {
                            var g = n[a]
                              , _ = g.index;
                            if (!(_ < m)) {
                                d = _;
                                break
                            }
                            a++,
                            s.push(g),
                            u = _,
                            d = 1 / 0
                        }
                        d - m >= i && m - u >= i && (s.push(p),
                        u = m)
                    }
                    for (; a < r; a++)
                        s.push(n[a])
                }
            return this._cache = s,
            this._cache
        }
        ,
        o.prototype.state = function(e) {
            for (var t = [], i = this._marksBySpan.length; i--; )
                this._marksBySpan[i] && (t = t.concat(this._marksBySpan[i]));
            if (null !== e) {
                const i = e.firstBar()
                  , s = e.lastBar();
                t = t.filter((e=>e.index >= i && e.index <= s))
            }
            return {
                marks: t = t.map((function(e) {
                    return [e.span, e.time, e.index]
                }
                )),
                version: 2
            }
        }
        ,
        o.prototype.restoreState = function(e) {
            if (this._marksByIndex = new Map,
            this._marksBySpan = [],
            this.maxIndex = void 0,
            this.minIndex = void 0,
            e && e.marks && e.marks.length)
                if (2 === e.version) {
                    var t = e.marks.map((function(e) {
                        return {
                            span: e[0],
                            time: e[1],
                            index: e[2]
                        }
                    }
                    ));
                    this.merge(t)
                } else
                    this.merge(e.marks)
        }
        ,
        e.exports.Tickmarks = o
    }
    ,
    501571: (e,t,i)=>{
        "use strict";
        i.d(t, {
            INVALID_TIME_POINT_INDEX: ()=>s,
            UNPLOTTABLE_TIME_POINT_INDEX: ()=>o
        });
        const s = -2e6
          , o = -1e6
    }
    ,
    220003: (e,t,i)=>{
        "use strict";
        i.d(t, {
            restoreTimeHoursFormatSettingsValue: ()=>l,
            timeHoursFormatProperty: ()=>a
        });
        var s = i(62802)
          , o = i(998418);
        const n = "time_hours_format";
        function r() {
            return s.getValue(n, "24-hours")
        }
        const a = (0,
        o.createPrimitiveProperty)(r());
        function l() {
            a.setValue("24-hours"),
            s.remove(n)
        }
        s.onSync.subscribe(null, (()=>a.setValue(r()))),
        a.subscribe(null, (()=>s.setValue(n, a.value())))
    }
    ,
    69184: (e,t,i)=>{
        "use strict";
        i.d(t, {
            getHourMinuteFormat: ()=>o,
            getHourMinuteSecondFormat: ()=>n,
            getTimeFormatForInterval: ()=>r
        });
        var s = i(662445);
        function o(e) {
            return "12-hours" === e ? s.twelveHourMinuteFormat : s.hourMinuteFormat
        }
        function n(e) {
            return "12-hours" === e ? s.twelveHourMinuteSecondFormat : s.hourMinuteSecondFormat
        }
        function r(e, t) {
            if (e.isRange())
                return function(e) {
                    return "12-hours" === e ? s.twelveHourMinuteNonZeroSecondFormat : s.hourMinuteNonZeroSecondFormat
                }(t);
            if (e.isTicks())
                return s.hourMinuteSecondMillisecFormat;
            return e.isSeconds() || e.isTicks() ? n(t) : o(t)
        }
    }
    ,
    376036: (e,t,i)=>{
        "use strict";
        i.d(t, {
            forceTradingObjVisibilityOnScreenshot: ()=>d,
            restoreShowOnScreenshotSettingsValue: ()=>c,
            showOnScreenshotProperty: ()=>l
        });
        var s = i(62802)
          , o = i(978296)
          , n = i(998418);
        const r = "trading_drawings_on_screenshot";
        function a() {
            return s.getBool(r, !1)
        }
        const l = (0,
        n.createPrimitiveProperty)(a());
        function c() {
            l.setValue(!1),
            s.remove(r)
        }
        s.onSync.subscribe(null, (()=>l.setValue(a()))),
        l.subscribe(null, (()=>s.setValue(r, l.value())));
        const d = new o.WatchedValue(null)
    }
    ,
    204425: (e,t,i)=>{
        "use strict";
        i.d(t, {
            ExcludeLineToolsFromGroupUndoCommand: ()=>d
        });
        var s = i(650151)
          , o = (i(466281),
        i(444372))
          , n = i(370407)
          , r = i(124829)
          , a = i(669763)
          , l = i(469805);
        const c = new n.TranslatedString("exclude line tools from group {group}",o.t(null, void 0, i(99395)));
        class d extends a.UndoCommand {
            constructor(e, t, i) {
                super(c.format({
                    group: t.name().value()
                }), void 0, !l.lineToolsDoNotAffectChartInvalidation),
                this._model = e,
                this._groupId = t.id,
                this._groupName = t.name().value(),
                this._lineToolsIds = i.map((e=>e.id()))
            }
            redo() {
                const e = (0,
                s.ensureNotNull)(this._model.lineToolsGroupModel().groupForId(this._groupId))
                  , t = this._lineToolsIds.map((e=>this._model.dataSourceForId(e))).filter(r.notNull);
                e.excludeLineTools(t),
                0 === e.lineTools().length && this._model.lineToolsGroupModel().removeGroup(e)
            }
            undo() {
                const e = this._lineToolsIds.map((e=>this._model.dataSourceForId(e)))
                  , t = this._model.lineToolsGroupModel().groupForId(this._groupId);
                null !== t ? t.addLineTools(e) : this._model.lineToolsGroupModel().createGroup(e, this._groupName, this._groupId)
            }
        }
    }
    ,
    414358: (e,t,i)=>{
        "use strict";
        i.d(t, {
            InsertStudyCommand: ()=>u
        });
        var s = i(650151)
          , o = i(247001)
          , n = i(788387)
          , r = i(795688)
          , a = i(434396)
          , l = i(487945)
          , c = i(669763)
          , d = i(345848);
        class u extends c.UndoCommand {
            constructor(e) {
                const {chartModel: t, studyMetaInfo: i, inputs: s, props: o, addAsOverlay: n, parentSources: r, preferredPriceScale: a, allowChangeCurrency: l, allowChangeUnit: c, paneSize: d, targetZOrder: u, studyId: h, targetScaleMode: p, undoText: m} = e;
                super(null != m ? m : null),
                this._paneState = null,
                this._studyInserResult = null,
                this._additionalStudiesInsertResults = [],
                this._chartModel = t,
                this._studyMetaInfo = i,
                this._props = o,
                this._addAsOverlay = n,
                this._parentIds = r.map((e=>e.id())),
                this._inputs = s,
                this._targetZOrder = u,
                this._preferredPriceScale = a,
                this._allowChangeCurrency = l,
                this._allowChangeUnit = c,
                this._paneSize = d,
                this._studyId = null != h ? h : null,
                this._targetScaleMode = null != p ? p : null
            }
            redo() {
                var e, t;
                const i = this._parentIds.map((e=>this._chartModel.dataSourceForId(e)));
                this._studyInserResult = this._chartModel.insertStudyWithParams(this._studyMetaInfo, this._inputs, this._targetZOrder, this._props, this._addAsOverlay, i, this._preferredPriceScale, this._allowChangeCurrency, this._allowChangeUnit, this._paneSize, null !== (e = this._targetScaleMode) && void 0 !== e ? e : void 0, null !== (t = this._studyId) && void 0 !== t ? t : void 0),
                this._studyInserResult.study.then((e=>{
                    if ((0,
                    l.isSymbolSource)(e)) {
                        null !== e.symbolInfo() ? this._createCopiesOfExistingFundamentalsForNewStock(e) : e.symbolResolved().subscribe(this, (()=>this._createCopiesOfExistingFundamentalsForNewStock(e)), !0)
                    } else
                        (0,
                        a.isFundamentalStudy)(e) && this._createCopiesOfNewFundamentalForAllStocks(e);
                    if (this._studyId = e.id(),
                    e.childStudyByRebind().subscribe(null, (()=>(0,
                    d.trackEvent)("SOS", "Apply SOS", "Rebind SOS"))),
                    (0,
                    o.trackStudies)(e, "add"),
                    this._chartModel.setShouldBeSavedEvenIfHidden(!0),
                    null !== this._paneState) {
                        (0,
                        s.ensureNotNull)(this._chartModel.paneForSource(e)).restoreState({
                            state: this._paneState,
                            withData: !1,
                            version: this._chartModel.version()
                        }),
                        this._paneState = null
                    }
                }
                ))
            }
            undo() {
                var e, t;
                const i = (0,
                s.ensureNotNull)(this._studyInserResult)
                  , o = i.entityId();
                let n = null
                  , r = null;
                if (null !== o) {
                    n = (0,
                    s.ensureNotNull)(this._chartModel.dataSourceForId(o));
                    const t = i.originalScaleMode();
                    null !== t && (null === (e = n.priceScale()) || void 0 === e || e.setMode(t)),
                    (0,
                    l.isSymbolSource)(n) && n.symbolResolved().unsubscribeAll(this),
                    r = (0,
                    s.ensureNotNull)(this._chartModel.paneForSource(n)).state()
                } else
                    i.cancel();
                null === (t = this._studyInserResult) || void 0 === t || t.cancel();
                for (const e of this._additionalStudiesInsertResults) {
                    const t = e.entityId();
                    null !== t ? this._chartModel.removeSource((0,
                    s.ensureNotNull)(this._chartModel.dataSourceForId(t))) : e.cancel()
                }
                this._additionalStudiesInsertResults = [],
                null !== n && this._chartModel.removeSource(n) && (this._paneState = r)
            }
            insertedStudy() {
                return (0,
                s.ensureNotNull)(this._studyInserResult)
            }
            _createCopiesOfNewFundamentalForAllStocks(e) {
                let t = (0,
                s.ensureNotNull)((0,
                r.getConfig)("FUNDAMENTALS_ON_CHART")).limit - this._chartModel.chartApi().getFundamentalCounter();
                e.isStarted() || (t -= 1);
                const i = this._studyMetaInfo.symbolInputId()
                  , o = this._chartModel.symbolSources();
                for (const r of o) {
                    if (t <= 0)
                        break;
                    if (!r.isVisible() || r === e.symbolSource())
                        continue;
                    const o = r.symbolInfo();
                    if (null !== o && (0,
                    n.isStockSymbol)(o.type, o.typespecs)) {
                        const e = {};
                        e[(0,
                        s.ensureNotNull)(i)] = r.symbol();
                        const o = this._chartModel.insertStudyWithParams(this._studyMetaInfo, e, null, this._props, !1);
                        this._additionalStudiesInsertResults.push(o),
                        t -= 1
                    }
                }
            }
            _createCopiesOfExistingFundamentalsForNewStock(e) {
                let t = (0,
                s.ensureNotNull)((0,
                r.getConfig)("FUNDAMENTALS_ON_CHART")).limit - this._chartModel.chartApi().getFundamentalCounter();
                const i = e.symbolInfo();
                if (null !== i && (0,
                n.isStockSymbol)(i.type, i.typespecs)) {
                    const i = new Set
                      , o = this._chartModel.allStudies(!0).filter((e=>(0,
                    a.isFundamentalStudy)(e) && e.isVisible()));
                    for (const n of o) {
                        if (t <= 0)
                            break;
                        const o = n.metaInfo();
                        if (!i.has(o.fullId)) {
                            const n = {};
                            n[(0,
                            s.ensureNotNull)(o.symbolInputId())] = e.symbol();
                            const r = this._chartModel.insertStudyWithParams(o, n, null, this._props, !1);
                            this._additionalStudiesInsertResults.push(r),
                            t -= 1,
                            i.add(o.fullId)
                        }
                    }
                }
            }
        }
    }
    ,
    121760: (e,t,i)=>{
        "use strict";
        i.d(t, {
            LineToolSynchronizeUndoCommand: ()=>o
        });
        var s = i(669763);
        class o extends s.UndoCommand {
            constructor(e, t, i, s=!0) {
                super(t, i, s),
                this._invalidateViaSync = !1,
                this._chartModel = e,
                this._invalidateViaSync = e.lineToolsSynchronizer().invalidateViaSync()
            }
            redo() {
                this._invalidateViaSync ? this._chartModel.lineToolsSynchronizer().executeSyncedAction((()=>this._redo())) : this._redo()
            }
            undo() {
                this._invalidateViaSync ? this._chartModel.lineToolsSynchronizer().executeSyncedAction((()=>this._undo())) : this._undo()
            }
        }
    }
    ,
    479935: (e,t,i)=>{
        "use strict";
        i.d(t, {
            MergeDownUndoCommand: ()=>a,
            MergeToTargetPane: ()=>l,
            MergeUpUndoCommand: ()=>r
        });
        var s = i(650151)
          , o = i(438266);
        class n extends o.MoveSourceUndoCommand {
            constructor(e, t, i, s) {
                super(e, t, i),
                this._restorePane = !1,
                this._keepZOrder = null != s && s,
                this._initialZOrder = t.zorder()
            }
            redo() {
                const e = this._chartModel.panes().length
                  , t = this._chartModel.panes()[this._targetPaneIndex()]
                  , i = (0,
                s.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId))
                  , o = (0,
                s.ensureNotNull)(this._chartModel.paneForSource(i))
                  , n = this._chartModel.children(i, !0);
                o.bulkActionMacro((()=>{
                    n.forEach((e=>this._chartModel.detachSource(e))),
                    this._restorePane = this._chartModel.detachSource(i)
                }
                ));
                const r = "overlay" === this._initialPriceScalePosition ? this._initialPriceScalePosition : void 0
                  , a = t.findSuitableScale(i, void 0, r)
                  , l = 0 === a.dataSources().length;
                if (t.bulkActionMacro((()=>{
                    t.addDataSource(i, a, this._keepZOrder),
                    n.forEach((e=>t.addDataSource(e, a, this._keepZOrder)))
                }
                )),
                i === this._chartModel.mainSeries()) {
                    const e = t.priceScalePosition(a);
                    t.movePriceScale(a, e, 0)
                }
                if (l) {
                    const e = (0,
                    s.ensureNotNull)(i.priceScale());
                    e.restoreState(this._newPriceScaleState(t.isOverlay(i))),
                    e.setHeight(t.height())
                }
                this._chartModel.fullUpdate(),
                e !== this._chartModel.panes().length && this._chartModel.setShouldBeSavedEvenIfHidden(!0)
            }
            undo() {
                let e;
                e = this._restorePane ? this._chartModel.createPane(this._initialPaneIndex) : this._chartModel.panes()[this._initialPaneIndex];
                const t = (0,
                s.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId))
                  , i = (0,
                s.ensureNotNull)(this._chartModel.paneForSource(t))
                  , o = this._chartModel.children(t, !0);
                i.bulkActionMacro((()=>{
                    o.forEach((e=>this._chartModel.detachSource(e))),
                    this._chartModel.detachSource(t)
                }
                ));
                let n = e.getPriceScaleById(this._initialPriceScaleId);
                null === n && (n = e.createPriceScaleAtPosition(this._initialPriceScalePosition, this._initialPriceScaleIndex)),
                e.bulkActionMacro((()=>{
                    t.setZorder(this._initialZOrder),
                    e.addDataSource(t, n, !0),
                    o.forEach((t=>e.addDataSource(t, n, !1)))
                }
                ));
                const r = (0,
                s.ensureNotNull)(t.priceScale());
                r.restoreState(this._originalPriceScaleState()),
                r.setHeight(e.height()),
                this._chartModel.fullUpdate()
            }
        }
        class r extends n {
            constructor(e, t, i) {
                super(e, t, i)
            }
            _targetPaneIndex() {
                return this._initialPaneIndex - 1
            }
        }
        class a extends n {
            constructor(e, t, i) {
                super(e, t, i)
            }
            _targetPaneIndex() {
                return this._initialPaneIndex + 1
            }
        }
        class l extends n {
            constructor(e, t, i, s, o) {
                super(e, t, s, o),
                this._targetPane = i
            }
            _targetPaneIndex() {
                return this._targetPane
            }
        }
    }
    ,
    438266: (e,t,i)=>{
        "use strict";
        i.d(t, {
            MoveSourceUndoCommand: ()=>n
        });
        var s = i(650151)
          , o = i(669763);
        class n extends o.UndoCommand {
            constructor(e, t, i) {
                super(i),
                this._chartModel = e,
                this._sourceId = t.id();
                const o = (0,
                s.ensureNotNull)(t.priceScale());
                this._initialPriceScaleId = o.id(),
                this._initialPriceScaleState = (0,
                s.ensureNotNull)(t.priceScale()).state();
                const n = (0,
                s.ensureNotNull)(e.paneForSource(t));
                this._initialPriceScalePosition = n.priceScalePosition(o),
                this._initialPriceScaleIndex = n.priceScaleIndex(o, this._initialPriceScalePosition),
                this._initialPaneIndex = e.panes().indexOf(n)
            }
            _newPriceScaleState(e) {
                const t = {
                    ...this._initialPriceScaleState
                };
                return delete t.m_isLockScale,
                delete t.id,
                delete t.m_topMargin,
                delete t.m_bottomMargin,
                delete t.hasCalculatedPriceRange,
                t
            }
            _originalPriceScaleState() {
                return this._initialPriceScaleState
            }
        }
    }
    ,
    995625: (e,t,i)=>{
        "use strict";
        i.d(t, {
            MoveToExistingPriceScaleUndoCommand: ()=>a,
            MoveToNewPriceScaleUndoCommand: ()=>r
        });
        var s = i(650151)
          , o = i(438266);
        class n extends o.MoveSourceUndoCommand {
            constructor(e, t, i, s) {
                super(e, t, s),
                this._sourcePaneRemoved = !1,
                this._targetPaneIndex = e.panes().indexOf(i)
            }
            redo() {
                const e = this._chartModel.panes()[this._initialPaneIndex]
                  , t = this._chartModel.panes()[this._targetPaneIndex]
                  , i = e !== t
                  , o = this._targetPriceScale(t)
                  , n = (0,
                s.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId))
                  , r = this._chartModel.children(n, !0);
                for (const e of r)
                    i ? (this._chartModel.detachSource(e),
                    t.addDataSource(e, o, !1)) : t.move(e, o);
                i ? (this._sourcePaneRemoved = this._chartModel.detachSource(n),
                t.addDataSource(n, o, !1)) : t.move(n, o);
                const a = t.priceScalePosition(o);
                t.movePriceScale(o, a, this._targetPriceScaleIndex(n)),
                this._chartModel.fullUpdate()
            }
            undo() {
                this._sourcePaneRemoved && this._chartModel.createPane(this._initialPaneIndex);
                const e = this._chartModel.panes()[this._initialPaneIndex]
                  , t = e !== this._chartModel.panes()[this._targetPaneIndex]
                  , i = (0,
                s.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId));
                let o = e.getPriceScaleById(this._initialPriceScaleId);
                null === o && (o = e.createPriceScaleAtPosition(this._initialPriceScalePosition, this._initialPriceScaleIndex));
                const n = this._chartModel.children(i, !0);
                for (const i of n)
                    t ? (this._chartModel.detachSource(i),
                    e.addDataSource(i, o, !1)) : e.move(i, o);
                t ? (this._chartModel.detachSource(i),
                e.addDataSource(i, o, !1)) : e.move(i, o);
                const r = (0,
                s.ensureNotNull)(i.priceScale());
                r.restoreState(this._originalPriceScaleState()),
                r.setHeight(e.height()),
                this._chartModel.fullUpdate()
            }
        }
        class r extends n {
            constructor(e, t, i, s, o) {
                super(e, t, i, o),
                this._targetPriceScalePosition = s
            }
            _targetPriceScale(e) {
                const t = e.createPriceScaleAtPosition(this._targetPriceScalePosition);
                return t.restoreState(this._newPriceScaleState("overlay" === this._targetPriceScalePosition)),
                t.setHeight(e.height()),
                t
            }
            _targetPriceScaleIndex(e) {
                return e === this._chartModel.mainSeries() ? 0 : void 0
            }
        }
        class a extends n {
            constructor(e, t, i, s, o) {
                super(e, t, i, o),
                this._targetPriceScaleId = s.id()
            }
            _targetPriceScale(e) {
                return (0,
                s.ensureNotNull)(e.getPriceScaleById(this._targetPriceScaleId))
            }
            _targetPriceScaleIndex(e) {}
        }
    }
    ,
    661725: (e,t,i)=>{
        "use strict";
        i.d(t, {
            RemoveSourcesUndoCommand: ()=>f
        });
        var s = i(650151)
          , o = i(444372)
          , n = i(370407)
          , r = i(247001)
          , a = i(121760)
          , l = i(465836)
          , c = i(338619)
          , d = i(632911)
          , u = i(434396)
          , h = i(469805)
          , p = i(204425);
        class m extends a.LineToolSynchronizeUndoCommand {
            constructor({chartModel: e, title: t, lineDataSourceIds: i}) {
                super(e, t, void 0, !h.lineToolsDoNotAffectChartInvalidation),
                this._excludeLineToolsFromGroupUndoCommands = [],
                this._undoState = [],
                this._lineDataSourceIds = i
            }
            _redo() {
                const e = this._lineDataSourceIds.map((e=>(0,
                s.ensureNotNull)(this._chartModel.dataSourceForId(e))));
                this._groupLineToolsByGroups(e).forEach(((e,t)=>{
                    const i = new p.ExcludeLineToolsFromGroupUndoCommand(this._chartModel,t,e);
                    i.redo(),
                    this._excludeLineToolsFromGroupUndoCommands.push(i)
                }
                )),
                e.forEach((e=>{
                    this._undoState.push({
                        state: e.state(!1),
                        paneIndex: this._chartModel.panes().indexOf((0,
                        s.ensureNotNull)(this._chartModel.paneForSource(e))),
                        sharingMode: e.sharingMode().value()
                    }),
                    this._chartModel.removeSource(e)
                }
                ))
            }
            _undo() {
                var e;
                for (let t = this._undoState.shift(); t; t = this._undoState.shift())
                    null === (e = this._chartModel.restoreSource(!1, t.paneIndex, null, t.state, null)) || void 0 === e || e.share(t.sharingMode);
                this._excludeLineToolsFromGroupUndoCommands.forEach((e=>e.undo()))
            }
            _groupLineToolsByGroups(e) {
                const t = this._chartModel.lineToolsGroupModel();
                return e.reduce(((e,i)=>{
                    const s = t.groupForLineTool(i);
                    if (null !== s) {
                        const t = e.get(s) || [];
                        t.push(i),
                        e.set(s, t)
                    }
                    return e
                }
                ), new Map)
            }
        }
        var g = i(850723)
          , _ = i(375308);
        const v = (0,
        c.getLogger)("Chart.RemoveSourcesUndoCommand")
          , S = new n.TranslatedString("remove line data sources",o.t(null, void 0, i(838199)));
        class f extends a.LineToolSynchronizeUndoCommand {
            constructor(e, t, i) {
                super(e, i, void 0, (0,
                _.sourcesAffectState)(t)),
                this._removeLineDataSourcesUndoCommand = null,
                this._initialPriceScaleMode = null;
                const [o,n] = (0,
                d.closeSourcesSet)(e, t).reduce(((e,t)=>((0,
                l.isLineTool)(t) ? e[1].push(t.id()) : e[0].push(t.id()),
                e)), [[], []]);
                this._sourceIds = o,
                this._lineDataSourceIds = n,
                this._sourceStates = [],
                this._paneIndexes = [],
                this._priceScalePositionIds = [],
                this._paneStates = [],
                this._restorePanes = [];
                const r = t[0];
                1 === t.length && (0,
                u.isStudy)(r) && (this._initialPriceScaleMode = (0,
                s.ensureNotNull)(r.priceScale()).mode())
            }
            removedIds() {
                return [...this._sourceIds, ...this._lineDataSourceIds]
            }
            _redo() {
                const e = this._chartModel.panes().length
                  , t = this._sourceIds.map((e=>(0,
                s.ensureNotNull)(this._chartModel.dataSourceForId(e))));
                this._sourceStates = t.map((e=>{
                    const t = e.state(!1);
                    return null === t && (0,
                    u.isStudyStub)(e) ? e.getDescriptor() : t
                }
                ));
                const i = t.map((e=>(0,
                s.ensureNotNull)(this._chartModel.paneForSource(e))));
                this._paneIndexes = i.map((e=>this._chartModel.panes().indexOf(e))),
                this._lineDataSourceIds.length > 0 && (this._removeLineDataSourcesUndoCommand = new m({
                    title: S,
                    chartModel: this._chartModel,
                    lineDataSourceIds: this._lineDataSourceIds
                }),
                this._removeLineDataSourcesUndoCommand.redo()),
                this._priceScalePositionIds = t.map(((e,t)=>{
                    const s = e.priceScale();
                    if (null === s)
                        return null;
                    const o = i[t].priceScalePosition(s);
                    return {
                        id: s.id(),
                        position: o,
                        priceScaleIndex: i[t].priceScaleIndex(s, o)
                    }
                }
                ));
                const o = new Set;
                t.forEach(((e,t)=>{
                    o.add(this._paneIndexes[t])
                }
                )),
                this._paneStates = t.map(((e,t)=>{
                    const s = this._paneIndexes[t];
                    return o.has(s) ? i[t].state(!1, !0) : null
                }
                )),
                this._restorePanes = t.map((e=>this._chartModel.removeSource(e))),
                t.forEach((e=>{
                    (0,
                    u.isStudy)(e) && (0,
                    r.trackStudies)(e, "remove")
                }
                )),
                e !== this._chartModel.panes().length && this._chartModel.setShouldBeSavedEvenIfHidden(!0)
            }
            _undo() {
                const e = [];
                for (let t = this._sourceStates.length - 1; t >= 0; t--) {
                    const i = this._sourceStates[t];
                    if (null !== i) {
                        let s = null;
                        s = "descriptor"in i && (0,
                        g.isStudyDescriptor)(i.descriptor) ? this._chartModel.restoreStudyStub(i) : this._chartModel.restoreSource(this._restorePanes[t], this._paneIndexes[t], this._paneStates[t], i, this._priceScalePositionIds[t]),
                        s && e.push(s)
                    }
                }
                e.some(((t,i)=>t.id() !== this._sourceIds[e.length - i - 1])) && v.logError("Source was restored improperly - source ids does not match"),
                null !== this._initialPriceScaleMode && (0,
                s.ensureNotNull)(e[0].priceScale()).setMode(this._initialPriceScaleMode),
                this._removeLineDataSourcesUndoCommand && this._removeLineDataSourcesUndoCommand.undo()
            }
        }
    }
    ,
    344409: (e,t,i)=>{
        "use strict";
        i.d(t, {
            SetPriceScaleCurrencyUndoCommand: ()=>r
        });
        var s = i(650151)
          , o = i(669763)
          , n = i(975179);
        class r extends o.UndoCommand {
            constructor(e, t, i, o) {
                super(o),
                this._newSourcesCurrencies = new Map,
                this._oldSourcesCurrencies = new Map,
                this._showFade = !1,
                this._chartModel = e;
                const r = e.mainSeries();
                for (const e of t.seriesLikeSources()) {
                    if (!e.isVisible() || !e.isActingAsSymbolSource().value())
                        continue;
                    const t = i || (0,
                    n.symbolOriginalCurrency)((0,
                    s.ensureNotNull)(e.symbolInfo()));
                    this._newSourcesCurrencies.set(e.id(), t),
                    this._oldSourcesCurrencies.set(e.id(), e.currency()),
                    this._showFade = this._showFade || e === r && e.currency() !== t
                }
            }
            redo() {
                this._applyCurrencies(this._newSourcesCurrencies)
            }
            undo() {
                this._applyCurrencies(this._oldSourcesCurrencies)
            }
            _applyCurrencies(e) {
                e.forEach(((e,t)=>{
                    (0,
                    s.ensureNotNull)(this._chartModel.dataSourceForId(t)).setCurrency(e)
                }
                )),
                this._chartModel.selectionMacro((e=>{
                    e.clearSelection()
                }
                )),
                this._showFade && this._chartModel.undoModel().loadingScreen().show(!0)
            }
        }
    }
    ,
    696459: (e,t,i)=>{
        "use strict";
        i.d(t, {
            SetPriceScaleModeCommand: ()=>r
        });
        var s = i(262624)
          , o = i(669763)
          , n = i(169532);
        class r extends o.UndoCommand {
            constructor(e, t, i, s) {
                super(i),
                this._newMode = e,
                this._priceScaleId = t.id(),
                this._model = s,
                this._oldMode = t.mode()
            }
            redo() {
                this._applyMode(this._newMode)
            }
            undo() {
                this._applyMode(this._oldMode)
            }
            _applyMode(e) {
                const t = this._findPriceScaleById();
                null !== t && ((0,
                s.allowSavingDefaults)(!0),
                t.setMode(e),
                (0,
                s.allowSavingDefaults)(!1),
                this._model && (this._model.recalculateAllPanes((0,
                n.viewportChangeEvent)()),
                this._model.lightUpdate()))
            }
            _findPriceScaleById() {
                const e = this._model.panes();
                for (let t = 0; t < e.length; t++) {
                    const i = e[t].getPriceScaleById(this._priceScaleId);
                    if (null !== i)
                        return i
                }
                return null
            }
        }
    }
    ,
    473936: (e,t,i)=>{
        "use strict";
        i.d(t, {
            SetPriceScaleUnitUndoCommand: ()=>r
        });
        var s = i(650151)
          , o = i(669763)
          , n = i(975179);
        class r extends o.UndoCommand {
            constructor(e, t, i, o) {
                super(o),
                this._newSourcesUnits = new Map,
                this._oldSourcesUnits = new Map,
                this._showFade = !1,
                this._chartModel = e;
                const r = e.mainSeries();
                for (const e of t.seriesLikeSources()) {
                    if (!e.isVisible() || !e.isActingAsSymbolSource().value())
                        continue;
                    const t = i || (0,
                    n.symbolOriginalUnit)((0,
                    s.ensureNotNull)(e.symbolInfo()), this._chartModel.unitConversionEnabled());
                    this._newSourcesUnits.set(e.id(), t),
                    this._oldSourcesUnits.set(e.id(), e.unit()),
                    this._showFade = this._showFade || e === r && e.unit() !== t
                }
            }
            redo() {
                this._applyUnits(this._newSourcesUnits)
            }
            undo() {
                this._applyUnits(this._oldSourcesUnits)
            }
            _applyUnits(e) {
                e.forEach(((e,t)=>{
                    (0,
                    s.ensureNotNull)(this._chartModel.dataSourceForId(t)).setUnit(e)
                }
                )),
                this._chartModel.selectionMacro((e=>{
                    e.clearSelection()
                }
                )),
                this._showFade && this._chartModel.undoModel().loadingScreen().show(!0)
            }
        }
    }
    ,
    246020: (e,t,i)=>{
        "use strict";
        i.d(t, {
            SetScaleRatioPropertiesCommand: ()=>r
        });
        var s = i(669763)
          , o = i(262624)
          , n = i(169532);
        class r extends s.UndoCommand {
            constructor(e, t, i, s) {
                super(i),
                this._property = e,
                this._newValue = t,
                this._model = s,
                this._priceScale = this._model.mainSeries().priceScale(),
                this._oldValue = this._property.value(),
                this._oldMode = this._priceScale.mode()
            }
            redo() {
                this._oldValue = this._property.value(),
                this._oldMode = this._priceScale.mode(),
                (0,
                o.allowSavingDefaults)(!0),
                this._priceScale.setMode({
                    autoScale: !1,
                    percentage: !1,
                    log: !1
                }),
                this._property.setValue(this._newValue),
                (0,
                o.allowSavingDefaults)(!1),
                this._model.recalculateAllPanes((0,
                n.viewportChangeEvent)()),
                this._model.lightUpdate()
            }
            undo() {
                (0,
                o.allowSavingDefaults)(!0),
                this._property.setValue(this._oldValue),
                this._priceScale.setMode(this._oldMode),
                (0,
                o.allowSavingDefaults)(!1),
                this._model.recalculateAllPanes((0,
                n.viewportChangeEvent)()),
                this._model.lightUpdate()
            }
        }
    }
    ,
    109117: (e,t,i)=>{
        "use strict";
        i.d(t, {
            SetWatchedValueCommand: ()=>o
        });
        var s = i(669763);
        class o extends s.UndoCommand {
            constructor(e, t, i, s=!0) {
                super(i, void 0, s),
                this._wv = e,
                this._newValue = t,
                this._oldValue = e.value()
            }
            redo() {
                this._wv.setValue(this._newValue)
            }
            undo() {
                this._wv.setValue(this._oldValue)
            }
        }
    }
    ,
    632911: (e,t,i)=>{
        "use strict";
        function s(e, t) {
            let i = [];
            const o = e.children(t, !1);
            for (let t = 0; t < o.length; t++)
                i = i.concat(s(e, o[t]));
            return i.push(t),
            i
        }
        function o(e, t) {
            const i = new Set
              , o = t=>{
                e.children(t, !1).forEach((e=>{
                    i.has(e) || (i.add(e),
                    o(e))
                }
                ))
            }
            ;
            return t.forEach(o),
            t.filter((e=>!i.has(e))).map((t=>s(e, t))).reduce(((e,t)=>e.concat(t)), [])
        }
        i.d(t, {
            closeSourcesSet: ()=>o
        })
    }
    ,
    778660: (e,t,i)=>{
        "use strict";
        i.d(t, {
            SwapChartsUndoCommand: ()=>a
        });
        var s = i(444372)
          , o = i(370407)
          , n = i(669763);
        const r = new o.TranslatedString("swap charts in the Layout",s.t(null, void 0, i(919209)));
        class a extends n.UndoCommand {
            constructor(e, t, i) {
                super(r),
                this._swapper = e,
                this._from = t,
                this._to = i
            }
            redo() {
                this._swapper(this._from, this._to)
            }
            undo() {
                this._swapper(this._from, this._to)
            }
        }
    }
    ,
    405338: (e,t,i)=>{
        "use strict";
        i.d(t, {
            createUndoHistory: ()=>d
        });
        var s = i(650151)
          , o = i(375727)
          , n = i(571491)
          , r = i(109117)
          , a = i(338619)
          , l = i(942634);
        const c = (0,
        a.getLogger)("Common.UndoHistory");
        function d() {
            const e = []
              , t = new o.UndoStack
              , i = new o.UndoStack
              , a = new l.Delegate;
            function d(s) {
                if (e.length > 0)
                    e[e.length - 1].addCommand(s);
                else {
                    i.clear();
                    const e = t.head()
                      , o = e && e.text().originalText();
                    e && e.canMerge(s) ? e.merge(s) : t.push(s);
                    const n = s.text().originalText();
                    "" !== n && n !== o && c.logNormal("DO: " + n)
                }
                s.executeOnPush() && s.redo(),
                e.length || a.fire(u())
            }
            function u() {
                const e = t.head()
                  , s = i.head()
                  , o = void 0 === e ? void 0 : e.text()
                  , n = void 0 === s ? void 0 : s.text();
                return {
                    enableUndo: !t.isEmpty(),
                    undoCommandCount: t.size(),
                    undoText: void 0 !== o ? o.translatedText() : o,
                    enableRedo: !i.isEmpty(),
                    redoCommandCount: i.size(),
                    redoText: void 0 !== n ? n.translatedText() : n,
                    originalUndoText: void 0 !== o ? o.originalText() : void 0,
                    originalRedoText: void 0 !== n ? n.originalText() : void 0
                }
            }
            return {
                beginUndoMacro: function(t) {
                    const i = new n.UndoMacroCommand(t);
                    return e.push(i),
                    i
                },
                clearStack: function() {
                    t.clear(),
                    i.clear(),
                    a.fire(u())
                },
                createUndoCheckpoint: function() {
                    return {
                        lastActualCommand: t.isEmpty() ? null : t.head()
                    }
                },
                endUndoMacro: function() {
                    const t = (0,
                    s.ensureDefined)(e.pop());
                    t.isEmpty() || d(t)
                },
                pushUndoCommand: d,
                redo: function() {
                    if (i.isEmpty())
                        return !1;
                    const e = i.pop();
                    return !!e && (e.redo(),
                    t.push(e),
                    c.logNormal("REDO: " + e.text().originalText()),
                    a.fire(u()),
                    !0)
                },
                redoStack: function() {
                    return i
                },
                setWatchedValue: function(e, t, i, s) {
                    if (e.value() !== t) {
                        const o = new r.SetWatchedValueCommand(e,t,i,!s);
                        d(o),
                        o.redo()
                    }
                },
                undo: function() {
                    if (t.isEmpty())
                        return !1;
                    const e = t.pop();
                    return !!e && (e.undo(),
                    i.push(e),
                    c.logNormal("UNDO: " + e.text().originalText()),
                    a.fire(u()),
                    !0)
                },
                undoStack: function() {
                    return t
                },
                undoToCheckpoint: function(e) {
                    for (; !t.isEmpty() && e.lastActualCommand !== t.head(); )
                        t.pop().undo();
                    i.clear(),
                    a.fire(u())
                },
                state: u,
                onChange: function() {
                    return a
                }
            }
        }
    }
    ,
    571491: (e,t,i)=>{
        "use strict";
        i.d(t, {
            UndoMacroCommand: ()=>o
        });
        var s = i(669763);
        class o extends s.UndoCommand {
            constructor(e) {
                super(e, !1),
                this._subcommands = []
            }
            addCommand(e) {
                this._subcommands.push(e)
            }
            isEmpty() {
                return 0 === this._subcommands.length
            }
            redo() {
                for (let e = 0; e < this._subcommands.length; e++)
                    this._subcommands[e].redo()
            }
            undo() {
                for (let e = this._subcommands.length - 1; e >= 0; e--)
                    this._subcommands[e].undo()
            }
            commands() {
                return this._subcommands
            }
            affectsState() {
                return this._subcommands.some((e=>e.affectsState()))
            }
        }
    }
    ,
    375727: (e,t,i)=>{
        "use strict";
        i.d(t, {
            UndoStack: ()=>r
        });
        var s = i(669763)
          , o = i(942634);
        const n = (0,
        i(338619).getLogger)("Common.UndoStack");
        class r {
            constructor() {
                this._commands = [],
                this._onChange = new o.Delegate
            }
            onChange() {
                return this._onChange
            }
            isEmpty() {
                return 0 === this._commands.length
            }
            size() {
                return this._commands.length
            }
            clear() {
                this.isEmpty() || (this._commands.length = 0,
                this._onChange.fire())
            }
            push(e) {
                if (!(e instanceof s.UndoCommand))
                    throw new TypeError("argument must be an instance of UndoCommand");
                this._commands.push(e),
                this._onChange.fire(e)
            }
            pop() {
                if (this.isEmpty())
                    return void n.logDebug("pop: undo stack is empty");
                const e = this._commands.pop();
                return this._onChange.fire(e),
                e
            }
            head() {
                if (!this.isEmpty())
                    return this._commands[this._commands.length - 1]
            }
        }
    }
    ,
    781178: (e,t,i)=>{
        "use strict";
        i.d(t, {
            UnmergeDownUndoCommand: ()=>r,
            UnmergeToNewBottomPane: ()=>l,
            UnmergeUpUndoCommand: ()=>a
        });
        var s = i(650151)
          , o = i(438266);
        class n extends o.MoveSourceUndoCommand {
            constructor(e, t, i) {
                super(e, t, i)
            }
            redo() {
                const e = (0,
                s.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId))
                  , t = (0,
                s.ensureNotNull)(this._chartModel.paneForSource(e))
                  , i = this._chartModel.children(e, !0);
                t.bulkActionMacro((()=>{
                    i.forEach((e=>this._chartModel.detachSource(e))),
                    this._chartModel.detachSource(e)
                }
                ));
                const o = this._chartModel.createPane(this.targetPaneIndex())
                  , n = o.findSuitableScale(e);
                o.bulkActionMacro((()=>{
                    o.addDataSource(e, n, !1),
                    i.forEach((e=>o.addDataSource(e, n, !1)))
                }
                ));
                const r = (0,
                s.ensureNotNull)(e.priceScale());
                r.restoreState(this._newPriceScaleState(o.isOverlay(e))),
                r.setHeight(o.height()),
                this._chartModel.fullUpdate(),
                this._chartModel.setShouldBeSavedEvenIfHidden(!0)
            }
            undo() {
                const e = (0,
                s.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId))
                  , t = (0,
                s.ensureNotNull)(this._chartModel.paneForSource(e))
                  , i = this._chartModel.children(e, !0);
                t.bulkActionMacro((()=>{
                    i.forEach((e=>this._chartModel.detachSource(e)));
                    const t = this._chartModel.detachSource(e);
                    (0,
                    s.assert)(t, "Undo of detaching must remove pane")
                }
                ));
                const o = this._chartModel.panes()[this._initialPaneIndex];
                let n = o.getPriceScaleById(this._initialPriceScaleId);
                null === n && (n = o.createPriceScaleAtPosition(this._initialPriceScalePosition, this._initialPriceScaleIndex)),
                o.bulkActionMacro((()=>{
                    o.addDataSource(e, n, !0),
                    i.forEach((e=>o.addDataSource(e, n, !1)))
                }
                ));
                const r = (0,
                s.ensureNotNull)(e.priceScale());
                r.restoreState(this._originalPriceScaleState()),
                r.setHeight(o.height()),
                this._chartModel.fullUpdate()
            }
        }
        class r extends n {
            constructor(e, t, i) {
                super(e, t, i)
            }
            targetPaneIndex() {
                return this._initialPaneIndex + 1
            }
        }
        class a extends n {
            constructor(e, t, i) {
                super(e, t, i)
            }
            targetPaneIndex() {
                return this._initialPaneIndex
            }
        }
        class l extends n {
            constructor(e, t, i) {
                super(e, t, i)
            }
            targetPaneIndex() {
                return this._chartModel.panes().length
            }
        }
    }
    ,
    674720: (e,t,i)=>{
        "use strict";
        i.d(t, {
            sourceNewUnitOnPinningToPriceScale: ()=>r,
            unitConvertibleGroups: ()=>n
        });
        var s = i(487945)
          , o = i(975179);
        function n(e, t, i) {
            const s = (0,
            o.symbolUnitConvertibleGroupsIfExist)(e, !0);
            if (null !== s)
                return s;
            const n = i.unitGroupById(t);
            return null === n ? [] : [n]
        }
        function r(e, t, i, o) {
            let r = null;
            if (i.unitConversionEnabled() && (0,
            s.isSymbolSource)(e)) {
                const s = i.availableUnits()
                  , a = t.unit(s)
                  , l = e.unit()
                  , c = null === l ? [] : n(e.symbolInfo(), l, s);
                null !== a && null !== a.selectedUnit && !a.allUnitsAreOriginal && a.selectedUnit !== l && (o && null === l || null !== l && s.convertible(l, c)) && (r = a.selectedUnit)
            }
            return r
        }
    }
    ,
    893556: (e,t,i)=>{
        "use strict";
        i.d(t, {
            restoreWithWeekdaySettingsValue: ()=>l,
            withWeekdayProperty: ()=>a
        });
        var s = i(62802)
          , o = i(998418);
        const n = "date_format_with_weekday";
        function r() {
            return s.getBool(n, !0)
        }
        const a = (0,
        o.createPrimitiveProperty)(r());
        function l() {
            a.setValue(!0),
            s.remove(n)
        }
        a.subscribe(null, (()=>s.setValue(n, a.value()))),
        s.onSync.subscribe(null, (()=>a.setValue(r())))
    }
    ,
    691246: (e,t,i)=>{
        "use strict";
        i.d(t, {
            moveAfterSource: ()=>E,
            moveBeforeSource: ()=>k,
            newLineToolZOrder: ()=>C,
            newStudyZOrder: ()=>w,
            reorderDataSourcesStateZOrder: ()=>f
        });
        var s = i(465836)
          , o = i(434396)
          , n = i(526910)
          , r = i(198930)
          , a = i(828473);
        function l(e) {
            return (0,
            s.isLineTool)(e) && !e.isSpeciallyZOrderedSource()
        }
        function c(e) {
            return (0,
            o.isStudy)(e) && !e.isSpeciallyZOrderedSource() || (0,
            o.isStudyStub)(e)
        }
        function d(e, t) {
            return e.zorder - t.zorder
        }
        function u(e, t) {
            (0,
            r.isMainSeriesState)(e) ? e.zorder = 0 : e.zorder = t
        }
        function h(e, t) {
            e.setZorder(t)
        }
        function p(e) {
            return e.zorder()
        }
        function m(e) {
            return Math.round(1e3 * e) / 1e3
        }
        function g(e, t) {
            const i = Math.max(e, t)
              , s = Math.min(e, t);
            return Math.max(0, Math.ceil(i) - Math.floor(s) - 1)
        }
        function _(e, t, i) {
            let s = 0;
            const o = function(e, t) {
                const i = 1e3;
                return Math.abs(t * i - e * i) / i
            }(t, e);
            var n;
            return o > i ? (e = Math.trunc(e),
            s = Math.floor(o / (i + 1))) : (n = o / (i + 1),
            s = Math.floor(1e3 * n) / 1e3),
            {
                startZOrder: e,
                zOrderStep: s
            }
        }
        function v(e, t, i, s) {
            let o = e.length
              , n = t;
            for (let t = e.length - 1; t >= -1; t--)
                if (-1 === t || s(e[t])) {
                    const s = t;
                    let r = P(n);
                    if (o - 1 === s)
                        s >= 0 && i(e[s], r);
                    else {
                        const t = g(o, s);
                        let a = 0;
                        for (; 0 === a; ) {
                            const e = _(n, r, t);
                            n = e.startZOrder,
                            a = e.zOrderStep,
                            0 === a && (r -= 1e4,
                            0 === r && (r -= 1e4))
                        }
                        let l = o - 1;
                        for (; l > s; ) {
                            const t = m(n - a);
                            i(e[l], t),
                            n = t,
                            l--
                        }
                        s >= 0 && i(e[s], r)
                    }
                    n = r,
                    o = s
                }
        }
        function S(e, t, i, s) {
            let o = -1
              , n = t;
            for (let t = 0; t <= e.length; t++)
                if (t === e.length || s(e[t])) {
                    const s = t;
                    let r = T(n);
                    if (o + 1 === s)
                        s <= e.length - 1 && i(e[s], r);
                    else {
                        const t = g(o, s);
                        let a = 0;
                        for (; 0 === a; ) {
                            const e = _(n, r, t);
                            n = e.startZOrder,
                            a = e.zOrderStep,
                            0 === a && (r += 1e4,
                            0 === r && (r += 1e4))
                        }
                        let l = o + 1;
                        for (; l <= s - 1; ) {
                            const t = m(n + a);
                            i(e[l], t),
                            n = t,
                            l++
                        }
                        s <= e.length - 1 && i(e[s], r)
                    }
                    n = r,
                    o = s
                }
        }
        function f(e) {
            !function(e, t, i, s, o, n) {
                let r = null;
                const a = [];
                for (const o of e)
                    t(o) ? (a.push(o),
                    r = o) : (i(o) || s(o)) && a.push(o);
                a.sort(n),
                null !== r && o(r, 0);
                const l = null === r ? -1 : a.indexOf(r);
                -1 !== l ? (v(a.slice(0, l), 0, o, i),
                S(a.slice(l + 1), 0, o, i)) : S(a, 0, o, i)
            }(e, r.isMainSeriesState, r.isStudyState, r.isLineToolState, u, d)
        }
        function b(e, t) {
            const i = Math.floor(e / 1e4);
            let s = t.get(i);
            return void 0 === s && (s = [],
            t.set(i, s)),
            s
        }
        function y(e, t, i, s, o, n) {
            let r = -1 / 0
              , a = 1 / 0
              , l = -1 / 0
              , c = 0;
            const d = new Map;
            for (let s = 0; s < e.length; ++s) {
                const n = e[s]
                  , u = o(n);
                t(n) ? (r = Math.max(r, u),
                b(u, d).push(n)) : i(n) && (u < 0 && (a = Math.min(a, u),
                l = Math.max(l, u)),
                c = Math.max(c, u))
            }
            if (n) {
                const e = Math.max(c, r)
                  , t = _(e, T(e), 1);
                return m(t.startZOrder + t.zOrderStep)
            }
            if (r === -1 / 0) {
                const e = a === 1 / 0 ? 0 : a
                  , t = _(P(e), e, 1);
                return m(t.startZOrder + t.zOrderStep)
            }
            const u = _(r, T(r), 1);
            if (0 !== u.zOrderStep)
                return m(u.startZOrder + u.zOrderStep);
            const h = b(r, d).sort(((e,t)=>o(e) - o(t)));
            let p = P(o(h[0]));
            const g = T(p)
              , v = _(p, g, h.length + 1).zOrderStep;
            return 0 !== v ? (h.forEach((e=>{
                const t = m(p + v);
                s(e, t),
                p = t
            }
            )),
            m(p + v)) : m(g + 5e3)
        }
        function C(e, t) {
            return y(e, l, c, h, p, t)
        }
        function w(e) {
            let t = -1e4;
            for (const i of e)
                c(i) && (t = Math.min(t, i.zorder() - 1e4));
            return 0 === t ? -1e4 : t
        }
        function T(e) {
            const t = 1e4 * Math.ceil(e / 1e4);
            return t === e ? t + 1e4 : t
        }
        function P(e) {
            const t = 1e4 * Math.floor(e / 1e4);
            return t === e ? t - 1e4 : t
        }
        function x(e, t, i, s, o, n, r) {
            const l = t.length
              , {newItems: c, movedItemsStartIndex: d} = i > 0 ? (0,
            a.moveAfter)(e, t, i - 1) : (0,
            a.moveBefore)(e, t, 0);
            let u = !1;
            for (let t = d; t < d + l; t++)
                if (c[t] !== e[t]) {
                    u = !0;
                    break
                }
            if (!u)
                return;
            if (s(t[0]))
                return void (i < e.length && r(e[i]) < 0 ? S(c.slice(d + 1), 0, n, o) : v(c.slice(0, d), 0, n, o));
            t.some((e=>o(e))) ? function(e, t, i, s, o, n) {
                let r, a, l = -1, c = -1;
                0 === i ? (c = M(e, i + t, s),
                a = n(e[c])) : i + t === e.length ? (l = I(e, i - 1, s),
                r = n(e[l])) : (l = I(e, i - 1, s),
                r = n(e[l]),
                c = M(e, i + t, s),
                a = n(e[c]));
                if ((void 0 === r || r < 0) && void 0 !== a && a <= 0)
                    v(e.slice(0, c), a, o, s);
                else if ((void 0 === a || a > 0) && void 0 !== r && r >= 0)
                    S(e.slice(l + 1), r, o, s);
                else {
                    i + t < e.length - i ? v(e.slice(0, i + t), n(e[i + t]), o, s) : S(e.slice(i), n(e[i - 1]), o, s)
                }
            }(c, l, d, o, n, r) : function(e, t, i, s, o, n, r) {
                let a, l;
                0 === i ? l = r(e[i + t]) : i + t === e.length ? a = r(e[i - 1]) : (a = r(e[i - 1]),
                l = r(e[i + t]));
                let c = 0
                  , d = 0
                  , u = 0
                  , h = 0
                  , p = 0;
                if ((void 0 === a || a < 0) && void 0 !== l && l <= 0) {
                    c = l;
                    const e = _(c, void 0 !== a ? a : P(l), t);
                    c = e.startZOrder,
                    p = e.zOrderStep,
                    u = i + t - 1,
                    h = u - t,
                    d = -1
                } else if ((void 0 === l || l > 0) && void 0 !== a && a >= 0) {
                    c = a;
                    const e = _(c, void 0 !== l ? l : T(a), t);
                    c = e.startZOrder,
                    p = e.zOrderStep,
                    u = i,
                    h = u + t,
                    d = 1
                }
                if (0 !== p)
                    for (; u !== h; ) {
                        const t = m(c + d * p);
                        n(e[u], t),
                        c = t,
                        u += d
                    }
                else {
                    const t = e.findIndex((e=>o(e)));
                    -1 !== t ? (v(e.slice(0, t), 0, n, s),
                    S(e.slice(t + 1), 0, n, s)) : S(e, 0, n, s)
                }
            }(c, l, d, o, s, n, r)
        }
        function M(e, t, i) {
            for (; t < e.length && i(e[t]); )
                t++;
            return Math.min(t, e.length - 1)
        }
        function I(e, t, i) {
            for (; t >= 0 && i(e[t]); )
                t--;
            return Math.max(0, t)
        }
        function A(e, t, i, s, o, n, r) {
            const a = e.indexOf(i) + 1;
            x(e, t, a, s, o, n, r)
        }
        function L(e, t, i, s, o, n, r) {
            const a = e.indexOf(i);
            x(e, t, a, s, o, n, r)
        }
        function E(e, t, i) {
            A(e, t, i, n.isSeries, c, h, p)
        }
        function k(e, t, i) {
            L(e, t, i, n.isSeries, c, h, p)
        }
    }
    ,
    230844: (e,t,i)=>{
        "use strict";
        i.d(t, {
            getAlertsActionCreators: ()=>o,
            getFiresActionCreators: ()=>n
        });
        var s = i(481251);
        const o = (0,
        s.default)((async()=>new ((await Promise.all([i.e(22568), i.e(91929), i.e(23930), i.e(49502)]).then(i.bind(i, 647533))).AlertsActionCreators)))
          , n = (0,
        s.default)((async()=>new ((await Promise.all([i.e(22568), i.e(91929), i.e(23930), i.e(68074)]).then(i.bind(i, 334284))).FiresActionCreators)))
    }
    ,
    694193: (e,t,i)=>{
        "use strict";
        i.d(t, {
            getAlertDescription: ()=>n
        });
        var s = i(882782)
          , o = i(472814);
        function n(e) {
            return function(e) {
                return "function" == typeof e.name ? e.name() : e.name
            }(e) || function(e) {
                return "description"in e ? e.description() : e.message
            }(e) || function(e) {
                const t = function(e) {
                    return "dataSource"in e ? "symbol" === e.dataSource.type ? e.dataSource.symbol : e.dataSource.watchlistName : "function" == typeof e.symbol ? (0,
                    s.decodeExtendedSymbol)(e.symbol()) : e.symbol
                }(e)
                  , i = "function" == typeof e.resolution ? e.resolution() : e.resolution
                  , n = "function" == typeof e.crossInterval ? e.crossInterval() : e.crossInterval;
                return (0,
                o.formatSymbolAndResolution)({
                    symbol: t,
                    resolution: i,
                    crossInterval: n
                })
            }(e)
        }
    }
    ,
    407781: (e,t,i)=>{
        "use strict";
        function s(e=0) {
            return e < 1e3 ? e : e / 1e3
        }
        function o(e, t) {
            if (e.length > t) {
                const i = /[\W]+$/g
                  , s = e.substring(0, t)
                  , o = s.replace(i, "");
                return `${o.length ? o : s.substring(0, t - 1)}…`
            }
            return e
        }
        i.d(t, {
            cutString: ()=>o,
            ensureDurationInSeconds: ()=>s
        })
    }
    ,
    771702: (e,t,i)=>{
        "use strict";
        i.d(t, {
            canPlaceAlertOnResolution: ()=>n
        });
        var s = i(378975)
          , o = i(795688);
        function n(e, t) {
            const i = s.Interval.isSeconds(e)
              , n = t ? null == t ? void 0 : t.alertsOnSeconds : (0,
            o.enabled)("ALERTS_ON_SECONDS");
            return !i || n
        }
    }
    ,
    558634: (e,t,i)=>{
        "use strict";
        i.d(t, {
            getAlertsChartActionCreators: ()=>s
        });
        const s = (0,
        i(481251).default)((async()=>{
            const {getCreateAlertAction: e} = await Promise.all([i.e(73068), i.e(43853)]).then(i.bind(i, 790279))
              , {getEditAlertOnLineDataSourceAction: t} = await Promise.all([i.e(73068), i.e(43853)]).then(i.bind(i, 190151));
            return {
                createAlert: e,
                editAlertOnLineDataSource: t
            }
        }
        ))
    }
    ,
    417947: (e,t,i)=>{
        "use strict";
        i.d(t, {
            hasUsualAlertPlots: ()=>a,
            isFirstAlertPlotUsual: ()=>r
        });
        var s = i(526910)
          , o = i(434396)
          , n = i(924166);
        function r(e) {
            if ((0,
            s.isSeries)(e))
                return !0;
            if ((0,
            o.isStudy)(e) && !(0,
            o.isStudyStrategy)(e)) {
                const t = (0,
                n.plotsForAlert)(e.metaInfo(), e.offset.bind(e));
                return !e.metaInfo().hasAlertFunction && t.every((e=>"alertcondition" !== e.type))
            }
            return !1
        }
        function a(e) {
            if ((0,
            s.isSeries)(e))
                return !0;
            if ((0,
            o.isStudy)(e) && !(0,
            o.isStudyStrategy)(e)) {
                return (0,
                n.plotsForAlert)(e.metaInfo(), e.offset.bind(e)).some((e=>"alertcondition" !== e.type))
            }
            return !1
        }
    }
    ,
    411667: (e,t,i)=>{
        "use strict";
        var s;
        i.d(t, {
            AlertStopReason: ()=>s
        }),
        function(e) {
            e[e.Auto = 0] = "Auto",
            e[e.Manual = 1] = "Manual",
            e[e.Expired = 2] = "Expired",
            e[e.Created = 3] = "Created"
        }(s || (s = {}))
    }
    ,
    475365: (e,t,i)=>{
        "use strict";
        i.d(t, {
            confirmDatasourceRemoving: ()=>n
        });
        var s = i(444372)
          , o = i(779923);
        function n() {
            return new Promise((e=>(0,
            o.showConfirm)({
                text: s.t(null, void 0, i(577322)),
                onConfirm: ({dialogClose: t})=>{
                    e(!0),
                    t()
                }
                ,
                onClose: ()=>e(!1)
            })))
        }
    }
    ,
    966837: (e,t,i)=>{
        "use strict";
        function s(e) {
            return n().then((t=>t.hasUserAccessToDataSource(e)))
        }
        function o(e) {
            return n().then((t=>t.filterAccessibleDataSources(e)))
        }
        i.d(t, {
            filterAccessibleDataSources: ()=>o,
            hasUserAccessToDataSource: ()=>s
        });
        const n = ()=>Promise.all([i.e(29267), i.e(47793), i.e(80690), i.e(98241), i.e(4066), i.e(70045), i.e(42095), i.e(53608), i.e(27620), i.e(27534), i.e(83441)]).then(i.bind(i, 649994))
    }
    ,
    922182: (e,t,i)=>{
        "use strict";
        i.d(t, {
            bulkRemoveConfirmation: ()=>r,
            bulkRemoveInactiveConfirmation: ()=>a,
            selectedRemoveConfirmation: ()=>l
        });
        var s = i(444372)
          , o = i(694193)
          , n = i(407781);
        const r = e=>e ? {
            title: s.t(null, void 0, i(716688)),
            text: s.t(null, void 0, i(724146))
        } : {
            title: s.t(null, void 0, i(862436)),
            text: s.t(null, void 0, i(444323))
        }
          , a = ()=>({
            title: s.t(null, void 0, i(408166)),
            text: s.t(null, void 0, i(554643))
        })
          , l = e=>{
            if (1 !== e.length)
                return {
                    title: s.t(null, void 0, i(423481)),
                    text: s.t(null, void 0, i(955138))
                };
            const t = e[0]
              , r = (0,
            o.getAlertDescription)(t);
            return {
                title: s.t(null, void 0, i(2376)),
                text: s.t(null, void 0, i(332063)).format({
                    alert: (0,
                    n.cutString)(r, 100)
                })
            }
        }
    }
    ,
    432059: (e,t,i)=>{
        "use strict";
        i.r(t),
        i.d(t, {
            alphaToTransparency: ()=>r,
            applyAlpha: ()=>n,
            applyTransparency: ()=>l,
            colorFromBackground: ()=>h,
            colorToInteger: ()=>v,
            generateColor: ()=>o,
            getLuminance: ()=>d,
            gradientColorAtPercent: ()=>p,
            isColorDark: ()=>m,
            isHexColor: ()=>u,
            resetTransparency: ()=>c,
            rgbaFromInteger: ()=>g,
            rgbaToInteger: ()=>_,
            transparencyToAlpha: ()=>a
        });
        var s = i(724377);
        function o(e, t, i) {
            if (t = t || 0,
            !u(e))
                return i ? (0,
                s.rgbaToString)((0,
                s.rgba)((0,
                s.parseRgb)(e), (0,
                s.normalizeAlphaComponent)(a(t)))) : e;
            const [o,n,r] = (0,
            s.parseRgb)(e)
              , l = (0,
            s.normalizeAlphaComponent)(a(t));
            return (0,
            s.rgbaToString)([o, n, r, l])
        }
        function n(e, t, i) {
            const o = (0,
            s.tryParseRgba)(e);
            if (null === o)
                throw new Error(`Invalid color: ${e}`);
            const [n,r,a,l] = o
              , c = (0,
            s.normalizeAlphaComponent)(t * (i ? l : 1));
            return (0,
            s.rgbaToString)((0,
            s.rgba)([n, r, a], c))
        }
        function r(e) {
            return 100 * (1 - e)
        }
        function a(e) {
            if (e < 0 || e > 100)
                throw new Error("invalid transparency");
            return 1 - e / 100
        }
        function l(e, t) {
            if ("transparent" === e)
                return e;
            const i = (0,
            s.parseRgba)(e)
              , o = i[3];
            return (0,
            s.rgbaToString)((0,
            s.rgba)(i[0], i[1], i[2], a(t) * o))
        }
        function c(e) {
            return "transparent" === e ? e : u(e) ? e.slice(0, 7) : (0,
            s.rgbaToString)((0,
            s.rgba)((0,
            s.parseRgb)(e), (0,
            s.normalizeAlphaComponent)(1)))
        }
        function d(e) {
            const t = (0,
            s.parseRgb)(e).map((e=>(e /= 255) <= .03928 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4)));
            return Number((.2126 * t[0] + .7152 * t[1] + .0722 * t[2]).toFixed(3))
        }
        function u(e) {
            return 0 === e.indexOf("#")
        }
        function h(e) {
            return "black" === (0,
            s.rgbToBlackWhiteString)((0,
            s.parseRgb)(e), 150) ? "#ffffff" : "#000000"
        }
        function p(e, t, i) {
            const [o,n,r,a] = (0,
            s.parseRgba)(e)
              , [l,c,d,u] = (0,
            s.parseRgba)(t)
              , h = (0,
            s.rgba)(Math.round(o + i * (l - o)), Math.round(n + i * (c - n)), Math.round(r + i * (d - r)), a + i * (u - a));
            return (0,
            s.rgbaToString)(h)
        }
        function m(e) {
            return d(c(e)) < .5
        }
        function g(e) {
            const t = (e = Math.round(e)) % 256;
            e -= t;
            const i = (e /= 256) % 256;
            e -= i;
            const s = (e /= 256) % 256;
            e -= s;
            return `rgba(${t},${i},${s},${(e /= 256) / 255})`
        }
        function _(e) {
            const t = Math.round(255 * e[3]);
            return e[0] + 256 * e[1] + 65536 * e[2] + 16777216 * t
        }
        function v(e) {
            const t = (0,
            s.tryParseRgba)(e);
            return null === t ? 0 : _(t)
        }
    }
    ,
    130841: (e,t,i)=>{
        "use strict";
        function s(e, t, i="promise rejected by time-out") {
            return new Promise(((s,o)=>{
                const n = setTimeout((()=>o(i)), t);
                e.then((e=>{
                    clearTimeout(n),
                    s(e)
                }
                )),
                e.catch((e=>{
                    clearTimeout(n),
                    o(e)
                }
                ))
            }
            ))
        }
        i.d(t, {
            makeTimeLimited: ()=>s
        })
    }
    ,
    533679: (e,t,i)=>{
        "use strict";
        function s() {
            return Promise.all([i.e(6342), i.e(93703), i.e(75816), i.e(78794), i.e(48012), i.e(21356), i.e(62093), i.e(25480), i.e(11390), i.e(32227), i.e(62526), i.e(32077)]).then(i.bind(i, 906657))
        }
        i.d(t, {
            loadChangeIntervalDialog: ()=>s
        })
    }
    ,
    214372: (e,t,i)=>{
        "use strict";
        i.d(t, {
            showChangeIntervalDialogAsync: ()=>n
        });
        var s = i(533679);
        let o = null;
        function n(e) {
            const t = o = (0,
            s.loadChangeIntervalDialog)().then((i=>{
                t === o && i.showChangeIntervalDialog(e)
            }
            ));
            return t
        }
    }
    ,
    207195: (e,t,i)=>{
        "use strict";
        function s(e) {
            return Promise.all([i.e(52170), i.e(46445), i.e(93703), i.e(75816), i.e(49481), i.e(78794), i.e(48012), i.e(44524), i.e(21356), i.e(62093), i.e(53953), i.e(2520), i.e(25480), i.e(62564), i.e(29296), i.e(59258), i.e(82421), i.e(67158), i.e(8222), i.e(33828), i.e(80089), i.e(25983), i.e(31085), i.e(50210), i.e(9430), i.e(32227), i.e(62526), i.e(9859), i.e(90223), i.e(15274), i.e(11097), i.e(91859)]).then(i.bind(i, 850758)).then((t=>t.showGoToDateDialog(e)))
        }
        i.d(t, {
            showGoToDateDialog: ()=>s
        })
    }
    ,
    310681: (e,t,i)=>{
        "use strict";
        async function s(e) {
            (await Promise.all([i.e(97811), i.e(46445), i.e(75816), i.e(65857), i.e(36010), i.e(22164), i.e(88488), i.e(88778), i.e(33253), i.e(34693), i.e(43311), i.e(35955), i.e(13689), i.e(32227), i.e(47793), i.e(38578), i.e(24229), i.e(29147), i.e(26066)]).then(i.bind(i, 915913))).renderGoToTradingViewReferralDialog(e)
        }
        i.d(t, {
            showGoToTradingViewReferralDialog: ()=>s
        })
    }
    ,
    374271: (e,t,i)=>{
        "use strict";
        i.d(t, {
            isOpenedModals: ()=>o,
            openedModals: ()=>s
        });
        const s = [];
        function o() {
            return 0 !== s.length
        }
    }
    ,
    956248: (e,t,i)=>{
        "use strict";
        i.d(t, {
            showDeleteStudyTreeConfirm: ()=>n
        });
        var s = i(444372)
          , o = i(779923);
        function n(e) {
            (0,
            o.showConfirm)({
                title: s.t(null, void 0, i(381605)),
                text: s.t(null, void 0, i(377174)),
                onConfirm: ({dialogClose: t})=>{
                    e(),
                    t()
                }
            })
        }
    }
    ,
    440075: (e,t,i)=>{
        "use strict";
        function s(e) {
            Promise.all([i.e(66613), i.e(93703), i.e(75816), i.e(49481), i.e(44524), i.e(21356), i.e(62093), i.e(53953), i.e(73399), i.e(2520), i.e(75826), i.e(59258), i.e(82421), i.e(67158), i.e(74600), i.e(97384), i.e(49325), i.e(94106), i.e(6752), i.e(79753), i.e(97956), i.e(32227), i.e(62526), i.e(31154), i.e(49399), i.e(9374)]).then(i.bind(i, 946499)).then((({SymbolInfoDialogImpl: t})=>{
                t.getInstance().show(e)
            }
            ))
        }
        i.d(t, {
            showSymbolInfoDialog: ()=>s
        })
    }
    ,
    875385: (e,t,i)=>{
        "use strict";
        i.d(t, {
            getProPlanDetailsForUser: ()=>h,
            getProPlanWeight: ()=>a,
            isExpertFeature: ()=>u
        });
        var s = i(795688)
          , o = i(549358)
          , n = i(702598)
          , r = i(296638);
        function a(e) {
            return window.pro ? "free" === e ? -1 : window.pro.getProduct((0,
            o.getProductForTrial)(e)).upgrade_weight : 0
        }
        function l(e) {
            return window.pro ? window.pro.getProduct((0,
            o.getProductForTrial)(e)).upgrade_weight : 0
        }
        function c(e) {
            return function(e) {
                return e.sort(((e,t)=>a(e) - a(t)))
            }((0,
            s.getProPlansWithFeature)(e).filter((e=>!(0,
            o.isTrialProduct)(e))))[0] || null
        }
        function d(e) {
            return function(e) {
                return e.sort(((e,t)=>l(e) - l(t)))
            }((0,
            s.getExpertPlansWithFeature)(e))[0] || null
        }
        function u(e) {
            const t = d(e)
              , i = c(e);
            return Boolean(t) && !Boolean(i)
        }
        async function h() {
            const e = await (0,
            n.fetch)("/pro-plans/profile/")
              , t = await e.json();
            if (e.ok)
                return t;
            if (403 === e.status) {
                const i = t;
                throw new r.ApiError(i.detail,e.status,i.code)
            }
            throw new Error(`Unable to handle unexpected response: ${String(e.text())}`)
        }
    }
    ,
    576119: (e,t,i)=>{
        "use strict";
        i.d(t, {
            disable: ()=>c,
            enable: ()=>d,
            pushBackListener: ()=>l
        });
        var s = i(79342);
        const o = [];
        let n = null;
        function r(e) {
            for (let t = 0; t < o.length; t++)
                if (o[t].name === e)
                    return t;
            return -1
        }
        function a(e) {
            if (!n)
                for (let t = o.length - 1; t >= 0 && !0 !== o[t].func(e); t--)
                    ;
        }
        function l(e, t) {
            const i = {
                name: e,
                func: t
            }
              , s = r(i.name);
            s > -1 && o.splice(s, 1),
            o.unshift(i)
        }
        function c() {
            return n ? null : (n = (0,
            s.randomHashN)(4),
            n)
        }
        function d(e) {
            if (e !== n)
                throw Error("Lock id is outdated");
            n = null
        }
        window.addEventListener("keypress", a, !1)
    }
    ,
    160285: (e,t,i)=>{
        "use strict";
        i.d(t, {
            workerBasedTimers: ()=>n
        });
        var s = i(622864)
          , o = i(454763);
        const n = new class {
            constructor() {
                this._timerWorker = null,
                this._timerIdCounter = 1,
                this._timersMap = new Map,
                this._rejectsToCall = new Set,
                this._processMessage = e=>{
                    const t = this._timersMap.get(e.data.turnaround);
                    switch (e.data.type) {
                    case "timerCreated":
                        t && (t.scheduledForRemoving ? ("interval" === t.type ? this._getTimerWorker().postMessage({
                            type: "clearInterval",
                            id: e.data.id
                        }) : this._getTimerWorker().postMessage({
                            type: "clearTimeout",
                            id: e.data.id
                        }),
                        this._deleteTimerFromMap(e.data.turnaround)) : t.workerTimerId = e.data.id);
                        break;
                    case "timerFired":
                        t && (t.callback(),
                        "timeout" === t.type && this._deleteTimerFromMap(e.data.turnaround))
                    }
                }
            }
            destroy() {
                var e;
                this._rejectsToCall.forEach((e=>e((0,
                s.createAbortError)()))),
                null === (e = this._timerWorker) || void 0 === e || e.terminate(),
                this._timerWorker = null,
                this._timersMap.clear()
            }
            setTimeout(e, t) {
                return this._setTimeoutImpl(e, t, "timeout")
            }
            clearTimeout(e) {
                const t = this._timersMap.get(e);
                t && (t.workerTimerId ? (this._getTimerWorker().postMessage({
                    type: "clearTimeout",
                    id: t.workerTimerId
                }),
                this._deleteTimerFromMap(e)) : t.scheduledForRemoving = !0)
            }
            setInterval(e, t) {
                const i = this._nextTimerId();
                return this._timersMap.set(i, {
                    callback: e,
                    type: "interval"
                }),
                this._getTimerWorker().postMessage({
                    type: "setInterval",
                    delay: t,
                    turnaround: i
                }),
                i
            }
            clearInterval(e) {
                const t = this._timersMap.get(e);
                t && (t.workerTimerId ? (this._getTimerWorker().postMessage({
                    type: "clearInterval",
                    id: t.workerTimerId
                }),
                this._deleteTimerFromMap(e)) : t.scheduledForRemoving = !0)
            }
            async createTimeout(e, t) {
                let i;
                return new Promise(((o,n)=>{
                    var r;
                    i = n,
                    this._rejectsToCall.add(i);
                    const a = this.setTimeout(o, e);
                    null === (r = null == t ? void 0 : t.signal) || void 0 === r || r.addEventListener("abort", (()=>{
                        this.clearTimeout(a),
                        n((0,
                        s.createAbortError)())
                    }
                    ))
                }
                )).finally((()=>{
                    this._rejectsToCall.delete(i)
                }
                ))
            }
            async*createInterval(e, t) {
                let i = ()=>{}
                  , o = e=>{}
                ;
                const n = this.setInterval((()=>{
                    i()
                }
                ), e);
                t.signal.addEventListener("abort", (()=>{
                    this.clearInterval(n),
                    o((0,
                    s.createAbortError)())
                }
                ));
                try {
                    for (; ; )
                        await new Promise(((e,t)=>{
                            i = e,
                            this._rejectsToCall.delete(o),
                            o = t,
                            this._rejectsToCall.add(o)
                        }
                        )),
                        yield
                } catch (e) {
                    if (!(0,
                    s.isAbortError)(e))
                        throw e
                }
            }
            _getTimerWorker() {
                return null === this._timerWorker && (this._timerWorker = new o.Worker(new URL(i.p + i.u(77050),i.b),{
                    name: "Timer worker"
                }),
                this._timerWorker.onmessage = this._processMessage),
                this._timerWorker
            }
            _setTimeoutImpl(e, t, i) {
                const s = this._nextTimerId();
                return this._timersMap.set(s, {
                    callback: e,
                    type: i
                }),
                this._getTimerWorker().postMessage({
                    type: "setTimeout",
                    delay: t,
                    turnaround: s
                }),
                s
            }
            _deleteTimerFromMap(e) {
                if (this._timersMap.delete(e),
                0 === this._timersMap.size) {
                    const e = this._setTimeoutImpl((()=>{
                        var t;
                        1 === this._timersMap.size && this._timersMap.has(e) && (this._timersMap.delete(e),
                        null === (t = this._timerWorker) || void 0 === t || t.terminate(),
                        this._timerWorker = null)
                    }
                    ), 6e4, "terminal_timer")
                }
            }
            _nextTimerId() {
                return this._timerIdCounter++
            }
        }
    }
    ,
    625923: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" d="m19.54 4.5 3.96 4.32-.74.68-3.96-4.32.74-.68ZM7.46 4.5 3.5 8.82l.74.68L8.2 5.18l-.74-.68ZM19.74 10.33A7.5 7.5 0 0 1 21 14.5v.5h1v-.5a8.5 8.5 0 1 0-8.5 8.5h.5v-1h-.5a7.5 7.5 0 1 1 6.24-11.67Z"/><path fill="currentColor" d="M13 9v5h-3v1h4V9h-1ZM19 20v-4h1v4h4v1h-4v4h-1v-4h-4v-1h4Z"/></svg>'
    }
    ,
    270068: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" d="M20.1 4 25 9.32l-.73.68-4.9-5.32.73-.68ZM7.9 4 3 9.32l.73.68 4.91-5.32L7.91 4ZM14 15v-5h1v6h-4v-1h3Z"/><path fill="currentColor" d="M5 15a9 9 0 1 1 18 0 9 9 0 0 1-18 0Zm9-8a8 8 0 1 0 0 16 8 8 0 0 0 0-16Z"/></svg>'
    }
    ,
    634369: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28" fill="currentColor"><path fill-rule="evenodd" d="M18 14a4 4 0 1 1-8 0 4 4 0 0 1 8 0Zm-1 0a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"/><path fill-rule="evenodd" d="M8.5 5h11l5 9-5 9h-11l-5-9 5-9Zm-3.86 9L9.1 6h9.82l4.45 8-4.45 8H9.1l-4.45-8Z"/></svg>'
    }
    ,
    748040: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" d="M16.73 6.56a2.5 2.5 0 0 1 3.54 0l1.17 1.17a2.5 2.5 0 0 1 0 3.54l-.59.58-9 9-1 1-.14.15H6v-4.7l.15-.15 1-1 9-9 .58-.59Zm2.83.7a1.5 1.5 0 0 0-2.12 0l-.23.24 3.29 3.3.23-.24a1.5 1.5 0 0 0 0-2.12l-1.17-1.17Zm.23 4.24L16.5 8.2l-8.3 8.3 3.3 3.3 8.3-8.3Zm-9 9L7.5 17.2l-.5.5V21h3.3l.5-.5Z"/></svg>'
    }
    ,
    324020: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" d="M15 5H6.5C5.67 5 5 5.67 5 6.5v15c0 .83.67 1.5 1.5 1.5h15c.83 0 1.5-.67 1.5-1.5V16h1v5.5a2.5 2.5 0 0 1-2.5 2.5h-15A2.5 2.5 0 0 1 4 21.5v-15A2.5 2.5 0 0 1 6.5 4H15v1Zm7.41-.3a2 2 0 0 0-2.82 0l-.94.95-7.5 7.5-1 1-.15.14V19h4.7l.15-.15 1-1 7.5-7.5.94-.94a2 2 0 0 0 0-2.82L22.41 4.7Zm-2.12.71a1 1 0 0 1 1.42 0l1.88 1.88a1 1 0 0 1 0 1.42l-.59.58-1.65-1.64L19.71 6l.58-.59Zm.36 2.94L22.29 10l-6.79 6.8-1.65-1.65-1.64-1.65L19 6.7l1.65 1.65Zm-7.5 7.5 1.64 1.65-.5.5H11v-3.3l.5-.5 1.65 1.65Z"/></svg>'
    }
    ,
    421672: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" fill-rule="evenodd" d="M14 22a8 8 0 1 0 0-16 8 8 0 0 0 0 16Zm5-9H9v2h10v-2Z"/></svg>'
    }
    ,
    553218: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><rect width="10" height="4" fill="currentColor" rx="2" x="4" y="7"/></svg>'
    }
    ,
    24165: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 22" width="22" height="22"><path fill="currentColor" d="M6 10h10v3H6v-3Z"/></svg>'
    }
    ,
    792263: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" d="M5 8h8v2H5V8Z"/></svg>'
    }
    ,
    262998: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><circle fill="currentColor" cx="9" cy="9" r="5"/></svg>'
    }
    ,
    732140: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18" fill="none"><circle fill="currentColor" cx="9" cy="9" r="4"/></svg>'
    }
    ,
    109494: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" fill-rule="evenodd" d="M4.74 3.26a4.62 4.62 0 0 0 1.8 5.3l.67.44-.66.44a4.63 4.63 0 0 0-1.81 5.3c.05.15.2.26.36.26h7.8c.17 0 .31-.1.37-.26a4.62 4.62 0 0 0-1.82-5.3L10.8 9l.66-.44a4.63 4.63 0 0 0 1.82-5.3.39.39 0 0 0-.37-.26H5.1c-.17 0-.31.1-.36.26ZM9 8.32l1.58-1.06a3.06 3.06 0 0 0 1.36-2.7H6.06a3.06 3.06 0 0 0 1.36 2.7L9 8.32Z"/></svg>'
    }
    ,
    792845: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" fill-rule="evenodd" d="M5.45 4.22a3.85 3.85 0 0 0 1.5 4.41l.56.37-.55.37a3.86 3.86 0 0 0-1.51 4.41c.04.13.16.22.3.22h6.5c.14 0 .26-.09.3-.22a3.85 3.85 0 0 0-1.5-4.41L10.48 9l.55-.37a3.86 3.86 0 0 0 1.51-4.41.32.32 0 0 0-.3-.22h-6.5a.32.32 0 0 0-.3.22ZM9 8.44l1.32-.89a2.55 2.55 0 0 0 1.13-2.25h-4.9c-.04.88.37 1.74 1.13 2.25L9 8.44Z"/></svg>'
    }
    ,
    725230: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" d="M9.3 9l.9-4.53a1.23 1.23 0 1 0-2.4 0L8.7 9l-.9 4.53a1.23 1.23 0 1 0 2.4 0L9.3 9z"/><path fill="currentColor" d="M9.15 9.26l4.38-1.48a1.23 1.23 0 1 0-1.21-2.09L8.85 8.74l-4.38 1.48a1.23 1.23 0 1 0 1.21 2.09l3.47-3.05z"/><path fill="currentColor" d="M9.15 8.74L5.68 5.69a1.23 1.23 0 1 0-1.2 2.09l4.37 1.48 3.47 3.05a1.23 1.23 0 1 0 1.2-2.09L9.16 8.74z"/></svg>'
    }
    ,
    643401: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M13.29 4.8h-.09a4.2 4.2 0 1 0 .09 8.4 6 6 0 1 1 0-8.4z"/></svg>'
    }
    ,
    212462: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" d="M12.58 12.1A3.86 3.86 0 0 0 9 6.75a3.87 3.87 0 0 0-3.58 5.33 7.74 7.74 0 0 1 7.16 0zM3.64 9.93l-2.3-.62.37-1.38 2.3.62-.37 1.38zM6.1 6.07L5.07 3.92l1.3-.6 1 2.15-1.29.6zM10.62 5.47l1-2.16 1.3.6-1.01 2.16-1.3-.6zM13.99 8.55l2.3-.62.36 1.38-2.3.62L14 8.55z"/></svg>'
    }
    ,
    845437: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd"><path stroke="currentColor" d="M13 22.5H5.5a2 2 0 0 1-2-2v-14a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2V14"/><path stroke="currentColor" stroke-linecap="square" d="M18.5 15.5v8m-4-4h8"/><path fill="currentColor" d="M7 8h11v1H7zm0 4h11v1H7zm0 4h5v1H7z"/></g></svg>'
    }
    ,
    201457: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" stroke="currentColor"><path d="M13.111 18.5H10.5a1 1 0 0 1-1-1v-11a1 1 0 0 1 1-1h11a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1h-8.389z"/><path d="M18.5 20v1.5a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1v-11a1 1 0 0 1 1-1H8"/></g></svg>'
    }
    ,
    855824: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 7 5" width="7" height="5" fill="none"><path stroke="currentColor" stroke-width="1.2" d="M1 1.5l2.5 2 2.5-2"/></svg>'
    }
    ,
    539706: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" d="M5 2H4v3H1v1h3v3h1V6h3V5H5V2Z"/><path fill="currentColor" fill-rule="evenodd" d="M17.5 11h-7a1.5 1.5 0 0 0 0 3h7a1.5 1.5 0 0 0 0-3Zm-7-1a2.5 2.5 0 0 0 0 5h7a2.5 2.5 0 0 0 0-5h-7Z"/><path fill="currentColor" d="M8 18h12v1H8v-1Z"/><path fill="currentColor" d="M21.5 6H10V5h11.5A2.5 2.5 0 0 1 24 7.5v14a2.5 2.5 0 0 1-2.5 2.5h-15A2.5 2.5 0 0 1 4 21.5V11h1v10.5c0 .83.67 1.5 1.5 1.5h15c.83 0 1.5-.67 1.5-1.5v-14c0-.83-.67-1.5-1.5-1.5Z"/></svg>'
    }
    ,
    428026: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28" fill="none"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M17.5 7H17v6h-3v-3H9v6H5v6h17V7h-4.5zm.5 14h3V8h-3v13zm-1 0v-7h-3v7h3zm-4-7.5V21h-3V11h3v2.5zM9 21v-4H6v4h3z"/></svg>'
    }
    ,
    437924: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" transform="translate(4 5)"><circle stroke="currentColor" cx="9.5" cy="9.5" r="9"/><path stroke="currentColor" d="M7 14.5h2.5v-5H7"/><path stroke="currentColor" stroke-linecap="square" d="M9.5 14.5h2"/><path fill="currentColor" d="M9.5 7a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z"/></g></svg>'
    }
    ,
    699875: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="backgroundColor" d="M5 7V6a4 4 0 1 1 8 0v1a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9c0-1.1.9-2 2-2Z"/><path fill="lineColor" fill-rule="evenodd" d="M9 3a3 3 0 0 0-3 3v1h6V6a3 3 0 0 0-3-3ZM5 6v1a2 2 0 0 0-2 2v5c0 1.1.9 2 2 2h8a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2V6a4 4 0 0 0-8 0Zm0 2a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H5Zm4 2a1 1 0 0 0-1 1v1a1 1 0 1 0 2 0v-1a1 1 0 0 0-1-1Z"/></svg>'
    }
    ,
    902872: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" stroke="currentColor" transform="translate(6 3)"><rect width="15" height="12" rx="2" x=".5" y="8.5"/><path stroke-linecap="round" stroke-width="2" d="M8 15v2"/><path d="M11.5 4a3.5 3.5 0 0 0-7 0v4.5"/></g></svg>'
    }
    ,
    205144: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" width="25" height="25"><circle fill="transparent" stroke="currentColor" stroke-width="1.5" cx="12.5" cy="12.5" r="11.75"/><path fill="currentColor" fill-rule="evenodd" d="M8.24 6.29a5.3 5.3 0 0 0 1.8 5.73l.67.48-.66.48a5.3 5.3 0 0 0-1.81 5.73c.05.17.2.29.36.29h7.8c.17 0 .31-.12.36-.29a5.3 5.3 0 0 0-1.8-5.73l-.67-.48.66-.48a5.3 5.3 0 0 0 1.81-5.73.39.39 0 0 0-.36-.29H8.6a.39.39 0 0 0-.36.29Zm4.26 5.48 1.58-1.15a3.41 3.41 0 0 0 1.36-2.93H9.56a3.41 3.41 0 0 0 1.36 2.93l1.58 1.15Z"/></svg>'
    }
    ,
    600459: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" width="25" height="25" fill="none"><circle stroke="currentColor" stroke-width="1.5" cx="12.5" cy="12.5" r="11.75"/><path fill="currentColor" d="M12.12 6.76a.4.4 0 0 1 .76 0l.8 2.16a4.06 4.06 0 0 0 2.4 2.4l2.16.8a.4.4 0 0 1 0 .76l-2.16.8a4.06 4.06 0 0 0-2.4 2.4l-.8 2.16a.4.4 0 0 1-.76 0l-.8-2.16a4.06 4.06 0 0 0-2.4-2.4l-2.16-.8a.4.4 0 0 1 0-.76l2.16-.8a4.06 4.06 0 0 0 2.4-2.4l.8-2.16Z"/></svg>'
    }
    ,
    707491: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" width="25" height="25"><circle fill="none" stroke="currentColor" stroke-width="1.5" cx="12.5" cy="12.5" r="11.75"/><path fill="currentColor" d="m15.65 6 1.02.9-4.02 4.93h5.29L9.59 19l-1.02-.9 4.02-4.93H7.3L15.65 6Z"/></svg>'
    }
    ,
    507983: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15 13" width="15" height="13"><path fill="currentColor" fill-rule="evenodd" d="M4.1 1 1.14 6.5 4.1 12h6.8l2.96-5.5L10.9 1H4.1ZM15 6.5 11.5 0h-8L0 6.5 3.5 13h8L15 6.5ZM7.5 8a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Zm0 1a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z"/></svg>'
    }
    ,
    139267: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" stroke="currentColor"><path d="M6.5 15A8.5 8.5 0 1 0 15 6.5H8.5"/><path d="M12 10L8.5 6.5 12 3"/></g></svg>'
    }
    ,
    416911: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" stroke="currentColor" transform="translate(3 6)"><path d="M.964 8C3 4 6.679.5 11 .5 15.32.5 19 4 21.036 8 19 12 15.32 15.5 11 15.5 6.679 15.5 3 12 .964 8z"/><circle cx="11" cy="8" r="3.5"/></g></svg>'
    }
    ,
    198083: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28" fill="none"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M19.9792 16.6205C19.7396 16.8955 19.3241 16.9285 19.044 16.6948L14.3924 12.8117L14.072 12.5442L13.7516 12.8117L9.10009 16.6947C8.82008 16.9285 8.40456 16.8955 8.16495 16.6205C7.92467 16.3447 7.94981 15.9272 8.22144 15.6822L14.0721 10.4057L19.9227 15.6822C20.1943 15.9272 20.2195 16.3447 19.9792 16.6205ZM18.4032 17.4624C19.1009 18.0448 20.1362 17.9626 20.7332 17.2774C21.3318 16.5902 21.2692 15.55 20.5924 14.9396L14.407 9.36109L14.0721 9.05908L13.7373 9.36109L7.55171 14.9396C6.87492 15.55 6.81229 16.5902 7.41096 17.2774C8.00796 17.9626 9.04326 18.0448 9.74094 17.4624L14.072 13.8468L18.4032 17.4624Z"/></svg>'
    }
    ,
    472382: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28" fill="none"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M19.9792 12.2892C19.7396 12.0142 19.3241 11.9812 19.044 12.2149L14.3924 16.098L14.072 16.3655L13.7516 16.098L9.10009 12.2149C8.82008 11.9812 8.40456 12.0142 8.16495 12.2892C7.92467 12.565 7.94981 12.9825 8.22144 13.2275L14.0721 18.504L19.9227 13.2275C20.1943 12.9825 20.2195 12.565 19.9792 12.2892ZM18.4032 11.4472C19.1009 10.8648 20.1362 10.9471 20.7332 11.6323C21.3318 12.3195 21.2692 13.3597 20.5924 13.9701L14.407 19.5486L14.0721 19.8506L13.7373 19.5486L7.55171 13.9701C6.87492 13.3597 6.81229 12.3195 7.41096 11.6323C8.00796 10.9471 9.04326 10.8648 9.74094 11.4473L14.072 15.0628L18.4032 11.4472Z"/></svg>'
    }
    ,
    706862: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" stroke="currentColor"><path stroke-linecap="square" d="M11.5 21.5v-7m3 7v-5m3 5v-3m-9 3v-5"/><path d="M5.5 22v-3"/><path stroke-linecap="square" d="M5.5 13.5l4.297-4.297a2.406 2.406 0 0 1 3.406 0l2.594 2.594c.94.94 2.463.943 3.406 0L23.5 7.5M22.5 12.5v6m-3-3h6"/></g></svg>'
    }
    ,
    854190: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><path fill="none" fill-rule="evenodd" stroke="currentColor" stroke-linecap="square" d="M6.145 11.968L14 5.5l7.855 6.468a.3.3 0 0 1-.191.532H6.336a.3.3 0 0 1-.19-.532zm0 4.064L14 22.5l7.855-6.468a.3.3 0 0 0-.191-.532H6.336a.3.3 0 0 0-.19.532z"/></svg>'
    }
    ,
    225191: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" transform="translate(4 5)"><path fill="currentColor" d="M3 1h1v13.5H3z"/><circle stroke="currentColor" cx="3.5" cy="16.5" r="2"/><path fill="currentColor" d="M5.5 16H18v1H5.5z"/><path stroke="currentColor" d="M0 4L3.5.5 7 4m8 9l3.5 3.5L15 20"/></g></svg>'
    }
    ,
    593379: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><g fill="currentColor" fill-rule="nonzero"><path d="M4 15h8.5v-1h-8.5zM16.5 15h8.5v-1h-8.5z"/><path d="M14.5 16c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5-1.5.672-1.5 1.5.672 1.5 1.5 1.5zm0 1c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5z"/></g></svg>'
    }
    ,
    484959: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><path fill="currentColor" d="M18.15 7.02A9.05 9.05 0 0014 6c-3.45 0-6.08 2-7.8 3.92a18.18 18.18 0 00-2.64 3.84v.02h-.01L4 14l-.45-.21-.1.21.1.21L4 14l-.45.21.01.03a5.85 5.85 0 00.16.32c.11.2.28.51.5.87a18.18 18.18 0 002.4 3.12l.71-.71A17.18 17.18 0 014.56 14a10.05 10.05 0 01.52-.91c.41-.69 1.04-1.6 1.85-2.5C8.58 8.75 10.95 7 14 7a8 8 0 013.4.77l.75-.75zm-3.11 3.12a4 4 0 00-4.9 4.9l.86-.87V14a3 3 0 013.17-3l.87-.86zm1.96 3.7l.86-.88a4 4 0 01-4.9 4.9l.87-.86A3 3 0 0017 13.83zm-6.4 6.4A8 8 0 0014 21c3.05 0 5.42-1.76 7.07-3.58A17.18 17.18 0 0023.44 14a9.47 9.47 0 00-.52-.91 17.18 17.18 0 00-2.25-2.93l.7-.7a18.18 18.18 0 013.06 4.3l.02.02L24 14l.45.21-.01.03a7.03 7.03 0 01-.16.32c-.11.2-.28.51-.5.87-.44.72-1.1 1.69-1.97 2.65C20.08 20.01 17.45 22 14 22c-1.55 0-2.94-.4-4.15-1.02l.75-.75zM24 14l.45-.21.1.21-.1.21L24 14zM22.2 6.5L6.5 22.2l-.7-.7L21.5 5.8l.7.7z"/></svg>'
    }
    ,
    397874: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><g fill="none" fill-rule="evenodd" stroke="currentColor" transform="translate(6 4)"><rect width="15" height="12" rx="2" x=".5" y="7.5"/><path stroke-linecap="round" stroke-width="2" d="M8 14v2"/><path d="M11.5 7.5V4a3.5 3.5 0 0 0-7 0v3.5"/></g></svg>'
    }
    ,
    677067: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" d="M13.39 3.84a1 1 0 0 1 1.22 0l8.19 6.37a1 1 0 0 1 0 1.58l-8.19 6.37a1 1 0 0 1-1.22 0L5.2 11.79a1 1 0 0 1 0-1.58l8.19-6.37zm.61.8L5.81 11 14 17.37 22.19 11 14 4.63zM5.3 13.6l8.7 6.76 8.7-6.76.6.78-8.69 6.77a1 1 0 0 1-1.22 0l-8.7-6.77.62-.78zm8.09 10.55l-8.7-6.77.62-.78L14 23.37l8.7-6.76.6.78-8.69 6.77a1 1 0 0 1-1.22 0z"/></svg>'
    }
    ,
    776351: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 28" width="36" height="28"><path fill="currentColor" d="M14 22H7V11H0V4h14v18zM28 22h-8l7.5-18h8L28 22z"/><circle fill="currentColor" cx="20" cy="8" r="4"/></svg>'
    }
    ,
    439970: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" fill-rule="evenodd" d="M13.5 24a9.5 9.5 0 1 0 0-19 9.5 9.5 0 0 0 0 19zm0 1a10.5 10.5 0 1 0 0-21 10.5 10.5 0 0 0 0 21zM11 10h1v9h-1v-9zm5 0h-1v9h1v-9z"/></svg>'
    }
    ,
    789795: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" fill-rule="evenodd" d="M23 14.5a9.5 9.5 0 1 1-19 0 9.5 9.5 0 0 1 19 0zm1 0a10.5 10.5 0 1 1-21 0 10.5 10.5 0 0 1 21 0zM11.3 9.6l-.8-.6v11l.8-.6 6-4.5.53-.4-.53-.4-6-4.5zm4.87 4.9L11.5 18v-7l4.67 3.5z"/></svg>'
    }
    ,
    133736: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="none"><path stroke="currentColor" d="M5.5 16.5c1 3 7 7 11 7 2-4 2-8.5 2-8.5s-1-3.5-2-4-4.5.5-4.5.5-3 3.5-6.5 5z"/><path stroke="currentColor" d="M15.5 11l3-6s.5-1 1.5-.5.5 1.5.5 1.5l-3 6M12 11.5l6.5 3.5M7.5 19c2-.5 4-2.5 4-2.5m0 5.5c2-1 3-3.5 3-3.5"/></svg>'
    }
    ,
    808757: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="none"><path stroke="currentColor" d="M6.5 16v4.5a1 1 0 001 1h14a1 1 0 001-1V16M14.5 18V5.5m-4 4l4-4l4 4"/></svg>'
    }
    ,
    786559: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><rect width="18" height="18" fill="#EC407A" rx="9" opacity=".15"/><path fill="#C2185B" d="M13.4 5.9c-.41 1.62-1.16 2.43-2.25 2.43-.52 0-1.25-.15-2.2-.45-.93-.3-1.58-.45-1.96-.45-.55 0-.98.3-1.27.9H4.66c.1-.67.36-1.24.76-1.71.4-.48.86-.72 1.4-.72.56 0 1.31.16 2.27.46.95.3 1.62.45 2.01.45.64 0 1.06-.3 1.27-.9h1.03zm0 3.87c-.41 1.62-1.16 2.43-2.25 2.43-.52 0-1.25-.15-2.2-.45-.93-.3-1.58-.46-1.96-.46-.55 0-.98.3-1.27.9H4.66c.1-.67.36-1.24.76-1.7.4-.48.86-.72 1.4-.72.56 0 1.31.15 2.27.46.95.3 1.62.44 2.01.44.64 0 1.06-.3 1.27-.9h1.03z"/></svg>'
    }
    ,
    80465: e=>{
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28" fill="none"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M5.5 6C4.67 6 4 6.67 4 7.5V20.5c0 .83.67 1.5 1.5 1.5H16v-1H5.5a.5.5 0 0 1-.5-.5V12h16v1h1V9.5c0-.83-.67-1.5-1.5-1.5h-8.8L9.86 6.15 9.71 6H5.5zM21 11H5V7.5c0-.28.22-.5.5-.5h3.8l1.85 1.85.14.15h9.21c.28 0 .5.22.5.5V11zm1 11v-3h3v-1h-3v-3h-1v3h-3v1h3v3h1z"/></svg>'
    }
    ,
    287489: e=>{
        "use strict";
        e.exports = JSON.parse('{"4":["v",["h",0,2],["h",1,3]],"6":["v",["h",0,2,4],["h",1,3,5]],"8":["v",["h",0,2,4,6],["h",1,3,5,7]],"2h":["h",0,1],"2v":["v",0,1],"2-1":["v",["h",0,2],1],"3s":["h",0,["v",1,2]],"3h":["h",0,1,2],"3v":["v",0,1,2],"1-2":["v",0,["h",1,2]],"3r":["h",["v",0,1],2],"4h":["h",0,1,2,3],"4v":["v",0,1,2,3],"4s":["h",0,["v",1,2,3]],"4s-l":["h",["v",1,2,3],0],"5h":["h",0,1,2,3,4],"5v":["v",0,1,2,3,4],"6h":["h",0,1,2,3,4,5],"6v":["v",0,1,2,3,4,5],"7h":["h",0,1,2,3,4,5,6],"8h":["h",0,1,2,3,4,5,6,7],"8v":["v",0,1,2,3,4,5,6,7],"9h":["h",0,1,2,3,4,5,6,7,8],"9v":["v",0,1,2,3,4,5,6,7,8],"10h":["h",0,1,2,3,4,5,6,7,8,9],"10v":["v",0,1,2,3,4,5,6,7,8,9],"1-3":["v",0,["h",1,2,3]],"2-2":["v",["h",0,1],["v",2,3]],"2-2-l":["h",0,1,["v",2,3]],"2-3":["v",["h",0,1],["h",2,3,4]],"3-2":["v",["h",0,1,2],["h",3,4]],"1-4":["v",0,["h",1,2,3,4]],"2-4":["v",["h",0,1],["h",2,3,4,5]],"5s":["h",0,["v",1,2,3,4]],"6c":["v",["h",0,1],["h",2,3],["h",4,5]],"8c":["v",["h",0,1],["h",2,3],["h",4,5],["h",6,7]],"9s":["v",["h",0,1,2],["h",3,4,5],["h",6,7,8]],"10c5":["v",["h",0,2,4,6,8],["h",1,3,5,7,9]],"12c6":["v",["h",0,2,4,6,8,10],["h",1,3,5,7,9,11]],"12c4":["v",["h",0,4,8],["h",1,5,9],["h",2,6,10],["h",3,7,11]],"14c7":["v",["h",0,2,4,6,8,10,12],["h",1,3,5,7,9,11,13]],"16c8":["v",["h",0,2,4,6,8,10,12,14],["h",1,3,5,7,9,11,13,15]],"16c4":["v",["h",0,4,8,12],["h",1,5,9,13],["h",2,6,10,14],["h",3,7,11,15]],"s":0}')
    }
}]);
